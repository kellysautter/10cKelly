	TITLE	c:\10c\A\oe\KZOEOIAA.C
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@OFE@lpAppQualView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@EIGE@EntitySpec?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@FPPG@SourceViewName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NIIK@SourceViewID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CPOO@SourceEntityName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@ICOG@SourceAttributeName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04FKDH@Oper?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02PKFC@IS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01GFI@?$CI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LACO@AND?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@LOJF@EntityName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@JICG@AttributeName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01KPOD@?$DN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KBGO@Value?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01KMMP@?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GDMG@LOD_Name?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GOHN@KeyValue?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BJPE@UserName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KMOL@Timestamp?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09NCPC@AllowRead?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07KIPN@ZPLOCKO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IIJI@?$CDGlobal?5Entity?5Lock?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IMFF@?$CD?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PIFJ@ZeidonLock?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01OAK@N?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@JGEA@Locking?5semaphore?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DE@IKDC@Waited?5too?5long?5to?5write?5pessimi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@FJHF@Expecting?5valid?5OI?5for?5zACTIVATE@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DB@KPMG@Root?5entity?5has?5no?5default?5seque@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IDPE@kzdbhqua?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02CHDK@OR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FHE@?$DM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FAFK@?$DO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08ILBJ@KZDBHQUA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@JJIL@__Load?9in?9progress?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CF@DGPI@?$CIoi?$CJ?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CF@NCHC@?$CIoi?$CJ?5Database?5unavailable?9?9try?5a@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@FJHI@?$CIoi?$CJ?5Database?5Deadlock?5?9?5Object?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@DAGF@?5Activate?5Retry?5Count?$DN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@FIPO@?$CIoi?$CJ?5Deadlock?5Crash?5?9?5Retry?5Coun@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DP@HHNF@?$CIoi?$CJ?5Database?5Memory?5Limit?5Reach@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DIOI@QualAttrib?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@GCPH@SubQualAttrib?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@GDPI@Network?5cannot?5be?5started?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IDGA@KZOEOIAA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02KKOC@xx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OKGH@?$CFlf?5seconds?5for?5object?5?$CFs?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CO@EJKO@?$CIoi?$CJ?5Total?5time?5for?5ActivateObje@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@FGFK@TZCMULWO?4POR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@PPBE@?$CIoi?$CJ?5opening?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CKOO@Out?5of?5buffer?5space?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@LIH@Internal?5Core?5Error?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02CJCI@KZ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@KGHM@DBH_MsgProc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@GMLG@_DBH_MsgProc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@KJEE@?$CIoi?$CJ?5Attempting?5to?5load?5GK?9handl@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GIDM@GKH_MsgProc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@KCPG@_GKH_MsgProc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@HCHL@View?5doesn?8t?5have?5an?5OI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@ECGE@Object?5Name?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@FEHG@?$CIoi?$CJ?5Can?8t?5start?5network?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@GCPD@?$CIoi?$CJ?5Warning?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@OGGO@?$CIoi?$CJ?5Object?5definition?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@BILP@?$CIoi?$CJ?5Entity?5name?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HPNO@?$CIoi?$CJ?5EI?5Flags?5?5?5?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FP@BNEA@Return?5code?5indicates?5that?5Commi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@OPBG@OE?5Warning?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EC@LDIB@?$CFs?5?5?$CFs?5?5?5Object?5Definition?3?5?$CFs?5?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@FIA@?$CFlf?5seconds?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@PHHP@?$CIoi?$CJ?5Total?5time?5for?5CommitMultip@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@DMOI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5Warning?5?9?9?9?9?9?9@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06EOKH@create?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IDPA@delete?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07JPDC@created?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07NAPP@deleted?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0ID@FFNG@Warning?3?5Trying?5to?5commit?5an?5ent@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@PJII@Number?5of?5views?5in?5the?5cluster?3?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@IIDP@?$CInull?$CJ?5View?5not?5flagged?5as?5chang@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@FMKN@?5?5?5View?5ID?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@MHHP@?5?5?5View?5ID?5?$DN?5?$CFlx?0?5Object?5name?5?$DN?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05OGKG@?$CFs?4?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@HLDF@OD?4Entity?5with?5Create?5flag?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@BCNN@OD?4Entity?5with?5Delete?5flag?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08MGEA@OI?5ID?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@MNFM@OD?4Entity?5with?5create?5authority?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0KE@LDAH@Warning?3?5Trying?5to?5commit?5an?5ent@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DMJL@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@KCFL@No?5GenKey?5handler?5set?5for?5LOD?3?5?$CF@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@FKJO@OIs?5have?5different?5GenKey?5handle@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08HFJA@KZGKHWOB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JOKA@_KZGKHWOB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OHJM@EntityID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JEOF@Genkey?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@KMCA@EntityCount?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JMBN@TableName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@PLOF@Infinite?5loop?5trying?5to?5set?5FKs?$DP@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LNBB@?$EA?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@CNGJ@Couldn?8t?5find?5original?5OI?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@PFIF@?$CIoi?$CJ?5Activating?5Optimistic?5Check@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DB@NCB@?$CIoi?$CJ?5Error?5loading?5Optimistic?5ch@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@JDBO@?$CIoi?$CJ?5Optimistic?5locking?5compare?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@BBG@mOITAG?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JENH@mOITAG?5?5?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@OMJF@mOIFLAGS?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GFPC@mOIFLAGS?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05HEAD@?$CFx?5?$CFx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GLEP@mETAG?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@DBLN@mETAG?5?5?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KKHA@mEKEY?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@IJFA@mEKEY?5?5?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NHOC@?0?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HIC@a?$CFlx?$CFs?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DCMN@?$CFs?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IACC@a?$CF?99s?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KPK@a?5?$CFx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FA@OBP@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Src?5View?5E@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DN@MLKO@Error?5writing?5OI?3?5ER?5Tokens?5don?8@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GN@i?$CFlx?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KPKL@c?$CFx?50?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BFPN@c?$CFx?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08ION@?5?5?5?5?5?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@LHOF@mCONTROL?5?$CFlx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JJOE@ZEND?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@BCKI@?$CI?$CFs?$CJ?5?$DN?5?$CFlf?5seconds?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@BFCD@?$CIoi?$CJ?5Total?5time?5for?5SfWriteOI_To@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CP@GGJF@Trying?5to?5drop?5original?5OI?5but?5i@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@NIPI@?9?5ParentEntity?5?$DN?$DN?5ChildEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@NMHK@?$CIoi?$CJ?5Hangin?5key?5error?$CB?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@BKHK@LOD?5?8?$CFs?8?5is?5locked?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@JJPK@Entity?5?8?$CFs?8?5is?5locked?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@NLCC@YYYY?9M?9D?5HH?3MI?3SS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NCBI@?$CIoi?$CJ?5Object?5locked?5by?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@FDBN@?$CIoi?$CJ?5Object?5locked?5on?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@POBP@?$CIoi?$CJ?5Concatenated?5key?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DH@OLHA@?$DN?$DN?$DN?$DN?5Activate?5error?3?5Infinite?5re@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@JOON@Object?5Name?5?5?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LMMD@Parent?5Entity?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@BHHL@Parent?5level?5?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@NJHF@Child?5Entity?5?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@IHNO@Child?5level?5?5?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PCJP@Y?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICJO@CONTROL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EECP@ETAG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BDIB@EKEY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JDHD@OITAG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07IFBG@OIFLAGS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@GEOJ@?$CIWARNING?$CJ?5Couldn?8t?5find?5entity?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@FECF@?$CIWARNING?$CJ?5in?5LOD?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PJCK@?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@HIC@Error?5from?5UUDECODE_NextLineToBu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@FNGM@UUDECODE?5length?5invalid?3?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FA@FOLJ@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Tgt?5View?5E@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@DJNN@ER?5Tokens?5don?8t?5match?5for?5linked@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@IKLP@?$CIoi?$CJ?5Failed?5entity?5linking?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@FPOB@?$CIoi?$CJ?5Link?5Src?5?$CD?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@GFPE@?$CIoi?$CJ?5Source?5Entity?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GIND@?$CIoi?$CJ?5Link?5Tgt?5?$CD?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@FHME@?$CIoi?$CJ?5Target?5Entity?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EA@MMNH@?$CIoi?$CJ?5Entity?5type?5mismatch?5during@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NLFK@TZCMULWO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@HFJB@?$CIoi?$CJ?5Total?5time?5for?5SfActivateOI@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FO@KBNJ@SfActivateSysOI_FromFile?5now?5REQ@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FM@LNBI@SfActivateSysOI_FromFile?5now?5REQ@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09BPDN@Zeidon?5OE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FL@BEFB@SfActivateSysEmptyOI?5now?5REQUIRE@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FI@FKHH@SfActivateSysEmptyOI?5now?5REQUIRE@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CEOG@?4bubblesort?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@NNA@fnOrderOI_ByDefaultAttribs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@NHNF@Out?5of?5space?5for?5entities?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@LCPB@Maximum?5?$CD?5of?5order?5entities?5used@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@KEBP@Sequencing?5error?5?$DO?540?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@OIFL@fnOrderEntitiesByDefaultAttribs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@BDHH@Ordering?5attributes?5?9?9?5resetting@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@KJKO@Unset?5or?5Null?5Cursor?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@GNIP@OrderEntities?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CO@OBEN@Ordering?5attributes?5?9?9?5Entity?5cu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@DGOD@Error?5occurs?5after?3?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CM@MJO@Error?5parsing?5command?4?5?5See?5trac@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09MHIP@ACTIVATE?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06ICCC@WHERE?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06KGGE@?$CKroot?$CK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CHNO@KeyList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@GDFL@IntegerValue?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_gszKeyDelimStr
_BSS	SEGMENT
_?ZeroAttribFlags@?BJ@??fnWriteOI_ToTextStream@@9@9 DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_gszKeyDelimStr DB '/|\', 09H, 0aH, '`~!@#$%^&*-_=+;<>?aAzZ10', 00H
_DATA	ENDS
PUBLIC	_fnInvokeOCEOperation
PUBLIC	_ActivateEmptyObjectInstance@16
PUBLIC	??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@ ; `string'
PUBLIC	??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@		; `string'
PUBLIC	??_C@_0O@OFE@lpAppQualView?$AA@			; `string'
PUBLIC	_fnActivateEmptyObjectInstance
EXTRN	_fnOperationCall:NEAR
EXTRN	_fnOperationReturn:NEAR
EXTRN	_fnDeclareView@20:NEAR
EXTRN	_fnDropView@4:NEAR
EXTRN	_AnchorBlock:DWORD
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_fnIssueCoreError:NEAR
;	COMDAT ??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@ DB 'More than one zL'
	DB	'EVEL_ option requested', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@
_DATA	SEGMENT
??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@ DB 'with zLEVEL_SAME', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@OFE@lpAppQualView?$AA@
_DATA	SEGMENT
??_C@_0O@OFE@lpAppQualView?$AA@ DB 'lpAppQualView', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_lControl$ = 20
_lpCurrentTask$ = -24
_lpOwningTask$ = -16
_lpViewOD$ = -4
_lpView$ = -8
_l$ = -20
_nRC$ = -12
_lpViewCsr$7664 = -28
_nState$7681 = -32
_ActivateEmptyObjectInstance@16 PROC NEAR

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 557  :    LPTASK         lpCurrentTask;
; 558  :    LPTASK         lpOwningTask;
; 559  :    LPVIEWOD       lpViewOD;
; 560  :    zVIEW          lpView;
; 561  :    zLONG          l;
; 562  :    zSHORT         nRC;
; 563  : 
; 564  :    // Init in case of early error
; 565  :    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 566  : 
; 567  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 568  :    if ( (lpCurrentTask = fnOperationCall( iActivateEmptyObjectInstance,
; 569  :                                           lpAppQualView, zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	push	50					; 00000032H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L7655

; 571  :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7648
$L7655:

; 573  : 
; 574  :    // Verify only one zLEVEL_ option requested
; 575  :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], edx

; 576  :    if ( l && (-l & l) != l )

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $L7656
	mov	eax, DWORD PTR _l$[ebp]
	neg	eax
	and	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _l$[ebp]
	je	SHORT $L7656

; 578  :       // error, More than one zLEVEL_ option requested
; 579  :       // "KZOEE023 - Invalid parameter, "
; 580  :       fnIssueCoreError( lpCurrentTask, lpAppQualView, 8, 23, 0,
; 581  :                         "More than one zLEVEL_ option requested", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@ ; `string'
	push	0
	push	23					; 00000017H
	push	8
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 582  :       fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	50					; 00000032H
	call	_fnOperationReturn
	add	esp, 8

; 583  :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7648
$L7656:

; 585  : 
; 586  :    // If zLEVEL_SAME is requested
; 587  :    if ( lControl & zLEVEL_SAME )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1024				; 00000400H
	test	ecx, ecx
	je	$L7673

; 589  :       if ( lpAppQualView == 0 || lpAppQualView->hSubtask )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $L7660
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $L7659
$L7660:

; 591  :          // "KZOEE100 - Invalid View, view is a Subtask View"
; 592  :          fnIssueCoreError( lpCurrentTask, lpAppQualView, 8, 100, 0,
; 593  :                            "lpAppQualView", "with zLEVEL_SAME" );

	push	OFFSET FLAT:??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0O@OFE@lpAppQualView?$AA@ ; `string'
	push	0
	push	100					; 00000064H
	push	8
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 594  :          fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	50					; 00000032H
	call	_fnOperationReturn
	add	esp, 8

; 595  :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7648
$L7659:

; 599  :          LPVIEWCSR lpViewCsr;
; 600  : 
; 601  :          // Turn off the 'same' indicator
; 602  :          lControl ^= zLEVEL_SAME;

	mov	eax, DWORD PTR _lControl$[ebp]
	xor	eax, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], eax

; 603  :          // To determine what the level is of the qualifying view
; 604  :          //   1. Change lpAppQualView to point to the initial
; 605  :          //      view created for the object instance
; 606  :          //   2. Check for application level, if there use
; 607  :          //      zLEVEL_APPLICATION.
; 608  :          //   3. Check if the view task is the main task, if so use
; 609  :          //      zLEVEL_SYSTEM.
; 610  :          //   4. Use the task level...
; 611  :          lpViewCsr = zGETPTR( lpAppQualView->hViewCsr );

	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$7664[ebp], eax
$L7667:

; 612  :          while ( lpViewCsr->hNextViewCsr )

	mov	eax, DWORD PTR _lpViewCsr$7664[ebp]
	cmp	DWORD PTR [eax+2], 0
	je	SHORT $L7668

; 613  :             lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	ecx, DWORD PTR _lpViewCsr$7664[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$7664[ebp], eax
	jmp	SHORT $L7667
$L7668:

; 614  : 
; 615  :          lpAppQualView = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$7664[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAppQualView$[ebp], eax

; 616  :          if ( lpAppQualView->bApplicationView )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L7671

; 617  :             lControl |= zLEVEL_APPLICATION;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 4
	mov	DWORD PTR _lControl$[ebp], ecx

; 618  :          else

	jmp	SHORT $L7673
$L7671:

; 619  :          if ( lpAppQualView->hTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $L7673

; 620  :             lControl |= zLEVEL_SYSTEM;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 8
	mov	DWORD PTR _lControl$[ebp], edx
$L7673:

; 623  : 
; 624  :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L7674

; 625  :       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 626  :    else

	jmp	SHORT $L7676
$L7674:

; 627  :       lpOwningTask = lpCurrentTask;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], eax
$L7676:

; 628  : 
; 629  :    if ( (nRC = fnDeclareView( pvReturnView, lpOwningTask,
; 630  :                               lpAppQualView, cpcViewOD_Name, 0 )) != 0 )

	push	0
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L7677

; 632  :       fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	50					; 00000032H
	call	_fnOperationReturn
	add	esp, 8

; 633  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L7648
$L7677:

; 635  : 
; 636  : #if 0
; 637  :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 638  :    {
; 639  :       zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 640  :                                   zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 641  :       if ( (nRC = SfTransferView( *pvReturnView, lpAppQualView,
; 642  :                                   nScope )) != 0 )
; 643  :       {
; 644  :          fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );
; 645  :          return( nRC );
; 646  :       }
; 647  :    }
; 648  : #endif
; 649  : 
; 650  :    nRC = fnActivateEmptyObjectInstance( lpCurrentTask, *pvReturnView, lControl );

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 651  :    lpView = *pvReturnView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpView$[ebp], eax

; 652  :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 653  :    if ( lControl & zREADONLY )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $L7679

; 654  :       lpView->bReadOnly = TRUE;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+30], edx
$L7679:

; 655  : 
; 656  : // TraceLine( "ActivateEmptyObjectInstance: 0x%08x   LOD: %s",
; 657  : //            lpView, lpViewOD->szName );
; 658  : 
; 659  : #ifdef __ACTIVATE_CONSTRAINTS__
; 660  :    if ( lpViewOD->bActivateEmptyConstraint && nRC == 0 )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L7683
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $L7683

; 662  :       zSHORT   nState;
; 663  : 
; 664  :       nState = (lControl & zLEVEL_SYSTEM) ? zOCE_STATE_SYSTEM : 0;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 8
	neg	ecx
	sbb	ecx, ecx
	and	ecx, 4
	mov	WORD PTR _nState$7681[ebp], cx

; 665  :          if ( lControl & zMULTIPLE )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 256				; 00000100H
	test	edx, edx
	je	SHORT $L7682

; 666  :             nState |= zOCE_STATE_MULTIPLE;

	mov	ax, WORD PTR _nState$7681[ebp]
	or	al, 16					; 00000010H
	mov	WORD PTR _nState$7681[ebp], ax
$L7682:

; 667  : 
; 668  :       nRC = fnInvokeOCEOperation( lpView, lpCurrentTask,
; 669  :                                   zOCE_ACTIVATE_EMPTY, nState );

	mov	cx, WORD PTR _nState$7681[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 670  :       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L7683

; 672  :          fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDropView@4

; 673  :          *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0
$L7683:

; 676  : #endif
; 677  : 
; 678  :    fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	50					; 00000032H
	call	_fnOperationReturn
	add	esp, 8

; 679  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L7648:

; 680  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_ActivateEmptyObjectInstance@16 ENDP
_TEXT	ENDS
PUBLIC	_fnResolveQualOI
PUBLIC	??_C@_0L@EIGE@EntitySpec?$AA@			; `string'
PUBLIC	??_C@_0P@FPPG@SourceViewName?$AA@		; `string'
PUBLIC	??_C@_0N@NIIK@SourceViewID?$AA@			; `string'
PUBLIC	??_C@_0BB@CPOO@SourceEntityName?$AA@		; `string'
PUBLIC	??_C@_0BE@ICOG@SourceAttributeName?$AA@		; `string'
PUBLIC	??_C@_04FKDH@Oper?$AA@				; `string'
PUBLIC	??_C@_02PKFC@IS?$AA@				; `string'
PUBLIC	??_C@_01GFI@?$CI?$AA@				; `string'
PUBLIC	??_C@_03LACO@AND?$AA@				; `string'
PUBLIC	??_C@_0L@LOJF@EntityName?$AA@			; `string'
PUBLIC	??_C@_0O@JICG@AttributeName?$AA@		; `string'
PUBLIC	??_C@_01KPOD@?$DN?$AA@				; `string'
PUBLIC	??_C@_05KBGO@Value?$AA@				; `string'
PUBLIC	??_C@_01KMMP@?$CJ?$AA@				; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
EXTRN	_GetIntegerFromAttribute@16:NEAR
EXTRN	_SetAttributeFromInteger@16:NEAR
EXTRN	_SetAttributeFromAttribute@24:NEAR
EXTRN	_MiGetViewEntityForView@8:NEAR
EXTRN	_CreateViewFromViewForTask@12:NEAR
EXTRN	_GetViewByName@16:NEAR
EXTRN	_GetAddrForAttribute@16:NEAR
EXTRN	_DropView@4:NEAR
EXTRN	_CreateEntity@12:NEAR
EXTRN	_DeleteEntity@12:NEAR
EXTRN	__imp___stricmp:NEAR
EXTRN	_SetCursorNextEntity@12:NEAR
EXTRN	_SetCursorFirstEntity@12:NEAR
EXTRN	_SetAttributeFromString@16:NEAR
;	COMDAT ??_C@_00A@?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??_C@_0L@EIGE@EntitySpec?$AA@
_DATA	SEGMENT
??_C@_0L@EIGE@EntitySpec?$AA@ DB 'EntitySpec', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@FPPG@SourceViewName?$AA@
_DATA	SEGMENT
??_C@_0P@FPPG@SourceViewName?$AA@ DB 'SourceViewName', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NIIK@SourceViewID?$AA@
_DATA	SEGMENT
??_C@_0N@NIIK@SourceViewID?$AA@ DB 'SourceViewID', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CPOO@SourceEntityName?$AA@
_DATA	SEGMENT
??_C@_0BB@CPOO@SourceEntityName?$AA@ DB 'SourceEntityName', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@ICOG@SourceAttributeName?$AA@
_DATA	SEGMENT
??_C@_0BE@ICOG@SourceAttributeName?$AA@ DB 'SourceAttributeName', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04FKDH@Oper?$AA@
_DATA	SEGMENT
??_C@_04FKDH@Oper?$AA@ DB 'Oper', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02PKFC@IS?$AA@
_DATA	SEGMENT
??_C@_02PKFC@IS?$AA@ DB 'IS', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01GFI@?$CI?$AA@
_DATA	SEGMENT
??_C@_01GFI@?$CI?$AA@ DB '(', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03LACO@AND?$AA@
_DATA	SEGMENT
??_C@_03LACO@AND?$AA@ DB 'AND', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@LOJF@EntityName?$AA@
_DATA	SEGMENT
??_C@_0L@LOJF@EntityName?$AA@ DB 'EntityName', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@JICG@AttributeName?$AA@
_DATA	SEGMENT
??_C@_0O@JICG@AttributeName?$AA@ DB 'AttributeName', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_01KPOD@?$DN?$AA@
_DATA	SEGMENT
??_C@_01KPOD@?$DN?$AA@ DB '=', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KBGO@Value?$AA@
_DATA	SEGMENT
??_C@_05KBGO@Value?$AA@ DB 'Value', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01KMMP@?$CJ?$AA@
_DATA	SEGMENT
??_C@_01KMMP@?$CJ?$AA@ DB ')', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vView$ = 8
_pchQualEntity$ = 12
_nRC$ = -4
_vSourceView$7698 = -12
_pchSourceViewName$7699 = -8
_pchSourceEntityName$7700 = -24
_pchSourceAttributeName$7701 = -20
_pchOper$7702 = -16
_lpViewEntity$7714 = -32
_lpViewAttrib$7715 = -36
_vTemp$7716 = -40
_bFirstKey$7717 = -28
_fnResolveQualOI PROC NEAR

; 688  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 689  :    zSHORT nRC;
; 690  : 
; 691  :    for ( nRC = SetCursorFirstEntity( vView, "EntitySpec", 0 );
; 692  :          nRC == zCURSOR_SET;
; 693  :          nRC = SetCursorNextEntity( vView, "EntitySpec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L7691
$L7692:
	push	0
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L7691:
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$L7693

; 695  :       for ( nRC = SetCursorFirstEntity( vView, pchQualEntity, "EntitySpec" );
; 696  :             nRC == zCURSOR_SET;
; 697  :             nRC = SetCursorNextEntity( vView, pchQualEntity, "EntitySpec" ) )

	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L7695
$L7696:
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L7695:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$L7697

; 699  :          zVIEW  vSourceView;
; 700  :          zPCHAR pchSourceViewName;
; 701  :          zPCHAR pchSourceEntityName;
; 702  :          zPCHAR pchSourceAttributeName;
; 703  :          zPCHAR pchOper;
; 704  : 
; 705  :          // See if QualAttrib references another view.
; 706  :          GetAddrForAttribute( &pchSourceViewName, vView, pchQualEntity,
; 707  :                               "SourceViewName" );

	push	OFFSET FLAT:??_C@_0P@FPPG@SourceViewName?$AA@ ; `string'
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchSourceViewName$7699[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 708  :          if ( *pchSourceViewName )

	mov	edx, DWORD PTR _pchSourceViewName$7699[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L7704

; 709  :             GetViewByName( &vSourceView, pchSourceViewName, vView, zLEVEL_TASK );

	push	2
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchSourceViewName$7699[ebp]
	push	edx
	lea	eax, DWORD PTR _vSourceView$7698[ebp]
	push	eax
	call	_GetViewByName@16

; 710  :          else

	jmp	SHORT $L7705
$L7704:

; 711  :             GetIntegerFromAttribute( (zPLONG) &vSourceView, vView,
; 712  :                                      pchQualEntity, "SourceViewID" );

	push	OFFSET FLAT:??_C@_0N@NIIK@SourceViewID?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vSourceView$7698[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
$L7705:

; 713  : 
; 714  :          // If vSourceView is 0, then the current QualAttrib doesn't reference
; 715  :          // another view, so continue with the next QualAttrib.
; 716  :          if ( vSourceView == 0 )

	cmp	DWORD PTR _vSourceView$7698[ebp], 0
	jne	SHORT $L7708

; 717  :             continue;

	jmp	SHORT $L7696
$L7708:

; 718  : 
; 719  :          // Get the source entity and attribute names.
; 720  :          GetAddrForAttribute( &pchSourceEntityName, vView, pchQualEntity,
; 721  :                               "SourceEntityName" );

	push	OFFSET FLAT:??_C@_0BB@CPOO@SourceEntityName?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchSourceEntityName$7700[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 722  :          GetAddrForAttribute( &pchSourceAttributeName, vView, pchQualEntity,
; 723  :                               "SourceAttributeName" );

	push	OFFSET FLAT:??_C@_0BE@ICOG@SourceAttributeName?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchSourceAttributeName$7701[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 724  : 
; 725  :          // Check to see if the operation is "IS".  If it is, then we have to
; 726  :          // save the key values.
; 727  :          GetAddrForAttribute( &pchOper, vView, pchQualEntity, "Oper" );

	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchOper$7702[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 728  :          if ( zstrcmpi( pchOper, "IS" ) == 0 )

	push	OFFSET FLAT:??_C@_02PKFC@IS?$AA@	; `string'
	mov	ecx, DWORD PTR _pchOper$7702[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	$L7712

; 730  :             LPVIEWENTITY lpViewEntity;
; 731  :             LPVIEWATTRIB lpViewAttrib;
; 732  :             zVIEW        vTemp;
; 733  :             zBOOL        bFirstKey = TRUE;

	mov	BYTE PTR _bFirstKey$7717[ebp], 1

; 734  : 
; 735  :             // Save a copy of the current view so we can delete the QualAttrib
; 736  :             // entity later.
; 737  :             CreateViewFromViewForTask( &vTemp, vView, 0 );

	push	0
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vTemp$7716[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 738  : 
; 739  :             CreateEntity( vView, pchQualEntity, zPOS_NEXT );

	push	3
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_CreateEntity@12

; 740  :             SetAttributeFromString( vView, pchQualEntity, "Oper", "(" );

	push	OFFSET FLAT:??_C@_01GFI@?$CI?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 741  : 
; 742  :             // The oper is "IS".  This means we need to replace the current
; 743  :             // QualAttrib with QualAttribs to compare each key.
; 744  :             lpViewEntity = MiGetViewEntityForView( vSourceView,
; 745  :                                                    pchSourceEntityName );

	mov	edx, DWORD PTR _pchSourceEntityName$7700[ebp]
	push	edx
	mov	eax, DWORD PTR _vSourceView$7698[ebp]
	push	eax
	call	_MiGetViewEntityForView@8
	mov	DWORD PTR _lpViewEntity$7714[ebp], eax

; 746  :             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 747  :                   lpViewAttrib;
; 748  :                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$7714[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$7715[ebp], eax
	jmp	SHORT $L7722
$L7723:
	mov	eax, DWORD PTR _lpViewAttrib$7715[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$7715[ebp], eax
$L7722:
	cmp	DWORD PTR _lpViewAttrib$7715[ebp], 0
	je	$L7724

; 750  :                // We only care about keys...
; 751  :                if ( lpViewAttrib->bKey == FALSE )

	mov	edx, DWORD PTR _lpViewAttrib$7715[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $L7725

; 752  :                   continue;

	jmp	SHORT $L7723
$L7725:

; 753  : 
; 754  :                if ( bFirstKey )

	mov	ecx, DWORD PTR _bFirstKey$7717[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L7726

; 755  :                   bFirstKey = FALSE;

	mov	BYTE PTR _bFirstKey$7717[ebp], 0

; 756  :                else

	jmp	SHORT $L7727
$L7726:

; 758  :                   CreateEntity( vView, pchQualEntity, zPOS_NEXT );

	push	3
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_CreateEntity@12

; 759  :                   SetAttributeFromString( vView, pchQualEntity, "Oper", "AND" );

	push	OFFSET FLAT:??_C@_03LACO@AND?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L7727:

; 761  : 
; 762  :                CreateEntity( vView, pchQualEntity, zPOS_NEXT );

	push	3
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 763  :                SetAttributeFromString( vView, pchQualEntity, "EntityName",
; 764  :                                        pchSourceEntityName );

	mov	edx, DWORD PTR _pchSourceEntityName$7700[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 765  :                SetAttributeFromString( vView, pchQualEntity, "AttributeName",
; 766  :                                        lpViewAttrib->szName );

	mov	edx, DWORD PTR _lpViewAttrib$7715[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_0O@JICG@AttributeName?$AA@ ; `string'
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 767  :                SetAttributeFromString( vView, pchQualEntity, "Oper", "=" );

	push	OFFSET FLAT:??_C@_01KPOD@?$DN?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 768  :                SetAttributeFromAttribute( vView, pchQualEntity, "Value",
; 769  :                                           vSourceView, pchSourceEntityName,
; 770  :                                           lpViewAttrib->szName );

	mov	ecx, DWORD PTR _lpViewAttrib$7715[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _pchSourceEntityName$7700[ebp]
	push	edx
	mov	eax, DWORD PTR _vSourceView$7698[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_05KBGO@Value?$AA@	; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetAttributeFromAttribute@24

; 771  :             } // for...

	jmp	$L7723
$L7724:

; 772  : 
; 773  :             CreateEntity( vView, pchQualEntity, zPOS_NEXT );

	push	3
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 774  :             SetAttributeFromString( vView, pchQualEntity, "Oper", ")" );

	push	OFFSET FLAT:??_C@_01KMMP@?$CJ?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 775  : 
; 776  :             DeleteEntity( vTemp, pchQualEntity, zREPOS_NONE );

	push	0
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTemp$7716[ebp]
	push	edx
	call	_DeleteEntity@12

; 777  :             DropView( vTemp );

	mov	eax, DWORD PTR _vTemp$7716[ebp]
	push	eax
	call	_DropView@4

; 778  : 
; 779  :             // We've done all that needs to be done, so process the next
; 780  :             // qual entity.
; 781  :             continue;

	jmp	$L7696
$L7712:

; 784  : 
; 785  :          // Copy attribute value from the source view to the qual view.
; 786  :          SetAttributeFromAttribute( vView, pchQualEntity, "Value",
; 787  :                                     vSourceView, pchSourceEntityName,
; 788  :                                     pchSourceAttributeName );

	mov	ecx, DWORD PTR _pchSourceAttributeName$7701[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchSourceEntityName$7700[ebp]
	push	edx
	mov	eax, DWORD PTR _vSourceView$7698[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_05KBGO@Value?$AA@	; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetAttributeFromAttribute@24

; 789  : 
; 790  :          // Set the qual attrib to be null.
; 791  :          SetAttributeFromString( vView, pchQualEntity, "SourceViewName", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0P@FPPG@SourceViewName?$AA@ ; `string'
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 792  :          SetAttributeFromInteger( vView, pchQualEntity, "SourceViewID", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0N@NIIK@SourceViewID?$AA@ ; `string'
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 793  :          SetAttributeFromString( vView, pchQualEntity, "SourceEntityName", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BB@CPOO@SourceEntityName?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 794  :          SetAttributeFromString( vView, pchQualEntity, "SourceAttributeName", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BE@ICOG@SourceAttributeName?$AA@ ; `string'
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 795  : 
; 796  :       } // for each pchQualEntity...

	jmp	$L7696
$L7697:

; 797  : 
; 798  :    } // for each "EntitySpec"...

	jmp	$L7692
$L7693:

; 799  : 
; 800  : } // fnResolveQualOI

	mov	esp, ebp
	pop	ebp
	ret	0
_fnResolveQualOI ENDP
_TEXT	ENDS
PUBLIC	_fnSetLockingAttributes@36
PUBLIC	??_C@_08GDMG@LOD_Name?$AA@			; `string'
PUBLIC	??_C@_08GOHN@KeyValue?$AA@			; `string'
PUBLIC	??_C@_08BJPE@UserName?$AA@			; `string'
PUBLIC	??_C@_09KMOL@Timestamp?$AA@			; `string'
PUBLIC	??_C@_09NCPC@AllowRead?$AA@			; `string'
EXTRN	_SysGetUserID@12:NEAR
EXTRN	_fnSetAttributeFromVariable:NEAR
EXTRN	_strcmp:NEAR
EXTRN	_SysGetDateTime@4:NEAR
;	COMDAT ??_C@_08GDMG@LOD_Name?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_08GDMG@LOD_Name?$AA@ DB 'LOD_Name', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GOHN@KeyValue?$AA@
_DATA	SEGMENT
??_C@_08GOHN@KeyValue?$AA@ DB 'KeyValue', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08BJPE@UserName?$AA@
_DATA	SEGMENT
??_C@_08BJPE@UserName?$AA@ DB 'UserName', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09KMOL@Timestamp?$AA@
_DATA	SEGMENT
??_C@_09KMOL@Timestamp?$AA@ DB 'Timestamp', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09NCPC@AllowRead?$AA@
_DATA	SEGMENT
??_C@_09NCPC@AllowRead?$AA@ DB 'AllowRead', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_vLock$ = 12
_lpLockEntity$ = 16
_lpLockEntityCsr$ = 20
_pchLOD_Name$ = 24
_pchKeyString$ = 28
_bSetUserName$ = 32
_bSetTimestamp$ = 36
_pchAllowRead$ = 40
_lpViewAttrib$ = -8
_nCnt$ = -4
_szUserName$7796 = -40
_szPassword$7797 = -72
_szDateTime$7810 = -104
_fnSetLockingAttributes@36 PROC NEAR

; 812  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 813  :    LPVIEWATTRIB lpViewAttrib;
; 814  :    zSHORT       nCnt = 0;

	mov	WORD PTR _nCnt$[ebp], 0

; 815  : 
; 816  :    // Loop through each of the attributes in the lock OI.  When we find
; 817  :    // one we want set it.  To keep us from looping unnecessarily we keep
; 818  :    // track of the # of attributes we set.  When we get to 5 we're done.
; 819  :    for ( lpViewAttrib = zGETPTR( lpLockEntity->hFirstOD_Attrib );
; 820  :          lpViewAttrib && nCnt < 5;
; 821  :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpLockEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L7762
$L7763:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L7762:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$L7764
	movsx	ecx, WORD PTR _nCnt$[ebp]
	cmp	ecx, 5
	jge	$L7764

; 823  :       if ( zstrcmp( lpViewAttrib->szName, "LOD_Name" ) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	movsx	ecx, BYTE PTR ??_C@_08GDMG@LOD_Name?$AA@
	cmp	eax, ecx
	jne	SHORT $L12753
	push	OFFSET FLAT:??_C@_08GDMG@LOD_Name?$AA@	; `string'
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -108+[ebp], eax
	jmp	SHORT $L12754
$L12753:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR ??_C@_08GDMG@LOD_Name?$AA@
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -108+[ebp], eax
$L12754:
	cmp	DWORD PTR -108+[ebp], 0
	jne	SHORT $L7771

; 825  :          nCnt++;

	mov	cx, WORD PTR _nCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nCnt$[ebp], cx

; 826  : 
; 827  :          if ( pchLOD_Name &&
; 828  :               fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 829  :                                           lpViewAttrib,
; 830  :                                           (zPVOID) pchLOD_Name, 'S', 0, 0,
; 831  :                                           lpCurrentTask, 0 ) != 0 )

	cmp	DWORD PTR _pchLOD_Name$[ebp], 0
	je	SHORT $L7774
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchLOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L7774

; 833  :             return( zCALL_ERROR ); // error setting attribute

	mov	ax, -16					; fffffff0H
	jmp	$L7757
$L7774:

; 836  :       else

	jmp	$L7823
$L7771:

; 837  :       if ( zstrcmp( lpViewAttrib->szName, "KeyValue" ) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	movsx	ecx, BYTE PTR ??_C@_08GOHN@KeyValue?$AA@
	cmp	eax, ecx
	jne	SHORT $L12755
	push	OFFSET FLAT:??_C@_08GOHN@KeyValue?$AA@	; `string'
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -112+[ebp], eax
	jmp	SHORT $L12756
$L12755:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR ??_C@_08GOHN@KeyValue?$AA@
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -112+[ebp], eax
$L12756:
	cmp	DWORD PTR -112+[ebp], 0
	jne	SHORT $L7782

; 839  :          nCnt++;

	mov	cx, WORD PTR _nCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nCnt$[ebp], cx

; 840  : 
; 841  :          if ( fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 842  :                                           lpViewAttrib,
; 843  :                                           (zPVOID) pchKeyString, 'S',
; 844  :                                           0, 0, lpCurrentTask, 0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchKeyString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L7785

; 846  :             return( zCALL_ERROR ); // error setting attribute

	mov	ax, -16					; fffffff0H
	jmp	$L7757
$L7785:

; 849  :       else

	jmp	$L7823
$L7782:

; 850  :       if ( zstrcmp( lpViewAttrib->szName, "UserName" ) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	movsx	ecx, BYTE PTR ??_C@_08BJPE@UserName?$AA@
	cmp	eax, ecx
	jne	SHORT $L12757
	push	OFFSET FLAT:??_C@_08BJPE@UserName?$AA@	; `string'
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -116+[ebp], eax
	jmp	SHORT $L12758
$L12757:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR ??_C@_08BJPE@UserName?$AA@
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -116+[ebp], eax
$L12758:
	cmp	DWORD PTR -116+[ebp], 0
	jne	SHORT $L7793

; 852  :          nCnt++;

	mov	cx, WORD PTR _nCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nCnt$[ebp], cx

; 853  : 
; 854  :          if ( bSetUserName )

	mov	edx, DWORD PTR _bSetUserName$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L7799

; 856  :             zCHAR szUserName[ 30 ];
; 857  :             zCHAR szPassword[ 30 ];
; 858  : 
; 859  :             SysGetUserID( vLock, szUserName, szPassword );

	lea	eax, DWORD PTR _szPassword$7797[ebp]
	push	eax
	lea	ecx, DWORD PTR _szUserName$7796[ebp]
	push	ecx
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_SysGetUserID@12

; 860  :             if ( fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 861  :                                              lpViewAttrib,
; 862  :                                              (zPVOID) szUserName, 'S',
; 863  :                                              0, 0, lpCurrentTask, 0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	0
	push	83					; 00000053H
	lea	ecx, DWORD PTR _szUserName$7796[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L7799

; 865  :                return( zCALL_ERROR ); // error setting attribute

	mov	ax, -16					; fffffff0H
	jmp	$L7757
$L7799:

; 869  :       else

	jmp	$L7823
$L7793:

; 870  :       if ( zstrcmp( lpViewAttrib->szName, "Timestamp" ) == 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR ??_C@_09KMOL@Timestamp?$AA@
	cmp	ecx, edx
	jne	SHORT $L12759
	push	OFFSET FLAT:??_C@_09KMOL@Timestamp?$AA@	; `string'
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -120+[ebp], eax
	jmp	SHORT $L12760
$L12759:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	movsx	eax, BYTE PTR ??_C@_09KMOL@Timestamp?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -120+[ebp], ecx
$L12760:
	cmp	DWORD PTR -120+[ebp], 0
	jne	SHORT $L7807

; 872  :          nCnt++;

	mov	dx, WORD PTR _nCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nCnt$[ebp], dx

; 873  : 
; 874  :          if ( bSetTimestamp )

	mov	eax, DWORD PTR _bSetTimestamp$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L7812

; 876  :             zCHAR szDateTime[ 30 ];
; 877  : 
; 878  :             SysGetDateTime( szDateTime );

	lea	ecx, DWORD PTR _szDateTime$7810[ebp]
	push	ecx
	call	_SysGetDateTime@4

; 879  :             if ( fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 880  :                                              lpViewAttrib,
; 881  :                                              (zPVOID) szDateTime, 'S',
; 882  :                                              0, 0, lpCurrentTask, 0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	lea	eax, DWORD PTR _szDateTime$7810[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L7812

; 884  :                return( zCALL_ERROR ); // error setting attribute

	mov	ax, -16					; fffffff0H
	jmp	$L7757
$L7812:

; 888  :       else

	jmp	$L7823
$L7807:

; 889  :       if ( zstrcmp( lpViewAttrib->szName, "AllowRead" ) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	movsx	ecx, BYTE PTR ??_C@_09NCPC@AllowRead?$AA@
	cmp	eax, ecx
	jne	SHORT $L12761
	push	OFFSET FLAT:??_C@_09NCPC@AllowRead?$AA@	; `string'
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -124+[ebp], eax
	jmp	SHORT $L12762
$L12761:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR ??_C@_09NCPC@AllowRead?$AA@
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -124+[ebp], eax
$L12762:
	cmp	DWORD PTR -124+[ebp], 0
	jne	SHORT $L7823

; 891  :          nCnt++;

	mov	cx, WORD PTR _nCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nCnt$[ebp], cx

; 892  : 
; 893  :          if ( pchAllowRead &&
; 894  :               fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 895  :                                           lpViewAttrib,
; 896  :                                           (zPVOID) pchAllowRead, 'S',
; 897  :                                           0, 0, lpCurrentTask, 0 ) != 0 )

	cmp	DWORD PTR _pchAllowRead$[ebp], 0
	je	SHORT $L7823
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchAllowRead$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L7823

; 899  :             return( zCALL_ERROR ); // error setting attribute

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L7757
$L7823:

; 902  : 
; 903  :    } // for each lpViewAttrib...

	jmp	$L7763
$L7764:

; 904  : 
; 905  :    return( 0 );

	xor	ax, ax
$L7757:

; 906  : 
; 907  : } // fnSetLockingAttributes

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_fnSetLockingAttributes@36 ENDP
_TEXT	ENDS
PUBLIC	_fnCommitObjectInstance@28
PUBLIC	_fnCreatePessimisticSemaphore@20
PUBLIC	??_C@_07KIPN@ZPLOCKO?$AA@			; `string'
PUBLIC	??_C@_0BE@IIJI@?$CDGlobal?5Entity?5Lock?$AA@	; `string'
PUBLIC	??_C@_03IMFF@?$CD?$CFs?$AA@			; `string'
PUBLIC	??_C@_0L@PIFJ@ZeidonLock?$AA@			; `string'
PUBLIC	??_C@_01OAK@N?$AA@				; `string'
PUBLIC	??_C@_0BC@JGEA@Locking?5semaphore?$AA@		; `string'
PUBLIC	??_C@_0DE@IKDC@Waited?5too?5long?5to?5write?5pessimi@ ; `string'
EXTRN	_fnSysMessageBox@16:NEAR
EXTRN	__imp__sprintf:NEAR
EXTRN	_fnValidViewEntity@16:NEAR
EXTRN	_SysWait@4:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_SetCursorFirstEntityByString@20:NEAR
EXTRN	_fnCreateEntity@20:NEAR
EXTRN	_fnSysLockCoreMutex@4:NEAR
EXTRN	_fnSysUnlockCoreMutex@4:NEAR
EXTRN	_szlOE_SystemError:DWORD
;	COMDAT ??_C@_07KIPN@ZPLOCKO?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_07KIPN@ZPLOCKO?$AA@ DB 'ZPLOCKO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IIJI@?$CDGlobal?5Entity?5Lock?$AA@
_DATA	SEGMENT
??_C@_0BE@IIJI@?$CDGlobal?5Entity?5Lock?$AA@ DB '#Global Entity Lock', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IMFF@?$CD?$CFs?$AA@
_DATA	SEGMENT
??_C@_03IMFF@?$CD?$CFs?$AA@ DB '#%s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@PIFJ@ZeidonLock?$AA@
_DATA	SEGMENT
??_C@_0L@PIFJ@ZeidonLock?$AA@ DB 'ZeidonLock', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_01OAK@N?$AA@
_DATA	SEGMENT
??_C@_01OAK@N?$AA@ DB 'N', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@JGEA@Locking?5semaphore?$AA@
_DATA	SEGMENT
??_C@_0BC@JGEA@Locking?5semaphore?$AA@ DB 'Locking semaphore', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DE@IKDC@Waited?5too?5long?5to?5write?5pessimi@
_DATA	SEGMENT
??_C@_0DE@IKDC@Waited?5too?5long?5to?5write?5pessimi@ DB 'Waited too long'
	DB	' to write pessimistic lock semaphore', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_lpArray$ = 12
_nViewCount$ = 16
_pnViewErrorIdx$ = 20
_vSubtask$ = 24
_vLock$ = -20
_lpLockEntity$ = -24
_lpLockEntityCsr$ = -164
_lpEntityInstance$ = -84
_lpViewCluster$ = -88
_tViewArrayBlock$ = -152
_szLockName$ = -80
_bGlobalLockCreated$ = -8
_bArrayIsViewList$ = -12
_bMutexLocked$ = -168
_bCreateSemaphore$ = -4
_nCommit$ = -156
_k$ = -160
_nRC$ = -28
_lpViewOD$7863 = -172
_fnCreatePessimisticSemaphore@20 PROC NEAR

; 924  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	edi

; 925  :    ViewClusterRecord vLock;
; 926  :    LPVIEWENTITY      lpLockEntity;
; 927  :    LPVIEWENTITYCSR   lpLockEntityCsr;
; 928  :    LPENTITYINSTANCE  lpEntityInstance;
; 929  :    LPVIEWCLUSTER     lpViewCluster;
; 930  :    VIEWARRAYBLOCK    tViewArrayBlock = { 0 };

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	mov	ecx, 15					; 0000000fH
	xor	eax, eax
	lea	edi, DWORD PTR _tViewArrayBlock$[ebp+4]
	rep stosd

; 931  :    zCHAR             szLockName[ 50 ];
; 932  :    zBOOL             bGlobalLockCreated = FALSE;

	mov	BYTE PTR _bGlobalLockCreated$[ebp], 0

; 933  :    zBOOL             bArrayIsViewList;
; 934  :    zBOOL             bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$[ebp], 0

; 935  :    zBOOL             bCreateSemaphore;
; 936  :    zSHORT            nCommit;
; 937  :    zSHORT            k;
; 938  :    zSHORT            nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 939  : 
; 940  :    vLock.vOI = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 941  :    vLock.lControl = 0;

	mov	DWORD PTR _vLock$[ebp+4], 0

; 942  : 
; 943  :    if ( vSubtask == 0 )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	jne	SHORT $L7850

; 945  :       bArrayIsViewList = TRUE;

	mov	BYTE PTR _bArrayIsViewList$[ebp], 1

; 946  :       lpViewCluster = (LPVIEWCLUSTER) lpArray;

	mov	eax, DWORD PTR _lpArray$[ebp]
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 947  : 
; 948  :       // vSubtask is just the first valid view in the list.
; 949  :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L7852
$L7853:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L7852:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	SHORT $L7854

; 951  :          if ( lpViewCluster[ k ].vOI )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	je	SHORT $L7855

; 953  :             vSubtask = lpViewCluster[ k ].vOI;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _vSubtask$[ebp], edx

; 954  :             break;

	jmp	SHORT $L7854
$L7855:

; 956  :       }

	jmp	SHORT $L7853
$L7854:

; 958  :    else

	jmp	SHORT $L7856
$L7850:

; 959  :       bArrayIsViewList = FALSE;

	mov	BYTE PTR _bArrayIsViewList$[ebp], 0
$L7856:

; 960  : 
; 961  :    // Create an empty lock OI.
; 962  :    if ( fnDeclareView( &vLock.vOI, lpCurrentTask, vSubtask, "ZPLOCKO", 0 ) != 0 )

	push	0
	push	OFFSET FLAT:??_C@_07KIPN@ZPLOCKO?$AA@	; `string'
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDeclareView@20
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7857

; 963  :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7835
$L7857:

; 964  : 
; 965  :    if ( fnActivateEmptyObjectInstance( lpCurrentTask, vLock.vOI, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7859

; 966  :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7835
$L7859:

; 967  : 
; 968  :    // It's possible that the user wants to keep the locks for all the views.
; 969  :    // Following flag is TRUE if there is a least one lock.
; 970  :    bCreateSemaphore = FALSE;

	mov	BYTE PTR _bCreateSemaphore$[ebp], 0

; 971  : 
; 972  :    // Loop through all the views and set a lock.
; 973  :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L7860
$L7861:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L7860:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$L7862

; 975  :       LPVIEWOD lpViewOD;
; 976  : 
; 977  :       if ( bArrayIsViewList )

	mov	ecx, DWORD PTR _bArrayIsViewList$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L7864

; 979  :          if ( lpViewCluster[ k ].vOI == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	jne	SHORT $L7865

; 980  :             continue;

	jmp	SHORT $L7861
$L7865:

; 981  : 
; 982  :          // If we're keeping locks on this guy then skip him.
; 983  :          if ( lpViewCluster[ k ].lControl & zCOMMIT_KEEPLOCKS )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $L7866

; 984  :             continue;

	jmp	SHORT $L7861
$L7866:

; 985  : 
; 986  :          // Get ViewOD from view.
; 987  :          lpViewOD = zGETPTR( lpViewCluster[ k ].vOI->hViewOD );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$7863[ebp], eax

; 989  :       else

	jmp	SHORT $L7868
$L7864:

; 991  :          if ( lpArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $L7869

; 992  :             continue;

	jmp	$L7861
$L7869:

; 993  : 
; 994  :          lpViewOD = (LPVIEWOD) lpArray[ k ];

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _lpViewOD$7863[ebp], eax
$L7868:

; 996  : 
; 997  :       // If this ViewOD doesn't have any locking (which is possible if we're
; 998  :       // committing a cluster) then we can skip it.
; 999  :       if ( lpViewOD->nLock       < zLL_PESSIMISTIC &&
; 1000 :            lpViewOD->nEntityLock < zLL_PESSIMISTIC )

	mov	ecx, DWORD PTR _lpViewOD$7863[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	cmp	edx, 3
	jge	SHORT $L7871
	mov	eax, DWORD PTR _lpViewOD$7863[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+237]
	cmp	ecx, 3
	jge	SHORT $L7871

; 1002 :          continue;

	jmp	$L7861
$L7871:

; 1004 : 
; 1005 :       bCreateSemaphore = TRUE;

	mov	BYTE PTR _bCreateSemaphore$[ebp], 1

; 1006 : 
; 1007 :       // Set lock name.  If OD does not have pessimistic locking at the entity
; 1008 :       // level then it's safe to lock out other users trying to lock the same
; 1009 :       // OD.  This allows us to use the entity name for the locking semaphore.
; 1010 :       // If the OD has entity locking we need to use a "global" entity locking
; 1011 :       // semaphore so that no one can lock entities at the same time.
; 1012 :       if ( lpViewOD->nEntityLock )

	mov	edx, DWORD PTR _lpViewOD$7863[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+237]
	test	eax, eax
	je	SHORT $L7872

; 1014 :          // If we've already created the global lock entity just continue.
; 1015 :          if ( bGlobalLockCreated )

	mov	ecx, DWORD PTR _bGlobalLockCreated$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L7873

; 1016 :             continue;

	jmp	$L7861
$L7873:

; 1017 : 
; 1018 :          bGlobalLockCreated = TRUE;

	mov	BYTE PTR _bGlobalLockCreated$[ebp], 1

; 1019 : 
; 1020 :          // We are using entity level locking.
; 1021 :          zstrcpy( szLockName, "#Global Entity Lock" );

	push	OFFSET FLAT:??_C@_0BE@IIJI@?$CDGlobal?5Entity?5Lock?$AA@ ; `string'
	lea	edx, DWORD PTR _szLockName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1023 :       else

	jmp	SHORT $L7875
$L7872:

; 1024 :          // We are not using entity level locking so we can just lock out other
; 1025 :          // users using the same LOD.  We prefix the name with a '#' to to
; 1026 :          // indicate that this is the locking semaphore.
; 1027 :          zsprintf( szLockName, "#%s", lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$7863[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET FLAT:??_C@_03IMFF@?$CD?$CFs?$AA@	; `string'
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L7875:

; 1028 : 
; 1029 :       // Check to make sure we're not already setting the lock for this type.
; 1030 :       if ( SetCursorFirstEntityByString( vLock.vOI, "ZeidonLock", "LOD_Name",
; 1031 :                                          szLockName, 0 ) >= zCURSOR_SET )

	push	0
	lea	edx, DWORD PTR _szLockName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08GDMG@LOD_Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jl	SHORT $L7877

; 1033 :          continue;

	jmp	$L7861
$L7877:

; 1035 : 
; 1036 :       // Get the lpViewEntity and lpLockEntityCsr for the lock OI.
; 1037 :       lpLockEntity = fnValidViewEntity( &lpLockEntityCsr, vLock.vOI,
; 1038 :                                         "ZeidonLock", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpLockEntity$[ebp], eax

; 1039 : 
; 1040 :       if ( fnCreateEntity( vLock.vOI, lpLockEntity, lpLockEntityCsr,
; 1041 :                            zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	ecx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnCreateEntity@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L7880

; 1043 :          goto EndOfFunction;

	jmp	$EndOfFunction$7881
$L7880:

; 1045 : 
; 1046 :       // fnCreateEntity DOES NOT set the bCreated flag so set it.
; 1047 :       lpEntityInstance = zGETPTR( lpLockEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1048 :       lpEntityInstance->u.nInd.bCreated = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 2
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 1049 : 
; 1050 :       // Set entity name and key string (which is just a description).
; 1051 :       if ( fnSetLockingAttributes( lpCurrentTask,
; 1052 :                                    vLock.vOI, lpLockEntity, lpLockEntityCsr,
; 1053 :                                    szLockName, "Locking semaphore",
; 1054 :                                    TRUE, TRUE, "N" ) != 0 )

	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	1
	push	1
	push	OFFSET FLAT:??_C@_0BC@JGEA@Locking?5semaphore?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnSetLockingAttributes@36
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7883

; 1055 :          goto EndOfFunction;

	jmp	$EndOfFunction$7881
$L7883:

; 1056 : 
; 1057 :    } // for ( k... )...

	jmp	$L7861
$L7862:

; 1058 : 
; 1059 :    // If we didn't find any views that needed to drop their locks then get out.
; 1060 :    if ( bCreateSemaphore == FALSE )

	mov	ecx, DWORD PTR _bCreateSemaphore$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L7886

; 1061 :       return( 1 );

	mov	ax, 1
	jmp	$L7835
$L7886:

; 1062 : 
; 1063 :    // Now lock the pessimistic semaphore.  This will hopefully single-thread
; 1064 :    // creation of the semaphore.  It doesn't really do anything if we are
; 1065 :    // running as simple client-server.
; 1066 :    zLOCK_MUTEX( zMUTEX_PESSIMISTICLOCK );

	push	9
	call	_fnSysLockCoreMutex@4

; 1067 :    bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$[ebp], 1

; 1068 : 
; 1069 :    // Now commit the lock OI.  This should set the semaphore lock.  We'll try
; 1070 :    // a few times before giving up.
; 1071 :    if ( fnInitViewArrayBlock( &tViewArrayBlock, 1 ) != 0 )

	push	1
	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7887

; 1072 :       goto EndOfFunction;

	jmp	$EndOfFunction$7881
$L7887:

; 1073 : 
; 1074 :    for ( k = 0; k < 10; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L7888
$L7889:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L7888:
	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 10					; 0000000aH
	jge	SHORT $L7890

; 1076 :       // Try committing the semaphore.  If the return code indicates that
; 1077 :       // we have a duplicate root then somebody else is working with the
; 1078 :       // lock object so try again.
; 1079 :       nCommit = fnCommitObjectInstance( &vLock, &vLock.vOI, 1, 0,
; 1080 :                                         lpCurrentTask, 0, &tViewArrayBlock );

	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	1
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnCommitObjectInstance@28
	mov	WORD PTR _nCommit$[ebp], ax

; 1081 :       if ( nCommit == 0 )

	movsx	ecx, WORD PTR _nCommit$[ebp]
	test	ecx, ecx
	jne	SHORT $L7891

; 1082 :          break;               // Everything OK.

	jmp	SHORT $L7890
$L7891:

; 1083 : 
; 1084 :       if ( nCommit == zDUPLICATE_ROOT )

	movsx	edx, WORD PTR _nCommit$[ebp]
	cmp	edx, -4					; fffffffcH
	jne	SHORT $L7892

; 1086 :          SysWait( 1000 );     // Wait a second.

	push	1000					; 000003e8H
	call	_SysWait@4

; 1087 :          continue;            // Try again.

	jmp	SHORT $L7889
$L7892:

; 1089 : 
; 1090 :       // Oops--there must be something wrong.  Get out.
; 1091 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$7881
$L7890:

; 1093 : 
; 1094 :    // If nCommit isn't 0 then we had problems trying to write the semaphore
; 1095 :    // record.  Show error and get out.
; 1096 :    if ( nCommit )

	movsx	eax, WORD PTR _nCommit$[ebp]
	test	eax, eax
	je	SHORT $L7893

; 1098 :       fnSysMessageBox( lpCurrentTask, szlOE_SystemError,
; 1099 :                        "Waited too long to write pessimistic lock semaphore", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0DE@IKDC@Waited?5too?5long?5to?5write?5pessimi@ ; `string'
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnSysMessageBox@16

; 1100 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$7881
$L7893:

; 1102 : 
; 1103 :    // Set flag indicating that current task has written locking semaphore.
; 1104 :    lpCurrentTask->bPessimisticLockingSet = TRUE;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	or	ch, 1
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [edx+443], ecx

; 1105 : 
; 1106 :    // If we get here everything's OK.
; 1107 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$7881:

; 1108 : 
; 1109 : EndOfFunction:
; 1110 :    // If something went wrong then unlock the mutex.
; 1111 :    if ( nRC && bMutexLocked )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L7895
	mov	ecx, DWORD PTR _bMutexLocked$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L7895

; 1112 :       zUNLOCK_MUTEX( zMUTEX_PESSIMISTICLOCK );

	push	9
	call	_fnSysUnlockCoreMutex@4
$L7895:

; 1113 : 
; 1114 :    if ( vLock.vOI )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $L7896

; 1115 :       fnDropView( vLock.vOI );

	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDropView@4
$L7896:

; 1116 : 
; 1117 :    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 1118 : 
; 1119 :    if ( nRC == zCALL_ERROR && pnViewErrorIdx )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $L7897
	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L7897

; 1120 :       *pnViewErrorIdx = k;

	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	ax, WORD PTR _k$[ebp]
	mov	WORD PTR [edx], ax
$L7897:

; 1121 : 
; 1122 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L7835:

; 1123 : 
; 1124 : } // fnCreatePessimisticSemaphore

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnCreatePessimisticSemaphore@20 ENDP
_TEXT	ENDS
PUBLIC	_fnDeletePessimisticSemaphore@20
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_lpArray$ = 12
_nViewCount$ = 16
_pnViewErrorIdx$ = 20
_vSubtask$ = 24
_vLock$ = -12
_szLockName$ = -76
_lpLockEntity$ = -16
_lpLockEntityCsr$ = -152
_lpEntityInstance$ = -24
_lpViewCluster$ = -80
_tViewArrayBlock$ = -144
_bArrayIsViewList$ = -4
_k$ = -148
_nRC$ = -20
_lpViewOD$7932 = -156
_fnDeletePessimisticSemaphore@20 PROC NEAR

; 1132 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	edi

; 1133 :    ViewClusterRecord vLock;
; 1134 :    zCHAR             szLockName[ 50 ];
; 1135 :    LPVIEWENTITY      lpLockEntity;
; 1136 :    LPVIEWENTITYCSR   lpLockEntityCsr;
; 1137 :    LPENTITYINSTANCE  lpEntityInstance;
; 1138 :    LPVIEWCLUSTER     lpViewCluster;
; 1139 :    VIEWARRAYBLOCK    tViewArrayBlock = {0};

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	mov	ecx, 15					; 0000000fH
	xor	eax, eax
	lea	edi, DWORD PTR _tViewArrayBlock$[ebp+4]
	rep stosd

; 1140 :    zBOOL             bArrayIsViewList;
; 1141 :    zSHORT            k;
; 1142 :    zSHORT            nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 1143 : 
; 1144 :    vLock.vOI = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 1145 :    vLock.lControl = 0;

	mov	DWORD PTR _vLock$[ebp+4], 0

; 1146 : 
; 1147 :    if ( vSubtask == 0 )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	jne	SHORT $L7920

; 1149 :       bArrayIsViewList = TRUE;

	mov	BYTE PTR _bArrayIsViewList$[ebp], 1

; 1150 :       lpViewCluster = (LPVIEWCLUSTER) lpArray;

	mov	eax, DWORD PTR _lpArray$[ebp]
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 1151 : 
; 1152 :       // vSubtask is just the first valid view in the list.
; 1153 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L7922
$L7923:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L7922:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	SHORT $L7924

; 1155 :          if ( lpViewCluster[ k ].vOI )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	je	SHORT $L7925

; 1157 :             vSubtask = lpViewCluster[ k ].vOI;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _vSubtask$[ebp], edx

; 1158 :             break;

	jmp	SHORT $L7924
$L7925:

; 1160 :       }

	jmp	SHORT $L7923
$L7924:

; 1162 :    else

	jmp	SHORT $L7926
$L7920:

; 1163 :       bArrayIsViewList = FALSE;

	mov	BYTE PTR _bArrayIsViewList$[ebp], 0
$L7926:

; 1164 : 
; 1165 :    // Create an empty lock OI.
; 1166 :    if ( fnDeclareView( &vLock.vOI, lpCurrentTask, vSubtask, "ZPLOCKO", 0 ) != 0 )

	push	0
	push	OFFSET FLAT:??_C@_07KIPN@ZPLOCKO?$AA@	; `string'
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDeclareView@20
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7927

; 1167 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7909
$L7927:

; 1168 : 
; 1169 :    if ( fnActivateEmptyObjectInstance( lpCurrentTask, vLock.vOI, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7928

; 1170 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L7909
$L7928:

; 1171 : 
; 1172 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L7929
$L7930:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L7929:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$L7931

; 1174 :       LPVIEWOD lpViewOD;
; 1175 : 
; 1176 :       if ( bArrayIsViewList )

	mov	ecx, DWORD PTR _bArrayIsViewList$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L7933

; 1178 :          if ( lpViewCluster[ k ].vOI == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	jne	SHORT $L7934

; 1179 :             continue;

	jmp	SHORT $L7930
$L7934:

; 1180 : 
; 1181 :          // If we're keeping locks on this guy then skip him.
; 1182 :          if ( lpViewCluster[ k ].lControl & zCOMMIT_KEEPLOCKS )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $L7935

; 1183 :             continue;

	jmp	SHORT $L7930
$L7935:

; 1184 : 
; 1185 :          // Get ViewOD from view.
; 1186 :          lpViewOD = zGETPTR( lpViewCluster[ k ].vOI->hViewOD );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$7932[ebp], eax

; 1188 :       else

	jmp	SHORT $L7937
$L7933:

; 1190 :          if ( lpArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $L7938

; 1191 :             continue;

	jmp	$L7930
$L7938:

; 1192 : 
; 1193 :          lpViewOD = (LPVIEWOD) lpArray[ k ];

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _lpViewOD$7932[ebp], eax
$L7937:

; 1195 : 
; 1196 :       // If this ViewOD doesn't have any locking (which is possible if we're
; 1197 :       // committing a cluster) then we can skip it.
; 1198 :       if ( lpViewOD->nLock       < zLL_PESSIMISTIC &&
; 1199 :            lpViewOD->nEntityLock < zLL_PESSIMISTIC )

	mov	ecx, DWORD PTR _lpViewOD$7932[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	cmp	edx, 3
	jge	SHORT $L7940
	mov	eax, DWORD PTR _lpViewOD$7932[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+237]
	cmp	ecx, 3
	jge	SHORT $L7940

; 1201 :          continue;

	jmp	$L7930
$L7940:

; 1203 : 
; 1204 :       // Set lock name.  If OD does not have pessimistic locking at the entity
; 1205 :       // level then it's safe to lock out other users trying to lock the same
; 1206 :       // OD.  This allows us to use the entity name for the locking semaphore.
; 1207 :       // If the OD has entity locking we need to use a "global" entity locking
; 1208 :       // semaphore so that no one can lock entities at the same time.
; 1209 :       if ( lpViewOD->nEntityLock )

	mov	edx, DWORD PTR _lpViewOD$7932[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+237]
	test	eax, eax
	je	SHORT $L7941

; 1211 :          // We are using entity level locking.
; 1212 :          zstrcpy( szLockName, "#Global Entity Lock" );

	push	OFFSET FLAT:??_C@_0BE@IIJI@?$CDGlobal?5Entity?5Lock?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1214 :       else

	jmp	SHORT $L7942
$L7941:

; 1216 :          // We are not using entity level locking so we can just lock out other
; 1217 :          // users using the same LOD.  We prefix the name with a '#' to to
; 1218 :          // indicate that this is the locking semaphore.
; 1219 :          zsprintf( szLockName, "#%s", lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$7932[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_03IMFF@?$CD?$CFs?$AA@	; `string'
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L7942:

; 1221 : 
; 1222 :       // Get the lpViewEntity and lpLockEntityCsr for the lock OI.
; 1223 :       lpLockEntity = fnValidViewEntity( &lpLockEntityCsr, vLock.vOI,
; 1224 :                                         "ZeidonLock", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpLockEntity$[ebp], eax

; 1225 : 
; 1226 :       if ( fnCreateEntity( vLock.vOI, lpLockEntity, lpLockEntityCsr,
; 1227 :                            zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLockEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnCreateEntity@20
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7944

; 1229 :          goto EndOfFunction;

	jmp	$EndOfFunction$7945
$L7944:

; 1231 : 
; 1232 :       // Set entity name and key string (which is just a description).
; 1233 :       if ( fnSetLockingAttributes( lpCurrentTask,
; 1234 :                                    vLock.vOI, lpLockEntity, lpLockEntityCsr,
; 1235 :                                    szLockName, "Locking semaphore",
; 1236 :                                    0, 0, 0 ) != 0 )

	push	0
	push	0
	push	0
	push	OFFSET FLAT:??_C@_0BC@JGEA@Locking?5semaphore?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnSetLockingAttributes@36
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7946

; 1238 :          goto EndOfFunction;

	jmp	$EndOfFunction$7945
$L7946:

; 1240 : 
; 1241 :       // Here's where we cheat -- turn off Create flag and turn on the
; 1242 :       // Delete/Hidden flags so that when we commit the OI the locking
; 1243 :       // records will be deleted.
; 1244 :       lpEntityInstance = zGETPTR( lpLockEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpLockEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1245 :       lpEntityInstance->u.nInd.bCreated = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 1246 :       lpEntityInstance->u.nInd.bDeleted = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 8
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 1247 :       lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ch, 4
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 1248 :    }

	jmp	$L7930
$L7931:

; 1249 : 
; 1250 :    // Set flag indicating that current task no longer has a locking semaphore.
; 1251 :    lpCurrentTask->bPessimisticLockingSet = FALSE;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	and	ch, -2					; fffffffeH
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [edx+443], ecx

; 1252 : 
; 1253 :    // Now commit the lock OI.  This should release the semaphore lock.
; 1254 :    if ( fnInitViewArrayBlock( &tViewArrayBlock, 1 ) != 0 )

	push	1
	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L7948

; 1255 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$7945
$L7948:

; 1256 : 
; 1257 :    if ( fnCommitObjectInstance( &vLock, &vLock.vOI, 1, 0, lpCurrentTask,
; 1258 :                                 0, &tViewArrayBlock ) != 0 )

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	1
	lea	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnCommitObjectInstance@28
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L7949

; 1260 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$7945
$L7949:

; 1262 : 
; 1263 :    // If we get here everything's OK.
; 1264 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$7945:

; 1265 : 
; 1266 : EndOfFunction:
; 1267 :    zUNLOCK_MUTEX( zMUTEX_PESSIMISTICLOCK );

	push	9
	call	_fnSysUnlockCoreMutex@4

; 1268 : 
; 1269 :    if ( vLock.vOI )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $L7950

; 1270 :       fnDropView( vLock.vOI );

	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnDropView@4
$L7950:

; 1271 : 
; 1272 :    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 1273 : 
; 1274 :    if ( nRC == zCALL_ERROR && pnViewErrorIdx )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L7951
	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L7951

; 1275 :       *pnViewErrorIdx = k;

	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	dx, WORD PTR _k$[ebp]
	mov	WORD PTR [ecx], dx
$L7951:

; 1276 : 
; 1277 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L7909:

; 1278 : 
; 1279 : } // fnDeletePessimisticSemaphore

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnDeletePessimisticSemaphore@20 ENDP
_TEXT	ENDS
PUBLIC	_fnRelinkObjectInstance@4
EXTRN	_fnEstablishViewForInstance:NEAR
EXTRN	_fnIncludeSubobjectFromSubobject:NEAR
EXTRN	_fnInstanceKeysMatch:NEAR
EXTRN	_fnRelinkInstanceToInstance:NEAR
_TEXT	SEGMENT
_lpView$ = 8
_lpViewEntity$ = -28
_lpViewOD$ = -8
_lpViewCsr$ = -4
_lpViewOI$ = -32
_lpRootInstance$ = -24
_lpEntityInstance$ = -20
_lpSearchInstance$ = -16
_nRC$ = -12
_lpDupEntityInstance$7970 = -36
_lpSearchViewEntity$7983 = -40
_hDupRelParent$7995 = -44
_lpParentInstance$7996 = -48
_lpSearchInstance$8002 = -56
_lpSourceInstance$8003 = -52
_lpSourceEntity$8009 = -60
_lpViewEntityCsr$8010 = -64
_fnRelinkObjectInstance@4 PROC NEAR

; 1301 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1302 :    LPVIEWENTITY      lpViewEntity;
; 1303 :    LPVIEWOD          lpViewOD;
; 1304 :    LPVIEWCSR         lpViewCsr;
; 1305 :    LPVIEWOI          lpViewOI;
; 1306 :    LPENTITYINSTANCE  lpRootInstance;
; 1307 :    LPENTITYINSTANCE  lpEntityInstance;
; 1308 :    LPENTITYINSTANCE  lpSearchInstance;
; 1309 :    zSHORT            nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 1310 : 
; 1311 :    lpViewOD       = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1312 :    lpViewCsr      = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1313 :    lpViewOI       = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1314 :    lpRootInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootInstance$[ebp], eax

; 1315 : 
; 1316 :    if ( lpRootInstance == 0 )

	cmp	DWORD PTR _lpRootInstance$[ebp], 0
	jne	SHORT $L7968

; 1317 :       return( 0 );

	xor	ax, ax
	jmp	$L7955
$L7968:

; 1318 : 
; 1319 :    // If the object definition has view entities marked as
; 1320 :    // has dup instance, go through and attempt to relink them
; 1321 :    // together now
; 1322 :    if ( lpViewOD->bHasDupInstance )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	and	eax, 1
	test	eax, eax
	je	$L7975

; 1324 :       LPENTITYINSTANCE lpDupEntityInstance = 0;

	mov	DWORD PTR _lpDupEntityInstance$7970[ebp], 0

; 1325 : 
; 1326 :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L7971

; 1327 :          nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1
$L7971:

; 1328 : 
; 1329 :       // Look for EI's that are flagged as duplicate instances and link
; 1330 :       // together the same instances.  We will start looping with the first
; 1331 :       // EI and see if it is the same as any PREVIOUS EI's.  If we find a
; 1332 :       // match then they will be linked.
; 1333 :       for ( lpEntityInstance = lpRootInstance;
; 1334 :             lpEntityInstance;
; 1335 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpRootInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $L7973
$L7974:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L7973:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L7975

; 1337 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1338 : 
; 1339 :          // If this EI isn't a duplicate entity then skip it.
; 1340 :          if ( lpViewEntity->bDupInstance == FALSE )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 25					; 00000019H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L7977

; 1341 :             continue;

	jmp	SHORT $L7974
$L7977:

; 1342 : 
; 1343 :          // To save some looping time we'll keep track of the first EI that
; 1344 :          // is flagged as a dup instance.
; 1345 :          if ( lpDupEntityInstance == 0 )

	cmp	DWORD PTR _lpDupEntityInstance$7970[ebp], 0
	jne	SHORT $L7978

; 1346 :             lpDupEntityInstance = lpEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpDupEntityInstance$7970[ebp], eax
$L7978:

; 1347 : 
; 1348 :          // Now try to find the first EI that matches lpEntityInstance.  If
; 1349 :          // lpSearchInstance == lpEntityInstance then we've searched all the
; 1350 :          // previous EIs so we can stop looking.
; 1351 :          for ( lpSearchInstance = lpDupEntityInstance;
; 1352 :                lpSearchInstance != lpEntityInstance;
; 1353 :                lpSearchInstance = zGETPTR( lpSearchInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpDupEntityInstance$7970[ebp]
	mov	DWORD PTR _lpSearchInstance$[ebp], ecx
	jmp	SHORT $L7980
$L7981:
	mov	edx, DWORD PTR _lpSearchInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchInstance$[ebp], eax
$L7980:
	mov	ecx, DWORD PTR _lpSearchInstance$[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L7982

; 1355 :             LPVIEWENTITY lpSearchViewEntity;
; 1356 : 
; 1357 :             lpSearchViewEntity = zGETPTR( lpSearchInstance->hViewEntity );

	mov	edx, DWORD PTR _lpSearchInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$7983[ebp], eax

; 1358 : 
; 1359 :             // If the entities are not the same ER entity then we can't link.
; 1360 :             if ( lpViewEntity->lEREntTok != lpSearchViewEntity->lEREntTok )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR _lpSearchViewEntity$7983[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	je	SHORT $L7985

; 1361 :                continue;

	jmp	SHORT $L7981
$L7985:

; 1362 : 
; 1363 :             // The search view entity must be flagged as duplicate instance.
; 1364 :             if ( lpSearchViewEntity->bDupInstance == FALSE )

	mov	ecx, DWORD PTR _lpSearchViewEntity$7983[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 25					; 00000019H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L7986

; 1365 :                continue;

	jmp	SHORT $L7981
$L7986:

; 1366 : 
; 1367 :             if ( !fnInstanceKeysMatch( lpEntityInstance, lpSearchInstance ) )

	mov	eax, DWORD PTR _lpSearchInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L7987

; 1368 :                continue;

	jmp	SHORT $L7981
$L7987:

; 1369 : 
; 1370 :             fnRelinkInstanceToInstance( lpEntityInstance, lpSearchInstance );

	mov	eax, DWORD PTR _lpSearchInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRelinkInstanceToInstance
	add	esp, 8
$L7982:

; 1377 : 
; 1378 :       } // for ( lpEntityInstance...)

	jmp	$L7974
$L7975:

; 1381 : 
; 1382 :    // if the view object has duplicate relationships, try and
; 1383 :    // spawn any necessary includes to instantiate the relationships
; 1384 :    if ( lpViewOD->bHasDupRel )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	$L7994

; 1386 :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L7989

; 1387 :          nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1
$L7989:

; 1388 : 
; 1389 :       // Loop through the view entities and look for entities that are
; 1390 :       // flagged as dup relationships.
; 1391 :       for ( lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );
; 1392 :             lpViewEntity;
; 1393 :             lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $L7992
$L7993:
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$L7992:
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	$L7994

; 1395 :          LPVIEWENTITY      hDupRelParent;
; 1396 :          LPENTITYINSTANCE  lpParentInstance;
; 1397 : 
; 1398 :          if ( lpViewEntity->bDupRel == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 26					; 0000001aH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L7997

; 1399 :             continue;

	jmp	SHORT $L7993
$L7997:

; 1400 : 
; 1401 :          // Get the parent entity of the dup rel entity.  Then we will loop
; 1402 :          // through all the the EI's looking for instances of the parent.
; 1403 :          hDupRelParent = lpViewEntity->hParent;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	mov	DWORD PTR _hDupRelParent$7995[ebp], eax

; 1404 :          for ( lpParentInstance = lpRootInstance;
; 1405 :                lpParentInstance;
; 1406 :                lpParentInstance = zGETPTR( lpParentInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpRootInstance$[ebp]
	mov	DWORD PTR _lpParentInstance$7996[ebp], ecx
	jmp	SHORT $L7999
$L8000:
	mov	edx, DWORD PTR _lpParentInstance$7996[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentInstance$7996[ebp], eax
$L7999:
	cmp	DWORD PTR _lpParentInstance$7996[ebp], 0
	je	$L8001

; 1408 :             LPENTITYINSTANCE lpSearchInstance;
; 1409 :             LPENTITYINSTANCE lpSourceInstance;
; 1410 : 
; 1411 :             if ( lpParentInstance->hViewEntity != hDupRelParent )

	mov	ecx, DWORD PTR _lpParentInstance$7996[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hDupRelParent$7995[ebp]
	je	SHORT $L8004

; 1412 :                continue;

	jmp	SHORT $L8000
$L8004:

; 1413 : 
; 1414 :             // We have found an an entity instance that is the parent of the
; 1415 :             // dup rel entity.  Now we have to check to see if we should
; 1416 :             // include another entity instance under the parent.  Look to
; 1417 :             // see if there is another EI in the OI who's relationship
; 1418 :             // matches the dup rel entity.
; 1419 :             for ( lpSearchInstance = lpRootInstance;
; 1420 :                   lpSearchInstance;
; 1421 :                   lpSearchInstance = zGETPTR( lpSearchInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpRootInstance$[ebp]
	mov	DWORD PTR _lpSearchInstance$8002[ebp], eax
	jmp	SHORT $L8006
$L8007:
	mov	ecx, DWORD PTR _lpSearchInstance$8002[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchInstance$8002[ebp], eax
$L8006:
	cmp	DWORD PTR _lpSearchInstance$8002[ebp], 0
	je	$L8008

; 1423 :                LPVIEWENTITY    lpSourceEntity;
; 1424 :                LPVIEWENTITYCSR lpViewEntityCsr;
; 1425 : 
; 1426 :                lpSourceEntity = zGETPTR( lpSearchInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSearchInstance$8002[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceEntity$8009[ebp], eax

; 1427 : 
; 1428 :                // If the relationship token of the source instance does not
; 1429 :                // match the token of the dup rel entity then try the next one.
; 1430 :                if ( lpSourceEntity->lERRelTok != lpViewEntity->lERRelTok )

	mov	edx, DWORD PTR _lpSourceEntity$8009[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+199]
	cmp	ecx, DWORD PTR [eax+199]
	je	SHORT $L8012

; 1431 :                   continue;

	jmp	SHORT $L8007
$L8012:

; 1432 : 
; 1433 :                // Make sure the source entity is not derived or dup rel itself.
; 1434 :                if ( lpSourceEntity->bDerivedPath || lpSourceEntity->bDupRelPath )

	mov	edx, DWORD PTR _lpSourceEntity$8009[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	jne	SHORT $L8014
	mov	ecx, DWORD PTR _lpSourceEntity$8009[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	test	edx, edx
	je	SHORT $L8013
$L8014:

; 1435 :                   continue;

	jmp	SHORT $L8007
$L8013:

; 1436 : 
; 1437 :                // Check to see if the relationship of the search instance is
; 1438 :                // the same or the inverse of lpViewEntity.
; 1439 :                if ( lpSourceEntity->lEREntTok == lpViewEntity->lEREntTok )

	mov	eax, DWORD PTR _lpSourceEntity$8009[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	jne	SHORT $L8015

; 1441 :                   // If we get here then the following is an example of the
; 1442 :                   // situation:
; 1443 :                   //
; 1444 :                   //     (R)
; 1445 :                   //      |
; 1446 :                   //     (A)
; 1447 :                   //    /  \
; 1448 :                   //  (X)  (B)
; 1449 :                   //   |    |
; 1450 :                   //  (Y)  (X')
; 1451 :                   //        |
; 1452 :                   //       (Y')
; 1453 :                   //
; 1454 :                   // Y' is the dup rel entity (lpViewEntity) and X' is the
; 1455 :                   // parent (lpParent).  Y is the current lpSearchInstance and
; 1456 :                   // is the entity that we want to include under X'.  In this
; 1457 :                   // case we want to make sure that the values of the keys for
; 1458 :                   // X and X' are the same.
; 1459 :                   if ( !fnInstanceKeysMatch( lpParentInstance,
; 1460 :                                              zGETPTR( lpSearchInstance->hParent ) ) )

	mov	eax, DWORD PTR _lpSearchInstance$8002[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpParentInstance$7996[ebp]
	push	edx
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L8017

; 1462 :                      // Keys don't match so it's not a candidate.  Try again
; 1463 :                      // with the next instance.
; 1464 :                      continue;

	jmp	$L8007
$L8017:

; 1466 : 
; 1467 :                   // Source for the include is Y (lpSearchInstance).
; 1468 :                   lpSourceInstance = lpSearchInstance;

	mov	ecx, DWORD PTR _lpSearchInstance$8002[ebp]
	mov	DWORD PTR _lpSourceInstance$8003[ebp], ecx

; 1470 :                else

	jmp	SHORT $L8018
$L8015:

; 1472 :                   // If we get here then the following is an example of the
; 1473 :                   // situation:
; 1474 :                   //
; 1475 :                   //                       (R)
; 1476 :                   //                        |
; 1477 :                   //                       (A)
; 1478 :                   //                      /  \
; 1479 :                   //  X and Y are  ==>  (Y)  (B)
; 1480 :                   //  inversed           |    |
; 1481 :                   //  from above   ==>  (X)  (X')
; 1482 :                   //                          |
; 1483 :                   //                         (Y')
; 1484 :                   //
; 1485 :                   // Y' is the dup rel entity (lpViewEntity) and X' is the
; 1486 :                   // parent (lpParent).  X is the current lpSearchInstance.
; 1487 :                   // The entity that we want to include under X' is the
; 1488 :                   // parent of X -- Y.  Make sure X and X' are the same.
; 1489 :                   if ( !fnInstanceKeysMatch( lpParentInstance,
; 1490 :                                              lpSearchInstance ) )

	mov	edx, DWORD PTR _lpSearchInstance$8002[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParentInstance$7996[ebp]
	push	eax
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L8019

; 1492 :                      // Keys don't match so it's not a candidate.  Try again
; 1493 :                      // with the next instance.
; 1494 :                      continue;

	jmp	$L8007
$L8019:

; 1496 : 
; 1497 :                   // The source of the include is the parent of X.
; 1498 :                   lpSourceInstance = zGETPTR( lpSearchInstance->hParent );

	mov	edx, DWORD PTR _lpSearchInstance$8002[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceInstance$8003[ebp], eax

; 1499 :                   lpSourceEntity   = zGETPTR( lpSourceInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSourceInstance$8003[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceEntity$8009[ebp], eax
$L8018:

; 1501 : 
; 1502 :                // We have found a match!  First establish the cursor positions
; 1503 :                // to match our parent and source instances.
; 1504 :                lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$8010[ebp], eax

; 1505 :                lpViewEntityCsr += (lpViewEntity->nHierNbr - 1);

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	sub	eax, 1
	imul	eax, 30					; 0000001eH
	mov	ecx, DWORD PTR _lpViewEntityCsr$8010[ebp]
	add	ecx, eax
	mov	DWORD PTR _lpViewEntityCsr$8010[ebp], ecx

; 1506 :                lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpViewEntityCsr$8010[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$8010[ebp], eax

; 1507 :                fnEstablishViewForInstance( lpView, lpViewEntityCsr,
; 1508 :                                            lpParentInstance );

	mov	ecx, DWORD PTR _lpParentInstance$7996[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$8010[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1509 : 
; 1510 :                lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$8010[ebp], eax

; 1511 :                lpViewEntityCsr += (lpSourceEntity->nHierNbr - 1);

	mov	eax, DWORD PTR _lpSourceEntity$8009[ebp]
	movsx	ecx, WORD PTR [eax+217]
	sub	ecx, 1
	imul	ecx, 30					; 0000001eH
	mov	edx, DWORD PTR _lpViewEntityCsr$8010[ebp]
	add	edx, ecx
	mov	DWORD PTR _lpViewEntityCsr$8010[ebp], edx

; 1512 :                fnEstablishViewForInstance( lpView, lpViewEntityCsr,
; 1513 :                                            lpSourceInstance );

	mov	eax, DWORD PTR _lpSourceInstance$8003[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$8010[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1514 : 
; 1515 :                // Include the source instance to instantiate the dup rel entity.
; 1516 :                if ( fnIncludeSubobjectFromSubobject( lpView, lpViewEntity,
; 1517 :                                                      lpView, lpSourceEntity,
; 1518 :                                                      zPOS_FIRST, 0,
; 1519 :                                                      0 ) == zCALL_ERROR )

	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _lpSourceEntity$8009[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnIncludeSubobjectFromSubobject
	add	esp, 28					; 0000001cH
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $L8026

; 1521 :                   return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L7955
$L8026:

; 1523 : 
; 1524 :                // We've found the source instance and included it so we're
; 1525 :                // done looking for a source instance to include so break.
; 1526 :                //break;
; 1527 : 
; 1528 :             } // for ( lpSearchInstance )...

	jmp	$L8007
$L8008:

; 1529 : 
; 1530 :          } // for ( lpParentInstance )...

	jmp	$L8000
$L8001:

; 1531 : 
; 1532 :       } // for ( lpViewEntity...)

	jmp	$L7993
$L7994:

; 1535 : 
; 1536 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L7955:

; 1537 : 
; 1538 : } // fnRelinkObjectInstance

	mov	esp, ebp
	pop	ebp
	ret	4
_fnRelinkObjectInstance@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DIOI@QualAttrib?$AA@			; `string'
PUBLIC	??_C@_0O@GCPH@SubQualAttrib?$AA@		; `string'
PUBLIC	??_C@_0BL@GDPI@Network?5cannot?5be?5started?4?$AA@ ; `string'
PUBLIC	??_C@_08IDGA@KZOEOIAA?$AA@			; `string'
PUBLIC	??_C@_02KKOC@xx?$AA@				; `string'
PUBLIC	??_C@_0BL@OKGH@?$CFlf?5seconds?5for?5object?5?$CFs?5?$AA@ ; `string'
PUBLIC	??_C@_0CO@EJKO@?$CIoi?$CJ?5Total?5time?5for?5ActivateObje@ ; `string'
PUBLIC	_ActivateObjectInstance@20
PUBLIC	_ActivateOI_FromOI_ForTask@16
PUBLIC	_DropObjectInstance@4
PUBLIC	__real@8@4008fa00000000000000
PUBLIC	_SfActivateSysEmptyOI@16
PUBLIC	??_C@_0CK@FJHF@Expecting?5valid?5OI?5for?5zACTIVATE@ ; `string'
PUBLIC	??_C@_0DB@KPMG@Root?5entity?5has?5no?5default?5seque@ ; `string'
PUBLIC	??_C@_08IDPE@kzdbhqua?$AA@			; `string'
PUBLIC	??_C@_02CHDK@OR?$AA@				; `string'
PUBLIC	??_C@_01FHE@?$DM?$AA@				; `string'
PUBLIC	??_C@_01FAFK@?$DO?$AA@				; `string'
PUBLIC	_fnActivateObjectInstance
PUBLIC	??_C@_08ILBJ@KZDBHQUA?$AA@			; `string'
PUBLIC	??_C@_0BD@JJIL@__Load?9in?9progress?$AA@	; `string'
PUBLIC	??_C@_0CF@DGPI@?$CIoi?$CJ?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_0CF@NCHC@?$CIoi?$CJ?5Database?5unavailable?9?9try?5a@ ; `string'
PUBLIC	??_C@_0CB@FJHI@?$CIoi?$CJ?5Database?5Deadlock?5?9?5Object?$DN@ ; `string'
PUBLIC	??_C@_0BH@DAGF@?5Activate?5Retry?5Count?$DN?$AA@ ; `string'
PUBLIC	??_C@_0CL@FIPO@?$CIoi?$CJ?5Deadlock?5Crash?5?9?5Retry?5Coun@ ; `string'
PUBLIC	??_C@_0DP@HHNF@?$CIoi?$CJ?5Database?5Memory?5Limit?5Reach@ ; `string'
EXTRN	_SysGetTickCount@0:NEAR
EXTRN	_fnGetAttrAddrFromEntityInstance:NEAR
EXTRN	_fnStoreValueInEntityInstance:NEAR
EXTRN	_TraceLineI@8:NEAR
EXTRN	_TraceLineS@8:NEAR
EXTRN	_TraceLine:NEAR
EXTRN	_fnValidView:NEAR
EXTRN	_fnValidViewObject:NEAR
EXTRN	_fnSetViewFromView:NEAR
EXTRN	_fnResetView:NEAR
EXTRN	_SetNameForView@16:NEAR
EXTRN	_DropNameForView@16:NEAR
EXTRN	_GetStringFromRecord@20:NEAR
EXTRN	__fltused:NEAR
EXTRN	_strcat:NEAR
EXTRN	_ActivateViewObject@12:NEAR
EXTRN	_SetCursorPrevEntity@12:NEAR
EXTRN	_MessageSend@24:NEAR
EXTRN	_NetStartup@12:NEAR
EXTRN	_NetActivateOI@28:NEAR
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_szlEntityName:DWORD
EXTRN	_szlEntitySpec:DWORD
EXTRN	_NetStatus@8:NEAR
EXTRN	_szlOper:DWORD
EXTRN	_szlQualAttrib:DWORD
;	COMDAT ??_C@_0CK@FJHF@Expecting?5valid?5OI?5for?5zACTIVATE@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CK@FJHF@Expecting?5valid?5OI?5for?5zACTIVATE@ DB 'Expecting valid '
	DB	'OI for zACTIVATE_CONTINUE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DB@KPMG@Root?5entity?5has?5no?5default?5seque@
_DATA	SEGMENT
??_C@_0DB@KPMG@Root?5entity?5has?5no?5default?5seque@ DB 'Root entity has'
	DB	' no default sequencing attributes', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IDPE@kzdbhqua?$AA@
_DATA	SEGMENT
??_C@_08IDPE@kzdbhqua?$AA@ DB 'kzdbhqua', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02CHDK@OR?$AA@
_DATA	SEGMENT
??_C@_02CHDK@OR?$AA@ DB 'OR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FHE@?$DM?$AA@
_DATA	SEGMENT
??_C@_01FHE@?$DM?$AA@ DB '<', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FAFK@?$DO?$AA@
_DATA	SEGMENT
??_C@_01FAFK@?$DO?$AA@ DB '>', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08ILBJ@KZDBHQUA?$AA@
_DATA	SEGMENT
??_C@_08ILBJ@KZDBHQUA?$AA@ DB 'KZDBHQUA', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@JJIL@__Load?9in?9progress?$AA@
_DATA	SEGMENT
??_C@_0BD@JJIL@__Load?9in?9progress?$AA@ DB '__Load-in-progress', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CF@DGPI@?$CIoi?$CJ?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@
_DATA	SEGMENT
??_C@_0CF@DGPI@?$CIoi?$CJ?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ DB '('
	DB	'oi) -------------------------------', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CF@NCHC@?$CIoi?$CJ?5Database?5unavailable?9?9try?5a@
_DATA	SEGMENT
??_C@_0CF@NCHC@?$CIoi?$CJ?5Database?5unavailable?9?9try?5a@ DB '(oi) Data'
	DB	'base unavailable--try again', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@FJHI@?$CIoi?$CJ?5Database?5Deadlock?5?9?5Object?$DN@
_DATA	SEGMENT
??_C@_0CB@FJHI@?$CIoi?$CJ?5Database?5Deadlock?5?9?5Object?$DN@ DB '(oi) D'
	DB	'atabase Deadlock - Object=', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@DAGF@?5Activate?5Retry?5Count?$DN?$AA@
_DATA	SEGMENT
??_C@_0BH@DAGF@?5Activate?5Retry?5Count?$DN?$AA@ DB ' Activate Retry Coun'
	DB	't=', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@FIPO@?$CIoi?$CJ?5Deadlock?5Crash?5?9?5Retry?5Coun@
_DATA	SEGMENT
??_C@_0CL@FIPO@?$CIoi?$CJ?5Deadlock?5Crash?5?9?5Retry?5Coun@ DB '(oi) Dea'
	DB	'dlock Crash - Retry Count exceeded', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DP@HHNF@?$CIoi?$CJ?5Database?5Memory?5Limit?5Reach@
_DATA	SEGMENT
??_C@_0DP@HHNF@?$CIoi?$CJ?5Database?5Memory?5Limit?5Reach@ DB '(oi) Datab'
	DB	'ase Memory Limit Reached (Task: 0x%08x) - Object: %s', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DIOI@QualAttrib?$AA@
_DATA	SEGMENT
??_C@_0L@DIOI@QualAttrib?$AA@ DB 'QualAttrib', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@GCPH@SubQualAttrib?$AA@
_DATA	SEGMENT
??_C@_0O@GCPH@SubQualAttrib?$AA@ DB 'SubQualAttrib', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@GDPI@Network?5cannot?5be?5started?4?$AA@
_DATA	SEGMENT
??_C@_0BL@GDPI@Network?5cannot?5be?5started?4?$AA@ DB 'Network cannot be '
	DB	'started.', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IDGA@KZOEOIAA?$AA@
_DATA	SEGMENT
??_C@_08IDGA@KZOEOIAA?$AA@ DB 'KZOEOIAA', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02KKOC@xx?$AA@
_DATA	SEGMENT
??_C@_02KKOC@xx?$AA@ DB 'xx', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OKGH@?$CFlf?5seconds?5for?5object?5?$CFs?5?$AA@
_DATA	SEGMENT
??_C@_0BL@OKGH@?$CFlf?5seconds?5for?5object?5?$CFs?5?$AA@ DB '%lf seconds'
	DB	' for object %s ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CO@EJKO@?$CIoi?$CJ?5Total?5time?5for?5ActivateObje@
_DATA	SEGMENT
??_C@_0CO@EJKO@?$CIoi?$CJ?5Total?5time?5for?5ActivateObje@ DB '(oi) Total'
	DB	' time for ActivateObjectInstance = ', 00H	; `string'
_DATA	ENDS
;	COMDAT __real@8@4008fa00000000000000
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
_TEXT	SEGMENT
_vOriginalOI$8193 = -696
_vQualOI$8201 = -700
_lNetControl$8208 = -704
_lpEntityInstance$8221 = -708
_lpViewAttrib$8227 = -712
_lpViewEntityCsr$8228 = -724
_lpNewEI$8229 = -716
_bNewRoot$8230 = -720
_lpPtr$8242 = -732
_uLth$8243 = -728
_nState$8250 = -740
_k$8251 = -736
_sz$8260 = -840
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_lpQualView$ = 20
_lControl$ = 24
_lpCurrentTask$ = -64
_lpOwningTask$ = -28
_lpViewOD$ = -8
_lpViewOI$ = -56
_lpViewEntity$ = -24
_lpViewCsr$ = -4
_lpOrigInstance$ = -20
_lpOrigViewEntityCsr$ = -52
_lpView$ = -12
_vTempQual$ = -36
_vOrigView$ = -44
_lTickCount$ = -60
_l$ = -48
_bDropQual$ = -40
_bLockingSemaphoreCreatedHere$ = -32
_nRC$ = -16
_lpViewAttrib$8079 = -156
_lpSeqViewAttrib$8080 = -152
_lpOrigViewCsr$8081 = -172
_lpOrigViewOI$8082 = -160
_chCurrentAttrNbr$8083 = -168
_chMaxAttrNbr$8084 = -68
_chFirstAttrNbr$8085 = -164
_k$8124 = -176
_sz$8134 = -432
_nActivateCount$8149 = -436
_szMsg$8177 = -692
_ActivateObjectInstance@20 PROC NEAR

; 1619 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 848				; 00000350H

; 1620 :    LPTASK            lpCurrentTask;
; 1621 :    LPTASK            lpOwningTask;
; 1622 :    LPVIEWOD          lpViewOD;
; 1623 :    LPVIEWOI          lpViewOI = 0;

	mov	DWORD PTR _lpViewOI$[ebp], 0

; 1624 :    LPVIEWENTITY      lpViewEntity;
; 1625 :    LPVIEWCSR         lpViewCsr;
; 1626 :    LPENTITYINSTANCE  lpOrigInstance;
; 1627 :    LPVIEWENTITYCSR   lpOrigViewEntityCsr;
; 1628 :    zVIEW             lpView = 0;

	mov	DWORD PTR _lpView$[ebp], 0

; 1629 :    zVIEW             vTempQual = 0;

	mov	DWORD PTR _vTempQual$[ebp], 0

; 1630 :    zVIEW             vOrigView = *pvReturnView;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vOrigView$[ebp], ecx

; 1631 :    zLONG             lTickCount;
; 1632 :    zLONG             l;
; 1633 :    zBOOL             bDropQual = FALSE;   // used when continuing an activate

	mov	BYTE PTR _bDropQual$[ebp], 0

; 1634 :    zBOOL             bLockingSemaphoreCreatedHere = FALSE;

	mov	BYTE PTR _bLockingSemaphoreCreatedHere$[ebp], 0

; 1635 :    zSHORT            nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 1636 : 
; 1637 :    *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0

; 1638 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8054

; 1639 :       lTickCount = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTickCount$[ebp], eax
$L8054:

; 1640 : 
; 1641 :    // If task not active or disabled, return zCALL_ERROR.
; 1642 :    if ( lpAppQualView )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $L8055

; 1643 :       lpView = lpAppQualView;

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	DWORD PTR _lpView$[ebp], edx
$L8055:

; 1644 : 
; 1645 :    if ( (lpCurrentTask = fnOperationCall( iActivateObjectInstance,
; 1646 :                                           lpView, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	52					; 00000034H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8056

; 1648 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8037
$L8056:

; 1650 : 
; 1651 :    lpCurrentTask->bLoadAllocLimit = FALSE;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	and	dh, -65					; ffffffbfH
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [eax+443], edx

; 1652 :    if ( lpQualView && fnValidViewObject( lpCurrentTask, lpQualView ) == 0 )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	SHORT $L8057
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidViewObject
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L8057

; 1653 :       goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8057:

; 1654 : 
; 1655 :    if ( fnValidView( lpCurrentTask, lpAppQualView ) == 0 )

	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidView
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L8059

; 1656 :       goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8059:

; 1657 : 
; 1658 :    lpViewOD = ActivateViewObject( lpAppQualView, cpcViewOD_Name, FALSE );

	push	0
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	call	_ActivateViewObject@12
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1659 :    if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $L8060

; 1660 :       goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8060:

; 1661 : 
; 1662 :    // Verify only one zLEVEL_ option requested.
; 1663 :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], eax

; 1664 :    if ( l && (-l & l) != l )

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $L8061
	mov	ecx, DWORD PTR _l$[ebp]
	neg	ecx
	and	ecx, DWORD PTR _l$[ebp]
	cmp	ecx, DWORD PTR _l$[ebp]
	je	SHORT $L8061

; 1666 :       // error, More than one zLEVEL_ option requested
; 1667 :       // "KZOEE023 - Invalid parameter, "
; 1668 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 23, 0,
; 1669 :                         "More than one zLEVEL_ option requested", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@ ; `string'
	push	0
	push	23					; 00000017H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1670 :       goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8061:

; 1672 : 
; 1673 :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 12					; 0000000cH
	test	ecx, ecx
	je	SHORT $L8062

; 1674 :       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 1675 :    else

	jmp	SHORT $L8064
$L8062:

; 1676 :       lpOwningTask = lpCurrentTask;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], ecx
$L8064:

; 1677 : 
; 1678 :    // If zLEVEL_SAME is requested.
; 1679 :    if ( lControl & zLEVEL_SAME )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1024				; 00000400H
	test	edx, edx
	je	$L8077

; 1681 :       if ( lpAppQualView == 0 || lpAppQualView->hSubtask )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $L8067
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	cmp	DWORD PTR [eax+18], 0
	je	SHORT $L8066
$L8067:

; 1683 :          // "KZOEE100 - Invalid View, view is a Subtask View"
; 1684 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 100, 0, "lpAppQualView",
; 1685 :                            "with zLEVEL_SAME" );

	push	OFFSET FLAT:??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0O@OFE@lpAppQualView?$AA@ ; `string'
	push	0
	push	100					; 00000064H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1686 :          goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8066:

; 1690 :          // LPVIEWCSR lpViewCsr;
; 1691 : 
; 1692 :          // Turn off the 'same' indicator
; 1693 :          lControl ^= zLEVEL_SAME;

	mov	eax, DWORD PTR _lControl$[ebp]
	xor	eax, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], eax

; 1694 :          // To determine what the level is of the qualifying view
; 1695 :          //   1. Change lpAppQualView to point to the initial
; 1696 :          //      view created for the object instance
; 1697 :          //   2. Check for application level, if there use
; 1698 :          //      zLEVEL_APPLICATION.
; 1699 :          //   3. Check if the view task is the main task, if so use
; 1700 :          //      zLEVEL_SYSTEM.
; 1701 :          //   4. Use the task level...
; 1702 :          lpViewCsr = zGETPTR( lpAppQualView->hViewCsr );

	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
$L8071:

; 1703 :          while ( lpViewCsr->hNextViewCsr )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [eax+2], 0
	je	SHORT $L8072

; 1704 :             lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
	jmp	SHORT $L8071
$L8072:

; 1705 : 
; 1706 :          lpAppQualView = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAppQualView$[ebp], eax

; 1707 :          if ( lpAppQualView->bApplicationView )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L8075

; 1708 :             lControl |= zLEVEL_APPLICATION;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 4
	mov	DWORD PTR _lControl$[ebp], ecx

; 1709 :          else

	jmp	SHORT $L8077
$L8075:

; 1710 :          if ( lpAppQualView->hTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $L8077

; 1711 :             lControl |= zLEVEL_SYSTEM;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 8
	mov	DWORD PTR _lControl$[ebp], edx
$L8077:

; 1714 : 
; 1715 :    // Check to see if we are continuing a previous activate.  If we are, then
; 1716 :    // we need to activate the next group of entities from the database.  To
; 1717 :    // do this we need to add to the current qualification view information to
; 1718 :    // load only entities that come after the last entity in the current OI.
; 1719 :    // The new qualification will then logically look like:
; 1720 :    //       ACTIVATE view
; 1721 :    //       WHERE (original-qual) AND
; 1722 :    //             (view.ent.seq-attr1 > lastent.ent.seq-attr1 OR
; 1723 :    //              (view.ent.seq-attr1 = lastent.ent.seq-attr1 AND
; 1724 :    //               view.ent.seq-attr2 > lastent.ent.seq-attr2))
; 1725 :    if ( lControl & zACTIVATE_CONTINUE )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	$L8123

; 1727 :       LPVIEWATTRIB     lpViewAttrib;
; 1728 :       LPVIEWATTRIB     lpSeqViewAttrib[ MAX_SEQ_ATTS + 1 ];
; 1729 :       LPVIEWCSR        lpOrigViewCsr;
; 1730 :       LPVIEWOI         lpOrigViewOI;
; 1731 :       zCHAR            chCurrentAttrNbr;
; 1732 :       zCHAR            chMaxAttrNbr;
; 1733 :       zCHAR            chFirstAttrNbr;
; 1734 : 
; 1735 :       // Since we are continuing a previous activate, they had better pass
; 1736 :       // us the old view.
; 1737 :       if ( fnValidView( lpCurrentTask, vOrigView ) == 0 )

	mov	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidView
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L8086

; 1738 :          goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8086:

; 1739 : 
; 1740 :       *pvReturnView = vOrigView;

	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	edx, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR [ecx], edx

; 1741 :       lpOrigViewCsr = zGETPTR( vOrigView->hViewCsr );

	mov	eax, DWORD PTR _vOrigView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOrigViewCsr$8081[ebp], eax

; 1742 :       lpOrigViewOI  = zGETPTR( lpOrigViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpOrigViewCsr$8081[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOrigViewOI$8082[ebp], eax

; 1743 :       if ( lpOrigViewOI == 0 || lpOrigViewOI->hRootEntityInstance == 0  )

	cmp	DWORD PTR _lpOrigViewOI$8082[ebp], 0
	je	SHORT $L8090
	mov	ecx, DWORD PTR _lpOrigViewOI$8082[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	SHORT $L8089
$L8090:

; 1745 :          fnSysMessageBox( lpCurrentTask, szlOE_SystemError,
; 1746 :                           "Expecting valid OI for zACTIVATE_CONTINUE", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0CK@FJHF@Expecting?5valid?5OI?5for?5zACTIVATE@ ; `string'
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnSysMessageBox@16

; 1747 :          goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8089:

; 1749 : 
; 1750 :       // Get the root view entity.
; 1751 :       lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1752 : 
; 1753 :       // Null out table for now.
; 1754 :       for ( chCurrentAttrNbr = 0;
; 1755 :             chCurrentAttrNbr <= MAX_SEQ_ATTS;
; 1756 :             chCurrentAttrNbr++ )

	mov	BYTE PTR _chCurrentAttrNbr$8083[ebp], 0
	jmp	SHORT $L8093
$L8094:
	mov	al, BYTE PTR _chCurrentAttrNbr$8083[ebp]
	add	al, 1
	mov	BYTE PTR _chCurrentAttrNbr$8083[ebp], al
$L8093:
	movsx	ecx, BYTE PTR _chCurrentAttrNbr$8083[ebp]
	cmp	ecx, 20					; 00000014H
	jg	SHORT $L8095

; 1758 :          lpSeqViewAttrib[ chCurrentAttrNbr ] = 0;

	movsx	edx, BYTE PTR _chCurrentAttrNbr$8083[ebp]
	mov	DWORD PTR _lpSeqViewAttrib$8080[ebp+edx*4], 0

; 1759 :       }

	jmp	SHORT $L8094
$L8095:

; 1760 : 
; 1761 :       // First find the max cSequencing numbers for persistent attributes.
; 1762 :       chMaxAttrNbr = 0;

	mov	BYTE PTR _chMaxAttrNbr$8084[ebp], 0

; 1763 :       for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 1764 :             lpViewAttrib;
; 1765 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$8079[ebp], eax
	jmp	SHORT $L8098
$L8099:
	mov	edx, DWORD PTR _lpViewAttrib$8079[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$8079[ebp], eax
$L8098:
	cmp	DWORD PTR _lpViewAttrib$8079[ebp], 0
	je	SHORT $L8100

; 1767 :          if ( lpViewAttrib->cSequencing == 0 )

	mov	ecx, DWORD PTR _lpViewAttrib$8079[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+197]
	test	edx, edx
	jne	SHORT $L8101

; 1768 :             continue;

	jmp	SHORT $L8099
$L8101:

; 1769 : 
; 1770 :          lpSeqViewAttrib[ lpViewAttrib->cSequencing ] = lpViewAttrib;

	mov	eax, DWORD PTR _lpViewAttrib$8079[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+197]
	mov	edx, DWORD PTR _lpViewAttrib$8079[ebp]
	mov	DWORD PTR _lpSeqViewAttrib$8080[ebp+ecx*4], edx

; 1771 : 
; 1772 :          if ( lpViewAttrib->cSequencing > chMaxAttrNbr )

	mov	eax, DWORD PTR _lpViewAttrib$8079[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+197]
	movsx	edx, BYTE PTR _chMaxAttrNbr$8084[ebp]
	cmp	ecx, edx
	jle	SHORT $L8102

; 1773 :             chMaxAttrNbr = lpViewAttrib->cSequencing;

	mov	eax, DWORD PTR _lpViewAttrib$8079[ebp]
	mov	cl, BYTE PTR [eax+197]
	mov	BYTE PTR _chMaxAttrNbr$8084[ebp], cl
$L8102:

; 1774 :       }

	jmp	SHORT $L8099
$L8100:

; 1775 : 
; 1776 :       if ( chMaxAttrNbr == 0 )

	movsx	edx, BYTE PTR _chMaxAttrNbr$8084[ebp]
	test	edx, edx
	jne	SHORT $L8103

; 1778 :          fnSysMessageBox( lpCurrentTask, szlOE_SystemError,
; 1779 :                           "Root entity has no default sequencing attributes",
; 1780 :                           1 );

	push	1
	push	OFFSET FLAT:??_C@_0DB@KPMG@Root?5entity?5has?5no?5default?5seque@ ; `string'
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnSysMessageBox@16

; 1781 :          goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8103:

; 1783 : 
; 1784 :       // We need to add information to the qualification object.  If they
; 1785 :       // didn't give us one, then we need to create one.  We also need to set
; 1786 :       // the flag that indcates we will need to drop the qualification object
; 1787 :       // later.
; 1788 :       bDropQual = TRUE;

	mov	BYTE PTR _bDropQual$[ebp], 1

; 1789 :       if ( lpQualView == 0 )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	jne	SHORT $L8105

; 1791 :          SfActivateSysEmptyOI( &lpQualView, "kzdbhqua",
; 1792 :                                lpAppQualView, zMULTIPLE );

	push	256					; 00000100H
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08IDPE@kzdbhqua?$AA@	; `string'
	lea	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SfActivateSysEmptyOI@16

; 1794 :       else

	jmp	SHORT $L8107
$L8105:

; 1795 :          ActivateOI_FromOI_ForTask( &lpQualView, lpQualView, 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_ActivateOI_FromOI_ForTask@16
$L8107:

; 1796 : 
; 1797 :       // We need to find the last root instance of the original OI.
; 1798 :       for ( lpOrigInstance = zGETPTR( lpOrigViewOI->hRootEntityInstance );
; 1799 :             lpOrigInstance->hNextTwin;
; 1800 :             lpOrigInstance = zGETPTR( lpOrigInstance->hNextTwin ) )

	mov	eax, DWORD PTR _lpOrigViewOI$8082[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOrigInstance$[ebp], eax
	jmp	SHORT $L8110
$L8111:
	mov	edx, DWORD PTR _lpOrigInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOrigInstance$[ebp], eax
$L8110:
	mov	ecx, DWORD PTR _lpOrigInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $L8112

; 1802 :          ;  // nothing needs to be done here
; 1803 :       }

	jmp	SHORT $L8111
$L8112:

; 1804 : 
; 1805 :       lpOrigViewEntityCsr = fnEstablishViewForInstance( vOrigView, 0,
; 1806 :                                                         lpOrigInstance );

	mov	edx, DWORD PTR _lpOrigInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _vOrigView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpOrigViewEntityCsr$[ebp], eax

; 1807 : 
; 1808 :       // Make sure that EntitySpec for the root entity exists.
; 1809 :       if ( SetCursorFirstEntityByString( lpQualView, szlEntitySpec,
; 1810 :                                          szlEntityName,
; 1811 :                                          lpViewEntity->szName,
; 1812 :                                          0 ) < zCURSOR_SET )

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _szlEntityName
	push	edx
	mov	eax, DWORD PTR _szlEntitySpec
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByString@20
	movsx	edx, ax
	test	edx, edx
	jge	SHORT $L8113

; 1814 :          CreateEntity( lpQualView, szlEntitySpec, zPOS_LAST );

	push	2
	mov	eax, DWORD PTR _szlEntitySpec
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1815 :          SetAttributeFromString( lpQualView, szlEntitySpec, szlEntityName,
; 1816 :                                  lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _szlEntityName
	push	eax
	mov	ecx, DWORD PTR _szlEntitySpec
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 1818 :       else

	jmp	$L8115
$L8113:

; 1820 :          // Qual view already has qualification on the root entity, so add
; 1821 :          // QualAttrib entities to surround qualification with parens.
; 1822 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_FIRST );

	push	1
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1823 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "(" );

	push	OFFSET FLAT:??_C@_01GFI@?$CI?$AA@	; `string'
	mov	edx, DWORD PTR _szlOper
	push	edx
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 1824 : 
; 1825 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_LAST );

	push	2
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CreateEntity@12

; 1826 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, ")" );

	push	OFFSET FLAT:??_C@_01KMMP@?$CJ?$AA@	; `string'
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1827 : 
; 1828 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_LAST );

	push	2
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_CreateEntity@12

; 1829 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "AND" );

	push	OFFSET FLAT:??_C@_03LACO@AND?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 1830 : 
; 1831 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1832 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "(" );

	push	OFFSET FLAT:??_C@_01GFI@?$CI?$AA@	; `string'
	mov	edx, DWORD PTR _szlOper
	push	edx
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 1833 : 
; 1834 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_LAST );

	push	2
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CreateEntity@12

; 1835 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, ")" );

	push	OFFSET FLAT:??_C@_01KMMP@?$CJ?$AA@	; `string'
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1836 : 
; 1837 :          SetCursorPrevEntity( lpQualView, szlQualAttrib, 0 );

	push	0
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetCursorPrevEntity@12
$L8115:

; 1839 : 
; 1840 :       chFirstAttrNbr = 0;

	mov	BYTE PTR _chFirstAttrNbr$8085[ebp], 0

; 1841 : 
; 1842 :       for ( chCurrentAttrNbr = 1;
; 1843 :             chCurrentAttrNbr <= chMaxAttrNbr;
; 1844 :             chCurrentAttrNbr++ )

	mov	BYTE PTR _chCurrentAttrNbr$8083[ebp], 1
	jmp	SHORT $L8121
$L8122:
	mov	al, BYTE PTR _chCurrentAttrNbr$8083[ebp]
	add	al, 1
	mov	BYTE PTR _chCurrentAttrNbr$8083[ebp], al
$L8121:
	movsx	ecx, BYTE PTR _chCurrentAttrNbr$8083[ebp]
	movsx	edx, BYTE PTR _chMaxAttrNbr$8084[ebp]
	cmp	ecx, edx
	jg	$L8123

; 1846 :          zSHORT k;
; 1847 : 
; 1848 :          if ( lpSeqViewAttrib[ chCurrentAttrNbr ] == 0 )

	movsx	eax, BYTE PTR _chCurrentAttrNbr$8083[ebp]
	cmp	DWORD PTR _lpSeqViewAttrib$8080[ebp+eax*4], 0
	jne	SHORT $L8125

; 1849 :             continue;

	jmp	SHORT $L8122
$L8125:

; 1850 : 
; 1851 :          if ( chFirstAttrNbr == 0 )

	movsx	ecx, BYTE PTR _chFirstAttrNbr$8085[ebp]
	test	ecx, ecx
	jne	SHORT $L8126

; 1852 :             chFirstAttrNbr = chCurrentAttrNbr;

	mov	dl, BYTE PTR _chCurrentAttrNbr$8083[ebp]
	mov	BYTE PTR _chFirstAttrNbr$8085[ebp], dl
$L8126:

; 1853 : 
; 1854 :          // If chCurrentAttrNbr > chFirstAttrNbr, then we have multiple seq
; 1855 :          // attrs in the entity and we need to stick in an "OR".
; 1856 :          if ( chCurrentAttrNbr > chFirstAttrNbr )

	movsx	eax, BYTE PTR _chCurrentAttrNbr$8083[ebp]
	movsx	ecx, BYTE PTR _chFirstAttrNbr$8085[ebp]
	cmp	eax, ecx
	jle	SHORT $L8127

; 1858 :             CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CreateEntity@12

; 1859 :             SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "OR" );

	push	OFFSET FLAT:??_C@_02CHDK@OR?$AA@	; `string'
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1860 : 
; 1861 :             CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_CreateEntity@12

; 1862 :             SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "(" );

	push	OFFSET FLAT:??_C@_01GFI@?$CI?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L8127:

; 1864 : 
; 1865 :          for ( k = chFirstAttrNbr; k <= chCurrentAttrNbr; k++ )

	movsx	ax, BYTE PTR _chFirstAttrNbr$8085[ebp]
	mov	WORD PTR _k$8124[ebp], ax
	jmp	SHORT $L8131
$L8132:
	mov	cx, WORD PTR _k$8124[ebp]
	add	cx, 1
	mov	WORD PTR _k$8124[ebp], cx
$L8131:
	movsx	edx, WORD PTR _k$8124[ebp]
	movsx	eax, BYTE PTR _chCurrentAttrNbr$8083[ebp]
	cmp	edx, eax
	jg	$L8133

; 1867 :             zCHAR sz[ 256 ];
; 1868 : 
; 1869 :             if ( lpSeqViewAttrib[ k ] == 0 )

	movsx	ecx, WORD PTR _k$8124[ebp]
	cmp	DWORD PTR _lpSeqViewAttrib$8080[ebp+ecx*4], 0
	jne	SHORT $L8135

; 1870 :                continue;

	jmp	SHORT $L8132
$L8135:

; 1871 : 
; 1872 :             if ( k > chFirstAttrNbr )

	movsx	edx, WORD PTR _k$8124[ebp]
	movsx	eax, BYTE PTR _chFirstAttrNbr$8085[ebp]
	cmp	edx, eax
	jle	SHORT $L8136

; 1874 :                CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_CreateEntity@12

; 1875 :                SetAttributeFromString( lpQualView, szlQualAttrib,
; 1876 :                                        szlOper, "AND" );

	push	OFFSET FLAT:??_C@_03LACO@AND?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L8136:

; 1878 : 
; 1879 :             CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1880 :             SetAttributeFromString( lpQualView, szlQualAttrib, szlEntityName,
; 1881 :                                     lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _szlEntityName
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 1882 :             SetAttributeFromString( lpQualView, szlQualAttrib, "AttributeName",
; 1883 :                                     lpSeqViewAttrib[ k ]->szName );

	movsx	eax, WORD PTR _k$8124[ebp]
	mov	ecx, DWORD PTR _lpSeqViewAttrib$8080[ebp+eax*4]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0O@JICG@AttributeName?$AA@ ; `string'
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1884 : 
; 1885 :             if ( k == chCurrentAttrNbr )

	movsx	ecx, WORD PTR _k$8124[ebp]
	movsx	edx, BYTE PTR _chCurrentAttrNbr$8083[ebp]
	cmp	ecx, edx
	jne	SHORT $L8139

; 1887 :                if ( lpSeqViewAttrib[ k ]->bSequencingD )

	movsx	eax, WORD PTR _k$8124[ebp]
	mov	ecx, DWORD PTR _lpSeqViewAttrib$8080[ebp+eax*4]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	test	edx, edx
	je	SHORT $L8140

; 1888 :                   SetAttributeFromString( lpQualView, szlQualAttrib,
; 1889 :                                           szlOper, "<" );

	push	OFFSET FLAT:??_C@_01FHE@?$DM?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 1890 :                else

	jmp	SHORT $L8142
$L8140:

; 1891 :                   SetAttributeFromString( lpQualView, szlQualAttrib,
; 1892 :                                           szlOper, ">" );

	push	OFFSET FLAT:??_C@_01FAFK@?$DO?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L8142:

; 1894 :             else

	jmp	SHORT $L8144
$L8139:

; 1895 :                SetAttributeFromString( lpQualView, szlQualAttrib,
; 1896 :                                        szlOper, "=" );

	push	OFFSET FLAT:??_C@_01KPOD@?$DN?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L8144:

; 1897 : 
; 1898 :             GetStringFromRecord( vOrigView, lpViewEntity,
; 1899 :                                  lpSeqViewAttrib[ k ], sz, 256 );

	push	256					; 00000100H
	lea	eax, DWORD PTR _sz$8134[ebp]
	push	eax
	movsx	ecx, WORD PTR _k$8124[ebp]
	mov	edx, DWORD PTR _lpSeqViewAttrib$8080[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	call	_GetStringFromRecord@20

; 1900 :             SetAttributeFromString( lpQualView, szlQualAttrib, "Value", sz );

	lea	edx, DWORD PTR _sz$8134[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_05KBGO@Value?$AA@	; `string'
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 1901 :          }

	jmp	$L8132
$L8133:

; 1902 : 
; 1903 :          if ( chCurrentAttrNbr > chFirstAttrNbr )

	movsx	edx, BYTE PTR _chCurrentAttrNbr$8083[ebp]
	movsx	eax, BYTE PTR _chFirstAttrNbr$8085[ebp]
	cmp	edx, eax
	jle	SHORT $L8145

; 1905 :             CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_CreateEntity@12

; 1906 :             SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, ")" );

	push	OFFSET FLAT:??_C@_01KMMP@?$CJ?$AA@	; `string'
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L8145:

; 1908 : 
; 1909 :       } // for...

	jmp	$L8122
$L8123:

; 1912 : 
; 1913 :    lpView = 0;

	mov	DWORD PTR _lpView$[ebp], 0

; 1914 :    if ( lpViewOD->szNetwork[ 0 ] == 0 || lControl & zACTIVATE_LOCAL )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+109]
	test	ecx, ecx
	je	SHORT $L8148
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1073741824				; 40000000H
	test	edx, edx
	je	$L8147
$L8148:

; 1916 :       zSHORT nActivateCount;
; 1917 : 
; 1918 :       // Make sure the LOD has data records.
; 1919 :       lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1920 :       if ( lpViewEntity->hFirstDataRecord == 0 )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+191], 0
	jne	SHORT $L8151

; 1922 :          // "KZOEE083 - LOD does not have physical information"
; 1923 :          fnIssueCoreError( lpCurrentTask, lpAppQualView, 16, 83, 0, lpViewOD->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	0
	push	83					; 00000053H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1924 :          goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8151:

; 1926 : 
; 1927 :       // Check to see if we have pessimistic locking defined for the LOD.
; 1928 :       if ( lpViewOD->nLock       >= zLL_PESSIMISTIC ||
; 1929 :            lpViewOD->nEntityLock >= zLL_PESSIMISTIC )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+236]
	cmp	ecx, 3
	jge	SHORT $L8153
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+237]
	cmp	eax, 3
	jl	SHORT $L8158
$L8153:

; 1931 :          // Check to make sure we can load objects needed for pessimistic
; 1932 :          // locking.
; 1933 :          if ( ActivateViewObject( lpAppQualView, "ZPLOCKO", FALSE ) == 0 )

	push	0
	push	OFFSET FLAT:??_C@_07KIPN@ZPLOCKO?$AA@	; `string'
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	call	_ActivateViewObject@12
	test	eax, eax
	jne	SHORT $L8154

; 1934 :             goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8154:

; 1935 : 
; 1936 :          // Look for the qualification object.
; 1937 :          if ( ActivateViewObject( lpAppQualView, "KZDBHQUA", TRUE ) == 0 )

	push	1
	push	OFFSET FLAT:??_C@_08ILBJ@KZDBHQUA?$AA@	; `string'
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	call	_ActivateViewObject@12
	test	eax, eax
	jne	SHORT $L8155

; 1938 :             goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8155:

; 1939 : 
; 1940 :          // If user requests locking, then we need to create the locking
; 1941 :          // semaphore so that only one user changes locking at the same time.
; 1942 :          if ( lControl & zSINGLE_FOR_UPDATE )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	SHORT $L8158

; 1944 :             if ( lpCurrentTask->bPessimisticLockingSet == FALSE )

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 8
	and	edx, 1
	test	edx, edx
	jne	SHORT $L8158

; 1946 :                if ( fnCreatePessimisticSemaphore( lpCurrentTask,
; 1947 :                                                   (zPVOID) &lpViewOD, 1, 0,
; 1948 :                                                   lpAppQualView ) < 0 )

	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	push	0
	push	1
	lea	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCreatePessimisticSemaphore@20
	movsx	eax, ax
	test	eax, eax
	jge	SHORT $L8160

; 1950 :                   goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8160:

; 1952 : 
; 1953 :                bLockingSemaphoreCreatedHere = TRUE;

	mov	BYTE PTR _bLockingSemaphoreCreatedHere$[ebp], 1
$L8158:

; 1957 : 
; 1958 :       if ( (nRC = fnDeclareView( &lpView, lpOwningTask, lpAppQualView,
; 1959 :                                  cpcViewOD_Name, FALSE )) != 0 )

	push	0
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L8161

; 1961 :          goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8161:

; 1963 : 
; 1964 : #if 0
; 1965 :       if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 1966 :       {
; 1967 :          zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 1968 :                                      zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 1969 : 
; 1970 :          // Must be done prior to activation.
; 1971 :          SfTransferView( lpView, lpAppQualView, nScope );
; 1972 :       }
; 1973 : #endif
; 1974 : 
; 1975 :       nRC = fnActivateEmptyObjectInstance( lpCurrentTask, lpView, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 1976 :       if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L8162

; 1978 :          // fnActivateEmptyObjectInstance didn't work for some reason.
; 1979 :          // Restore the view cursor to the way is was before the call.
; 1980 :          goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8162:

; 1982 : 
; 1983 :       nActivateCount = 1;

	mov	WORD PTR _nActivateCount$8149[ebp], 1

; 1984 : 
; 1985 :       SetNameForView( lpView, "__Load-in-progress", 0, zLEVEL_TASK );

	push	2
	push	0
	push	OFFSET FLAT:??_C@_0BD@JJIL@__Load?9in?9progress?$AA@ ; `string'
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetNameForView@16

; 1986 : 
; 1987 :       // Call fnActivateObjectInstance until activate was achieved. It is
; 1988 :       // possible that there are locks in place that keep the activate from
; 1989 :       // working.
; 1990 :       // Activate object instance.  If database is in use, wait two seconds
; 1991 :       // and try again.
; 1992 :       // Create a temp qualification so the original doesn't get changed.
; 1993 :       if ( lpQualView )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	SHORT $L8164

; 1995 :          fnDeclareView( &vTempQual, lpOwningTask, lpQualView, 0, 0 );

	push	0
	push	0
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vTempQual$[ebp]
	push	ecx
	call	_fnDeclareView@20

; 1996 :          fnSetViewFromView( vTempQual, lpQualView );

	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _vTempQual$[ebp]
	push	eax
	call	_fnSetViewFromView
	add	esp, 8

; 1998 :       else

	jmp	SHORT $L8165
$L8164:

; 1999 :          vTempQual = 0;

	mov	DWORD PTR _vTempQual$[ebp], 0
$L8165:

; 2000 : 
; 2001 :       while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	$L8168

; 2003 :          nRC = fnActivateObjectInstance( lpCurrentTask, lpView,
; 2004 :                                          vTempQual, lControl );

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _vTempQual$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateObjectInstance
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 2005 : 
; 2006 :          // If fnActivateObjectInstance worked OK, drop old ViewCsr,
; 2007 :          // otherwise restore the view cursor.
; 2008 :          if ( nRC >= -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jl	SHORT $L8169

; 2010 :             // Try to relink entity instances.
; 2011 :             fnRelinkObjectInstance( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnRelinkObjectInstance@4

; 2012 :             break;

	jmp	$L8168
$L8169:

; 2014 :          else
; 2015 :          if ( nRC == zDB_UNAVAIL )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -2					; fffffffeH
	jne	SHORT $L8171

; 2017 :             // Database was unavailable (in use by another user).
; 2018 :             nActivateCount++;

	mov	ax, WORD PTR _nActivateCount$8149[ebp]
	add	ax, 1
	mov	WORD PTR _nActivateCount$8149[ebp], ax

; 2019 : 
; 2020 :             // If we've tried 8 times, exit anyway.
; 2021 :             if ( nActivateCount > 8 )

	movsx	ecx, WORD PTR _nActivateCount$8149[ebp]
	cmp	ecx, 8
	jle	SHORT $L8172

; 2023 :                fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDropView@4

; 2024 :                lpView = 0;   // Null out lpView so it won't be dropped again.

	mov	DWORD PTR _lpView$[ebp], 0

; 2025 :                goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8172:

; 2027 : 
; 2028 :             SysWait( 2000 );  // Wait for 2 seconds then try again.

	push	2000					; 000007d0H
	call	_SysWait@4

; 2029 :             TraceLineS( "(oi) -------------------------------", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CF@DGPI@?$CIoi?$CJ?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	call	_TraceLineS@8

; 2030 :             TraceLineS( "(oi) Database unavailable--try again", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CF@NCHC@?$CIoi?$CJ?5Database?5unavailable?9?9try?5a@ ; `string'
	call	_TraceLineS@8

; 2031 :             TraceLineS( "(oi) -------------------------------", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CF@DGPI@?$CIoi?$CJ?5?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9@ ; `string'
	call	_TraceLineS@8

; 2033 :          else

	jmp	$L8184
$L8171:

; 2034 :          if ( nRC == zDB_DEADLOCK )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -3					; fffffffdH
	jne	$L8176

; 2036 :             // Transaction backed out because of deadlock.
; 2037 :             zCHAR  szMsg[ 256 ];
; 2038 : 
; 2039 :             zstrcpy( szMsg, "(oi) Database Deadlock - Object=" );

	push	OFFSET FLAT:??_C@_0CB@FJHI@?$CIoi?$CJ?5Database?5Deadlock?5?9?5Object?$DN@ ; `string'
	lea	ecx, DWORD PTR _szMsg$8177[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2040 :             zstrcat( szMsg, cpcViewOD_Name );

	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	lea	eax, DWORD PTR _szMsg$8177[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2041 :             zstrcat( szMsg, " Activate Retry Count=" );

	push	OFFSET FLAT:??_C@_0BH@DAGF@?5Activate?5Retry?5Count?$DN?$AA@ ; `string'
	lea	ecx, DWORD PTR _szMsg$8177[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2042 :             TraceLineI( szMsg, nActivateCount );

	movsx	edx, WORD PTR _nActivateCount$8149[ebp]
	push	edx
	lea	eax, DWORD PTR _szMsg$8177[ebp]
	push	eax
	call	_TraceLineI@8

; 2043 : 
; 2044 :             nActivateCount++;

	mov	cx, WORD PTR _nActivateCount$8149[ebp]
	add	cx, 1
	mov	WORD PTR _nActivateCount$8149[ebp], cx

; 2045 : 
; 2046 :             // If we've tried 3 times, exit anyway.
; 2047 :             if ( nActivateCount > 3 )

	movsx	edx, WORD PTR _nActivateCount$8149[ebp]
	cmp	edx, 3
	jle	SHORT $L8180

; 2049 :                fnDropView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnDropView@4

; 2050 :                lpView = 0;   // Null out lpView so it won't be dropped again.

	mov	DWORD PTR _lpView$[ebp], 0

; 2051 :                TraceLineS( "(oi) Deadlock Crash - Retry Count exceeded", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CL@FIPO@?$CIoi?$CJ?5Deadlock?5Crash?5?9?5Retry?5Coun@ ; `string'
	call	_TraceLineS@8

; 2052 : 
; 2053 :                goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8180:

; 2055 : 
; 2056 :             DropObjectInstance( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_DropObjectInstance@4

; 2057 : 
; 2058 :             nRC = fnDeclareView( &lpView, lpOwningTask, lpAppQualView,
; 2059 :                                  cpcViewOD_Name, FALSE );

	push	0
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax

; 2060 :             if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L8182

; 2061 :                goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8182:

; 2062 : 
; 2063 : #if 0
; 2064 :             if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 2065 :             {
; 2066 :                zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 2067 :                                            zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 2068 :                SfTransferView( lpView, lpAppQualView, nScope );
; 2069 :             }
; 2070 : #endif
; 2071 : 
; 2072 :             if ( fnActivateEmptyObjectInstance( lpCurrentTask, lpView,
; 2073 :                                                 lControl ) != 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L8183

; 2075 :                goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8183:

; 2077 : 
; 2078 :             SetNameForView( lpView, "__Load-in-progress", 0, zLEVEL_TASK );

	push	2
	push	0
	push	OFFSET FLAT:??_C@_0BD@JJIL@__Load?9in?9progress?$AA@ ; `string'
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SetNameForView@16

; 2080 :          else

	jmp	SHORT $L8184
$L8176:

; 2082 :             if ( nRC == zMEMORY_LIMIT )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -7					; fffffff9H
	jne	SHORT $L8185

; 2084 :                // Transaction backed out because of memory error.
; 2085 :                TraceLine( "(oi) Database Memory Limit Reached (Task: 0x%08x) - Object: %s",
; 2086 :                           zGETHNDL( lpCurrentTask), cpcViewOD_Name );

	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET FLAT:??_C@_0DP@HHNF@?$CIoi?$CJ?5Database?5Memory?5Limit?5Reach@ ; `string'
	call	_TraceLine
	add	esp, 12					; 0000000cH
$L8185:

; 2088 : 
; 2089 :             // Some error occurred.  Bomb out.
; 2090 :             fnDropView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnDropView@4

; 2091 :             lpView = 0;   // Null out lpView so it won't be dropped again.

	mov	DWORD PTR _lpView$[ebp], 0

; 2092 :             goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8184:

; 2094 :       } // while ( TRUE )...

	jmp	$L8165
$L8168:

; 2095 : 
; 2096 :       if ( nRC >= 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $L8188

; 2098 :          lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2099 :          lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax
$L8188:

; 2101 : 
; 2102 :       // If nRC is 0 or greater, then we've retrieved a valid object.  If
; 2103 :       // the Object instance has any optmistic locking, then some
; 2104 :       // processing needs to be performed.
; 2105 :       if ( nRC >= 0 && (lControl & zSINGLE_FOR_UPDATE) &&
; 2106 :            (lpViewOD->nLock == zLL_OPTIMISTIC_NOINC ||
; 2107 :             lpViewOD->nLock == zLL_OPTIMISTIC_CMPRALL) )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L8205
	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 67108864				; 04000000H
	test	ecx, ecx
	je	$L8205
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+236]
	cmp	eax, 1
	je	SHORT $L8192
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	cmp	edx, 2
	jne	$L8205
$L8192:

; 2109 :          zVIEW vOriginalOI;
; 2110 : 
; 2111 :          // The user wants optimistic locking.  All we need to do right
; 2112 :          // now is save the current OI and the qualification OI.  First
; 2113 :          // make sure we don't have any old ones lying around.
; 2114 :          if ( lpViewOI->vOriginalOI )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $L8194

; 2115 :             fnDropView( zGETPTR( lpViewOI->vOriginalOI ) );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4
$L8194:

; 2116 : 
; 2117 :          if ( lpViewOI->vQualOI )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $L8196

; 2118 :             fnDropView( zGETPTR( lpViewOI->vQualOI ) );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4
$L8196:

; 2119 : 
; 2120 :          // Copy the current OI to a safe place so that we can reference
; 2121 :          // it later.  We need to flag the original view so that if
; 2122 :          // vOriginalOI gets dropped before the main OI gets dropped we
; 2123 :          // will know about it.
; 2124 :          ActivateOI_FromOI_ForTask( &vOriginalOI, lpView, 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vOriginalOI$8193[ebp]
	push	ecx
	call	_ActivateOI_FromOI_ForTask@16

; 2125 :          vOriginalOI->bOrigView   = TRUE;

	mov	edx, DWORD PTR _vOriginalOI$8193[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, -128				; ffffff80H
	mov	ecx, DWORD PTR _vOriginalOI$8193[ebp]
	mov	DWORD PTR [ecx+30], eax

; 2126 :          vOriginalOI->bViewLocked = TRUE;

	mov	edx, DWORD PTR _vOriginalOI$8193[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _vOriginalOI$8193[ebp]
	mov	DWORD PTR [ecx+30], eax

; 2127 :          vOriginalOI->hMainOI     = zGETHNDL( lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _vOriginalOI$8193[ebp]
	mov	DWORD PTR [ecx+26], eax

; 2128 :          lpViewOI->vOriginalOI    = zGETHNDL( vOriginalOI );

	mov	edx, DWORD PTR _vOriginalOI$8193[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 2129 : 
; 2130 :          if ( lpQualView )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	$L8200

; 2132 :             zVIEW vQualOI;
; 2133 : 
; 2134 :             ActivateOI_FromOI_ForTask( &vQualOI, lpQualView, 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vQualOI$8201[ebp]
	push	eax
	call	_ActivateOI_FromOI_ForTask@16

; 2135 :             vQualOI->bQualView   = TRUE;

	mov	ecx, DWORD PTR _vQualOI$8201[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	dh, 1
	mov	eax, DWORD PTR _vQualOI$8201[ebp]
	mov	DWORD PTR [eax+30], edx

; 2136 :             vQualOI->bViewLocked = TRUE;

	mov	ecx, DWORD PTR _vQualOI$8201[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _vQualOI$8201[ebp]
	mov	DWORD PTR [eax+30], edx

; 2137 :             vQualOI->hMainOI     = vOriginalOI->hMainOI; // = zGETHNDL( lpViewOI );

	mov	ecx, DWORD PTR _vQualOI$8201[ebp]
	mov	edx, DWORD PTR _vOriginalOI$8193[ebp]
	mov	eax, DWORD PTR [edx+26]
	mov	DWORD PTR [ecx+26], eax

; 2138 : 
; 2139 :             // It is possible that the qual OI contains references to
; 2140 :             // another view.  These views might not be around (or they
; 2141 :             // might change) when we use the qual OI again.  To avoid
; 2142 :             // these errors, resolve all references to other views.
; 2143 :             fnResolveQualOI( vQualOI, "QualAttrib" );

	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	ecx, DWORD PTR _vQualOI$8201[ebp]
	push	ecx
	call	_fnResolveQualOI
	add	esp, 8

; 2144 :             fnResolveQualOI( vQualOI, "SubQualAttrib" );

	push	OFFSET FLAT:??_C@_0O@GCPH@SubQualAttrib?$AA@ ; `string'
	mov	edx, DWORD PTR _vQualOI$8201[ebp]
	push	edx
	call	_fnResolveQualOI
	add	esp, 8

; 2145 : 
; 2146 :             lpViewOI->vQualOI = zGETHNDL( vQualOI );

	mov	eax, DWORD PTR _vQualOI$8201[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 2148 :          else

	jmp	SHORT $L8205
$L8200:

; 2149 :             lpViewOI->vQualOI = 0;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+44], 0
$L8205:

; 2152 : 
; 2153 :       if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $L8206

; 2154 :          DropNameForView( lpView, "__Load-in-progress", lpView, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BD@JJIL@__Load?9in?9progress?$AA@ ; `string'
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_DropNameForView@16
$L8206:

; 2157 :    else

	jmp	$L8207
$L8147:

; 2159 :       zLONG lNetControl;
; 2160 : 
; 2161 :       // We need to activate from the network, sooo ...
; 2162 : 
; 2163 :       // First make sure the network is active.
; 2164 :       nRC = NetStatus( lpAppQualView, lpViewOD->szNetwork );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 109				; 0000006dH
	push	edx
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	call	_NetStatus@8
	mov	WORD PTR _nRC$[ebp], ax

; 2165 :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L8210

; 2167 :          nRC = NetStartup( lpAppQualView, lpViewOD->szNetwork,
; 2168 :                            lpViewOD->szNetwork );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 109				; 0000006dH
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 109				; 0000006dH
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	call	_NetStartup@12
	mov	WORD PTR _nRC$[ebp], ax

; 2169 :          if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L8210

; 2171 :             MessageSend( lpAppQualView, "xx", "KZOEOIAA",
; 2172 :                         "Network cannot be started.",
; 2173 :                         zMSGQ_OBJECT_CONSTRAINT_ERROR, 1 );

	push	1
	push	300					; 0000012cH
	push	OFFSET FLAT:??_C@_0BL@GDPI@Network?5cannot?5be?5started?4?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_08IDGA@KZOEOIAA?$AA@	; `string'
	push	OFFSET FLAT:??_C@_02KKOC@xx?$AA@	; `string'
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	call	_MessageSend@24

; 2174 :             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 2175 :             goto EndOfFunction;

	jmp	$EndOfFunction$8058
$L8210:

; 2178 : 
; 2179 :       // Since we are handling the CONTINUE logic on the client side, turn
; 2180 :       // off the CONTINUE flag (if it's on).
; 2181 :       lNetControl = lControl & ~zACTIVATE_CONTINUE;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, -134217729				; f7ffffffH
	mov	DWORD PTR _lNetControl$8208[ebp], ecx

; 2182 : 
; 2183 :       nRC = NetActivateOI( lpViewOD->szNetwork, 0, &lpView,
; 2184 :                            (zPCHAR) cpcViewOD_Name, lpAppQualView,
; 2185 :                            lpQualView, lNetControl );

	mov	edx, DWORD PTR _lNetControl$8208[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 109				; 0000006dH
	push	ecx
	call	_NetActivateOI@28
	mov	WORD PTR _nRC$[ebp], ax
$L8207:

; 2187 : 
; 2188 :    if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $L8215

; 2190 :       lpViewOD  = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 2191 :       lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2192 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2193 :       lpViewOI->lActivateControl = lControl;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR _lControl$[ebp]
	mov	DWORD PTR [edx+48], eax
$L8215:

; 2195 : 
; 2196 :    if ( nRC >= 0 && lControl & zREADONLY )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $L8219
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2048				; 00000800H
	test	edx, edx
	je	SHORT $L8219

; 2197 :       lpView->bReadOnly = TRUE;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx
$L8219:

; 2198 : 
; 2199 :    // If we are doing a CONTINUE activate then we need to add the entities
; 2200 :    // just loaded to the original instance.
; 2201 :    if ( lControl & zACTIVATE_CONTINUE )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	je	$L8220

; 2203 :       LPENTITYINSTANCE lpEntityInstance;
; 2204 : 
; 2205 :       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 2206 :             lpEntityInstance;
; 2207 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$8221[ebp], eax
	jmp	SHORT $L8224
$L8225:
	mov	eax, DWORD PTR _lpEntityInstance$8221[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$8221[ebp], eax
$L8224:
	cmp	DWORD PTR _lpEntityInstance$8221[ebp], 0
	je	$L8226

; 2209 :       // LPDATARECORD     lpFirstDataRecord;
; 2210 :       // LPDATAFIELD      lpDataField;
; 2211 :          LPVIEWATTRIB     lpViewAttrib;
; 2212 :          LPVIEWENTITYCSR  lpViewEntityCsr;
; 2213 :          LPENTITYINSTANCE lpNewEI;
; 2214 :          zBOOL            bNewRoot;
; 2215 : 
; 2216 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$8221[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 2217 :          fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$8221[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 2218 : 
; 2219 :          fnValidViewEntity( &lpViewEntityCsr, vOrigView,
; 2220 :                             lpViewEntity->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$8228[ebp]
	push	edx
	call	_fnValidViewEntity@16

; 2221 :          if ( lpViewEntity->hParent )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $L8232

; 2222 :             bNewRoot = FALSE;

	mov	BYTE PTR _bNewRoot$8230[ebp], 0

; 2223 :          else

	jmp	SHORT $L8233
$L8232:

; 2224 :             bNewRoot = FALSE; // TRUE;

	mov	BYTE PTR _bNewRoot$8230[ebp], 0
$L8233:

; 2225 : 
; 2226 :          fnCreateEntity( vOrigView, lpViewEntity, lpViewEntityCsr, zPOS_LAST,
; 2227 :                          (zSHORT) bNewRoot );

	movzx	cx, BYTE PTR _bNewRoot$8230[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _lpViewEntityCsr$8228[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	call	_fnCreateEntity@20

; 2228 :          lpNewEI = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$8228[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewEI$8229[ebp], eax

; 2229 : 
; 2230 :          // Loop through all persistent entities and store values in object.
; 2231 :          for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 2232 :                lpViewAttrib;
; 2233 :                lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$8227[ebp], eax
	jmp	SHORT $L8239
$L8240:
	mov	eax, DWORD PTR _lpViewAttrib$8227[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$8227[ebp], eax
$L8239:
	cmp	DWORD PTR _lpViewAttrib$8227[ebp], 0
	je	SHORT $L8241

; 2235 :             zPCHAR  lpPtr;
; 2236 :             zULONG  uLth;
; 2237 : 
; 2238 :             if ( lpViewAttrib->bPersist )

	mov	edx, DWORD PTR _lpViewAttrib$8227[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	test	eax, eax
	je	SHORT $L8244

; 2240 :                fnGetAttrAddrFromEntityInstance( &lpPtr, &uLth,
; 2241 :                                                 lpEntityInstance,
; 2242 :                                                 lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$8227[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$8221[ebp]
	push	edx
	lea	eax, DWORD PTR _uLth$8243[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpPtr$8242[ebp]
	push	ecx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H

; 2243 :                fnStoreValueInEntityInstance( lpNewEI, lpViewEntity,
; 2244 :                                              lpViewAttrib, lpPtr, uLth );

	mov	edx, DWORD PTR _uLth$8243[ebp]
	push	edx
	mov	eax, DWORD PTR _lpPtr$8242[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$8227[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewEI$8229[ebp]
	push	eax
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
$L8244:

; 2246 : 
; 2247 :          } // for ( lpDataField... )...

	jmp	SHORT $L8240
$L8241:

; 2248 : 
; 2249 :       } // for ( lpEntityInstance... )...

	jmp	$L8225
$L8226:

; 2250 : 
; 2251 :       fnDropView( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropView@4

; 2252 :       lpView = vOrigView;

	mov	edx, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR _lpView$[ebp], edx
$L8220:

; 2255 : 
; 2256 :    if ( nRC >= 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $L8247

; 2258 :       // Reset the view to its initial state.
; 2259 :       if ( lControl & zACTIVATE_CONTINUE )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 134217728				; 08000000H
	test	ecx, ecx
	je	SHORT $L8246

; 2260 :          fnEstablishViewForInstance( lpView, 0, lpOrigInstance );

	mov	edx, DWORD PTR _lpOrigInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 2261 :       else

	jmp	SHORT $L8247
$L8246:

; 2262 :          fnResetView( lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetView
	add	esp, 8
$L8247:

; 2265 : 
; 2266 : #ifdef __ACTIVATE_CONSTRAINTS__
; 2267 : 
; 2268 :    if ( (lControl & zACTIVATE_NOCONSTRAINTS) == 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 16777216				; 01000000H
	test	edx, edx
	jne	$L8253

; 2270 :       // If there is an Object Constraint for activate, see if it has
; 2271 :       // any objections about continuing.
; 2272 :       if ( nRC >= 0 && lpViewOD->bActivateConstraint )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $L8253
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	je	SHORT $L8253

; 2274 :          zSHORT   nState;
; 2275 :          zSHORT   k;
; 2276 : 
; 2277 :          nState = (lControl & zLEVEL_SYSTEM) ? zOCE_STATE_SYSTEM : 0;

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 8
	neg	eax
	sbb	eax, eax
	and	eax, 4
	mov	WORD PTR _nState$8250[ebp], ax

; 2278 :          if ( lControl & zMULTIPLE )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L8252

; 2279 :             nState |= zOCE_STATE_MULTIPLE;

	mov	dx, WORD PTR _nState$8250[ebp]
	or	dl, 16					; 00000010H
	mov	WORD PTR _nState$8250[ebp], dx
$L8252:

; 2280 : 
; 2281 :          k = fnInvokeOCEOperation( lpView, lpCurrentTask,
; 2282 :                                    zOCE_ACTIVATE, nState );

	mov	ax, WORD PTR _nState$8250[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _k$8251[ebp], ax

; 2283 :          // If object constraint says no go, drop the view and exit
; 2284 :          if ( k )

	movsx	eax, WORD PTR _k$8251[ebp]
	test	eax, eax
	je	SHORT $L8253

; 2286 :             nRC = k;

	mov	cx, WORD PTR _k$8251[ebp]
	mov	WORD PTR _nRC$[ebp], cx

; 2287 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$8058
$L8253:

; 2291 : #endif
; 2292 : 
; 2293 :    // If the view has pessimistic locking and if the zSINGLE_FOR_UPDATE flag
; 2294 :    // has not been set or if the locking level is zLL_PESSIMISTIC then the
; 2295 :    // view is read-only.
; 2296 :    if ( nRC >= -1 && lpView &&
; 2297 :         (((lControl & zSINGLE_FOR_UPDATE) == 0 &&
; 2298 :           (lpViewOD->nLock > 0 ||
; 2299 :            lpViewOD->nEntityLock > zLL_PESSIMISTIC)) ||
; 2300 :          lpViewOD->nLock == zLL_PESSIMISTIC) )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jl	SHORT $EndOfFunction$8058
	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $EndOfFunction$8058
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	jne	SHORT $L8256
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	test	edx, edx
	jg	SHORT $L8255
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+237]
	cmp	ecx, 3
	jg	SHORT $L8255
$L8256:
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+236]
	cmp	eax, 3
	jne	SHORT $EndOfFunction$8058
$L8255:

; 2302 :       lpView->bReadOnly   = TRUE;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+30], edx

; 2303 :       lpViewOI->bReadOnly = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 4
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$EndOfFunction$8058:

; 2305 : 
; 2306 : EndOfFunction:
; 2307 : 
; 2308 :    if ( bLockingSemaphoreCreatedHere )

	mov	ecx, DWORD PTR _bLockingSemaphoreCreatedHere$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L8257

; 2309 :       fnDeletePessimisticSemaphore( lpCurrentTask,
; 2310 :                                     (zPVOID) &lpViewOD, 1, 0, lpAppQualView );

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	0
	push	1
	lea	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnDeletePessimisticSemaphore@20
$L8257:

; 2311 : 
; 2312 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	and	eax, 1
	test	eax, eax
	je	SHORT $L8259

; 2314 :       zCHAR sz[ 100 ];
; 2315 : 
; 2316 :       zsprintf( sz, "%lf seconds for object %s ",
; 2317 :                 (double) (SysGetTickCount( ) - lTickCount) / zTICKS_PER_SECOND,
; 2318 :                 cpcViewOD_Name );

	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	call	_SysGetTickCount@0
	sub	eax, DWORD PTR _lTickCount$[ebp]
	mov	DWORD PTR -848+[ebp], eax
	mov	DWORD PTR -848+[ebp+4], 0
	fild	QWORD PTR -848+[ebp]
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BL@OKGH@?$CFlf?5seconds?5for?5object?5?$CFs?5?$AA@ ; `string'
	lea	edx, DWORD PTR _sz$8260[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2319 :       TraceLineS( "(oi) Total time for ActivateObjectInstance = ", sz );

	lea	eax, DWORD PTR _sz$8260[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CO@EJKO@?$CIoi?$CJ?5Total?5time?5for?5ActivateObje@ ; `string'
	call	_TraceLineS@8
$L8259:

; 2321 : 
; 2322 :    if ( nRC < -1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jge	SHORT $L8264

; 2324 :       if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $L8265

; 2325 :          fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDropView@4
$L8265:

; 2326 : 
; 2327 :       if ( (lControl & zACTIVATE_CONTINUE) == 0 )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 134217728				; 08000000H
	test	eax, eax
	jne	SHORT $L8266

; 2328 :          *pvReturnView = 0;

	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [ecx], 0
$L8266:

; 2330 :    else

	jmp	SHORT $L8267
$L8264:

; 2331 :       *pvReturnView = lpView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx], eax
$L8267:

; 2332 : 
; 2333 :    if ( vTempQual )

	cmp	DWORD PTR _vTempQual$[ebp], 0
	je	SHORT $L8268

; 2334 :       fnDropView( vTempQual );

	mov	ecx, DWORD PTR _vTempQual$[ebp]
	push	ecx
	call	_fnDropView@4
$L8268:

; 2335 : 
; 2336 :    if ( bDropQual )

	mov	edx, DWORD PTR _bDropQual$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L8269

; 2337 :       fnDropView( lpQualView );

	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_fnDropView@4
$L8269:

; 2338 : 
; 2339 :    fnOperationReturn( iActivateObjectInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	52					; 00000034H
	call	_fnOperationReturn
	add	esp, 8

; 2340 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L8037:

; 2341 : 
; 2342 : }  // ActivateObjectInstance

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_ActivateObjectInstance@20 ENDP
_TEXT	ENDS
PUBLIC	_fnReadDataFromFileStream@20
EXTRN	_SysReadLine@12:NEAR
EXTRN	_SysReadLineLth@16:NEAR
_TEXT	SEGMENT
_lpView$ = 8
_pvData$ = 12
_ppchReturnBuffer$ = 16
_uLth$ = 20
_nErrorNbr$ = 24
_lpFileData$ = -4
_pchExtraData$8285 = -8
_lpTask$8287 = -12
_fnReadDataFromFileStream@20 PROC NEAR

; 2350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2351 :    LPFILEDATA lpFileData = (LPFILEDATA) pvData;

	mov	eax, DWORD PTR _pvData$[ebp]
	mov	DWORD PTR _lpFileData$[ebp], eax

; 2352 : 
; 2353 :    // If nErrorNbr is not 0, then flash the error message and get out.
; 2354 :    if ( nErrorNbr )

	movsx	ecx, WORD PTR _nErrorNbr$[ebp]
	test	ecx, ecx
	je	$L8284

; 2356 :       zPCHAR pchExtraData = (zPCHAR) ppchReturnBuffer;

	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	DWORD PTR _pchExtraData$8285[ebp], edx

; 2357 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$8287[ebp], eax

; 2358 : 
; 2359 :       switch ( nErrorNbr )
; 2360 :       {

	movsx	edx, WORD PTR _nErrorNbr$[ebp]
	mov	DWORD PTR -16+[ebp], edx
	mov	eax, DWORD PTR -16+[ebp]
	sub	eax, 74					; 0000004aH
	mov	DWORD PTR -16+[ebp], eax
	cmp	DWORD PTR -16+[ebp], 30			; 0000001eH
	ja	$L8290
	mov	edx, DWORD PTR -16+[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR $L12771[edx]
	jmp	DWORD PTR $L12772[ecx*4]
$L8293:

; 2363 :             // "KZOEE074 - Invalid Entity name on line "
; 2364 :             fnIssueCoreError( lpTask, lpView, 16, 74, lpFileData->lLine,
; 2365 :                               pchExtraData, lpFileData->pchFileName );

	mov	eax, DWORD PTR _lpFileData$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pchExtraData$8285[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFileData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	74					; 0000004aH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$8287[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2366 :             break;

	jmp	SHORT $L8290
$L8294:

; 2368 : 
; 2369 :          case 75:
; 2370 :             // "KZOEE075 - Invalid Entity level on line "
; 2371 :             fnIssueCoreError( lpTask, lpView, 16, 75, lpFileData->lLine,
; 2372 :                               pchExtraData, lpFileData->pchFileName );

	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pchExtraData$8285[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	75					; 0000004bH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$8287[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2373 :             break;

	jmp	SHORT $L8290
$L8295:

; 2374 : 
; 2375 :          case 90:
; 2376 :             // "KZOEE090 - Maximum number of entites in portable file exceeded"
; 2377 :             fnIssueCoreError( lpTask, lpView, 16, 90, lpFileData->lLine,
; 2378 :                               lpFileData->pchFileName, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	edx, DWORD PTR _lpFileData$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	90					; 0000005aH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$8287[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2379 :             break;

	jmp	SHORT $L8290
$L8296:

; 2380 : 
; 2381 :          case 104:
; 2382 :             // "KZOEE104 - Invalid Attribute name for Entity"
; 2383 :             fnIssueCoreError( lpTask, lpView, 16, 104, 0, pchExtraData, 0 );

	push	0
	mov	edx, DWORD PTR _pchExtraData$8285[ebp]
	push	edx
	push	0
	push	104					; 00000068H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$8287[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$L8290:

; 2387 : 
; 2388 :       return( 0 );

	xor	ax, ax
	jmp	SHORT $L8298
$L8284:

; 2391 : 
; 2392 :    lpFileData->lLine++;

	mov	edx, DWORD PTR _lpFileData$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2393 : 
; 2394 :    if ( uLth )

	cmp	DWORD PTR _uLth$[ebp], 0
	je	SHORT $L8297

; 2395 :       return( SysReadLineLth( lpView, ppchReturnBuffer, lpFileData->hFile, uLth ) );

	mov	edx, DWORD PTR _uLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFileData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysReadLineLth@16
	jmp	SHORT $L8298
$L8297:

; 2396 :    else
; 2397 :       return( SysReadLine( lpView, ppchReturnBuffer, lpFileData->hFile ) );

	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ppchReturnBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysReadLine@12
$L8298:

; 2398 : 
; 2399 : } // fnReadDataFromFileStream

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L12772:
	DD	$L8293
	DD	$L8294
	DD	$L8295
	DD	$L8296
	DD	$L8290
$L12771:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_fnReadDataFromFileStream@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FGFK@TZCMULWO?4POR?$AA@		; `string'
PUBLIC	??_C@_0O@PPBE@?$CIoi?$CJ?5opening?5?$AA@	; `string'
PUBLIC	_ActivateOI_FromFile@20
PUBLIC	_SfActivateOI_FromStream@24
EXTRN	_fnGetApplicationForSubtask@8:NEAR
EXTRN	_SysOpenFile@12:NEAR
EXTRN	__imp__strchr:NEAR
EXTRN	__imp__strstr:NEAR
EXTRN	_cDirSep:BYTE
EXTRN	_SysAppendcDirSep@4:NEAR
EXTRN	_fnSysCloseFile@12:NEAR
EXTRN	_SysConvertEnvironmentString@8:NEAR
;	COMDAT ??_C@_0N@FGFK@TZCMULWO?4POR?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0N@FGFK@TZCMULWO?4POR?$AA@ DB 'TZCMULWO.POR', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@PPBE@?$CIoi?$CJ?5opening?5?$AA@
_DATA	SEGMENT
??_C@_0O@PPBE@?$CIoi?$CJ?5opening?5?$AA@ DB '(oi) opening ', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_cpcFileName$ = 20
_lControl$ = 24
_lpCurrentTask$ = -2104
_lpTask$ = -2068
_lpViewOD$ = -2060
_lpApp$ = -2072
_ActFileData$ = -2092
_vTask$ = -2100
_l$ = -2076
_hFile$ = -2080
_szOpenFileName$ = -2056
_szWork$ = -1028
_bSystemObj$ = -2096
_nRC$ = -2064
_lpViewCsr$8330 = -2108
_lpSystemApp$8345 = -2112
_ActivateOI_FromFile@20 PROC NEAR

; 2469 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2112				; 00000840H

; 2470 :    LPTASK          lpCurrentTask;
; 2471 :    LPTASK          lpTask;
; 2472 :    LPVIEWOD        lpViewOD;
; 2473 :    LPAPP           lpApp;
; 2474 :    FileDataRecord  ActFileData;
; 2475 :    zVIEW           vTask;
; 2476 :    zLONG           l;
; 2477 :    zLONG           hFile;
; 2478 :    zCHAR           szOpenFileName[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 2479 :    zCHAR           szWork[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 2480 :    zBOOL           bSystemObj;
; 2481 :    zSHORT          nRC;
; 2482 : 
; 2483 :    // Init in case of error.
; 2484 :    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 2485 :    bSystemObj = (lControl & zACTIVATE_SYSTEM) ? TRUE : FALSE;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 536870912				; 20000000H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	BYTE PTR _bSystemObj$[ebp], cl

; 2486 : 
; 2487 :    // If task not active or disabled, return zCALL_ERROR.
; 2488 :    if ( (lpCurrentTask = fnOperationCall( iActivateOI_FromFile,
; 2489 :                                           lpAppQualView, 0 )) == 0 )

	push	0
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	54					; 00000036H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8322

; 2491 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8309
$L8322:

; 2493 : 
; 2494 :    // Unless we're activating a system object, ensure that the app qual
; 2495 :    // view is valid.
; 2496 :    if ( (lpAppQualView || !(lControl & zACTIVATE_SYSTEM)) &&
; 2497 :         fnValidView( lpCurrentTask, lpAppQualView ) == 0 )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	jne	SHORT $L8324
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 536870912				; 20000000H
	test	eax, eax
	jne	SHORT $L8323
$L8324:
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidView
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L8323

; 2499 :       fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2500 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8309
$L8323:

; 2502 : 
; 2503 :    // Verify only one zLEVEL_ option requested.
; 2504 :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], edx

; 2505 :    if ( l && (-l & l) != l )

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $L8325
	mov	eax, DWORD PTR _l$[ebp]
	neg	eax
	and	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _l$[ebp]
	je	SHORT $L8325

; 2507 :       // error, More than one zLEVEL_ option requested
; 2508 :       // "KZOEE023 - Invalid parameter, "
; 2509 :       fnIssueCoreError( lpCurrentTask, lpAppQualView, 8, 23, 0,
; 2510 :                         "More than one zLEVEL_ option requested", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@ ; `string'
	push	0
	push	23					; 00000017H
	push	8
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2511 :       fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2512 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8309
$L8325:

; 2514 : 
; 2515 :    // If zLEVEL_SAME is requested.
; 2516 :    if ( lControl & zLEVEL_SAME )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1024				; 00000400H
	test	ecx, ecx
	je	$L8339

; 2518 :       if ( lpAppQualView == 0 || lpAppQualView->hSubtask )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $L8328
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $L8327
$L8328:

; 2520 :          // "KZOEE100 - Invalid View, view is a Subtask View"
; 2521 :          fnIssueCoreError( lpCurrentTask, lpAppQualView, 8, 100, 0,
; 2522 :                            "lpAppQualView", "with zLEVEL_SAME" );

	push	OFFSET FLAT:??_C@_0BB@MNMJ@with?5zLEVEL_SAME?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0O@OFE@lpAppQualView?$AA@ ; `string'
	push	0
	push	100					; 00000064H
	push	8
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2523 :          fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2524 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8309
$L8327:

; 2528 :          LPVIEWCSR lpViewCsr;
; 2529 : 
; 2530 :          // Turn off the 'same' indicator
; 2531 :          lControl ^= zLEVEL_SAME;

	mov	eax, DWORD PTR _lControl$[ebp]
	xor	eax, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], eax

; 2532 :          // To determine what the level is of the qualifying view
; 2533 :          //   1. Change lpAppQualView to point to the initial
; 2534 :          //      view created for the object instance
; 2535 :          //   2. Check for application level, if there use
; 2536 :          //      zLEVEL_APPLICATION.
; 2537 :          //   3. Check if the view task is the main task, if so use
; 2538 :          //      zLEVEL_SYSTEM.
; 2539 :          //   4. Use the task level...
; 2540 :          lpViewCsr = zGETPTR( lpAppQualView->hViewCsr );

	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$8330[ebp], eax
$L8333:

; 2541 :          while ( lpViewCsr->hNextViewCsr )

	mov	eax, DWORD PTR _lpViewCsr$8330[ebp]
	cmp	DWORD PTR [eax+2], 0
	je	SHORT $L8334

; 2542 :             lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	ecx, DWORD PTR _lpViewCsr$8330[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$8330[ebp], eax
	jmp	SHORT $L8333
$L8334:

; 2543 : 
; 2544 :          lpAppQualView = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$8330[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAppQualView$[ebp], eax

; 2545 :          if ( lpAppQualView->bApplicationView )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L8337

; 2546 :             lControl |= zLEVEL_APPLICATION;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 4
	mov	DWORD PTR _lControl$[ebp], ecx

; 2547 :          else

	jmp	SHORT $L8339
$L8337:

; 2548 :          if ( lpAppQualView->hTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $L8339

; 2549 :             lControl |= zLEVEL_SYSTEM;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 8
	mov	DWORD PTR _lControl$[ebp], edx
$L8339:

; 2552 : 
; 2553 :    // Make sure request is for valid OD.
; 2554 :    lpViewOD = ActivateViewObject( lpAppQualView, cpcViewOD_Name, bSystemObj );

	mov	al, BYTE PTR _bSystemObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	call	_ActivateViewObject@12
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 2555 :    if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $L8340

; 2557 :       fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2558 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8309
$L8340:

; 2560 : 
; 2561 :    // First off, see if we can open the filename requested,
; 2562 :    // go through characters in name and see if they need either
; 2563 :    // a directory qualification prefix or an object file suffix.
; 2564 : 
; 2565 : // Change DGC 5/27/96 -- In an attempt to make all code retrieve the
; 2566 : // application in the same way from a view, I have changed the following code.
; 2567 :    fnGetApplicationForSubtask( &lpApp, lpAppQualView );

	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	call	_fnGetApplicationForSubtask@8

; 2568 : 
; 2569 : // DGC 9/23/96
; 2570 : // I changed the logic: if the file name is not qualfied, use the object dir
; 2571 : // for the application. I repeated this change in CommitOI_ToFile.
; 2572 :    if ( zstrchr( cpcFileName, cDirSep ) == 0 )

	movsx	eax, BYTE PTR _cDirSep
	push	eax
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $L8342

; 2574 :       if ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $L8343

; 2575 :          zstrcpy( szWork, lpApp->szObjectDir );

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 347				; 0000015bH
	push	edx
	lea	eax, DWORD PTR _szWork$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2576 :       else

	jmp	SHORT $L8344
$L8343:

; 2578 :          LPAPP lpSystemApp = zGETPTR( AnchorBlock->hSystemApp );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSystemApp$8345[ebp], eax

; 2579 : 
; 2580 :          zstrcpy( szWork, lpSystemApp->szObjectDir );

	mov	eax, DWORD PTR _lpSystemApp$8345[ebp]
	add	eax, 347				; 0000015bH
	push	eax
	lea	ecx, DWORD PTR _szWork$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$L8344:

; 2582 : 
; 2583 :       SysAppendcDirSep( szWork );

	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 2585 :    else

	jmp	SHORT $L8347
$L8342:

; 2586 :       szWork[ 0 ] = 0;

	mov	BYTE PTR _szWork$[ebp], 0
$L8347:

; 2587 : 
; 2588 :    zstrcat( szWork, cpcFileName ); // w\bin\sys\tzrpsrco.lod

	mov	eax, DWORD PTR _cpcFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWork$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2589 :    SysConvertEnvironmentString( szOpenFileName, szWork );

	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	call	_SysConvertEnvironmentString@8

; 2590 : 
; 2591 :    if ( AnchorBlock->TraceFlags.bOpenFile )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	shr	edx, 2
	and	edx, 1
	test	edx, edx
	je	SHORT $L8349

; 2593 :       if ( zstrstr( cpcFileName, "TZCMULWO.POR" ) == 0 )

	push	OFFSET FLAT:??_C@_0N@FGFK@TZCMULWO?4POR?$AA@ ; `string'
	mov	eax, DWORD PTR _cpcFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $L8349

; 2594 :          TraceLineS( "(oi) opening ", szOpenFileName );

	lea	ecx, DWORD PTR _szOpenFileName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0O@PPBE@?$CIoi?$CJ?5opening?5?$AA@ ; `string'
	call	_TraceLineS@8
$L8349:

; 2596 : 
; 2597 :    // Open the file for the object instance data.
; 2598 :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 12					; 0000000cH
	test	edx, edx
	je	SHORT $L8352

; 2600 :       lpTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 2603 :    else

	jmp	SHORT $L8354
$L8352:

; 2605 :       lpTask = lpCurrentTask;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx
$L8354:

; 2608 : 
; 2609 :    if ( lpAppQualView && zGETPTR( lpAppQualView->hTask ) == lpTask ) // added dks 2006.09.15 to prevent looking

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $L8356
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpTask$[ebp]
	jne	SHORT $L8356

; 2610 :       vTask = lpAppQualView;                                         // at incorrect app when we just pick vTask

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	DWORD PTR _vTask$[ebp], edx

; 2611 :    else                                                              // willy-nilly (as is done on the next line)

	jmp	SHORT $L8357
$L8356:

; 2612 :       vTask = zGETPTR( lpTask->hFirstView );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vTask$[ebp], eax
$L8357:

; 2613 : 
; 2614 :    hFile = SysOpenFile( vTask, szOpenFileName, COREFILE_READ );

	push	128					; 00000080H
	lea	edx, DWORD PTR _szOpenFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _vTask$[ebp]
	push	eax
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 2615 :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $L8361

; 2617 :       if ( lControl & zNOI_OKAY )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 512				; 00000200H
	test	ecx, ecx
	je	SHORT $L8360

; 2619 :          fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2620 :          return( -1 );

	or	ax, -1
	jmp	$L8309
$L8360:

; 2624 :          //  "KZOEE071 - Error opening instance file "
; 2625 :          fnIssueCoreError( lpCurrentTask, lpAppQualView, 16, 71, 0,
; 2626 :                            szOpenFileName, 0 );

	push	0
	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	push	0
	push	71					; 00000047H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2627 :          fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2628 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8309
$L8361:

; 2631 : 
; 2632 :    ActFileData.pchFileName = szOpenFileName;

	lea	ecx, DWORD PTR _szOpenFileName$[ebp]
	mov	DWORD PTR _ActFileData$[ebp], ecx

; 2633 :    ActFileData.hFile = hFile;

	mov	edx, DWORD PTR _hFile$[ebp]
	mov	DWORD PTR _ActFileData$[ebp+4], edx

; 2634 :    ActFileData.lLine = 1;

	mov	DWORD PTR _ActFileData$[ebp+8], 1

; 2635 : 
; 2636 :    nRC = SfActivateOI_FromStream( pvReturnView, cpcViewOD_Name,
; 2637 :                                // lpAppQualView, lControl,
; 2638 :                                   vTask, lControl,
; 2639 :                                   fnReadDataFromFileStream,
; 2640 :                                   (zPVOID) &ActFileData );

	lea	eax, DWORD PTR _ActFileData$[ebp]
	push	eax
	push	OFFSET FLAT:_fnReadDataFromFileStream@20
	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcViewOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_SfActivateOI_FromStream@24
	mov	WORD PTR _nRC$[ebp], ax

; 2641 : 
; 2642 : // TraceLine( "ActivateOI_FromFile: 0x%08x", *pvReturnView );
; 2643 : 
; 2644 :    // Close the file
; 2645 :    fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFile@12

; 2646 : 
; 2647 :    fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2648 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L8309:

; 2649 : 
; 2650 : } // ActivateOI_FromFile

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_ActivateOI_FromFile@20 ENDP
_TEXT	ENDS
PUBLIC	_ActivateOI_FromOI@12
_TEXT	SEGMENT
_pvReturnView$ = 8
_lpSrcView$ = 12
_lControl$ = 16
_ActivateOI_FromOI@12 PROC NEAR

; 2705 : {

	push	ebp
	mov	ebp, esp

; 2706 :    return( ActivateOI_FromOI_ForTask( pvReturnView, lpSrcView, 0, lControl ) );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvReturnView$[ebp]
	push	edx
	call	_ActivateOI_FromOI_ForTask@16

; 2707 : }

	pop	ebp
	ret	12					; 0000000cH
_ActivateOI_FromOI@12 ENDP
_TEXT	ENDS
EXTRN	_fnCopyAttributeRecord:NEAR
EXTRN	_fnAddEntityToDebugChange@4:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_fnAllocDataspace:NEAR
EXTRN	_fnSetEntityKey@12:NEAR
_TEXT	SEGMENT
_pvReturnView$ = 8
_lpSrcView$ = 12
_lControl$ = 20
_lpCurrentTask$ = -36
_lpOwningTask$ = -20
_lpSrcViewOI$ = -28
_lpTgtViewOI$ = -12
_lpViewCsr$ = -4
_lpTgtView$ = -8
_l$ = -24
_bMultiple$ = -32
_nRC$ = -16
_lpInstanceOwningTask$8409 = -56
_lpViewEntity$8410 = -52
_lpSrcEntityInstance$8411 = -40
_lpTgtEntityInstance$8412 = -64
_lpLastTgtEntityInstance$8413 = -80
_lpTgtParent$8414 = -44
_lpWkInstance1$8415 = -72
_lpWkInstance2$8416 = -68
_hTgtViewOI$8417 = -48
_hTgtEntityInstance$8418 = -60
_nLastLvl$8419 = -76
_lpRootViewEntityCsr$8424 = -84
_hWkInstance1$8445 = -88
_ActivateOI_FromOI_ForTask@16 PROC NEAR

; 2714 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 2715 :    LPTASK      lpCurrentTask;
; 2716 :    LPTASK      lpOwningTask;
; 2717 :    LPVIEWOI    lpSrcViewOI;
; 2718 :    LPVIEWOI    lpTgtViewOI;
; 2719 :    LPVIEWCSR   lpViewCsr;
; 2720 :    zVIEW       lpTgtView;
; 2721 :    zLONG       l;
; 2722 :    zBOOL       bMultiple;
; 2723 :    zSHORT      nRC;
; 2724 : 
; 2725 :    *pvReturnView = 0;  // init in case of error

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 2726 : 
; 2727 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 2728 :    if ( (lpCurrentTask = fnOperationCall( iActivateOI_FromOI, lpSrcView,
; 2729 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	55					; 00000037H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8388

; 2731 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8378
$L8388:

; 2733 : 
; 2734 :    // Get the view oi and ensure that it has no outstanding temporal
; 2735 :    // entities or subobjects.
; 2736 :    lpViewCsr = zGETPTR( lpSrcView->hViewCsr );

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2737 : 
; 2738 :    lpSrcViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOI$[ebp], eax

; 2739 :    if ( lpSrcViewOI->nVersionedInstances )

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	je	SHORT $L8391

; 2741 :       //  "KZOEE076 - Object instance contains versioned entity instances"
; 2742 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 76, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	76					; 0000004cH
	push	8
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2743 :       fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	55					; 00000037H
	call	_fnOperationReturn
	add	esp, 8

; 2744 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8378
$L8391:

; 2746 : 
; 2747 :    // Verify only one zLEVEL_ option requested.
; 2748 :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], edx

; 2749 :    if ( l && (-l & l) != l )

	cmp	DWORD PTR _l$[ebp], 0
	je	SHORT $L8392
	mov	eax, DWORD PTR _l$[ebp]
	neg	eax
	and	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _l$[ebp]
	je	SHORT $L8392

; 2751 :       // error, More than one zLEVEL_ option requested
; 2752 :       // "KZOEE023 - Invalid parameter, "
; 2753 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 23, 0,
; 2754 :                         "More than one zLEVEL_ option requested", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0CH@CKH@More?5than?5one?5zLEVEL_?5option?5req@ ; `string'
	push	0
	push	23					; 00000017H
	push	8
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2755 :       fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	55					; 00000037H
	call	_fnOperationReturn
	add	esp, 8

; 2756 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8378
$L8392:

; 2758 : 
; 2759 :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 12					; 0000000cH
	test	ecx, ecx
	je	SHORT $L8393

; 2760 :       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 2761 :    else

	jmp	SHORT $L8395
$L8393:

; 2762 :       lpOwningTask = lpCurrentTask;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], ecx
$L8395:

; 2763 : 
; 2764 :    // Get multiple root indicator.
; 2765 :    bMultiple = 0;

	mov	BYTE PTR _bMultiple$[ebp], 0

; 2766 :    if ( lControl & zMULTIPLE )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 256				; 00000100H
	test	edx, edx
	je	SHORT $L8396

; 2767 :       bMultiple = TRUE;

	mov	BYTE PTR _bMultiple$[ebp], 1
$L8396:

; 2768 : 
; 2769 :    // If zLEVEL_SAME is requested.
; 2770 :    if ( lControl & zLEVEL_SAME )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $L8406

; 2772 :       // Turn off the 'same' indicator.
; 2773 :       lControl ^= zLEVEL_SAME;

	mov	ecx, DWORD PTR _lControl$[ebp]
	xor	ecx, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], ecx

; 2774 :       // To determine what the level is of the qualifying view
; 2775 :       //   1. Change lpSrcView to point to the initial
; 2776 :       //      view created for the object instance
; 2777 :       //   2. Check for application level, if there use
; 2778 :       //      zLEVEL_APPLICATION.
; 2779 :       //   3. Check if the view task is the main task, if so use
; 2780 :       //      zLEVEL_SYSTEM.
; 2781 :       //   4. Use the task level...
; 2782 :       lpViewCsr = zGETPTR( lpSrcView->hViewCsr );

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
$L8400:

; 2783 :       while ( lpViewCsr->hNextViewCsr )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+2], 0
	je	SHORT $L8401

; 2784 :          lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
	jmp	SHORT $L8400
$L8401:

; 2785 : 
; 2786 :       lpSrcView = zGETPTR( lpViewCsr->hView );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcView$[ebp], eax

; 2787 :       if ( lpSrcView->bApplicationView )

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 3
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8404

; 2788 :          lControl |= zLEVEL_APPLICATION;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 4
	mov	DWORD PTR _lControl$[ebp], edx

; 2789 :       else

	jmp	SHORT $L8406
$L8404:

; 2790 :       if ( lpSrcView->hTask == AnchorBlock->hMainTask )

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [eax+14]
	cmp	edx, DWORD PTR [ecx+106]
	jne	SHORT $L8406

; 2791 :          lControl |= zLEVEL_SYSTEM;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	al, 8
	mov	DWORD PTR _lControl$[ebp], eax
$L8406:

; 2793 : 
; 2794 :    if ( (nRC = fnDeclareView( &lpTgtView, lpOwningTask,
; 2795 :                               lpSrcView, 0, 0 )) != 0 )

	push	0
	push	0
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L8407

; 2797 :       fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	55					; 00000037H
	call	_fnOperationReturn
	add	esp, 8

; 2798 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L8378
$L8407:

; 2800 : 
; 2801 : #if 0
; 2802 :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 2803 :    {
; 2804 :       zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 2805 :                                   zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 2806 :       if ( (nRC = SfTransferView( lpTgtView, lpSrcView,
; 2807 :                                   nScope )) != 0 )
; 2808 :       {
; 2809 :          fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );
; 2810 :          return( nRC );
; 2811 :       }
; 2812 :    }
; 2813 : #endif
; 2814 : 
; 2815 :    // Create an empty object instance in which to copy the object instance.
; 2816 :    nRC = fnActivateEmptyObjectInstance( lpCurrentTask, lpTgtView, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 2817 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L8473

; 2819 :       LPTASK           lpInstanceOwningTask;
; 2820 :       LPVIEWENTITY     lpViewEntity;
; 2821 :       LPENTITYINSTANCE lpSrcEntityInstance;
; 2822 :       LPENTITYINSTANCE lpTgtEntityInstance;
; 2823 :       LPENTITYINSTANCE lpLastTgtEntityInstance;
; 2824 :       LPENTITYINSTANCE lpTgtParent;
; 2825 :       LPENTITYINSTANCE lpWkInstance1;
; 2826 :       LPENTITYINSTANCE lpWkInstance2;
; 2827 :       LPVIEWOI         hTgtViewOI;
; 2828 :       zPVOID           hTgtEntityInstance;
; 2829 :       zSHORT           nLastLvl;
; 2830 : 
; 2831 :       // Here we copy the instance in memory.
; 2832 :       lpViewCsr   = zGETPTR( lpTgtView->hViewCsr );

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2833 :       hTgtViewOI  = lpViewCsr->hViewOI;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hTgtViewOI$8417[ebp], ecx

; 2834 :       lpTgtViewOI = zGETPTR( hTgtViewOI );

	mov	edx, DWORD PTR _hTgtViewOI$8417[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOI$[ebp], eax

; 2835 :       lpInstanceOwningTask = zGETPTR( lpTgtViewOI->hAllocTask );

	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInstanceOwningTask$8409[ebp], eax

; 2836 :       lpTgtEntityInstance = 0;

	mov	DWORD PTR _lpTgtEntityInstance$8412[ebp], 0

; 2837 :       lpLastTgtEntityInstance = 0;

	mov	DWORD PTR _lpLastTgtEntityInstance$8413[ebp], 0

; 2838 :       lpTgtParent = 0;

	mov	DWORD PTR _lpTgtParent$8414[ebp], 0

; 2839 : 
; 2840 :       // Set the first source entity instance.  If zSINGLE was set, then the
; 2841 :       // first entity instance should be the selected root for the view.
; 2842 :       lpSrcEntityInstance = 0;

	mov	DWORD PTR _lpSrcEntityInstance$8411[ebp], 0

; 2843 : 
; 2844 :       if ( bMultiple == FALSE )

	mov	edx, DWORD PTR _bMultiple$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L8423

; 2846 :          LPVIEWENTITYCSR lpRootViewEntityCsr;
; 2847 : 
; 2848 :          lpViewCsr= zGETPTR( lpSrcView->hViewCsr );

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2849 :          lpRootViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootViewEntityCsr$8424[ebp], eax

; 2850 :          lpSrcEntityInstance = zGETPTR( lpRootViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpRootViewEntityCsr$8424[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$8411[ebp], eax
$L8423:

; 2852 : 
; 2853 :       if ( lpSrcEntityInstance == 0 || lpSrcEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpSrcEntityInstance$8411[ebp], 0
	je	SHORT $L8430
	cmp	DWORD PTR _lpSrcEntityInstance$8411[ebp], 1
	jne	SHORT $L8429
$L8430:

; 2854 :          lpSrcEntityInstance = zGETPTR( lpSrcViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$8411[ebp], eax
$L8429:

; 2855 : 
; 2856 :       // For each instance in the source, copy the instance and
; 2857 :       // link the new instance to the source instance. This link will
; 2858 :       // be removed later on after the initial copy is complete.
; 2859 :       while ( lpSrcEntityInstance )

	cmp	DWORD PTR _lpSrcEntityInstance$8411[ebp], 0
	je	$L8434

; 2861 :          nLastLvl = lpSrcEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nLastLvl$8419[ebp], ax

; 2862 :          lpViewEntity = zGETPTR( lpSrcEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$8410[ebp], eax

; 2863 : 
; 2864 :          hTgtEntityInstance =
; 2865 :                      fnAllocDataspace( lpInstanceOwningTask->hFirstDataHeader,
; 2866 :                                        sizeof( EntityInstanceRecord ), 0, 0,
; 2867 :                                        iEntityInstance );

	push	10024					; 00002728H
	push	0
	push	0
	push	68					; 00000044H
	mov	eax, DWORD PTR _lpInstanceOwningTask$8409[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTgtEntityInstance$8418[ebp], eax

; 2868 :          lpTgtEntityInstance = zGETPTR( hTgtEntityInstance );

	mov	edx, DWORD PTR _hTgtEntityInstance$8418[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$8412[ebp], eax

; 2869 :          if ( lpTgtEntityInstance )

	cmp	DWORD PTR _lpTgtEntityInstance$8412[ebp], 0
	je	$L8438

; 2871 :             zmemcpy( (zPVOID) lpTgtEntityInstance,
; 2872 :                      (zPVOID) lpSrcEntityInstance,
; 2873 :                      sizeof( EntityInstanceRecord ) );

	push	68					; 00000044H
	mov	eax, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2874 :             lpTgtEntityInstance->hViewOI   = hTgtViewOI;

	mov	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	eax, DWORD PTR _hTgtViewOI$8417[ebp]
	mov	DWORD PTR [edx+10], eax

; 2875 :             lpTgtEntityInstance->hPrevHier = zGETHNDL( lpLastTgtEntityInstance );

	mov	ecx, DWORD PTR _lpLastTgtEntityInstance$8413[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [edx+18], eax

; 2876 :             lpTgtEntityInstance->hNextHier = 0;

	mov	eax, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [eax+14], 0

; 2877 :             lpTgtEntityInstance->hNextTwin = 0;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [ecx+22], 0

; 2878 :             fnSetEntityKey( lpInstanceOwningTask, 0, lpTgtEntityInstance );

	mov	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpInstanceOwningTask$8409[ebp]
	push	eax
	call	_fnSetEntityKey@12

; 2879 :             if ( lpLastTgtEntityInstance )

	cmp	DWORD PTR _lpLastTgtEntityInstance$8413[ebp], 0
	je	$L8443

; 2881 :                lpLastTgtEntityInstance->hNextHier = hTgtEntityInstance;

	mov	ecx, DWORD PTR _lpLastTgtEntityInstance$8413[ebp]
	mov	edx, DWORD PTR _hTgtEntityInstance$8418[ebp]
	mov	DWORD PTR [ecx+14], edx

; 2882 :                if ( lpSrcEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $L8444

; 2884 :                   LPENTITYINSTANCE hWkInstance1;
; 2885 : 
; 2886 :                   hWkInstance1  = lpSrcEntityInstance->hPrevHier;

	mov	ecx, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	mov	edx, DWORD PTR [ecx+18]
	mov	DWORD PTR _hWkInstance1$8445[ebp], edx

; 2887 :                   lpWkInstance1 = zGETPTR( hWkInstance1 );

	mov	eax, DWORD PTR _hWkInstance1$8445[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8415[ebp], eax

; 2888 :                   lpWkInstance2 = zGETPTR( lpTgtEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance2$8416[ebp], eax
$L8449:

; 2889 :                   while ( hWkInstance1 != lpSrcEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	mov	ecx, DWORD PTR _hWkInstance1$8445[ebp]
	cmp	ecx, DWORD PTR [eax+26]
	je	SHORT $L8450

; 2891 :                      hWkInstance1  = lpWkInstance1->hPrevHier;

	mov	edx, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR _hWkInstance1$8445[ebp], eax

; 2892 :                      lpWkInstance1 = zGETPTR( hWkInstance1 );

	mov	ecx, DWORD PTR _hWkInstance1$8445[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8415[ebp], eax

; 2893 :                      lpWkInstance2 = zGETPTR( lpWkInstance2->hPrevHier );

	mov	edx, DWORD PTR _lpWkInstance2$8416[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance2$8416[ebp], eax

; 2894 :                   }

	jmp	SHORT $L8449
$L8450:

; 2895 : 
; 2896 :                   lpTgtEntityInstance->hPrevTwin = zGETHNDL( lpWkInstance2 );

	mov	ecx, DWORD PTR _lpWkInstance2$8416[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [edx+26], eax

; 2897 :                   lpWkInstance2->hNextTwin = hTgtEntityInstance;

	mov	eax, DWORD PTR _lpWkInstance2$8416[ebp]
	mov	ecx, DWORD PTR _hTgtEntityInstance$8418[ebp]
	mov	DWORD PTR [eax+22], ecx
$L8444:

; 2900 :             else

	jmp	SHORT $L8454
$L8443:

; 2902 :                lpTgtViewOI->hRootEntityInstance = hTgtEntityInstance;

	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	eax, DWORD PTR _hTgtEntityInstance$8418[ebp]
	mov	DWORD PTR [edx+26], eax

; 2903 :                lpTgtEntityInstance->hPrevTwin = 0;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [ecx+26], 0
$L8454:

; 2905 : 
; 2906 :             lpTgtEntityInstance->hParent = zGETHNDL( lpTgtParent );

	mov	edx, DWORD PTR _lpTgtParent$8414[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [ecx+30], eax

; 2907 :          // if ( lpTgtEntityInstance->hParent == UNSET_CSR )
; 2908 :          //    SysMessageBox( 0, "ActivateOI_FromOI", "UNSET_CSR", -1 );
; 2909 : 
; 2910 :             if ( lpSrcEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $L8456

; 2911 :                lpSrcEntityInstance->hNextLinked = hTgtEntityInstance;

	mov	eax, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	mov	ecx, DWORD PTR _hTgtEntityInstance$8418[ebp]
	mov	DWORD PTR [eax+42], ecx
$L8456:

; 2912 : 
; 2913 :             fnAddEntityToDebugChange( lpTgtEntityInstance );

	mov	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	push	edx
	call	_fnAddEntityToDebugChange@4

; 2915 :          else

	jmp	SHORT $L8458
$L8438:

; 2916 :          if ( lpLastTgtEntityInstance )

	cmp	DWORD PTR _lpLastTgtEntityInstance$8413[ebp], 0
	je	SHORT $L8458

; 2918 :             lpLastTgtEntityInstance->hNextHier = 0;

	mov	eax, DWORD PTR _lpLastTgtEntityInstance$8413[ebp]
	mov	DWORD PTR [eax+14], 0

; 2919 :             lpLastTgtEntityInstance->hNextTwin = 0;

	mov	ecx, DWORD PTR _lpLastTgtEntityInstance$8413[ebp]
	mov	DWORD PTR [ecx+22], 0

; 2920 :             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 2921 :             break;

	jmp	$L8434
$L8458:

; 2923 : 
; 2924 :          // Get the next entity instance in memory to copy.
; 2925 :          lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$8411[ebp], eax

; 2926 :          if ( lpSrcEntityInstance )

	cmp	DWORD PTR _lpSrcEntityInstance$8411[ebp], 0
	je	SHORT $L8460

; 2928 :             if ( lpSrcEntityInstance->nLevel == 1 && bMultiple == FALSE )

	mov	ecx, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	edx, 1
	jne	SHORT $L8461
	mov	eax, DWORD PTR _bMultiple$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L8461

; 2930 :                nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1

; 2931 :                lpSrcEntityInstance = 0;

	mov	DWORD PTR _lpSrcEntityInstance$8411[ebp], 0

; 2933 :             else

	jmp	SHORT $L8467
$L8461:

; 2934 :             if ( lpSrcEntityInstance->nLevel > nLastLvl )

	mov	ecx, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nLastLvl$8419[ebp]
	cmp	edx, eax
	jle	SHORT $L8463

; 2935 :                lpTgtParent = lpTgtEntityInstance;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	DWORD PTR _lpTgtParent$8414[ebp], ecx

; 2936 :             else

	jmp	SHORT $L8467
$L8463:

; 2938 :                while ( lpTgtParent &&
; 2939 :                        lpTgtParent->nLevel >= lpSrcEntityInstance->nLevel )

	cmp	DWORD PTR _lpTgtParent$8414[ebp], 0
	je	SHORT $L8467
	mov	edx, DWORD PTR _lpTgtParent$8414[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	eax, edx
	jl	SHORT $L8467

; 2941 :                   lpTgtParent = zGETPTR( lpTgtParent->hParent );

	mov	eax, DWORD PTR _lpTgtParent$8414[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtParent$8414[ebp], eax

; 2942 :                }

	jmp	SHORT $L8463
$L8467:

; 2945 :          else

	jmp	SHORT $L8469
$L8460:

; 2946 :             nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$L8469:

; 2947 : 
; 2948 :          lpLastTgtEntityInstance = lpTgtEntityInstance;

	mov	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	DWORD PTR _lpLastTgtEntityInstance$8413[ebp], edx

; 2949 :       }

	jmp	$L8429
$L8434:

; 2950 : 
; 2951 :       // We've copied the entity instance chain and linked all the
; 2952 :       // new instance information with the source being copied, now
; 2953 :       // isolate the copied instance by de-linking it from all
; 2954 :       // instances in other ViewOI's and copying the data-record
; 2955 :       // for each instance.
; 2956 :       hTgtEntityInstance  = lpTgtViewOI->hRootEntityInstance;

	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR _hTgtEntityInstance$8418[ebp], ecx

; 2957 :       lpTgtEntityInstance = zGETPTR( hTgtEntityInstance );

	mov	edx, DWORD PTR _hTgtEntityInstance$8418[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$8412[ebp], eax
$L8472:

; 2958 :       while ( lpTgtEntityInstance )

	cmp	DWORD PTR _lpTgtEntityInstance$8412[ebp], 0
	je	$L8473

; 2960 :          // First, see if the attribute record information needs
; 2961 :          // to be copied, if so, copy it now.
; 2962 :          lpWkInstance1 = zGETPTR( lpTgtEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8415[ebp], eax
$L8476:

; 2963 :          while ( lpWkInstance1 && lpWkInstance1 != lpTgtEntityInstance )

	cmp	DWORD PTR _lpWkInstance1$8415[ebp], 0
	je	SHORT $L8477
	mov	edx, DWORD PTR _lpWkInstance1$8415[ebp]
	cmp	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	je	SHORT $L8477

; 2965 :             if ( lpWkInstance1->hViewOI != hTgtViewOI )

	mov	eax, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	ecx, DWORD PTR [eax+10]
	cmp	ecx, DWORD PTR _hTgtViewOI$8417[ebp]
	je	SHORT $L8478

; 2966 :                break;

	jmp	SHORT $L8477
$L8478:

; 2967 : 
; 2968 :             lpWkInstance1 = zGETPTR( lpWkInstance1->hNextLinked );

	mov	edx, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8415[ebp], eax

; 2969 :          }

	jmp	SHORT $L8476
$L8477:

; 2970 : 
; 2971 :          // Copy the non-persistent record regardless
; 2972 :          lpTgtEntityInstance->hNonPersistRecord =
; 2973 :              fnCopyAttributeRecord( lpInstanceOwningTask,
; 2974 :                 zGETPTR( lpTgtEntityInstance->hViewEntity ),
; 2975 :                 (zPCHAR) zGETPTR( lpTgtEntityInstance->hNonPersistRecord ), 0 );

	push	0
	mov	ecx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpInstanceOwningTask$8409[ebp]
	push	edx
	call	_fnCopyAttributeRecord
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [ecx+64], eax

; 2976 : 
; 2977 :          // Copy the persistent record unless the instance is linked
; 2978 :          // only to instances in the same ViewOI (which means that
; 2979 :          // the persistent record has already been copied).
; 2980 :          if ( lpWkInstance1 != lpTgtEntityInstance )

	mov	edx, DWORD PTR _lpWkInstance1$8415[ebp]
	cmp	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	je	$L8495

; 2982 :             lpTgtEntityInstance->hPersistRecord =
; 2983 :                      fnCopyAttributeRecord( lpInstanceOwningTask,
; 2984 :                          zGETPTR( lpTgtEntityInstance->hViewEntity ),
; 2985 :                          (zPCHAR) zGETPTR( lpTgtEntityInstance->hPersistRecord ), 1 );

	push	1
	mov	eax, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpInstanceOwningTask$8409[ebp]
	push	ecx
	call	_fnCopyAttributeRecord
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [edx+60], eax

; 2986 : 
; 2987 :             if ( lpWkInstance1 )

	cmp	DWORD PTR _lpWkInstance1$8415[ebp], 0
	je	$L8495

; 2989 :                // The instance is linked to another instance in a different
; 2990 :                // ViewOI, create two chains out of the single chain to isolate
; 2991 :                // this object instance from the other one being copied.
; 2992 :                lpSrcEntityInstance = lpWkInstance1;

	mov	eax, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	DWORD PTR _lpSrcEntityInstance$8411[ebp], eax

; 2993 :                lpWkInstance1 = zGETPTR( lpTgtEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8415[ebp], eax
$L8490:

; 2994 :                while ( lpWkInstance1->hNextLinked != hTgtEntityInstance )

	mov	eax, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	ecx, DWORD PTR [eax+42]
	cmp	ecx, DWORD PTR _hTgtEntityInstance$8418[ebp]
	je	SHORT $L8491

; 2995 :                   lpWkInstance1 = zGETPTR( lpWkInstance1->hNextLinked );

	mov	edx, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8415[ebp], eax
	jmp	SHORT $L8490
$L8491:

; 2996 : 
; 2997 :                lpWkInstance1->hNextLinked = lpTgtEntityInstance->hNextLinked;

	mov	ecx, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax

; 2998 :                lpTgtEntityInstance->hNextLinked = 0;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [ecx+42], 0
$L8494:

; 3001 :                   lpWkInstance1 = zGETPTR( lpSrcEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8415[ebp], eax
$L8498:

; 3002 :                   while ( lpWkInstance1 != lpSrcEntityInstance &&
; 3003 :                           lpWkInstance1->hViewOI != lpTgtEntityInstance->hViewOI )

	mov	ecx, DWORD PTR _lpWkInstance1$8415[ebp]
	cmp	ecx, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	je	SHORT $L8499
	mov	edx, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	eax, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+10]
	je	SHORT $L8499

; 3005 :                      lpWkInstance1 = zGETPTR( lpWkInstance1->hNextLinked );

	mov	edx, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$8415[ebp], eax

; 3006 :                   }

	jmp	SHORT $L8498
$L8499:

; 3007 : 
; 3008 :                   if ( lpWkInstance1 == lpSrcEntityInstance )

	mov	ecx, DWORD PTR _lpWkInstance1$8415[ebp]
	cmp	ecx, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	jne	SHORT $L8501

; 3009 :                      break;

	jmp	SHORT $L8495
$L8501:

; 3010 : 
; 3011 :                   // We've found another instance in the source chain which
; 3012 :                   // needs to be moved to the target chain, add the instance
; 3013 :                   // to the target chain and update its record pointer to
; 3014 :                   // be the same as the target instance.
; 3015 :                   lpWkInstance2 = lpSrcEntityInstance;

	mov	edx, DWORD PTR _lpSrcEntityInstance$8411[ebp]
	mov	DWORD PTR _lpWkInstance2$8416[ebp], edx
$L8504:

; 3016 :                   while ( lpWkInstance2->hNextLinked != zGETHNDL( lpWkInstance1 ) )

	mov	eax, DWORD PTR _lpWkInstance1$8415[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpWkInstance2$8416[ebp]
	cmp	DWORD PTR [ecx+42], eax
	je	SHORT $L8505

; 3017 :                      lpWkInstance2 = zGETPTR( lpWkInstance2->hNextLinked );

	mov	edx, DWORD PTR _lpWkInstance2$8416[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance2$8416[ebp], eax
	jmp	SHORT $L8504
$L8505:

; 3018 : 
; 3019 :                   lpWkInstance2->hNextLinked = lpWkInstance1->hNextLinked;

	mov	ecx, DWORD PTR _lpWkInstance2$8416[ebp]
	mov	edx, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax

; 3020 :                   lpWkInstance1->hPersistRecord = lpTgtEntityInstance->hPersistRecord;

	mov	ecx, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax

; 3021 :                   if ( lpTgtEntityInstance->hNextLinked == 0 )

	mov	ecx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $L8507

; 3022 :                      lpWkInstance1->hNextLinked = hTgtEntityInstance;

	mov	edx, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	eax, DWORD PTR _hTgtEntityInstance$8418[ebp]
	mov	DWORD PTR [edx+42], eax

; 3023 :                   else

	jmp	SHORT $L8508
$L8507:

; 3024 :                      lpWkInstance1->hNextLinked = lpTgtEntityInstance->hNextLinked;

	mov	ecx, DWORD PTR _lpWkInstance1$8415[ebp]
	mov	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax
$L8508:

; 3025 : 
; 3026 :                   lpTgtEntityInstance->hNextLinked = zGETHNDL( lpWkInstance1 );

	mov	ecx, DWORD PTR _lpWkInstance1$8415[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	DWORD PTR [edx+42], eax

; 3027 :                }

	jmp	$L8494
$L8495:

; 3030 : 
; 3031 :          hTgtEntityInstance  = lpTgtEntityInstance->hNextHier;

	mov	eax, DWORD PTR _lpTgtEntityInstance$8412[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hTgtEntityInstance$8418[ebp], ecx

; 3032 :          lpTgtEntityInstance = zGETPTR( hTgtEntityInstance );

	mov	edx, DWORD PTR _hTgtEntityInstance$8418[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$8412[ebp], eax

; 3033 :       }

	jmp	$L8472
$L8473:

; 3035 : 
; 3036 :    if ( nRC >= 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $L8511

; 3037 :       fnResetView( lpTgtView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_fnResetView
	add	esp, 8
$L8511:

; 3038 : 
; 3039 :    // Based on the return code, see if we have to reset the view to the
; 3040 :    // prior instance or clean up the prior instance.
; 3041 :    // Note: rc = indicates multiple level1 roots are present.
; 3042 :    if ( nRC >= -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jl	SHORT $L8512

; 3044 :       if ( lControl & zREADONLY )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $L8513

; 3045 :          lpTgtView->bReadOnly = TRUE;

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	DWORD PTR [eax+30], edx
$L8513:

; 3046 : 
; 3047 :       lpTgtViewOI->bUpdated     = lpSrcViewOI->bUpdated;

	mov	ecx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shr	edx, 4
	and	edx, 1
	and	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -17				; ffffffefH
	or	ecx, edx
	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 3048 :       lpTgtViewOI->bUpdatedFile = lpSrcViewOI->bUpdatedFile;

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 5
	and	ecx, 1
	and	ecx, 1
	shl	ecx, 5
	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	al, -33					; ffffffdfH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 3049 : 
; 3050 :       *pvReturnView = lpTgtView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	DWORD PTR [edx], eax

; 3053 :    else

	jmp	SHORT $L8514
$L8512:

; 3055 :       fnDropView( lpTgtView );

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_fnDropView@4

; 3056 :       *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0
$L8514:

; 3058 : 
; 3059 :    fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	55					; 00000037H
	call	_fnOperationReturn
	add	esp, 8

; 3060 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L8378:

; 3061 : 
; 3062 : } // ActivateOI_FromOI_ForTask

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_ActivateOI_FromOI_ForTask@16 ENDP
_TEXT	ENDS
PUBLIC	_fnReadDataFromBuffer@20
PUBLIC	??_C@_0BE@CKOO@Out?5of?5buffer?5space?$AA@	; `string'
PUBLIC	??_C@_0BE@LIH@Internal?5Core?5Error?$AA@	; `string'
EXTRN	_SysMessageBox@16:NEAR
;	COMDAT ??_C@_0BE@CKOO@Out?5of?5buffer?5space?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BE@CKOO@Out?5of?5buffer?5space?$AA@ DB 'Out of buffer space', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@LIH@Internal?5Core?5Error?$AA@
_DATA	SEGMENT
??_C@_0BE@LIH@Internal?5Core?5Error?$AA@ DB 'Internal Core Error', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_pvData$ = 12
_ppchReturnBuffer$ = 16
_uLth$ = 20
_nErrorNbr$ = 24
_lpBufferData$ = -4
_lpTask$8530 = -12
_pchExtraData$8532 = -8
_fnReadDataFromBuffer@20 PROC NEAR

; 3074 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3075 :    LPBUFFERDATA lpBufferData = (LPBUFFERDATA) pvData;

	mov	eax, DWORD PTR _pvData$[ebp]
	mov	DWORD PTR _lpBufferData$[ebp], eax

; 3076 : 
; 3077 :    // If nErrorNbr is not 0, then flash the error message and get out.
; 3078 :    if ( nErrorNbr )

	movsx	ecx, WORD PTR _nErrorNbr$[ebp]
	test	ecx, ecx
	je	$L8529

; 3080 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$8530[ebp], eax

; 3081 :       zPCHAR pchExtraData = (zPCHAR) ppchReturnBuffer;

	mov	ecx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	DWORD PTR _pchExtraData$8532[ebp], ecx

; 3082 : 
; 3083 :       switch ( nErrorNbr )
; 3084 :       {

	movsx	edx, WORD PTR _nErrorNbr$[ebp]
	mov	DWORD PTR -16+[ebp], edx
	mov	eax, DWORD PTR -16+[ebp]
	sub	eax, 74					; 0000004aH
	mov	DWORD PTR -16+[ebp], eax
	cmp	DWORD PTR -16+[ebp], 30			; 0000001eH
	ja	$L8535
	mov	edx, DWORD PTR -16+[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR $L12777[edx]
	jmp	DWORD PTR $L12778[ecx*4]
$L8538:

; 3085 :          case 74:
; 3086 :             // "KZOEE074 - Invalid Entity name on line "
; 3087 :             fnIssueCoreError( lpTask, lpView, 16, 74, 0,
; 3088 :                               pchExtraData, 0 );

	push	0
	mov	eax, DWORD PTR _pchExtraData$8532[ebp]
	push	eax
	push	0
	push	74					; 0000004aH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$8530[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3089 :             break;

	jmp	SHORT $L8535
$L8539:

; 3090 : 
; 3091 :          case 75:
; 3092 :             // "KZOEE075 - Invalid Entity level on line "
; 3093 :             fnIssueCoreError( lpTask, lpView, 16, 75, 0,
; 3094 :                               pchExtraData, 0 );

	push	0
	mov	eax, DWORD PTR _pchExtraData$8532[ebp]
	push	eax
	push	0
	push	75					; 0000004bH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$8530[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3095 :             break;

	jmp	SHORT $L8535
$L8540:

; 3096 : 
; 3097 :          case 90:
; 3098 :             // "KZOEE090 - Maximum number of entites in portable file exceeded"
; 3099 :             fnIssueCoreError( lpTask, lpView, 16, 90, 0, 0, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	0
	push	0
	push	90					; 0000005aH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$8530[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3100 :             break;

	jmp	SHORT $L8535
$L8541:

; 3101 : 
; 3102 :          case 104:
; 3103 :             // "KZOEE104 - Invalid Attribute name for Entity"
; 3104 :             fnIssueCoreError( lpTask, lpView, 16, 104, 0, pchExtraData, 0 );

	push	0
	mov	edx, DWORD PTR _pchExtraData$8532[ebp]
	push	edx
	push	0
	push	104					; 00000068H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$8530[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$L8535:

; 3108 : 
; 3109 :       return( 0 );

	xor	ax, ax
	jmp	$L8547
$L8529:

; 3112 : 
; 3113 :    if ( lpBufferData->pchCurrentByte >= lpBufferData->pchEnd )

	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jb	SHORT $L8542

; 3115 :       *ppchReturnBuffer = 0;

	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	DWORD PTR [edx], 0

; 3116 :       return( 0 ); // EOF

	xor	ax, ax
	jmp	$L8547
$L8542:

; 3118 : 
; 3119 :    if ( uLth )

	cmp	DWORD PTR _uLth$[ebp], 0
	je	SHORT $L8543

; 3121 :       if ( lpBufferData->pchCurrentByte + uLth >= lpBufferData->pchEnd )

	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _uLth$[ebp]
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	jb	SHORT $L8544

; 3123 :          SysMessageBox( lpView, "Internal Core Error", "Out of buffer space", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0BE@CKOO@Out?5of?5buffer?5space?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BE@LIH@Internal?5Core?5Error?$AA@ ; `string'
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 3124 :          return( 0 );

	xor	ax, ax
	jmp	$L8547
$L8544:

; 3126 : 
; 3127 :       *ppchReturnBuffer = lpBufferData->pchCurrentByte;

	mov	ecx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax

; 3128 :       lpBufferData->pchCurrentByte += uLth;

	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _uLth$[ebp]
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3129 : 
; 3130 :       return( 1 );

	mov	ax, 1
	jmp	$L8547
$L8543:

; 3134 :       *ppchReturnBuffer = lpBufferData->pchCurrentByte;

	mov	ecx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
$L8549:

; 3135 : 
; 3136 :       // Look for the end of the line or the end of the buffer.  Note that
; 3137 :       // pchEnd points to the "EOF" char and is not part of the data.
; 3138 :       while ( lpBufferData->pchCurrentByte[ 0 ] != '\n' &&
; 3139 :               lpBufferData->pchCurrentByte[ 0 ] != '\r' &&
; 3140 :               lpBufferData->pchCurrentByte < lpBufferData->pchEnd )

	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $L8550
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $L8550
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $L8550

; 3142 :          lpBufferData->pchCurrentByte++;

	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3143 :       }

	jmp	SHORT $L8549
$L8550:

; 3144 : 
; 3145 :       if ( (lpBufferData->pchCurrentByte[ 0 ] == '\r' &&
; 3146 :             lpBufferData->pchCurrentByte[ 1 ] == '\n' ) ||
; 3147 :            (lpBufferData->pchCurrentByte[ 0 ] == '\n' &&
; 3148 :             lpBufferData->pchCurrentByte[ 1 ] == '\r') )

	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $L8553
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 10					; 0000000aH
	je	SHORT $L8552
$L8553:
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $L8551
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $L8551
$L8552:

; 3150 :          *(lpBufferData->pchCurrentByte++) = 0;  // Null end of line and skip \r or \n

	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	DWORD PTR [edx+4], ecx
$L8551:

; 3152 : 
; 3153 :       *(lpBufferData->pchCurrentByte++) = 0;  // Null end of line and skip \r or \n

	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 3154 : 
; 3155 :       return( 1 );

	mov	ax, 1
$L8547:

; 3157 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L12778:
	DD	$L8538
	DD	$L8539
	DD	$L8540
	DD	$L8541
	DD	$L8535
$L12777:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_fnReadDataFromBuffer@20 ENDP
_TEXT	ENDS
PUBLIC	_fnActivateOI_FromBuffer@24
EXTRN	__imp__free:NEAR
EXTRN	__imp__malloc:NEAR
_TEXT	SEGMENT
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_pchBuffer$ = 20
_uLth$ = 24
_lControl$ = 28
_ActBuffData$ = -20
_pchData$ = -4
_nRC$ = -8
_fnActivateOI_FromBuffer@24 PROC NEAR

; 3172 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3173 :    BufferDataRecord ActBuffData;
; 3174 :    zPCHAR pchData;
; 3175 :    zSHORT nRC;
; 3176 : 
; 3177 :    // SfActivate needs to be able to change the data in the buffer.  Because of
; 3178 :    // this we will copy the buffer into a temporary buffer.  SfActivate also
; 3179 :    // expects an extra character at the end of the buffer to indicate the EOF.
; 3180 :    // So we need to allocate an extra byte.
; 3181 :    pchData = malloc( uLth + 1 );

	mov	eax, DWORD PTR _uLth$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _pchData$[ebp], eax

; 3182 :    zmemcpy( pchData, pchBuffer, uLth );

	mov	ecx, DWORD PTR _uLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchData$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3183 :    pchData[ uLth ] = 0;  // set the last byte to NULL

	mov	ecx, DWORD PTR _pchData$[ebp]
	add	ecx, DWORD PTR _uLth$[ebp]
	mov	BYTE PTR [ecx], 0

; 3184 : 
; 3185 :    // Set up data to be passed through to fnReadDataFromBuffer( ).
; 3186 :    ActBuffData.pchBuffer      = pchData;

	mov	edx, DWORD PTR _pchData$[ebp]
	mov	DWORD PTR _ActBuffData$[ebp], edx

; 3187 :    ActBuffData.pchCurrentByte = pchData;

	mov	eax, DWORD PTR _pchData$[ebp]
	mov	DWORD PTR _ActBuffData$[ebp+4], eax

; 3188 :    ActBuffData.pchEnd         = pchData + uLth;

	mov	ecx, DWORD PTR _pchData$[ebp]
	add	ecx, DWORD PTR _uLth$[ebp]
	mov	DWORD PTR _ActBuffData$[ebp+8], ecx

; 3189 : 
; 3190 :    nRC = SfActivateOI_FromStream( pvReturnView, cpcViewOD_Name,
; 3191 :                                   lpAppQualView, lControl,
; 3192 :                                   fnReadDataFromBuffer,
; 3193 :                                   (zPVOID) &ActBuffData );

	lea	edx, DWORD PTR _ActBuffData$[ebp]
	push	edx
	push	OFFSET FLAT:_fnReadDataFromBuffer@20
	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	push	eax
	call	_SfActivateOI_FromStream@24
	mov	WORD PTR _nRC$[ebp], ax

; 3194 :    free( pchData );

	mov	ecx, DWORD PTR _pchData$[ebp]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4

; 3195 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 3196 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnActivateOI_FromBuffer@24 ENDP
_TEXT	ENDS
PUBLIC	_fnGetDBHandlerOper@12
PUBLIC	??_C@_02CJCI@KZ?$AA@				; `string'
PUBLIC	??_C@_0M@KGHM@DBH_MsgProc?$AA@			; `string'
PUBLIC	??_C@_0N@GMLG@_DBH_MsgProc?$AA@			; `string'
EXTRN	_SysGetProc@8:NEAR
EXTRN	_SysGetProcessID@4:NEAR
EXTRN	_SysLoadLibrary@8:NEAR
EXTRN	__imp___strnicmp:NEAR
;	COMDAT ??_C@_02CJCI@KZ?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_02CJCI@KZ?$AA@ DB 'KZ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@KGHM@DBH_MsgProc?$AA@
_DATA	SEGMENT
??_C@_0M@KGHM@DBH_MsgProc?$AA@ DB 'DBH_MsgProc', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@GMLG@_DBH_MsgProc?$AA@
_DATA	SEGMENT
??_C@_0N@GMLG@_DBH_MsgProc?$AA@ DB '_DBH_MsgProc', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_lpView$ = 12
_pOperReturn$ = 16
_hDBHandler$ = -24
_lpDBHandler$ = -36
_lpTaskDBHandler$ = -32
_lpViewOD$ = -12
_hLibrary$ = -8
_lpPtr$ = -20
_pOper$ = -28
_nRC$ = -16
_lProcessID$ = -4
_hTaskDBHandler$8600 = -72
_szFuncName$8601 = -68
_szLibName$8604 = -172
_fnGetDBHandlerOper@12 PROC NEAR

; 3319 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH

; 3320 :    LPDBHANDLER      hDBHandler;
; 3321 :    LPDBHANDLER      lpDBHandler;
; 3322 :    LPTASKDBHANDLER  lpTaskDBHandler;
; 3323 :    LPVIEWOD         lpViewOD;
; 3324 :    LPLIBRARY        hLibrary;
; 3325 :    zPVOID           lpPtr;
; 3326 :    zPDBHOPER        pOper;
; 3327 :    zSHORT           nRC;
; 3328 :    zLONG            lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 3329 : 
; 3330 :    *pOperReturn = 0;  // initialize

	mov	eax, DWORD PTR _pOperReturn$[ebp]
	mov	DWORD PTR [eax], 0

; 3331 : 
; 3332 :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 3333 :    hDBHandler = lpViewOD->hDBHandler;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	mov	DWORD PTR _hDBHandler$[ebp], ecx

; 3334 :    lpDBHandler = zGETPTR( hDBHandler );

	mov	edx, DWORD PTR _hDBHandler$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDBHandler$[ebp], eax

; 3335 : // lpDBHandler = fnGetDBHandler( hTask, lpViewOD->szDBHandler );
; 3336 : 
; 3337 :    // Make sure DBHandler can be found.
; 3338 :    if ( lpDBHandler == 0 )

	cmp	DWORD PTR _lpDBHandler$[ebp], 0
	jne	SHORT $L8590

; 3340 :       // "KZOEE080 - Object Definition does not have a Database handler
; 3341 :       // specified"
; 3342 :       fnIssueCoreError( lpTask, lpView, 8, 80, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	80					; 00000050H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3343 :       return( 0 );

	xor	eax, eax
	jmp	$L8578
$L8590:

; 3345 : 
; 3346 :    // See if DBHandler has already been invoked for this task.
; 3347 :    for ( lpTaskDBHandler = zGETPTR( lpTask->hFirstTaskDBHandler );
; 3348 :          lpTaskDBHandler;
; 3349 :          lpTaskDBHandler = zGETPTR( lpTaskDBHandler->hNextTaskDBHandler ) )

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+134]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax
	jmp	SHORT $L8593
$L8594:
	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax
$L8593:
	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	je	SHORT $L8595

; 3351 :       if ( lpTaskDBHandler->hDBHandler != hDBHandler )

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	cmp	ecx, DWORD PTR _hDBHandler$[ebp]
	je	SHORT $L8596

; 3352 :          continue;

	jmp	SHORT $L8594
$L8596:

; 3353 : 
; 3354 :       if ( lpTaskDBHandler->lProcessID != lProcessID )

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+22]
	cmp	eax, DWORD PTR _lProcessID$[ebp]
	je	SHORT $L8597

; 3355 :          continue;

	jmp	SHORT $L8594
$L8597:
$L8595:

; 3360 : 
; 3361 :    // If TaskDBHandler wasn't found, then this is the first time the
; 3362 :    // DBHandler has been called for this task.
; 3363 :    if ( lpTaskDBHandler )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	je	SHORT $L8598

; 3365 :       // The task DBHandler was found--return pointer to DBHandler routine.
; 3366 :       pOper = lpTaskDBHandler->pfDBHandlerOper;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _pOper$[ebp], edx

; 3368 :    else

	jmp	$L8599
$L8598:

; 3370 :       zPVOID hTaskDBHandler;
; 3371 :       zCHAR  szFuncName[ 30 ];
; 3372 : 
; 3373 :       // Load the DBHandler library.  If it can't be found, return with error.
; 3374 :       if ( zstrncmpi( lpDBHandler->szName, "KZ", 2 ) == 0 )

	push	2
	push	OFFSET FLAT:??_C@_02CJCI@KZ?$AA@	; `string'
	mov	eax, DWORD PTR _lpDBHandler$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L8602

; 3376 :          // If handler name starts with KZ, then load handler from Zeidon
; 3377 :          // bin directory.
; 3378 :          zCHAR szLibName[ 100 ];
; 3379 : 
; 3380 :          zstrcpy( szLibName, AnchorBlock->szZeidonBin );

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 395				; 0000018bH
	push	ecx
	lea	edx, DWORD PTR _szLibName$8604[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3381 :          zstrcat( szLibName, lpDBHandler->szName );

	mov	eax, DWORD PTR _lpDBHandler$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	lea	ecx, DWORD PTR _szLibName$8604[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3382 :          hLibrary = SysLoadLibrary( lpView, szLibName );

	lea	edx, DWORD PTR _szLibName$8604[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 3384 :       else

	jmp	SHORT $L8605
$L8602:

; 3385 :          hLibrary = SysLoadLibrary( lpView, lpDBHandler->szName );

	mov	ecx, DWORD PTR _lpDBHandler$[ebp]
	add	ecx, 11					; 0000000bH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax
$L8605:

; 3386 : 
; 3387 :       if ( hLibrary == 0 )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	jne	SHORT $L8606

; 3388 :          return( 0 );

	xor	eax, eax
	jmp	$L8578
$L8606:

; 3389 : 
; 3390 :       // Define entry function name.  First try the default name.
; 3391 :       pOper = (zPDBHOPER) SysGetProc( hLibrary, "DBH_MsgProc" );

	push	OFFSET FLAT:??_C@_0M@KGHM@DBH_MsgProc?$AA@ ; `string'
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	DWORD PTR _pOper$[ebp], eax

; 3392 :       if ( pOper == 0 )

	cmp	DWORD PTR _pOper$[ebp], 0
	jne	SHORT $L8614

; 3394 :          // Couldn't find the default name.  Try the old-style name.
; 3395 :          zstrcpy( (zPCHAR) szFuncName, lpDBHandler->szName );

	mov	ecx, DWORD PTR _lpDBHandler$[ebp]
	add	ecx, 11					; 0000000bH
	push	ecx
	lea	edx, DWORD PTR _szFuncName$8601[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3396 :          zstrcat( (zPCHAR) szFuncName, "_DBH_MsgProc" );

	push	OFFSET FLAT:??_C@_0N@GMLG@_DBH_MsgProc?$AA@ ; `string'
	lea	eax, DWORD PTR _szFuncName$8601[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3397 : 
; 3398 :          // Find the address of entry func.  If it can't be found, return with
; 3399 :          // an error.
; 3400 :          pOper = (zPDBHOPER) SysGetProc( hLibrary, szFuncName );

	lea	ecx, DWORD PTR _szFuncName$8601[ebp]
	push	ecx
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	DWORD PTR _pOper$[ebp], eax

; 3401 :          if ( pOper == 0 )

	cmp	DWORD PTR _pOper$[ebp], 0
	jne	SHORT $L8614

; 3402 :             return( 0 );

	xor	eax, eax
	jmp	$L8578
$L8614:

; 3404 : 
; 3405 :       // Call DBHandler routine to issue start of transaction.  Bomb out if
; 3406 :       // it doesn't work.
; 3407 :       lpPtr = 0;

	mov	DWORD PTR _lpPtr$[ebp], 0

; 3408 :       nRC = (*pOper)( (zLONG) zGETHNDL( lpTask ), DBH_Init, 0,
; 3409 :                       lpViewOD, 0, lpView, 0, (zPVOID) &lpPtr );

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	4096					; 00001000H
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 3410 :       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L8618

; 3411 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $L8578
$L8618:

; 3412 : 
; 3413 :       // Create TaskDBHandler object and attach to Task.
; 3414 :       hTaskDBHandler = fnAllocDataspace( lpTask->hFirstDataHeader,
; 3415 :                                          sizeof( TaskDBHandlerRecord ), 1, 0,
; 3416 :                                          iTaskDBHandler );

	push	10009					; 00002719H
	push	0
	push	1
	push	30					; 0000001eH
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskDBHandler$8600[ebp], eax

; 3417 :       lpTaskDBHandler = zGETPTR( hTaskDBHandler );

	mov	ecx, DWORD PTR _hTaskDBHandler$8600[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax

; 3418 :       if ( lpTaskDBHandler == 0 )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	jne	SHORT $L8621

; 3419 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $L8578
$L8621:

; 3420 : 
; 3421 :       lpTaskDBHandler->hLibrary        = hLibrary;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR _hLibrary$[ebp]
	mov	DWORD PTR [edx+10], eax

; 3422 :       lpTaskDBHandler->pfDBHandlerOper = pOper;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR _pOper$[ebp]
	mov	DWORD PTR [ecx+14], edx

; 3423 :       lpTaskDBHandler->hDBHandler      = hDBHandler;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR _hDBHandler$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 3424 :       lpTaskDBHandler->lProcessID      = lProcessID;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [edx+22], eax

; 3425 : 
; 3426 :       // Insert lpTaskDBHandler into lpTask chain.
; 3427 :       lpTaskDBHandler->hNextTaskDBHandler = lpTask->hFirstTaskDBHandler;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+134]
	mov	DWORD PTR [ecx+2], eax

; 3428 :       lpTask->hFirstTaskDBHandler = hTaskDBHandler;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _hTaskDBHandler$8600[ebp]
	mov	DWORD PTR [ecx+134], edx
$L8599:

; 3430 : 
; 3431 :    *pOperReturn = pOper;

	mov	eax, DWORD PTR _pOperReturn$[ebp]
	mov	ecx, DWORD PTR _pOper$[ebp]
	mov	DWORD PTR [eax], ecx

; 3432 : 
; 3433 : // TraceLine( "fnGetDBHandlerOper in Process: %d   looking for DBHandler: 0x%08x for Task: %d (0x%08x)   Name: %s",
; 3434 : //            lProcessID, zGETHNDL( lpDBHandler ), hTask, hTask, lpTaskDBHandler->szName );
; 3435 : 
; 3436 :    return( lpTaskDBHandler );

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
$L8578:

; 3437 : 
; 3438 : } // fnGetDBHandlerOper

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnGetDBHandlerOper@12 ENDP
_TEXT	ENDS
PUBLIC	_fnGetGKHandlerOper
PUBLIC	??_C@_0CH@KJEE@?$CIoi?$CJ?5Attempting?5to?5load?5GK?9handl@ ; `string'
PUBLIC	??_C@_0M@GIDM@GKH_MsgProc?$AA@			; `string'
PUBLIC	??_C@_0N@KCPG@_GKH_MsgProc?$AA@			; `string'
EXTRN	__imp__strncmp:NEAR
;	COMDAT ??_C@_0CH@KJEE@?$CIoi?$CJ?5Attempting?5to?5load?5GK?9handl@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CH@KJEE@?$CIoi?$CJ?5Attempting?5to?5load?5GK?9handl@ DB '(oi) Atte'
	DB	'mpting to load GK-handler as ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@GIDM@GKH_MsgProc?$AA@
_DATA	SEGMENT
??_C@_0M@GIDM@GKH_MsgProc?$AA@ DB 'GKH_MsgProc', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@KCPG@_GKH_MsgProc?$AA@
_DATA	SEGMENT
??_C@_0N@KCPG@_GKH_MsgProc?$AA@ DB '_GKH_MsgProc', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vSubtask$ = 8
_lpTask$ = 12
_hGKHandler$ = 16
_pOperReturn$ = 20
_lpGKHandler$ = -20
_lpTaskGKHandler$ = -8
_hLibrary$ = -12
_pGKOper$ = -24
_nRC$ = -16
_lProcessID$ = -4
_szFuncName$8648 = -60
_hTaskGKHandler$8649 = -28
_szLibName$8651 = -160
_fnGetGKHandlerOper PROC NEAR

; 3463 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H

; 3464 :    LPGKHANDLER      lpGKHandler;
; 3465 :    LPTASKGKHANDLER  lpTaskGKHandler;
; 3466 :    LPLIBRARY        hLibrary;
; 3467 :    zPGKHOPER        pGKOper;
; 3468 :    zSHORT           nRC;
; 3469 :    zLONG            lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 3470 : 
; 3471 :    lpGKHandler = zGETPTR( hGKHandler );

	mov	eax, DWORD PTR _hGKHandler$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGKHandler$[ebp], eax

; 3472 : 
; 3473 :    // Make sure DBHandler can be found.
; 3474 :    if ( lpGKHandler == 0 )

	cmp	DWORD PTR _lpGKHandler$[ebp], 0
	jne	SHORT $L8638

; 3476 :       // "KZOEE081 - Object Definition does not have a Genkey handler
; 3477 :       // specified"
; 3478 :       fnIssueCoreError( lpTask, vSubtask, 8, 81, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	81					; 00000051H
	push	8
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3479 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8630
$L8638:

; 3481 : 
; 3482 :    // See if GKHandler has already been invoked for this task.
; 3483 :    for ( lpTaskGKHandler = zGETPTR( lpTask->hFirstTaskGKHandler );
; 3484 :          lpTaskGKHandler;
; 3485 :          lpTaskGKHandler = zGETPTR( lpTaskGKHandler->hNextTaskGKHandler ) )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+138]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskGKHandler$[ebp], eax
	jmp	SHORT $L8641
$L8642:
	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskGKHandler$[ebp], eax
$L8641:
	cmp	DWORD PTR _lpTaskGKHandler$[ebp], 0
	je	SHORT $L8643

; 3487 :       if ( lpTaskGKHandler->lProcessID != lProcessID )

	mov	ecx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	je	SHORT $L8644

; 3488 :          continue;

	jmp	SHORT $L8642
$L8644:

; 3489 : 
; 3490 :       if ( lpTaskGKHandler->hGKHandler != hGKHandler )

	mov	eax, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	cmp	ecx, DWORD PTR _hGKHandler$[ebp]
	je	SHORT $L8645

; 3491 :          continue;

	jmp	SHORT $L8642
$L8645:
$L8643:

; 3496 : 
; 3497 :    // If TaskGKHandler wasn't found, then this is the first time the
; 3498 :    // GKHandler has been called for this task.
; 3499 :    if ( lpTaskGKHandler )

	cmp	DWORD PTR _lpTaskGKHandler$[ebp], 0
	je	SHORT $L8646

; 3501 :       // The task DBHandler was found--return pointer to DBHandler routine.
; 3502 :       pGKOper = lpTaskGKHandler->pfGKHandlerOper;

	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _pGKOper$[ebp], eax

; 3504 :    else

	jmp	$L8647
$L8646:

; 3506 :       zCHAR  szFuncName[ 30 ];
; 3507 :       zPVOID hTaskGKHandler;
; 3508 : 
; 3509 :       // Load the DBHandler library.  If it can't be found, return with error.
; 3510 :       if ( zstrncmp( lpGKHandler->szName, "KZ", 2 ) == 0 )

	push	2
	push	OFFSET FLAT:??_C@_02CJCI@KZ?$AA@	; `string'
	mov	ecx, DWORD PTR _lpGKHandler$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L8650

; 3512 :          // If handler name starts with KZ, then load handler from Zeidon
; 3513 :          // bin directory.
; 3514 :          zCHAR szLibName[ 100 ];
; 3515 : 
; 3516 :          zstrcpy( szLibName, AnchorBlock->szZeidonBin );

	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 395				; 0000018bH
	push	edx
	lea	eax, DWORD PTR _szLibName$8651[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 3517 :          zstrcat( szLibName, lpGKHandler->szName );

	mov	ecx, DWORD PTR _lpGKHandler$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _szLibName$8651[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3518 : 
; 3519 :          TraceLineS( "(oi) Attempting to load GK-handler as ", szLibName );

	lea	eax, DWORD PTR _szLibName$8651[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CH@KJEE@?$CIoi?$CJ?5Attempting?5to?5load?5GK?9handl@ ; `string'
	call	_TraceLineS@8

; 3520 :          hLibrary = SysLoadLibrary( vSubtask, szLibName );

	lea	ecx, DWORD PTR _szLibName$8651[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 3522 :       else

	jmp	SHORT $L8653
$L8650:

; 3524 :          TraceLineS( "(oi) Attempting to load GK-handler as ",
; 3525 :                      lpGKHandler->szName );

	mov	eax, DWORD PTR _lpGKHandler$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET FLAT:??_C@_0CH@KJEE@?$CIoi?$CJ?5Attempting?5to?5load?5GK?9handl@ ; `string'
	call	_TraceLineS@8

; 3526 :          hLibrary = SysLoadLibrary( vSubtask, lpGKHandler->szName );

	mov	ecx, DWORD PTR _lpGKHandler$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax
$L8653:

; 3528 : 
; 3529 :       if ( hLibrary == 0 )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	jne	SHORT $L8654

; 3530 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8630
$L8654:

; 3531 : 
; 3532 :       pGKOper = (zPGKHOPER) SysGetProc( hLibrary, "GKH_MsgProc" );

	push	OFFSET FLAT:??_C@_0M@GIDM@GKH_MsgProc?$AA@ ; `string'
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	DWORD PTR _pGKOper$[ebp], eax

; 3533 :       if ( pGKOper == 0 )

	cmp	DWORD PTR _pGKOper$[ebp], 0
	jne	SHORT $L8662

; 3535 :          // Try the old style name.
; 3536 :          zstrcpy( (zPCHAR) szFuncName, lpGKHandler->szName );

	mov	ecx, DWORD PTR _lpGKHandler$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _szFuncName$8648[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3537 :          zstrcat( (zPCHAR) szFuncName, "_GKH_MsgProc" );

	push	OFFSET FLAT:??_C@_0N@KCPG@_GKH_MsgProc?$AA@ ; `string'
	lea	eax, DWORD PTR _szFuncName$8648[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3538 : 
; 3539 :          // Find the address of entry func.  If it can't be found, return with
; 3540 :          // an error.
; 3541 :          pGKOper = (zPGKHOPER) SysGetProc( hLibrary, szFuncName );

	lea	ecx, DWORD PTR _szFuncName$8648[ebp]
	push	ecx
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	DWORD PTR _pGKOper$[ebp], eax

; 3542 :          if ( pGKOper == 0 )

	cmp	DWORD PTR _pGKOper$[ebp], 0
	jne	SHORT $L8662

; 3543 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8630
$L8662:

; 3545 : 
; 3546 :       // Call gkhandler routine to issue start of transaction.  Bomb out if
; 3547 :       // it doesn't work.
; 3548 :       nRC = (*pGKOper)( DBH_Init, vSubtask, 0, 0, 0 );

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	4096					; 00001000H
	call	DWORD PTR _pGKOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 3549 :       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L8663

; 3550 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8630
$L8663:

; 3551 : 
; 3552 :       // Create TaskGKHandler object and attatch to Task.
; 3553 :       hTaskGKHandler = fnAllocDataspace( lpTask->hFirstDataHeader,
; 3554 :                                          sizeof( TaskGKHandlerRecord ), 1, 0,
; 3555 :                                          iTaskGKHandler );

	push	10036					; 00002734H
	push	0
	push	1
	push	26					; 0000001aH
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskGKHandler$8649[ebp], eax

; 3556 :       lpTaskGKHandler = zGETPTR( hTaskGKHandler );

	mov	ecx, DWORD PTR _hTaskGKHandler$8649[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskGKHandler$[ebp], eax

; 3557 :       if ( lpTaskGKHandler == 0 )

	cmp	DWORD PTR _lpTaskGKHandler$[ebp], 0
	jne	SHORT $L8666

; 3558 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8630
$L8666:

; 3559 : 
; 3560 :       lpTaskGKHandler->hLibrary        = hLibrary;

	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR _hLibrary$[ebp]
	mov	DWORD PTR [edx+10], eax

; 3561 :       lpTaskGKHandler->pfGKHandlerOper = pGKOper;

	mov	ecx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	edx, DWORD PTR _pGKOper$[ebp]
	mov	DWORD PTR [ecx+14], edx

; 3562 :       lpTaskGKHandler->hGKHandler      = hGKHandler;

	mov	eax, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	ecx, DWORD PTR _hGKHandler$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 3563 :       lpTaskGKHandler->lProcessID      = lProcessID;

	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [edx+22], eax

; 3564 : 
; 3565 :       // Insert lpTaskGKHandler into lpTask chain.
; 3566 :       lpTaskGKHandler->hNextTaskGKHandler = lpTask->hFirstTaskGKHandler;

	mov	ecx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+138]
	mov	DWORD PTR [ecx+2], eax

; 3567 :       lpTask->hFirstTaskGKHandler = hTaskGKHandler;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _hTaskGKHandler$8649[ebp]
	mov	DWORD PTR [ecx+138], edx
$L8647:

; 3570 : 
; 3571 :    *pOperReturn = pGKOper;

	mov	eax, DWORD PTR _pOperReturn$[ebp]
	mov	ecx, DWORD PTR _pGKOper$[ebp]
	mov	DWORD PTR [eax], ecx

; 3572 : 
; 3573 :    return( 0 );

	xor	ax, ax
$L8630:

; 3574 : 
; 3575 : } // fnGetGKHandlerOper

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetGKHandlerOper ENDP
_TEXT	ENDS
PUBLIC	_CommitObjectInstance@4
PUBLIC	_CommitMultipleOIs@16
_TEXT	SEGMENT
_lpView$ = 8
_ViewCluster$ = -12
_lpCurrentTask$ = -16
_nRC$ = -4
_CommitObjectInstance@4 PROC NEAR

; 3774 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3775 :    ViewClusterRecord ViewCluster;
; 3776 :    LPTASK            lpCurrentTask;
; 3777 :    zSHORT            nRC;
; 3778 : 
; 3779 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 3780 :    if ( (lpCurrentTask = fnOperationCall( iCommitObjectInstance, lpView,
; 3781 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	60					; 0000003cH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8673

; 3783 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8669
$L8673:

; 3785 : 
; 3786 :    ViewCluster.vOI      = lpView;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR _ViewCluster$[ebp], ecx

; 3787 :    ViewCluster.lControl = 0;

	mov	DWORD PTR _ViewCluster$[ebp+4], 0

; 3788 : 
; 3789 :    // Call commit multiple.  We use "-1" to tell commit multiple that it is
; 3790 :    // being called from CommitObjectInstance.
; 3791 :    nRC = CommitMultipleOIs( &ViewCluster, 1, (zPSHORT) -1, 0 );

	push	0
	push	-1
	push	1
	lea	edx, DWORD PTR _ViewCluster$[ebp]
	push	edx
	call	_CommitMultipleOIs@16
	mov	WORD PTR _nRC$[ebp], ax

; 3792 :    fnOperationReturn( iCommitObjectInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	60					; 0000003cH
	call	_fnOperationReturn
	add	esp, 8

; 3793 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L8669:

; 3794 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_CommitObjectInstance@4 ENDP
_TEXT	ENDS
PUBLIC	_CreateViewCluster@8
_TEXT	SEGMENT
_vTaskView$ = 8
_lpArray$ = 12
_pv$ = -12
_lpTask$ = -4
_h$ = -8
_lCnt$ = -16
_CreateViewCluster@8 PROC NEAR

; 3815 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3816 :    LPVIEWCLUSTER pv;
; 3817 :    LPTASK        lpTask = zGETPTR( vTaskView->hTask );

	mov	eax, DWORD PTR _vTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 3818 :    zPVOID        h;
; 3819 :    zLONG         lCnt;
; 3820 : 
; 3821 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L8685

; 3822 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8679
$L8685:

; 3823 : 
; 3824 :    lCnt = zCLUSTER_VIEW_COUNT;

	mov	DWORD PTR _lCnt$[ebp], 2000		; 000007d0H

; 3825 : 
; 3826 :    // Allocate space and set it to all 0s.  Allocate enough space for all the
; 3827 :    // views + 1.  This will allow AddViewToViewArray( ) to know when it's
; 3828 :    // reached the end of the list.
; 3829 :    h = fnAllocDataspace( lpTask->hFirstDataHeader,
; 3830 :                          sizeof( ViewClusterRecord ) * (zULONG) (lCnt + 1),
; 3831 :                          TRUE, 0, iCluster );

	push	10104					; 00002778H
	push	0
	push	1
	mov	edx, DWORD PTR _lCnt$[ebp]
	lea	eax, DWORD PTR [edx*8+8]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _h$[ebp], eax

; 3832 :    pv = (LPVIEWCLUSTER) zGETPTR( h );

	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pv$[ebp], eax

; 3833 : 
; 3834 :    if ( pv )

	cmp	DWORD PTR _pv$[ebp], 0
	je	SHORT $L8690

; 3836 :       // At the end of the array set the last view to -1.
; 3837 :       pv[ lCnt ].vOI = (zVIEW) -1;

	mov	ecx, DWORD PTR _lCnt$[ebp]
	mov	edx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [edx+ecx*8], -1
$L8690:

; 3839 : 
; 3840 :    *lpArray = (zLONG) pv;

	mov	eax, DWORD PTR _lpArray$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [eax], ecx

; 3841 : 
; 3842 :    return( 0 );

	xor	ax, ax
$L8679:

; 3843 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CreateViewCluster@8 ENDP
_TEXT	ENDS
PUBLIC	_AddToViewCluster@12
PUBLIC	??_C@_0BI@HCHL@View?5doesn?8t?5have?5an?5OI?$AA@ ; `string'
;	COMDAT ??_C@_0BI@HCHL@View?5doesn?8t?5have?5an?5OI?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BI@HCHL@View?5doesn?8t?5have?5an?5OI?$AA@ DB 'View doesn''t have a'
	DB	'n OI', 00H					; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lArray$ = 8
_lpView$ = 12
_lControl$ = 16
_lpCurrentTask$ = -20
_pv$ = -16
_lpViewCsr$ = -4
_hViewOI$ = -12
_nIdx$ = -8
_AddToViewCluster@12 PROC NEAR

; 3864 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3865 :    LPTASK        lpCurrentTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 3866 :    LPVIEWCLUSTER pv = (LPVIEWCLUSTER) lArray;

	mov	edx, DWORD PTR _lArray$[ebp]
	mov	DWORD PTR _pv$[ebp], edx

; 3867 :    LPVIEWCSR     lpViewCsr;
; 3868 :    LPVIEWOI      hViewOI;
; 3869 :    zSHORT        nIdx;
; 3870 : 
; 3871 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 3872 :    if ( (lpCurrentTask = fnOperationCall( iAddToViewCluster, lpView,
; 3873 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	64					; 00000040H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8707

; 3875 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8699
$L8707:

; 3877 : 
; 3878 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3879 :    if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	jne	SHORT $L8709

; 3881 :       SysMessageBox( lpView, szlOE_SystemError, "View doesn't have an OI", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BI@HCHL@View?5doesn?8t?5have?5an?5OI?$AA@ ; `string'
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 3882 :       fnOperationReturn( iAddToViewCluster, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	64					; 00000040H
	call	_fnOperationReturn
	add	esp, 8

; 3883 :       return( -1 );

	or	ax, -1
	jmp	$L8699
$L8709:

; 3885 : 
; 3886 :    hViewOI = lpViewCsr->hViewOI;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hViewOI$[ebp], ecx

; 3887 : 
; 3888 :    // Look for the first 0 (e.g. empty) cell in the array. If we find one
; 3889 :    // that is -1, then we've reached the end of the list so end with error.
; 3890 :    for ( nIdx = 0; pv[ nIdx ].vOI; nIdx++ )

	mov	WORD PTR _nIdx$[ebp], 0
	jmp	SHORT $L8711
$L8712:
	mov	dx, WORD PTR _nIdx$[ebp]
	add	dx, 1
	mov	WORD PTR _nIdx$[ebp], dx
$L8711:
	movsx	eax, WORD PTR _nIdx$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	je	SHORT $L8713

; 3892 :       if ( pv[ nIdx ].vOI == (zVIEW) -1 )

	movsx	edx, WORD PTR _nIdx$[ebp]
	mov	eax, DWORD PTR _pv$[ebp]
	cmp	DWORD PTR [eax+edx*8], -1
	jne	SHORT $L8715

; 3894 :          // "KZOEE087 - Too many views in View array"
; 3895 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 87, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	87					; 00000057H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3896 :          fnOperationReturn( iAddToViewCluster, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	64					; 00000040H
	call	_fnOperationReturn
	add	esp, 8

; 3897 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8699
$L8715:

; 3899 :    }

	jmp	SHORT $L8712
$L8713:

; 3900 : 
; 3901 :    pv[ nIdx ].vOI      = lpView;

	movsx	ecx, WORD PTR _nIdx$[ebp]
	mov	edx, DWORD PTR _pv$[ebp]
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+ecx*8], eax

; 3902 :    pv[ nIdx ].lControl = lControl;

	movsx	ecx, WORD PTR _nIdx$[ebp]
	mov	edx, DWORD PTR _pv$[ebp]
	mov	eax, DWORD PTR _lControl$[ebp]
	mov	DWORD PTR [edx+ecx*8+4], eax

; 3903 : 
; 3904 :    fnOperationReturn( iAddToViewCluster, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	64					; 00000040H
	call	_fnOperationReturn
	add	esp, 8

; 3905 :    return( nIdx );

	mov	ax, WORD PTR _nIdx$[ebp]
$L8699:

; 3906 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_AddToViewCluster@12 ENDP
_TEXT	ENDS
PUBLIC	_AppendViewCluster@8
EXTRN	_fnFreeDataspace:NEAR
_TEXT	SEGMENT
_lTargetArray$ = 8
_lSourceArray$ = 12
_pvTarget$ = -4
_pvSource$ = -12
_k$ = -16
_n$ = -20
_nRC$ = -8
_AppendViewCluster@8 PROC NEAR

; 3930 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3931 :    LPVIEWCLUSTER pvTarget = (LPVIEWCLUSTER) lTargetArray;

	mov	eax, DWORD PTR _lTargetArray$[ebp]
	mov	DWORD PTR _pvTarget$[ebp], eax

; 3932 :    LPVIEWCLUSTER pvSource = (LPVIEWCLUSTER) lSourceArray;

	mov	ecx, DWORD PTR _lSourceArray$[ebp]
	mov	DWORD PTR _pvSource$[ebp], ecx

; 3933 :    zLONG  k;
; 3934 :    zSHORT n;
; 3935 :    zSHORT nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 3936 : 
; 3937 :    for ( k = 0; pvSource[ k ].vOI; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L8728
$L8729:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$L8728:
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pvSource$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	je	SHORT $L8730

; 3939 :       if ( pvSource[ k ].vOI == (zVIEW) -1 )

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pvSource$[ebp]
	cmp	DWORD PTR [eax+edx*8], -1
	jne	SHORT $L8732

; 3940 :          break; // this is the end of the array

	jmp	SHORT $L8730
$L8732:

; 3941 : 
; 3942 :       n = AddToViewCluster( lTargetArray,
; 3943 :                             pvSource[ k ].vOI, pvSource[ k ].lControl );

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pvSource$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pvSource$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR _lTargetArray$[ebp]
	push	ecx
	call	_AddToViewCluster@12
	mov	WORD PTR _n$[ebp], ax

; 3944 :       if ( n < 0 )

	movsx	edx, WORD PTR _n$[ebp]
	test	edx, edx
	jge	SHORT $L8733

; 3945 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8720
$L8733:

; 3946 : 
; 3947 :       if ( k == 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jne	SHORT $L8734

; 3948 :          nRC = n; // first index is the Offset of appended cluster

	mov	ax, WORD PTR _n$[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$L8734:

; 3949 :    }

	jmp	SHORT $L8729
$L8730:

; 3950 : 
; 3951 :    fnFreeDataspace( pvSource );

	mov	ecx, DWORD PTR _pvSource$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 3952 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L8720:

; 3953 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_AppendViewCluster@8 ENDP
_TEXT	ENDS
PUBLIC	_AddViewToViewCluster@8
_TEXT	SEGMENT
_lArray$ = 8
_lpView$ = 12
_AddViewToViewCluster@8 PROC NEAR

; 3974 : {

	push	ebp
	mov	ebp, esp

; 3975 :    return( AddToViewCluster( lArray, lpView, 0 ) );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lArray$[ebp]
	push	ecx
	call	_AddToViewCluster@12

; 3976 : }

	pop	ebp
	ret	8
_AddViewToViewCluster@8 ENDP
_TEXT	ENDS
PUBLIC	_DropViewCluster@4
_TEXT	SEGMENT
_lArray$ = 8
_lpCurrentTask$ = -12
_lpViewCluster$ = -8
_idx$ = -4
_DropViewCluster@4 PROC NEAR

; 3995 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3996 :    LPTASK        lpCurrentTask = 0;

	mov	DWORD PTR _lpCurrentTask$[ebp], 0

; 3997 :    LPVIEWCLUSTER lpViewCluster = (LPVIEWCLUSTER) lArray;

	mov	eax, DWORD PTR _lArray$[ebp]
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 3998 :    zSHORT        idx;
; 3999 : 
; 4000 :    // Loop through each of the OI's in the cluster.  If the vOI value is
; 4001 :    // -1 then we've reached the end of the view cluster.
; 4002 :    for ( idx = 0; lpViewCluster[ idx ].vOI != (zVIEW) -1; idx++ )

	mov	WORD PTR _idx$[ebp], 0
	jmp	SHORT $L8748
$L8749:
	mov	cx, WORD PTR _idx$[ebp]
	add	cx, 1
	mov	WORD PTR _idx$[ebp], cx
$L8748:
	movsx	edx, WORD PTR _idx$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], -1
	je	$L8750

; 4004 :       if ( lpViewCluster[ idx ].vOI == 0 )

	movsx	ecx, WORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	jne	SHORT $L8751

; 4005 :          continue;

	jmp	SHORT $L8749
$L8751:

; 4006 : 
; 4007 :       // Retrieve the task if we haven't done it already.
; 4008 :       if ( lpCurrentTask == 0 &&
; 4009 :            (lpCurrentTask = fnOperationCall( iDropViewCluster,
; 4010 :                                              lpViewCluster[ idx ].vOI, 0 )) == 0 )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8752
	push	0
	movsx	eax, WORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	push	63					; 0000003fH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8752

; 4012 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L8742
$L8752:

; 4014 : 
; 4015 :       if ( lpViewCluster[ idx ].lControl & zCOMMIT_DROPOBJECTINSTANCE )

	movsx	eax, WORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	and	edx, 16384				; 00004000H
	test	edx, edx
	je	SHORT $L8753

; 4016 :          DropObjectInstance( lpViewCluster[ idx ].vOI );

	movsx	eax, WORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	call	_DropObjectInstance@4

; 4017 :       else

	jmp	SHORT $L8755
$L8753:

; 4018 :       if ( lpViewCluster[ idx ].lControl & zCOMMIT_DROPVIEW )

	movsx	eax, WORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	and	edx, 8192				; 00002000H
	test	edx, edx
	je	SHORT $L8755

; 4019 :          DropView( lpViewCluster[ idx ].vOI );

	movsx	eax, WORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	call	_DropView@4
$L8755:

; 4020 :    }

	jmp	$L8749
$L8750:

; 4021 : 
; 4022 :    fnFreeDataspace( lpViewCluster );

	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 4023 : 
; 4024 :    if ( lpCurrentTask )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $L8756

; 4025 :       fnOperationReturn( iDropViewCluster, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	63					; 0000003fH
	call	_fnOperationReturn
	add	esp, 8
$L8756:

; 4026 : 
; 4027 :    return( 0 );

	xor	ax, ax
$L8742:

; 4028 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DropViewCluster@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@ECGE@Object?5Name?5?$DN?5?$AA@		; `string'
PUBLIC	??_C@_0BM@FEHG@?$CIoi?$CJ?5Can?8t?5start?5network?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0CK@GCPD@?$CIoi?$CJ?5Warning?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0BK@OGGO@?$CIoi?$CJ?5Object?5definition?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BE@BILP@?$CIoi?$CJ?5Entity?5name?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BE@HPNO@?$CIoi?$CJ?5EI?5Flags?5?5?5?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0FP@BNEA@Return?5code?5indicates?5that?5Commi@ ; `string'
PUBLIC	??_C@_0L@OPBG@OE?5Warning?$AA@			; `string'
PUBLIC	??_C@_0EC@LDIB@?$CFs?5?5?$CFs?5?5?5Object?5Definition?3?5?$CFs?5?5@ ; `string'
PUBLIC	??_C@_0M@FIA@?$CFlf?5seconds?$AA@		; `string'
PUBLIC	??_C@_0CJ@PHHP@?$CIoi?$CJ?5Total?5time?5for?5CommitMultip@ ; `string'
EXTRN	_TraceLineX@8:NEAR
EXTRN	_fnValidViewCsr:NEAR
EXTRN	_NetCommitOI@28:NEAR
EXTRN	_SysDiagnosticMessage@16:NEAR
;	COMDAT ??_C@_0P@ECGE@Object?5Name?5?$DN?5?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0P@ECGE@Object?5Name?5?$DN?5?$AA@ DB 'Object Name = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@FEHG@?$CIoi?$CJ?5Can?8t?5start?5network?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BM@FEHG@?$CIoi?$CJ?5Can?8t?5start?5network?5?$DN?5?$AA@ DB '(oi) C'
	DB	'an''t start network = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CK@GCPD@?$CIoi?$CJ?5Warning?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
_DATA	SEGMENT
??_C@_0CK@GCPD@?$CIoi?$CJ?5Warning?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '('
	DB	'oi) Warning ============================', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@OGGO@?$CIoi?$CJ?5Object?5definition?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BK@OGGO@?$CIoi?$CJ?5Object?5definition?5?$DN?5?$AA@ DB '(oi) Objec'
	DB	't definition = ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@BILP@?$CIoi?$CJ?5Entity?5name?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BE@BILP@?$CIoi?$CJ?5Entity?5name?5?$DN?5?$AA@ DB '(oi) Entity name'
	DB	' = ', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HPNO@?$CIoi?$CJ?5EI?5Flags?5?5?5?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BE@HPNO@?$CIoi?$CJ?5EI?5Flags?5?5?5?5?$DN?5?$AA@ DB '(oi) EI Flags'
	DB	'    = ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FP@BNEA@Return?5code?5indicates?5that?5Commi@
_DATA	SEGMENT
??_C@_0FP@BNEA@Return?5code?5indicates?5that?5Commi@ DB 'Return code indi'
	DB	'cates that Commit was successful but OI still has instances m'
	DB	'arked as changed.', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@OPBG@OE?5Warning?$AA@
_DATA	SEGMENT
??_C@_0L@OPBG@OE?5Warning?$AA@ DB 'OE Warning', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EC@LDIB@?$CFs?5?5?$CFs?5?5?5Object?5Definition?3?5?$CFs?5?5@
_DATA	SEGMENT
??_C@_0EC@LDIB@?$CFs?5?5?$CFs?5?5?5Object?5Definition?3?5?$CFs?5?5@ DB '%'
	DB	's  %s   Object Definition: %s   EntityName: %s   EI Flags 0x%'
	DB	'08x', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@FIA@?$CFlf?5seconds?$AA@
_DATA	SEGMENT
??_C@_0M@FIA@?$CFlf?5seconds?$AA@ DB '%lf seconds', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@PHHP@?$CIoi?$CJ?5Total?5time?5for?5CommitMultip@
_DATA	SEGMENT
??_C@_0CJ@PHHP@?$CIoi?$CJ?5Total?5time?5for?5CommitMultip@ DB '(oi) Total'
	DB	' time for CommitMultipleOIs = ', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpOrigViewCluster$ = 8
_nViewCount$ = 12
_pnViewErrorIdx$ = 16
_lControl$ = 20
_lpViewCluster$ = -24
_tViewArrayBlock$ = -104
_lpCurrentTask$ = -128
_lpViewCsr$ = -8
_lpViewOI$ = -120
_lpViewOD$ = -12
_pchNetworkName$ = -40
_vReferenceView$ = -108
_lpViewArray$ = -36
_lTickCount$ = -124
_bNetworkCommit$ = -32
_bLockingSemaphoreCreatedHere$ = -28
_bDropPessimisticLocks$ = -16
_iOpID$ = -116
_k$ = -112
_nRC$ = -20
_nReturn$ = -4
_lpViewCsr$8808 = -132
_hViewOI$8809 = -136
_j$8810 = -140
_lpTask$8841 = -144
_lpTask$8846 = -148
_nState$8862 = -152
_lpEntityInstance$8878 = -156
_lpViewEntity$8879 = -160
_szMsg$8894 = -1184
_sz$8916 = -1216
_CommitMultipleOIs@16 PROC NEAR

; 4078 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1224				; 000004c8H
	push	esi
	push	edi

; 4079 :    LPVIEWCLUSTER     lpViewCluster = 0;

	mov	DWORD PTR _lpViewCluster$[ebp], 0

; 4080 :    VIEWARRAYBLOCK    tViewArrayBlock = { 0 };

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	mov	ecx, 15					; 0000000fH
	xor	eax, eax
	lea	edi, DWORD PTR _tViewArrayBlock$[ebp+4]
	rep stosd

; 4081 :    LPTASK            lpCurrentTask;
; 4082 :    LPVIEWCSR         lpViewCsr;
; 4083 :    LPVIEWOI          lpViewOI;
; 4084 :    LPVIEWOD          lpViewOD;
; 4085 :    zPCHAR            pchNetworkName = 0;

	mov	DWORD PTR _pchNetworkName$[ebp], 0

; 4086 :    zVIEW             vReferenceView;
; 4087 :    zVIEW             *lpViewArray = 0;

	mov	DWORD PTR _lpViewArray$[ebp], 0

; 4088 :    zLONG             lTickCount;
; 4089 :    zBOOL             bNetworkCommit = FALSE;

	mov	BYTE PTR _bNetworkCommit$[ebp], 0

; 4090 :    zBOOL             bLockingSemaphoreCreatedHere = FALSE;

	mov	BYTE PTR _bLockingSemaphoreCreatedHere$[ebp], 0

; 4091 :    zBOOL             bDropPessimisticLocks = FALSE;

	mov	BYTE PTR _bDropPessimisticLocks$[ebp], 0

; 4092 :    zSHORT            iOpID;
; 4093 :    zSHORT            k;
; 4094 :    zSHORT            nRC;
; 4095 :    zSHORT            nReturn = zCALL_ERROR;

	mov	WORD PTR _nReturn$[ebp], -16		; fffffff0H

; 4096 : 
; 4097 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8783

; 4098 :       lTickCount = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTickCount$[ebp], eax
$L8783:

; 4099 : 
; 4100 :    // If nViewCount is 0 then determine number of views by counting non-zero
; 4101 :    // views.
; 4102 :    if ( nViewCount == 0 )

	movsx	edx, WORD PTR _nViewCount$[ebp]
	test	edx, edx
	jne	SHORT $L8791
$L8786:

; 4104 :       // The list can be terminated by either a 0 or -1.  The -1 might be
; 4105 :       // set by CreateEmptyViewCluster( ) above.
; 4106 :       while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L8787

; 4108 :          if ( lpOrigViewCluster[ nViewCount ].vOI == 0 )

	movsx	ecx, WORD PTR _nViewCount$[ebp]
	mov	edx, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	jne	SHORT $L8788

; 4109 :             break;

	jmp	SHORT $L8787
$L8788:

; 4110 : 
; 4111 :          if ( lpOrigViewCluster[ nViewCount ].vOI == (zVIEW) -1 )

	movsx	eax, WORD PTR _nViewCount$[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], -1
	jne	SHORT $L8790

; 4112 :             break;

	jmp	SHORT $L8787
$L8790:

; 4113 : 
; 4114 :          nViewCount++;

	mov	dx, WORD PTR _nViewCount$[ebp]
	add	dx, 1
	mov	WORD PTR _nViewCount$[ebp], dx

; 4115 :       }

	jmp	SHORT $L8786
$L8787:

; 4116 : 
; 4117 :       // If nViewCount is *still* 0 then just get out.
; 4118 :       if ( nViewCount == 0 )

	movsx	eax, WORD PTR _nViewCount$[ebp]
	test	eax, eax
	jne	SHORT $L8791

; 4120 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L8792

; 4121 :             *pnViewErrorIdx = -1;

	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	WORD PTR [ecx], -1
$L8792:

; 4122 : 
; 4123 :          return( 0 );

	xor	ax, ax
	jmp	$L8765
$L8791:

; 4126 : 
; 4127 :    if ( pnViewErrorIdx == (zPSHORT) -1 )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], -1
	jne	SHORT $L8794

; 4129 :       iOpID = iCommitObjectInstance;

	mov	WORD PTR _iOpID$[ebp], 60		; 0000003cH

; 4130 :       pnViewErrorIdx = 0;

	mov	DWORD PTR _pnViewErrorIdx$[ebp], 0

; 4131 :       lpCurrentTask = zGETPTR( lpOrigViewCluster[ 0 ].vOI->hTask );

	mov	edx, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 4133 :    else

	jmp	SHORT $L8801
$L8794:

; 4135 :       iOpID = iCommitMultipleOIs;

	mov	WORD PTR _iOpID$[ebp], 62		; 0000003eH

; 4136 : 
; 4137 :       // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 4138 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8797
$L8798:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L8797:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L8799

; 4140 :          if ( lpOrigViewCluster[ k ].vOI )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	je	SHORT $L8800

; 4141 :             break;

	jmp	SHORT $L8799
$L8800:

; 4142 :       }

	jmp	SHORT $L8798
$L8799:

; 4143 : 
; 4144 :       if ( (lpCurrentTask = fnOperationCall( iOpID,
; 4145 :                                              lpOrigViewCluster[ k ].vOI, 0 )) == 0 )

	push	0
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	cx, WORD PTR _iOpID$[ebp]
	push	ecx
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L8801

; 4147 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8765
$L8801:

; 4150 : 
; 4151 : // TraceLineI( "CommitMultipleOIs: ENTRY OperationID: ", iOpID );
; 4152 : 
; 4153 :    lpViewCluster = fnAllocDataspace( lpCurrentTask->hFirstDataHeader,
; 4154 :                                      sizeof( ViewClusterRecord ) * (zULONG) nViewCount,
; 4155 :                                      TRUE, 0, iCluster );

	push	10104					; 00002778H
	push	0
	push	1
	movsx	edx, WORD PTR _nViewCount$[ebp]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 4156 :    lpViewCluster = zGETPTR( lpViewCluster );

	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 4157 : 
; 4158 :    // Create temporary views so core can muck with the cursors.
; 4159 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8805
$L8806:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L8805:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$L8807

; 4161 :       LPVIEWCSR  lpViewCsr;
; 4162 :       LPVIEWOI   hViewOI;
; 4163 :       zLONG      j;
; 4164 : 
; 4165 :       if ( lpOrigViewCluster[ k ].vOI == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	jne	SHORT $L8811

; 4166 :          continue;

	jmp	SHORT $L8806
$L8811:

; 4167 : 
; 4168 :       lpViewCsr = zGETPTR( lpOrigViewCluster[ k ].vOI->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$8808[ebp], eax

; 4169 :       if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$8808[ebp], 0
	jne	SHORT $L8813

; 4170 :          continue; // should never occur

	jmp	SHORT $L8806
$L8813:

; 4171 : 
; 4172 :       hViewOI = lpViewCsr->hViewOI;

	mov	eax, DWORD PTR _lpViewCsr$8808[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hViewOI$8809[ebp], ecx

; 4173 : 
; 4174 :       // Make sure the OI isn't already part of the cluster.
; 4175 :       for ( j = 0; j < k; j++ )

	mov	DWORD PTR _j$8810[ebp], 0
	jmp	SHORT $L8814
$L8815:
	mov	edx, DWORD PTR _j$8810[ebp]
	add	edx, 1
	mov	DWORD PTR _j$8810[ebp], edx
$L8814:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	DWORD PTR _j$8810[ebp], eax
	jge	SHORT $L8816

; 4177 :          if ( lpOrigViewCluster[ j ].vOI == 0 )

	mov	ecx, DWORD PTR _j$8810[ebp]
	mov	edx, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	jne	SHORT $L8817

; 4178 :             continue;

	jmp	SHORT $L8815
$L8817:

; 4179 : 
; 4180 :          lpViewCsr = zGETPTR( lpOrigViewCluster[ j ].vOI->hViewCsr );

	mov	eax, DWORD PTR _j$8810[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$8808[ebp], eax

; 4181 :          if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$8808[ebp], 0
	jne	SHORT $L8819

; 4182 :             continue; // should never occur

	jmp	SHORT $L8815
$L8819:

; 4183 : 
; 4184 :          if ( lpViewCsr->hViewOI == hViewOI )

	mov	ecx, DWORD PTR _lpViewCsr$8808[ebp]
	mov	edx, DWORD PTR [ecx+10]
	cmp	edx, DWORD PTR _hViewOI$8809[ebp]
	jne	SHORT $L8820

; 4186 :             // it is already in cluster, so skip it for commit
; 4187 :             hViewOI = 0; // just to indicate skipping

	mov	DWORD PTR _hViewOI$8809[ebp], 0

; 4188 :             break;

	jmp	SHORT $L8816
$L8820:

; 4190 :       }

	jmp	SHORT $L8815
$L8816:

; 4191 : 
; 4192 :       if ( hViewOI == 0 )

	cmp	DWORD PTR _hViewOI$8809[ebp], 0
	jne	SHORT $L8821

; 4193 :          continue; // skip, because OI already found in cluster

	jmp	$L8806
$L8821:

; 4194 : 
; 4195 :       CreateViewFromViewForTask( &lpViewCluster[ k ].vOI,
; 4196 :                                  lpOrigViewCluster[ k ].vOI, 0 );

	push	0
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	call	_CreateViewFromViewForTask@12

; 4197 :    }

	jmp	$L8806
$L8807:

; 4198 : 
; 4199 :    if ( fnInitViewArrayBlock( &tViewArrayBlock, nViewCount ) != 0 )

	movsx	eax, WORD PTR _nViewCount$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tViewArrayBlock$[ebp]
	push	ecx
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L8822

; 4201 :       if ( iOpID == iCommitMultipleOIs )

	movsx	eax, WORD PTR _iOpID$[ebp]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $L8823

; 4202 :          fnOperationReturn( iOpID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	dx, WORD PTR _iOpID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8
$L8823:

; 4203 : 
; 4204 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L8765
$L8822:

; 4206 : 
; 4207 :    lpViewArray = tViewArrayBlock.pvArray;

	mov	eax, DWORD PTR _tViewArrayBlock$[ebp+4]
	mov	DWORD PTR _lpViewArray$[ebp], eax

; 4208 : 
; 4209 :    // Verify that all the views are OK.
; 4210 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8824
$L8825:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L8824:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$L8826

; 4212 :       // We allow NULL views.  This is mostly because fnNetProcessCommit might
; 4213 :       // send us an array containing null views.
; 4214 :       if ( lpViewCluster[ k ].vOI == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	jne	SHORT $L8827

; 4215 :          continue;

	jmp	SHORT $L8825
$L8827:

; 4216 : 
; 4217 :       if ( fnValidViewCsr( lpCurrentTask, lpViewCluster[ k ].vOI ) == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidViewCsr
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L8828

; 4219 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L8829

; 4220 :             *pnViewErrorIdx = k;

	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	ax, WORD PTR _k$[ebp]
	mov	WORD PTR [edx], ax
$L8829:

; 4221 : 
; 4222 :          goto EndOfFunction;

	jmp	$EndOfFunction$8830
$L8828:

; 4224 : 
; 4225 :       lpViewArray[ k ] = lpViewCluster[ k ].vOI;

	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	esi, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*8]
	mov	DWORD PTR [eax+edx*4], ecx

; 4226 : 
; 4227 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4228 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4229 :       lpViewOD  = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 4230 : 
; 4231 :       // Check to see if this is a network commit.
; 4232 :       if ( lpViewOD->szNetwork &&
; 4233 :            (lpViewOI->lActivateControl & zACTIVATE_LOCAL) == 0 )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 109				; 0000006dH
	test	eax, eax
	je	SHORT $L8834
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	and	edx, 1073741824				; 40000000H
	test	edx, edx
	jne	SHORT $L8834

; 4235 :          pchNetworkName = lpViewOD->szNetwork;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 109				; 0000006dH
	mov	DWORD PTR _pchNetworkName$[ebp], eax
$L8834:

; 4237 : 
; 4238 :       // If lControl for commit is zCOMMIT_DROPLOCKSONLY then turn on the flag
; 4239 :       // for each of the views.
; 4240 :       if ( lControl & zCOMMIT_DROPLOCKSONLY )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 2048				; 00000800H
	test	ecx, ecx
	je	SHORT $L8835

; 4241 :          lpViewCluster[ k ].lControl |= zCOMMIT_DROPLOCKSONLY;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	or	ch, 8
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx
$L8835:

; 4242 : 
; 4243 :       // If we're only committing the objects to drop the locks then we don't
; 4244 :       // want to commit this OI so set lpViewArray to 0.
; 4245 :       if ( lpViewCluster[ k ].lControl & zCOMMIT_DROPLOCKSONLY )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $L8836

; 4247 :          // If a network has been specified for this cluster then we *don't*
; 4248 :          // want to zero out the view because we want to send it the server.
; 4249 :          if ( pchNetworkName == 0 || *pchNetworkName == 0 )

	cmp	DWORD PTR _pchNetworkName$[ebp], 0
	je	SHORT $L8838
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L8837
$L8838:

; 4250 :             lpViewArray[ k ] = 0;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 4251 :          else

	jmp	SHORT $L8839
$L8837:

; 4252 :             vReferenceView = lpViewArray[ k ];  // dks donc jb  2004.11.02

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _vReferenceView$[ebp], ecx
$L8839:

; 4253 : 
; 4254 :          continue;

	jmp	$L8825
$L8836:

; 4256 : 
; 4257 :       // If OI is read-only then forget it.
; 4258 :       if ( lpViewOI->bReadOnly )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $L8840

; 4260 :          LPTASK lpTask = zGETPTR( lpViewArray[ k ]->hTask );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$8841[ebp], eax

; 4261 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L8843

; 4262 :             *pnViewErrorIdx = k;

	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	ax, WORD PTR _k$[ebp]
	mov	WORD PTR [edx], ax
$L8843:

; 4263 : 
; 4264 :          // "KZOEE079 - Trying to commit a read-only view".
; 4265 :          fnIssueCoreError( lpTask, lpViewArray[ k ], 8, 79, 0,
; 4266 :                            "Object Name = ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0P@ECGE@Object?5Name?5?$DN?5?$AA@ ; `string'
	push	0
	push	79					; 0000004fH
	push	8
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _lpTask$8841[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4267 :          goto EndOfFunction;

	jmp	$EndOfFunction$8830
$L8840:

; 4269 : 
; 4270 :       // Make sure OI does not contain versioned instances
; 4271 :       if ( lpViewOI->nVersionedInstances )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	je	SHORT $L8845

; 4273 :          LPTASK lpTask = zGETPTR( lpViewArray[ k ]->hTask );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$8846[ebp], eax

; 4274 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L8848

; 4275 :             *pnViewErrorIdx = k;

	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	cx, WORD PTR _k$[ebp]
	mov	WORD PTR [eax], cx
$L8848:

; 4276 : 
; 4277 :          //  "KZOEE076 - Object instance contains versioned entity instances"
; 4278 :          fnIssueCoreError( lpTask, lpViewArray[ k ], 8, 76, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	76					; 0000004cH
	push	8
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _lpTask$8846[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4279 :          goto EndOfFunction;

	jmp	$EndOfFunction$8830
$L8845:

; 4281 : 
; 4282 :       // Make sure that the view has an object instance.
; 4283 :       if ( lpViewOI->hRootEntityInstance == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $L8849

; 4285 :          // Set array value to 0 to indicate that we don't need to commit
; 4286 :          // this view.
; 4287 :          lpViewArray[ k ] = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	DWORD PTR [edx+ecx*4], 0

; 4288 :          continue;

	jmp	$L8825
$L8849:

; 4290 : 
; 4291 :       // If OI hasn't been updated then forget about it UNLESS...
; 4292 :       // there is pessimistic locking.  Then we need to continue so that any
; 4293 :       // pessimistic locks are dropped.
; 4294 :       if ( lpViewOI->bUpdated == FALSE &&
; 4295 :            (lpViewOI->lActivateControl & zACTIVATE_WITH_LOCKING) == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 4
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L8850
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	jne	SHORT $L8850

; 4297 :          // Set array value to 0 to indicate that we don't need to commit
; 4298 :          // this view.
; 4299 :          lpViewArray[ k ] = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	DWORD PTR [edx+ecx*4], 0

; 4300 :          continue;

	jmp	$L8825
$L8850:

; 4302 : 
; 4303 :       // Check to see if we need pessimistic locks on this view.
; 4304 :       if ( lpViewOI->bIsLocked && (lControl & zCOMMIT_KEEPLOCKS) == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 7
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8851
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 4096				; 00001000H
	test	edx, edx
	jne	SHORT $L8851

; 4305 :          bDropPessimisticLocks = TRUE;

	mov	BYTE PTR _bDropPessimisticLocks$[ebp], 1
$L8851:

; 4306 : 
; 4307 :       vReferenceView = lpViewArray[ k ];

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _vReferenceView$[ebp], edx

; 4308 :    }

	jmp	$L8825
$L8826:

; 4309 : 
; 4310 :    // Make sure that at least one view is being committed.
; 4311 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8852
$L8853:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L8852:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $L8854

; 4313 :       if ( lpViewArray[ k ] )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $L8855

; 4314 :          break;

	jmp	SHORT $L8854
$L8855:

; 4315 : 
; 4316 :       if ( lpViewCluster[ k ].lControl & zCOMMIT_DROPLOCKSONLY )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	and	ecx, 2048				; 00000800H
	test	ecx, ecx
	je	SHORT $L8856

; 4317 :          break;

	jmp	SHORT $L8854
$L8856:

; 4318 :    }

	jmp	SHORT $L8853
$L8854:

; 4319 : 
; 4320 :    if ( k == nViewCount )

	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jne	SHORT $L8857

; 4322 :       // No non-zero views found so forget it.
; 4323 :       nReturn = 0;

	mov	WORD PTR _nReturn$[ebp], 0

; 4324 :       goto EndOfFunction;

	jmp	$EndOfFunction$8830
$L8857:

; 4326 : 
; 4327 : #ifdef __ACTIVATE_CONSTRAINTS__
; 4328 :    if ( (lControl & zCOMMIT_NOCONSTRAINTS) == 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 16777216				; 01000000H
	test	ecx, ecx
	jne	$L8861

; 4330 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8859
$L8860:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L8859:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$L8861

; 4332 :          zSHORT nState;
; 4333 : 
; 4334 :          // Don't worry about null views.
; 4335 :          if ( lpViewArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $L8863

; 4336 :             continue;

	jmp	SHORT $L8860
$L8863:

; 4337 : 
; 4338 :          // If this view is only dropping the pessimistic locks then don't
; 4339 :          // call the constraint.
; 4340 :          if ( lpViewCluster[ k ].lControl & zCOMMIT_DROPLOCKSONLY )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	SHORT $L8864

; 4341 :             continue;

	jmp	SHORT $L8860
$L8864:

; 4342 : 
; 4343 :          lpViewOD = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 4344 : 
; 4345 :          // If object has commit constraint active, check for objections.
; 4346 :          // If any exit...
; 4347 :          if ( lpViewOD->bCommitConstraint == FALSE )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	jne	SHORT $L8866

; 4348 :             continue;

	jmp	SHORT $L8860
$L8866:

; 4349 : 
; 4350 :          nState = 0;

	mov	WORD PTR _nState$8862[ebp], 0

; 4351 :          if ( lpCurrentTask->bShutdown )

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 5
	and	edx, 1
	test	edx, edx
	je	SHORT $L8867

; 4352 :             nState += zOCE_STATE_SHUTDOWN;

	mov	ax, WORD PTR _nState$8862[ebp]
	add	ax, 2
	mov	WORD PTR _nState$8862[ebp], ax
$L8867:

; 4353 : 
; 4354 :          nRC = fnInvokeOCEOperation( lpViewArray[ k ], lpCurrentTask,
; 4355 :                                      zOCE_COMMIT, nState );

	mov	cx, WORD PTR _nState$8862[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 4356 :          if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L8868

; 4358 :             if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L8869

; 4359 :                *pnViewErrorIdx = k;

	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	dx, WORD PTR _k$[ebp]
	mov	WORD PTR [ecx], dx
$L8869:

; 4360 : 
; 4361 :             nReturn = nRC;

	mov	ax, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nReturn$[ebp], ax

; 4362 :             goto EndOfFunction;

	jmp	$EndOfFunction$8830
$L8868:

; 4364 :       }

	jmp	$L8860
$L8861:

; 4366 : #endif
; 4367 : 
; 4368 :    if ( pchNetworkName && *pchNetworkName )

	cmp	DWORD PTR _pchNetworkName$[ebp], 0
	je	$L8870
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$L8870

; 4370 :       // Network Commit
; 4371 : 
; 4372 :       // First make sure the network is active.
; 4373 :       if ( NetStatus( vReferenceView, pchNetworkName ) == 0 )

	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vReferenceView$[ebp]
	push	ecx
	call	_NetStatus@8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L8872

; 4375 :          if ( NetStartup( vReferenceView, pchNetworkName, pchNetworkName ) != 0 )

	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vReferenceView$[ebp]
	push	edx
	call	_NetStartup@12
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L8872

; 4377 :             TraceLineS( "(oi) Can't start network = ", pchNetworkName );

	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BM@FEHG@?$CIoi?$CJ?5Can?8t?5start?5network?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 4378 :             MessageSend( vReferenceView, "xx", "KZOEOIAA",
; 4379 :                         "Network cannot be started.",
; 4380 :                         zMSGQ_OBJECT_CONSTRAINT_ERROR, 1 );

	push	1
	push	300					; 0000012cH
	push	OFFSET FLAT:??_C@_0BL@GDPI@Network?5cannot?5be?5started?4?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_08IDGA@KZOEOIAA?$AA@	; `string'
	push	OFFSET FLAT:??_C@_02KKOC@xx?$AA@	; `string'
	mov	edx, DWORD PTR _vReferenceView$[ebp]
	push	edx
	call	_MessageSend@24

; 4381 : 
; 4382 :             goto EndOfFunction;

	jmp	$EndOfFunction$8830
$L8872:

; 4385 : 
; 4386 :       nRC = NetCommitOI( pchNetworkName, 0, lpViewCluster,
; 4387 :                          lpViewArray, nViewCount, pnViewErrorIdx, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	ecx
	mov	dx, WORD PTR _nViewCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	push	edx
	call	_NetCommitOI@28
	mov	WORD PTR _nRC$[ebp], ax

; 4388 : 
; 4389 : #ifdef DEBUG
; 4390 :       if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L8877

; 4392 :          for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8875
$L8876:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L8875:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$L8877

; 4394 :             LPENTITYINSTANCE lpEntityInstance;
; 4395 :             LPVIEWENTITY     lpViewEntity;
; 4396 : 
; 4397 :             if ( lpViewArray[ k ] == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $L8880

; 4398 :                continue;

	jmp	SHORT $L8876
$L8880:

; 4399 : 
; 4400 :             lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4401 :             lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4402 : 
; 4403 :             for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 4404 :                   lpEntityInstance;
; 4405 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$8878[ebp], eax
	jmp	SHORT $L8885
$L8886:
	mov	edx, DWORD PTR _lpEntityInstance$8878[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$8878[ebp], eax
$L8885:
	cmp	DWORD PTR _lpEntityInstance$8878[ebp], 0
	je	$L8887

; 4407 :                lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$8878[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$8879[ebp], eax

; 4408 : 
; 4409 :                if ( lpViewEntity->bDerivedPath == FALSE &&
; 4410 :                     ((lpEntityInstance->u.nInd.bCreated  &&
; 4411 :                       lpEntityInstance->u.nInd.bDeleted == FALSE &&
; 4412 :                       lpViewEntity->bCreate)                  ||
; 4413 :                      (lpEntityInstance->u.nInd.bUpdated  &&
; 4414 :                       lpEntityInstance->u.nInd.bDeleted == FALSE &&
; 4415 :                       lpViewEntity->bUpdate)                  ||
; 4416 :                      (lpEntityInstance->u.nInd.bDeleted  &&
; 4417 :                       lpEntityInstance->u.nInd.bCreated == FALSE &&
; 4418 :                       lpViewEntity->bDelete))
; 4419 : /*
; 4420 :                ||   (lpEntityInstance->u.nInd.bIncluded &&
; 4421 :                      lpViewEntity->bInclude)                 ||
; 4422 :                     (lpEntityInstance->u.nInd.bExcluded &&
; 4423 :                      lpViewEntity->bExclude)
; 4424 : */
; 4425 :                    )

	mov	eax, DWORD PTR _lpViewEntity$8879[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	jne	$L8903
	mov	edx, DWORD PTR _lpEntityInstance$8878[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $L8891
	mov	ecx, DWORD PTR _lpEntityInstance$8878[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L8891
	mov	eax, DWORD PTR _lpViewEntity$8879[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, 1
	test	ecx, ecx
	jne	$L8890
$L8891:
	mov	edx, DWORD PTR _lpEntityInstance$8878[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $L8892
	mov	ecx, DWORD PTR _lpEntityInstance$8878[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L8892
	mov	eax, DWORD PTR _lpViewEntity$8879[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 2
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L8890
$L8892:
	mov	edx, DWORD PTR _lpEntityInstance$8878[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	$L8903
	mov	ecx, DWORD PTR _lpEntityInstance$8878[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	jne	$L8903
	mov	eax, DWORD PTR _lpViewEntity$8879[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	je	$L8903
$L8890:

; 4427 :                   if ( (lControl & zCOMMIT_DROPLOCKSONLY) == 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2048				; 00000800H
	test	edx, edx
	jne	$L8893

; 4429 :                      zCHAR szMsg[ 1024 ];
; 4430 : 
; 4431 :                      lpViewOD = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 4432 : 
; 4433 :                      TraceLineS( "(oi) Warning ============================", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CK@GCPD@?$CIoi?$CJ?5Warning?5?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
	call	_TraceLineS@8

; 4434 :                      TraceLineS( "(oi) Object definition = ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0BK@OGGO@?$CIoi?$CJ?5Object?5definition?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 4435 :                      TraceLineS( "(oi) Entity name = ", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$8879[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET FLAT:??_C@_0BE@BILP@?$CIoi?$CJ?5Entity?5name?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 4436 :                      TraceLineX( "(oi) EI Flags    = ", lpEntityInstance->u.nIndicators );

	mov	eax, DWORD PTR _lpEntityInstance$8878[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	push	OFFSET FLAT:??_C@_0BE@HPNO@?$CIoi?$CJ?5EI?5Flags?5?5?5?5?$DN?5?$AA@ ; `string'
	call	_TraceLineX@8

; 4437 :                      zsprintf( szMsg, "%s  %s   Object Definition: %s   "
; 4438 :                                  "EntityName: %s   EI Flags 0x%08x",
; 4439 :                                "OE Warning", "Return code indicates that "
; 4440 :                                  "Commit was successful but OI still has "
; 4441 :                                  "instances marked as changed.",
; 4442 :                                lpViewOD->szName,
; 4443 :                                lpViewEntity->szName,
; 4444 :                                lpEntityInstance->u.nIndicators );

	mov	edx, DWORD PTR _lpEntityInstance$8878[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$8879[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_0FP@BNEA@Return?5code?5indicates?5that?5Commi@ ; `string'
	push	OFFSET FLAT:??_C@_0L@OPBG@OE?5Warning?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0EC@LDIB@?$CFs?5?5?$CFs?5?5?5Object?5Definition?3?5?$CFs?5?5@ ; `string'
	lea	eax, DWORD PTR _szMsg$8894[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 28					; 0000001cH

; 4445 :                      SysDiagnosticMessage( lpViewArray[ k ], "OE Warning",
; 4446 :                                            szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$8894[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0L@OPBG@OE?5Warning?$AA@ ; `string'
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_SysDiagnosticMessage@16
$L8893:

; 4448 : 
; 4449 :                   if ( lpViewEntity->bCreate )

	mov	edx, DWORD PTR _lpViewEntity$8879[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	test	eax, eax
	je	SHORT $L8903

; 4450 :                      lpEntityInstance->u.nInd.bCreated = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$8878[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _lpEntityInstance$8878[ebp]
	mov	DWORD PTR [eax+6], edx
$L8903:

; 4454 :             } // for...

	jmp	$L8886
$L8887:

; 4455 : 
; 4456 :          } // for k...

	jmp	$L8876
$L8877:

; 4458 : #endif
; 4459 : 
; 4460 :       nReturn = nRC;

	mov	cx, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nReturn$[ebp], cx

; 4461 :       goto EndOfFunction;

	jmp	$EndOfFunction$8830
$L8870:

; 4463 : 
; 4464 :    // Check to see if any OIs where activated using pessimistic locking.  If
; 4465 :    // so then we need to create the pessimistic lock semaphore record for the
; 4466 :    // current task (unless it's already been created).
; 4467 :    if ( bDropPessimisticLocks &&
; 4468 :         lpCurrentTask->bPessimisticLockingSet == FALSE )

	mov	edx, DWORD PTR _bDropPessimisticLocks$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L8907
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 8
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L8907

; 4470 :       // Returns: 0 - everything OK;  1 - Semaphore not needed.
; 4471 :       nRC = fnCreatePessimisticSemaphore( lpCurrentTask,
; 4472 :                                           (zPVOID) lpViewCluster,
; 4473 :                                           nViewCount, pnViewErrorIdx, 0 );

	push	0
	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	edx
	mov	ax, WORD PTR _nViewCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCreatePessimisticSemaphore@20
	mov	WORD PTR _nRC$[ebp], ax

; 4474 :       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $L8906

; 4475 :          goto EndOfFunction;  // oops...error.

	jmp	SHORT $EndOfFunction$8830
$L8906:

; 4476 : 
; 4477 :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L8907

; 4478 :          bLockingSemaphoreCreatedHere = TRUE;

	mov	BYTE PTR _bLockingSemaphoreCreatedHere$[ebp], 1
$L8907:

; 4480 : 
; 4481 :    // Commit all the object instances in the array.
; 4482 :    nReturn = fnCommitObjectInstance( lpViewCluster, lpViewArray, nViewCount,
; 4483 :                                      pnViewErrorIdx, lpCurrentTask,
; 4484 :                                      lControl, &tViewArrayBlock );

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	edx
	mov	ax, WORD PTR _nViewCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	push	edx
	call	_fnCommitObjectInstance@28
	mov	WORD PTR _nReturn$[ebp], ax

; 4485 : 
; 4486 :    if ( bLockingSemaphoreCreatedHere )

	mov	eax, DWORD PTR _bLockingSemaphoreCreatedHere$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $EndOfFunction$8830

; 4487 :       fnDeletePessimisticSemaphore( lpCurrentTask, (zPVOID) lpViewCluster,
; 4488 :                                     nViewCount, pnViewErrorIdx, 0 );

	push	0
	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	ecx
	mov	dx, WORD PTR _nViewCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnDeletePessimisticSemaphore@20
$EndOfFunction$8830:

; 4489 : 
; 4490 : EndOfFunction:
; 4491 :    if ( lpViewCluster )

	cmp	DWORD PTR _lpViewCluster$[ebp], 0
	je	SHORT $L8910

; 4493 :       // Drop the temporary views.
; 4494 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L8911
$L8912:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L8911:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L8913

; 4496 :          if ( lpViewCluster[ k ].vOI )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	je	SHORT $L8914

; 4497 :             fnDropView( lpViewCluster[ k ].vOI );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	_fnDropView@4
$L8914:

; 4498 :       }

	jmp	SHORT $L8912
$L8913:

; 4499 : 
; 4500 :       fnFreeDataspace( lpViewCluster );

	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4
$L8910:

; 4502 : 
; 4503 :    // free the VIEWARRAYBLOCK areas
; 4504 :    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 4505 : 
; 4506 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8915

; 4508 :       zCHAR sz[ 30 ];
; 4509 : 
; 4510 :       zsprintf( sz, "%lf seconds",
; 4511 :                 (double) (SysGetTickCount( ) - lTickCount) / zTICKS_PER_SECOND );

	call	_SysGetTickCount@0
	sub	eax, DWORD PTR _lTickCount$[ebp]
	mov	DWORD PTR -1224+[ebp], eax
	mov	DWORD PTR -1224+[ebp+4], 0
	fild	QWORD PTR -1224+[ebp]
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0M@FIA@?$CFlf?5seconds?$AA@ ; `string'
	lea	edx, DWORD PTR _sz$8916[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4512 :       TraceLineS( "(oi) Total time for CommitMultipleOIs = ", sz );

	lea	eax, DWORD PTR _sz$8916[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CJ@PHHP@?$CIoi?$CJ?5Total?5time?5for?5CommitMultip@ ; `string'
	call	_TraceLineS@8
$L8915:

; 4514 : 
; 4515 :    if ( iOpID == iCommitMultipleOIs )

	movsx	ecx, WORD PTR _iOpID$[ebp]
	cmp	ecx, 62					; 0000003eH
	jne	SHORT $L8920

; 4516 :       fnOperationReturn( iOpID, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	ax, WORD PTR _iOpID$[ebp]
	push	eax
	call	_fnOperationReturn
	add	esp, 8
$L8920:

; 4517 : 
; 4518 : // TraceLineI( "CommitMultipleOIs: EXIT OperationID: ", iOpID );
; 4519 :    return( nReturn );

	mov	ax, WORD PTR _nReturn$[ebp]
$L8765:

; 4520 : 
; 4521 : } // CommitMultipleOIs

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_CommitMultipleOIs@16 ENDP
_TEXT	ENDS
PUBLIC	_CommitMultipleObjectInstances@8
_TEXT	SEGMENT
_lpArray$ = 8
_lpErrorIndex$ = 12
_nIndex$ = -8
_nRC$ = -4
_CommitMultipleObjectInstances@8 PROC NEAR

; 4541 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4542 :    zSHORT nIndex;
; 4543 :    zSHORT nRC;
; 4544 : 
; 4545 :    nRC = CommitMultipleOIs( (LPVIEWCLUSTER) lpArray, 0, &nIndex, 0 );

	push	0
	lea	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpArray$[ebp]
	push	ecx
	call	_CommitMultipleOIs@16
	mov	WORD PTR _nRC$[ebp], ax

; 4546 :    *lpErrorIndex = (zLONG) nIndex;

	movsx	edx, WORD PTR _nIndex$[ebp]
	mov	eax, DWORD PTR _lpErrorIndex$[ebp]
	mov	DWORD PTR [eax], edx

; 4547 : 
; 4548 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 4549 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CommitMultipleObjectInstances@8 ENDP
_TEXT	ENDS
PUBLIC	_fnSetForeignKeysForInstance@4
EXTRN	_lNullInteger:DWORD
EXTRN	_stNullDateTime:FWORD
EXTRN	_SysAssignDecimalFromNull@4:NEAR
_TEXT	SEGMENT
_lpEntityInstance$ = 8
_lpViewEntity$ = -4
_lpDataRecord$ = -24
_lpRelRecord$ = -20
_lpRelField$ = -12
_lpViewOI$ = -16
_lpTask$ = -8
_lpSrcViewAttrib$8953 = -28
_lpRelViewAttrib$8954 = -36
_lpRelViewEntity$8955 = -48
_lpSrcViewEntity$8956 = -52
_lpRelInstance$8957 = -40
_lpSrcInstance$8958 = -32
_lpWkDataField$8959 = -44
_lpWkRelViewEntity$8972 = -56
_lpWkSrcViewEntity$8981 = -60
_uLth$8987 = -68
_lpValue$8988 = -64
_d$8992 = -116
_s$8993 = -76
_p$8994 = -72
_fnSetForeignKeysForInstance@4 PROC NEAR

; 4571 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H

; 4572 :    LPVIEWENTITY   lpViewEntity;
; 4573 :    LPDATARECORD   lpDataRecord;
; 4574 :    LPRELRECORD    lpRelRecord;
; 4575 :    LPRELFIELD     lpRelField;
; 4576 :    LPVIEWOI       lpViewOI;
; 4577 :    LPTASK         lpTask;
; 4578 : 
; 4579 :    lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4580 : 
; 4581 :    // Get Task owning the view object instance
; 4582 :    lpTask = zGETPTR( lpViewOI->hAllocTask );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 4583 : 
; 4584 :    lpEntityInstance->u.nInd.bForeignKeys = 0;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -4194305				; ffbfffffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 4585 : 
; 4586 :    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4587 :    if ( lpViewEntity->hParent == 0 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $L8943

; 4588 :       return( 0 );

	xor	ax, ax
	jmp	$L8933
$L8943:

; 4589 : 
; 4590 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 4591 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 4592 :    if ( lpRelRecord == 0 )

	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	jne	SHORT $L8946

; 4593 :       return( 0 );

	xor	ax, ax
	jmp	$L8933
$L8946:

; 4594 : 
; 4595 :    lpRelField   = zGETPTR( lpRelRecord->hFirstRelField );

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax

; 4596 :    if ( lpRelField == 0 )

	cmp	DWORD PTR _lpRelField$[ebp], 0
	jne	SHORT $L8948

; 4597 :       return( 0 );

	xor	ax, ax
	jmp	$L8933
$L8948:

; 4598 : 
; 4599 :    // For each rel field, check to see if the current entity
; 4600 :    // instance has a foreign key.  If it does, then the value
; 4601 :    // needs to be copied
; 4602 :    for ( ;
; 4603 :          lpRelField;
; 4604 :          lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	jmp	SHORT $L8950
$L8951:
	mov	ecx, DWORD PTR _lpRelField$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax
$L8950:
	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	$L8952

; 4606 :       LPVIEWATTRIB      lpSrcViewAttrib;
; 4607 :       LPVIEWATTRIB      lpRelViewAttrib;
; 4608 :       LPVIEWENTITY      lpRelViewEntity;
; 4609 :       LPVIEWENTITY      lpSrcViewEntity;
; 4610 :       LPENTITYINSTANCE  lpRelInstance;
; 4611 :       LPENTITYINSTANCE  lpSrcInstance;
; 4612 :       LPDATAFIELD       lpWkDataField;
; 4613 : 
; 4614 :       // If the rel field doesn't have a data field, then skip it.
; 4615 :       if ( lpRelField->hRelDataField == 0 )

	mov	eax, DWORD PTR _lpRelField$[ebp]
	cmp	DWORD PTR [eax+14], 0
	jne	SHORT $L8960

; 4616 :          continue;

	jmp	SHORT $L8951
$L8960:

; 4617 : 
; 4618 :       lpWkDataField   = zGETPTR( lpRelField->hSrcDataField );

	mov	ecx, DWORD PTR _lpRelField$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkDataField$8959[ebp], eax

; 4619 :       lpSrcViewAttrib = zGETPTR( lpWkDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpWkDataField$8959[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewAttrib$8953[ebp], eax

; 4620 :       lpWkDataField   = zGETPTR( lpRelField->hRelDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkDataField$8959[ebp], eax

; 4621 :       lpRelViewAttrib = zGETPTR( lpWkDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpWkDataField$8959[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelViewAttrib$8954[ebp], eax

; 4622 :       lpSrcViewEntity = zGETPTR( lpSrcViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpSrcViewAttrib$8953[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$8956[ebp], eax

; 4623 :       lpRelViewEntity = zGETPTR( lpRelViewAttrib->hViewEntity );

	mov	edx, DWORD PTR _lpRelViewAttrib$8954[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelViewEntity$8955[ebp], eax

; 4624 : 
; 4625 :       // We now have the attributes--the source and relationship (i.e. target)
; 4626 :       // attributes.  One is part of the current entity (lpViewEntity) and
; 4627 :       // the other is a parent of the current entity.  Find the entity
; 4628 :       // instance of the parent entity.
; 4629 : 
; 4630 :       if ( lpRelViewEntity != lpViewEntity )

	mov	ecx, DWORD PTR _lpRelViewEntity$8955[ebp]
	cmp	ecx, DWORD PTR _lpViewEntity$[ebp]
	je	$L8967

; 4632 :          // The relationship entity is different from the current entity.
; 4633 :          // Find the relationship entity instance.
; 4634 :          lpSrcInstance = lpEntityInstance;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpSrcInstance$8958[ebp], edx

; 4635 :          lpRelInstance = zGETPTR( lpEntityInstance->hParent );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelInstance$8957[ebp], eax
$L8970:

; 4636 :          while ( lpRelInstance->hViewEntity != lpRelViewAttrib->hViewEntity )

	mov	edx, DWORD PTR _lpRelInstance$8957[ebp]
	mov	eax, DWORD PTR _lpRelViewAttrib$8954[ebp]
	mov	ecx, DWORD PTR [edx+2]
	cmp	ecx, DWORD PTR [eax+6]
	je	SHORT $L8971

; 4638 :             LPVIEWENTITY lpWkRelViewEntity =
; 4639 :                                     zGETPTR( lpRelInstance->hViewEntity );

	mov	edx, DWORD PTR _lpRelInstance$8957[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkRelViewEntity$8972[ebp], eax

; 4640 : 
; 4641 :             // DGC 4/8/97
; 4642 :             // If the parent entity we are looking for is a recursive parent,
; 4643 :             // then it's possible that the entity instance we are looking for
; 4644 :             // has an lpViewEntity that is the recursive child entity.
; 4645 :             if ( lpRelViewEntity->bRecursivePar &&
; 4646 :                  lpWkRelViewEntity->bRecursive &&
; 4647 :                  lpWkRelViewEntity->lEREntTok == lpRelViewEntity->lEREntTok )

	mov	ecx, DWORD PTR _lpRelViewEntity$8955[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 29					; 0000001dH
	and	edx, 1
	test	edx, edx
	je	SHORT $L8974
	mov	eax, DWORD PTR _lpWkRelViewEntity$8972[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8974
	mov	edx, DWORD PTR _lpWkRelViewEntity$8972[ebp]
	mov	eax, DWORD PTR _lpRelViewEntity$8955[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	jne	SHORT $L8974

; 4649 :                break;

	jmp	SHORT $L8971
$L8974:

; 4651 : 
; 4652 :             lpRelInstance = zGETPTR( lpRelInstance->hParent );

	mov	edx, DWORD PTR _lpRelInstance$8957[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelInstance$8957[ebp], eax

; 4653 :          }

	jmp	SHORT $L8970
$L8971:

; 4655 :       else

	jmp	$L8980
$L8967:

; 4657 :          // The source entity is different from the current entity.
; 4658 :          // Find the source entity instance.
; 4659 :          lpRelInstance = lpEntityInstance;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpRelInstance$8957[ebp], ecx

; 4660 :          lpSrcInstance = zGETPTR( lpEntityInstance->hParent );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$8958[ebp], eax
$L8979:

; 4661 :          while ( lpSrcInstance->hViewEntity != lpSrcViewAttrib->hViewEntity )

	mov	ecx, DWORD PTR _lpSrcInstance$8958[ebp]
	mov	edx, DWORD PTR _lpSrcViewAttrib$8953[ebp]
	mov	eax, DWORD PTR [ecx+2]
	cmp	eax, DWORD PTR [edx+6]
	je	SHORT $L8980

; 4663 :             LPVIEWENTITY lpWkSrcViewEntity =
; 4664 :                                     zGETPTR( lpSrcInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSrcInstance$8958[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkSrcViewEntity$8981[ebp], eax

; 4665 : 
; 4666 :             // DGC 4/8/97
; 4667 :             // If the parent entity we are looking for is a recursive parent,
; 4668 :             // then it's possible that the entity instance we are looking for
; 4669 :             // has an lpViewEntity that is the recursive child entity.
; 4670 :             if ( lpSrcViewEntity->bRecursivePar &&
; 4671 :                  lpWkSrcViewEntity->bRecursive &&
; 4672 :                  lpWkSrcViewEntity->lEREntTok == lpSrcViewEntity->lEREntTok )

	mov	eax, DWORD PTR _lpSrcViewEntity$8956[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 29					; 0000001dH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L8983
	mov	edx, DWORD PTR _lpWkSrcViewEntity$8981[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	test	eax, eax
	je	SHORT $L8983
	mov	ecx, DWORD PTR _lpWkSrcViewEntity$8981[ebp]
	mov	edx, DWORD PTR _lpSrcViewEntity$8956[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	jne	SHORT $L8983

; 4674 :                break;

	jmp	SHORT $L8980
$L8983:

; 4676 : 
; 4677 :             lpSrcInstance = zGETPTR( lpSrcInstance->hParent );

	mov	ecx, DWORD PTR _lpSrcInstance$8958[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$8958[ebp], eax

; 4678 :          }

	jmp	SHORT $L8979
$L8980:

; 4680 : 
; 4681 :       if ( lpEntityInstance->u.nInd.bCreated ||
; 4682 :            lpEntityInstance->u.nInd.bIncluded )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L8986
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	je	SHORT $L8985
$L8986:

; 4684 :          zULONG  uLth;
; 4685 :          zPVOID  lpValue;
; 4686 : 
; 4687 :          // If the source instance hasn't had *IT'S* FKs set then skip this
; 4688 :          // one and try again later.
; 4689 :          if ( lpSrcInstance->u.nInd.bForeignKeys )

	mov	ecx, DWORD PTR _lpSrcInstance$8958[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 22					; 00000016H
	and	edx, 1
	test	edx, edx
	je	SHORT $L8989

; 4691 :             // Turn the flag back on for this instance.
; 4692 :             lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 4194304				; 00400000H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 4693 :             return( 1 );

	mov	ax, 1
	jmp	$L8933
$L8989:

; 4695 : 
; 4696 :          fnGetAttrAddrFromEntityInstance( (zCOREMEM) &lpValue,
; 4697 :                                           &uLth,
; 4698 :                                           lpSrcInstance,
; 4699 :                                           lpSrcViewAttrib );

	mov	eax, DWORD PTR _lpSrcViewAttrib$8953[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcInstance$8958[ebp]
	push	ecx
	lea	edx, DWORD PTR _uLth$8987[ebp]
	push	edx
	lea	eax, DWORD PTR _lpValue$8988[ebp]
	push	eax
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H

; 4700 :          fnStoreValueInEntityInstance( lpRelInstance,
; 4701 :                                        lpRelViewEntity,
; 4702 :                                        lpRelViewAttrib,
; 4703 :                                        lpValue, uLth );

	mov	ecx, DWORD PTR _uLth$8987[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpValue$8988[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelViewAttrib$8954[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelViewEntity$8955[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRelInstance$8957[ebp]
	push	edx
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H

; 4705 :       else

	jmp	$L9007
$L8985:

; 4707 :          zDECIMAL d;
; 4708 :          zCHAR    s[ 3 ] = "";

	mov	al, BYTE PTR ??_C@_00A@?$AA@		; `string'
	mov	BYTE PTR _s$8993[ebp], al
	xor	ecx, ecx
	mov	WORD PTR _s$8993[ebp+1], cx

; 4709 :          zPVOID   p;
; 4710 : 
; 4711 :          // Set foreign key to null.
; 4712 :          switch ( lpRelViewAttrib->cType )
; 4713 :          {

	mov	edx, DWORD PTR _lpRelViewAttrib$8954[ebp]
	movsx	eax, BYTE PTR [edx+202]
	mov	DWORD PTR -120+[ebp], eax
	mov	ecx, DWORD PTR -120+[ebp]
	sub	ecx, 68					; 00000044H
	mov	DWORD PTR -120+[ebp], ecx
	cmp	DWORD PTR -120+[ebp], 16		; 00000010H
	ja	SHORT $L8996
	mov	eax, DWORD PTR -120+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L12791[eax]
	jmp	DWORD PTR $L12792[edx*4]
$L8999:

; 4714 :             case zTYPE_DECIMAL:
; 4715 :                SysAssignDecimalFromNull( &d );

	lea	ecx, DWORD PTR _d$8992[ebp]
	push	ecx
	call	_SysAssignDecimalFromNull@4

; 4716 :                p = (zPVOID) &d;

	lea	edx, DWORD PTR _d$8992[ebp]
	mov	DWORD PTR _p$8994[ebp], edx

; 4717 :                break;

	jmp	SHORT $L8996
$L9001:

; 4718 : 
; 4719 :             case zTYPE_INTEGER:
; 4720 :                p = (zPVOID) &lNullInteger;

	mov	DWORD PTR _p$8994[ebp], OFFSET FLAT:_lNullInteger

; 4721 :                break;

	jmp	SHORT $L8996
$L9003:

; 4722 : 
; 4723 :             case zTYPE_STRING:
; 4724 :                p = (zPVOID) s;

	lea	eax, DWORD PTR _s$8993[ebp]
	mov	DWORD PTR _p$8994[ebp], eax

; 4725 :                break;

	jmp	SHORT $L8996
$L9005:

; 4726 : 
; 4727 :             case zTYPE_DATE:
; 4728 :             case zTYPE_DATETIME:
; 4729 :                p = (zPVOID) &stNullDateTime;

	mov	DWORD PTR _p$8994[ebp], OFFSET FLAT:_stNullDateTime
$L8996:

; 4732 : 
; 4733 :          // Gig, 10/4/93
; 4734 :          // If the foreign key is a key to the target entity, then
; 4735 :          // we cannot null the key because we would lose the
; 4736 :          // capability of updating the entity (in this case it
; 4737 :          // better be deleted!!!)
; 4738 :          if ( lpRelViewAttrib->bKey == FALSE )

	mov	ecx, DWORD PTR _lpRelViewAttrib$8954[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9007

; 4740 :             // HH: p points to correct datatype (set in 'switch' above).
; 4741 :             fnStoreValueInEntityInstance( lpRelInstance,
; 4742 :                                           lpRelViewEntity,
; 4743 :                                           lpRelViewAttrib,
; 4744 :                                           (zPVOID) p, 0 );

	push	0
	mov	eax, DWORD PTR _p$8994[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelViewAttrib$8954[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRelViewEntity$8955[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelInstance$8957[ebp]
	push	eax
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
$L9007:

; 4747 : 
; 4748 :       // Turn off the dbh flag to make sure that the DBHandler updates
; 4749 :       // the instance.
; 4750 :       lpRelInstance->u.nInd.bDBHUpdated = FALSE;

	mov	ecx, DWORD PTR _lpRelInstance$8957[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -131073				; fffdffffH
	mov	eax, DWORD PTR _lpRelInstance$8957[ebp]
	mov	DWORD PTR [eax+6], edx

; 4751 : 
; 4752 :    } // for ( lpRelField )...

	jmp	$L8951
$L8952:

; 4753 : 
; 4754 :    return( 0 );

	xor	ax, ax
$L8933:

; 4755 : 
; 4756 : } // fnSetForeignKeysForInstance

	mov	esp, ebp
	pop	ebp
	ret	4
$L12792:
	DD	$L9005
	DD	$L9001
	DD	$L8999
	DD	$L9003
	DD	$L8996
$L12791:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	0
_fnSetForeignKeysForInstance@4 ENDP
_TEXT	ENDS
PUBLIC	_fnCheckCreateDeleteFlags@24
PUBLIC	??_C@_0CL@DMOI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5Warning?5?9?9?9?9?9?9@ ; `string'
PUBLIC	??_C@_06EOKH@create?$AA@			; `string'
PUBLIC	??_C@_06IDPA@delete?$AA@			; `string'
PUBLIC	??_C@_07JPDC@created?$AA@			; `string'
PUBLIC	??_C@_07NAPP@deleted?$AA@			; `string'
PUBLIC	??_C@_0ID@FFNG@Warning?3?5Trying?5to?5commit?5an?5ent@ ; `string'
PUBLIC	??_C@_0CB@PJII@Number?5of?5views?5in?5the?5cluster?3?5@ ; `string'
PUBLIC	??_C@_0CD@IIDP@?$CInull?$CJ?5View?5not?5flagged?5as?5chang@ ; `string'
PUBLIC	??_C@_0O@FMKN@?5?5?5View?5ID?5?$DN?5?$AA@	; `string'
PUBLIC	??_C@_0CD@MHHP@?5?5?5View?5ID?5?$DN?5?$CFlx?0?5Object?5name?5?$DN?5@ ; `string'
PUBLIC	??_C@_05OGKG@?$CFs?4?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BO@HLDF@OD?4Entity?5with?5Create?5flag?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BO@BCNN@OD?4Entity?5with?5Delete?5flag?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_08MGEA@OI?5ID?5?$DN?5?$AA@		; `string'
PUBLIC	??_C@_0CD@MNFM@OD?4Entity?5with?5create?5authority?5@ ; `string'
PUBLIC	??_C@_0KE@LDAH@Warning?3?5Trying?5to?5commit?5an?5ent@ ; `string'
PUBLIC	??_C@_0BE@DMJL@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AA@ ; `string'
EXTRN	_DisplayEntityInstancePath@8:NEAR
;	COMDAT ??_C@_0CL@DMOI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5Warning?5?9?9?9?9?9?9@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CL@DMOI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5Warning?5?9?9?9?9?9?9@ DB '-'
	DB	'---------------- Warning ----------------', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_06EOKH@create?$AA@
_DATA	SEGMENT
??_C@_06EOKH@create?$AA@ DB 'create', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IDPA@delete?$AA@
_DATA	SEGMENT
??_C@_06IDPA@delete?$AA@ DB 'delete', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07JPDC@created?$AA@
_DATA	SEGMENT
??_C@_07JPDC@created?$AA@ DB 'created', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07NAPP@deleted?$AA@
_DATA	SEGMENT
??_C@_07NAPP@deleted?$AA@ DB 'deleted', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0ID@FFNG@Warning?3?5Trying?5to?5commit?5an?5ent@
_DATA	SEGMENT
??_C@_0ID@FFNG@Warning?3?5Trying?5to?5commit?5an?5ent@ DB 'Warning: Tryin'
	DB	'g to commit an entity that has been %s but does not have %s a'
	DB	'uthority in the current cluster.  OD.EntityName = %s.%s', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@PJII@Number?5of?5views?5in?5the?5cluster?3?5@
_DATA	SEGMENT
??_C@_0CB@PJII@Number?5of?5views?5in?5the?5cluster?3?5@ DB 'Number of vie'
	DB	'ws in the cluster: ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@IIDP@?$CInull?$CJ?5View?5not?5flagged?5as?5chang@
_DATA	SEGMENT
??_C@_0CD@IIDP@?$CInull?$CJ?5View?5not?5flagged?5as?5chang@ DB '(null) Vi'
	DB	'ew not flagged as changed', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@FMKN@?5?5?5View?5ID?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0O@FMKN@?5?5?5View?5ID?5?$DN?5?$AA@ DB '   View ID = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@MHHP@?5?5?5View?5ID?5?$DN?5?$CFlx?0?5Object?5name?5?$DN?5@
_DATA	SEGMENT
??_C@_0CD@MHHP@?5?5?5View?5ID?5?$DN?5?$CFlx?0?5Object?5name?5?$DN?5@ DB ' '
	DB	'  View ID = %lx, Object name = %s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05OGKG@?$CFs?4?$CFs?$AA@
_DATA	SEGMENT
??_C@_05OGKG@?$CFs?4?$CFs?$AA@ DB '%s.%s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@HLDF@OD?4Entity?5with?5Create?5flag?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BO@HLDF@OD?4Entity?5with?5Create?5flag?5?$DN?5?$AA@ DB 'OD.Entity '
	DB	'with Create flag = ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@BCNN@OD?4Entity?5with?5Delete?5flag?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BO@BCNN@OD?4Entity?5with?5Delete?5flag?5?$DN?5?$AA@ DB 'OD.Entity '
	DB	'with Delete flag = ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08MGEA@OI?5ID?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_08MGEA@OI?5ID?5?$DN?5?$AA@ DB 'OI ID = ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@MNFM@OD?4Entity?5with?5create?5authority?5@
_DATA	SEGMENT
??_C@_0CD@MNFM@OD?4Entity?5with?5create?5authority?5@ DB 'OD.Entity with '
	DB	'create authority = ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0KE@LDAH@Warning?3?5Trying?5to?5commit?5an?5ent@
_DATA	SEGMENT
??_C@_0KE@LDAH@Warning?3?5Trying?5to?5commit?5an?5ent@ DB 'Warning: Tryin'
	DB	'g to commit an entity that has been %s but does not have %s a'
	DB	'uthority in the current cluster.  OD.EntityName = %s.%s. See '
	DB	'trace for more information.', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DMJL@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AA@
_DATA	SEGMENT
??_C@_0BE@DMJL@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AA@ DB '----------'
	DB	'---------', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpEntityInstance$ = 8
_lpViewArray$ = 12
_lpViewOD_Array$ = 16
_lpViewOI_Array$ = 20
_nViewCount$ = 24
_bCheckCreate$ = 28
_lpViewEntity$ = -8
_lpCandidateViewEntity$ = -24
_lpCandidateViewOD$ = -12
_lpCandidateViewOI$ = -16
_lpViewOI$ = -28
_bShowMsg$ = -4
_k$ = -20
_lpLinked$9032 = -32
_lpLinkedViewEntity$9038 = -36
_szMsg$9054 = -1044
_lpView$9055 = -44
_lpViewOI$9056 = -1048
_lpViewOD$9058 = -40
_lpViewCsr$9063 = -1052
_fnCheckCreateDeleteFlags@24 PROC NEAR

; 4768 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1068				; 0000042cH

; 4769 :    LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4770 :    LPVIEWENTITY lpCandidateViewEntity = 0;

	mov	DWORD PTR _lpCandidateViewEntity$[ebp], 0

; 4771 :    LPVIEWOD     lpCandidateViewOD = 0;

	mov	DWORD PTR _lpCandidateViewOD$[ebp], 0

; 4772 :    LPVIEWOI     lpCandidateViewOI = 0;

	mov	DWORD PTR _lpCandidateViewOI$[ebp], 0

; 4773 :    LPVIEWOI     lpViewOI;
; 4774 :    zBOOL        bShowMsg = TRUE;  // We'll assume a problem.

	mov	BYTE PTR _bShowMsg$[ebp], 1

; 4775 :    zSHORT       k;
; 4776 : 
; 4777 :    // Look for a linked entity instance that has create authority.
; 4778 :    if ( lpEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	$L9037

; 4780 :       LPENTITYINSTANCE lpLinked;
; 4781 : 
; 4782 :       for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 4783 :             lpLinked != lpEntityInstance;
; 4784 :             lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$9032[ebp], eax
	jmp	SHORT $L9035
$L9036:
	mov	edx, DWORD PTR _lpLinked$9032[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$9032[ebp], eax
$L9035:
	mov	ecx, DWORD PTR _lpLinked$9032[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	$L9037

; 4786 :          LPVIEWENTITY lpLinkedViewEntity;
; 4787 : 
; 4788 :          // If the EI doesn't have create authority then skip it.
; 4789 :          lpLinkedViewEntity = zGETPTR( lpLinked->hViewEntity );

	mov	edx, DWORD PTR _lpLinked$9032[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedViewEntity$9038[ebp], eax

; 4790 :          if ( bCheckCreate )

	mov	ecx, DWORD PTR _bCheckCreate$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L9040

; 4792 :             if ( lpLinkedViewEntity->bCreate == FALSE )

	mov	edx, DWORD PTR _lpLinkedViewEntity$9038[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9041

; 4793 :                continue;

	jmp	SHORT $L9036
$L9041:

; 4795 :          else

	jmp	SHORT $L9043
$L9040:

; 4797 :             if ( lpLinkedViewEntity->bDelete == FALSE )

	mov	ecx, DWORD PTR _lpLinkedViewEntity$9038[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9043

; 4798 :                continue;

	jmp	SHORT $L9036
$L9043:

; 4800 : 
; 4801 :          lpViewOI = zGETPTR( lpLinked->hViewOI );

	mov	eax, DWORD PTR _lpLinked$9032[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4802 : 
; 4803 :          // Check to see if the linked EI belongs to one of the
; 4804 :          // OIs in the current cluster.
; 4805 :          for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9045
$L9046:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9045:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L9047

; 4807 :             if ( lpViewArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $L9048

; 4808 :                continue;

	jmp	SHORT $L9046
$L9048:

; 4809 : 
; 4810 :             if ( lpViewOI == lpViewOI_Array[ k ] )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	eax, DWORD PTR [edx+ecx*4]
	jne	SHORT $L9049

; 4812 :                // We found a linked EI in the current cluster with
; 4813 :                // create authority.  Everything's OK.
; 4814 :                bShowMsg = FALSE;

	mov	BYTE PTR _bShowMsg$[ebp], 0

; 4815 :                break;

	jmp	SHORT $L9047
$L9049:

; 4817 :          }

	jmp	SHORT $L9046
$L9047:

; 4818 : 
; 4819 :          if ( bShowMsg == FALSE )

	mov	ecx, DWORD PTR _bShowMsg$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L9050

; 4820 :             break;

	jmp	SHORT $L9037
$L9050:

; 4821 : 
; 4822 :          // If we get here then we've found an EI that has create/delete
; 4823 :          // authority but is not part of an OI in the cluster.
; 4824 :          // This is a candidate for adding to the cluster.
; 4825 :          lpCandidateViewEntity = zGETPTR( lpLinked->hViewEntity );

	mov	edx, DWORD PTR _lpLinked$9032[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCandidateViewEntity$[ebp], eax

; 4826 :          lpCandidateViewOD     = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCandidateViewOD$[ebp], eax

; 4827 :          lpCandidateViewOI     = lpViewOI;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR _lpCandidateViewOI$[ebp], eax

; 4828 :       } // for ( lpLinked...)...

	jmp	$L9036
$L9037:

; 4830 : 
; 4831 :    // If bShowMsg is TRUE then we didn't find an EI with create
; 4832 :    // authority in the current cluster.  Show diagnostic message.
; 4833 :    if ( bShowMsg )

	mov	ecx, DWORD PTR _bShowMsg$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	$L9053

; 4835 :       zCHAR    szMsg[ 1000 ];
; 4836 :       zVIEW    lpView = 0;

	mov	DWORD PTR _lpView$9055[ebp], 0

; 4837 :       LPVIEWOI lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$9056[ebp], eax

; 4838 :       LPVIEWOD lpViewOD = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$9056[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$9058[ebp], eax

; 4839 : 
; 4840 :       // Find the view that references lpViewOI.
; 4841 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9060
$L9061:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9060:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $L9062

; 4843 :          LPVIEWCSR lpViewCsr;
; 4844 : 
; 4845 :          if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $L9064

; 4846 :             continue;

	jmp	SHORT $L9061
$L9064:

; 4847 : 
; 4848 :          lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$9063[ebp], eax

; 4849 :          if ( lpViewCsr->hViewOI == lpEntityInstance->hViewOI )

	mov	eax, DWORD PTR _lpViewCsr$9063[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [eax+10]
	cmp	edx, DWORD PTR [ecx+10]
	jne	SHORT $L9066

; 4851 :             // We found it.
; 4852 :             lpView = lpViewArray[ k ];

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _lpView$9055[ebp], edx

; 4853 :             break;

	jmp	SHORT $L9062
$L9066:

; 4855 :       }

	jmp	SHORT $L9061
$L9062:

; 4856 : 
; 4857 :       TraceLineS( "----------------- Warning ----------------", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CL@DMOI@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?5Warning?5?9?9?9?9?9?9@ ; `string'
	call	_TraceLineS@8

; 4858 :       zsprintf( szMsg, "Warning: Trying to commit an entity that "
; 4859 :                 "has been %s but does not have %s "
; 4860 :                 "authority in the current cluster.  OD.EntityName = %s.%s",
; 4861 :                 bCheckCreate ? "created" : "deleted",
; 4862 :                 bCheckCreate ? "create" : "delete",
; 4863 :                 lpViewOD->szName, lpViewEntity->szName );

	mov	eax, DWORD PTR _bCheckCreate$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L12794
	mov	DWORD PTR -1056+[ebp], OFFSET FLAT:??_C@_06EOKH@create?$AA@ ; `string'
	jmp	SHORT $L12795
$L12794:
	mov	DWORD PTR -1056+[ebp], OFFSET FLAT:??_C@_06IDPA@delete?$AA@ ; `string'
$L12795:
	mov	ecx, DWORD PTR _bCheckCreate$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L12796
	mov	DWORD PTR -1060+[ebp], OFFSET FLAT:??_C@_07JPDC@created?$AA@ ; `string'
	jmp	SHORT $L12797
$L12796:
	mov	DWORD PTR -1060+[ebp], OFFSET FLAT:??_C@_07NAPP@deleted?$AA@ ; `string'
$L12797:
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpViewOD$9058[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR -1056+[ebp]
	push	ecx
	mov	edx, DWORD PTR -1060+[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0ID@FFNG@Warning?3?5Trying?5to?5commit?5an?5ent@ ; `string'
	lea	eax, DWORD PTR _szMsg$9054[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 4864 :       TraceLineS( szMsg, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szMsg$9054[ebp]
	push	ecx
	call	_TraceLineS@8

; 4865 :       TraceLineS( "", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	call	_TraceLineS@8

; 4866 : 
; 4867 :       // List the views in the cluster.
; 4868 :       TraceLineI( "Number of views in the cluster: ", nViewCount );

	movsx	edx, WORD PTR _nViewCount$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CB@PJII@Number?5of?5views?5in?5the?5cluster?3?5@ ; `string'
	call	_TraceLineI@8

; 4869 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9074
$L9075:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9074:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $L9076

; 4871 :          if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $L9077

; 4873 :             TraceLineS( "   View ID = ", "(null) View not flagged as changed" );

	push	OFFSET FLAT:??_C@_0CD@IIDP@?$CInull?$CJ?5View?5not?5flagged?5as?5chang@ ; `string'
	push	OFFSET FLAT:??_C@_0O@FMKN@?5?5?5View?5ID?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 4874 :             continue;

	jmp	SHORT $L9075
$L9077:

; 4876 : 
; 4877 :          zsprintf( szMsg, "   View ID = %lx, Object name = %s",
; 4878 :                    lpViewArray[ k ], lpViewOD_Array[ k ]->szName );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewOD_Array$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, 10					; 0000000aH
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	OFFSET FLAT:??_C@_0CD@MHHP@?5?5?5View?5ID?5?$DN?5?$CFlx?0?5Object?5name?5?$DN?5@ ; `string'
	lea	edx, DWORD PTR _szMsg$9054[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4879 :          TraceLineS( szMsg, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	eax, DWORD PTR _szMsg$9054[ebp]
	push	eax
	call	_TraceLineS@8

; 4880 :       }

	jmp	SHORT $L9075
$L9076:

; 4881 : 
; 4882 : 
; 4883 :       zsprintf( szMsg, "%s.%s", lpViewOD->szName, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$9058[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_05OGKG@?$CFs?4?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szMsg$9054[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4884 :       if ( bCheckCreate )

	mov	ecx, DWORD PTR _bCheckCreate$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L9082

; 4885 :          TraceLineS( "OD.Entity with Create flag = ", szMsg );

	lea	edx, DWORD PTR _szMsg$9054[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BO@HLDF@OD?4Entity?5with?5Create?5flag?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 4886 :       else

	jmp	SHORT $L9084
$L9082:

; 4887 :          TraceLineS( "OD.Entity with Delete flag = ", szMsg );

	lea	eax, DWORD PTR _szMsg$9054[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BO@BCNN@OD?4Entity?5with?5Delete?5flag?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8
$L9084:

; 4888 :       TraceLineX( "OI ID = ", (zLONG) lpViewOI );

	mov	ecx, DWORD PTR _lpViewOI$9056[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_08MGEA@OI?5ID?5?$DN?5?$AA@ ; `string'
	call	_TraceLineX@8

; 4889 : 
; 4890 :       if ( lpCandidateViewEntity )

	cmp	DWORD PTR _lpCandidateViewEntity$[ebp], 0
	je	SHORT $L9088

; 4892 :          zsprintf( szMsg, "%s.%s", lpCandidateViewOD->szName,
; 4893 :                    lpCandidateViewEntity->szName );

	mov	edx, DWORD PTR _lpCandidateViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpCandidateViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET FLAT:??_C@_05OGKG@?$CFs?4?$CFs?$AA@ ; `string'
	lea	ecx, DWORD PTR _szMsg$9054[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4894 :          TraceLineS( "OD.Entity with create authority = ", szMsg );

	lea	edx, DWORD PTR _szMsg$9054[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CD@MNFM@OD?4Entity?5with?5create?5authority?5@ ; `string'
	call	_TraceLineS@8

; 4895 :          TraceLineX( "OI ID = ", (zLONG) lpCandidateViewOI );

	mov	eax, DWORD PTR _lpCandidateViewOI$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08MGEA@OI?5ID?5?$DN?5?$AA@ ; `string'
	call	_TraceLineX@8
$L9088:

; 4897 : 
; 4898 :       TraceLineS( "", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	call	_TraceLineS@8

; 4899 :       CreateViewFromViewForTask( &lpView, lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$9055[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpView$9055[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 4900 :       fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$9055[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 4901 :       DisplayEntityInstancePath( lpView, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$9055[ebp]
	push	eax
	call	_DisplayEntityInstancePath@8

; 4902 :       zsprintf( szMsg, "Warning: Trying to commit an entity that "
; 4903 :                 "has been %s but does not have %s "
; 4904 :                 "authority in the current cluster.  OD.EntityName = %s.%s. "
; 4905 :                 "See trace for more information.",
; 4906 :                 bCheckCreate ? "created" : "deleted",
; 4907 :                 bCheckCreate ? "create" : "delete",
; 4908 :                 lpViewOD->szName, lpViewEntity->szName );

	mov	ecx, DWORD PTR _bCheckCreate$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L12798
	mov	DWORD PTR -1064+[ebp], OFFSET FLAT:??_C@_06EOKH@create?$AA@ ; `string'
	jmp	SHORT $L12799
$L12798:
	mov	DWORD PTR -1064+[ebp], OFFSET FLAT:??_C@_06IDPA@delete?$AA@ ; `string'
$L12799:
	mov	edx, DWORD PTR _bCheckCreate$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L12800
	mov	DWORD PTR -1068+[ebp], OFFSET FLAT:??_C@_07JPDC@created?$AA@ ; `string'
	jmp	SHORT $L12801
$L12800:
	mov	DWORD PTR -1068+[ebp], OFFSET FLAT:??_C@_07NAPP@deleted?$AA@ ; `string'
$L12801:
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$9058[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR -1064+[ebp]
	push	edx
	mov	eax, DWORD PTR -1068+[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0KE@LDAH@Warning?3?5Trying?5to?5commit?5an?5ent@ ; `string'
	lea	ecx, DWORD PTR _szMsg$9054[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 4909 :       SysDiagnosticMessage( lpView, szlOE_SystemError, szMsg, 1 );

	push	1
	lea	edx, DWORD PTR _szMsg$9054[ebp]
	push	edx
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpView$9055[ebp]
	push	ecx
	call	_SysDiagnosticMessage@16

; 4910 :       TraceLineS( "-------------------", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BE@DMJL@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AA@ ; `string'
	call	_TraceLineS@8

; 4911 :       fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$9055[ebp]
	push	edx
	call	_fnDropView@4
$L9053:

; 4913 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnCheckCreateDeleteFlags@24 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@PLOF@Infinite?5loop?5trying?5to?5set?5FKs?$DP@ ; `string'
PUBLIC	_fnInitializeGenKeys@28
PUBLIC	??_C@_0CC@KCFL@No?5GenKey?5handler?5set?5for?5LOD?3?5?$CF@ ; `string'
PUBLIC	??_C@_0CD@FKJO@OIs?5have?5different?5GenKey?5handle@ ; `string'
PUBLIC	??_C@_08HFJA@KZGKHWOB?$AA@			; `string'
PUBLIC	??_C@_09JOKA@_KZGKHWOB?$AA@			; `string'
PUBLIC	??_C@_08OHJM@EntityID?$AA@			; `string'
PUBLIC	??_C@_06JEOF@Genkey?$AA@			; `string'
PUBLIC	??_C@_0M@KMCA@EntityCount?$AA@			; `string'
PUBLIC	??_C@_09JMBN@TableName?$AA@			; `string'
EXTRN	_AddToAttributeFromInteger@16:NEAR
EXTRN	_SetCursorFirstEntityByInteger@20:NEAR
;	COMDAT ??_C@_0CC@KCFL@No?5GenKey?5handler?5set?5for?5LOD?3?5?$CF@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CC@KCFL@No?5GenKey?5handler?5set?5for?5LOD?3?5?$CF@ DB 'No GenKey '
	DB	'handler set for LOD: %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@FKJO@OIs?5have?5different?5GenKey?5handle@
_DATA	SEGMENT
??_C@_0CD@FKJO@OIs?5have?5different?5GenKey?5handle@ DB 'OIs have differe'
	DB	'nt GenKey handlers', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08HFJA@KZGKHWOB?$AA@
_DATA	SEGMENT
??_C@_08HFJA@KZGKHWOB?$AA@ DB 'KZGKHWOB', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JOKA@_KZGKHWOB?$AA@
_DATA	SEGMENT
??_C@_09JOKA@_KZGKHWOB?$AA@ DB '_KZGKHWOB', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08OHJM@EntityID?$AA@
_DATA	SEGMENT
??_C@_08OHJM@EntityID?$AA@ DB 'EntityID', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JEOF@Genkey?$AA@
_DATA	SEGMENT
??_C@_06JEOF@Genkey?$AA@ DB 'Genkey', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@KMCA@EntityCount?$AA@
_DATA	SEGMENT
??_C@_0M@KMCA@EntityCount?$AA@ DB 'EntityCount', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JMBN@TableName?$AA@
_DATA	SEGMENT
??_C@_09JMBN@TableName?$AA@ DB 'TableName', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@PLOF@Infinite?5loop?5trying?5to?5set?5FKs?$DP@
_DATA	SEGMENT
??_C@_0CB@PLOF@Infinite?5loop?5trying?5to?5set?5FKs?$DP@ DB 'Infinite loo'
	DB	'p trying to set FKs?', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpViewEntity$9222 = -356
_lpViewAttrib$9223 = -360
_pDummy$9224 = -348
_uLth$9225 = -352
_lpViewEntity$9251 = -364
_lpViewArray$ = 8
_nViewCount$ = 12
_lpCurrentTask$ = 20
_lpKZGKHWOB$ = 24
_ppGKOper$ = 28
_pViewArrayBlock$ = 32
_hGKHandler$ = -32
_lpViewOI_Array$ = -52
_lpViewOD_Array$ = -56
_lpLastInsertedViewEntity$ = -4
_lpEntityInstance$ = -16
_hTask$ = -36
_vSubtask$ = -48
_bHiddenOnly$ = -24
_bSettingFKs$ = -44
_bGenkeyNeededArray$ = -8
_bFK_NeededArray$ = -20
_nDebugCnt$ = -28
_k$ = -40
_nRC$ = -12
_lpViewCsr$9126 = -60
_szMsg$9142 = -316
_lpViewEntity$9152 = -328
_lpViewAttrib$9153 = -332
_pDummy$9154 = -320
_uLth$9155 = -324
_lpDataRecord$9195 = -336
_lpLinked$9201 = -340
_lpTask$9210 = -344
_fnInitializeGenKeys@28 PROC NEAR

; 4923 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH

; 4924 :    LPGKHANDLER      hGKHandler = 0;

	mov	DWORD PTR _hGKHandler$[ebp], 0

; 4925 :    LPVIEWOI         *lpViewOI_Array = pViewArrayBlock->pViewOI_Array;

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lpViewOI_Array$[ebp], ecx

; 4926 :    LPVIEWOD         *lpViewOD_Array = pViewArrayBlock->pViewOD_Array;

	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lpViewOD_Array$[ebp], eax

; 4927 :    LPVIEWENTITY     lpLastInsertedViewEntity = 0;

	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], 0

; 4928 :    LPENTITYINSTANCE lpEntityInstance;
; 4929 :    LPTASK           hTask;
; 4930 :    zVIEW            vSubtask;
; 4931 :    zBOOL            bHiddenOnly;
; 4932 :    zBOOL            bSettingFKs;
; 4933 :    zBOOL            *bGenkeyNeededArray = pViewArrayBlock->pbGenkeyNeededArray;

	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _bGenkeyNeededArray$[ebp], edx

; 4934 :    zBOOL            *bFK_NeededArray = pViewArrayBlock->pbFK_NeededArray;

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _bFK_NeededArray$[ebp], ecx

; 4935 :    zSHORT           nDebugCnt;
; 4936 :    zSHORT           k;
; 4937 :    zSHORT           nRC;
; 4938 : 
; 4939 :    // Set up support arrays.
; 4940 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9123
$L9124:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9123:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L9125

; 4942 :       LPVIEWCSR lpViewCsr;
; 4943 : 
; 4944 :       if ( lpViewArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $L9127

; 4945 :          continue;

	jmp	SHORT $L9124
$L9127:

; 4946 : 
; 4947 :       lpViewOD_Array[ k ] = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	movsx	edx, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 4948 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$9126[ebp], eax

; 4949 :       lpViewOI_Array[ k ] = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$9126[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	movsx	edx, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 4950 :    }

	jmp	SHORT $L9124
$L9125:

; 4951 : 
; 4952 :    // We'll use one of the views as a subtask view.
; 4953 :    // vSubtask is just the first valid view in the list.
; 4954 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9131
$L9132:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9131:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L9133

; 4956 :       if ( lpViewArray[ k ] )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L9134

; 4958 :          vSubtask = lpViewArray[ k ];

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _vSubtask$[ebp], eax

; 4959 :          break;

	jmp	SHORT $L9133
$L9134:

; 4961 :    }

	jmp	SHORT $L9132
$L9133:

; 4962 : 
; 4963 :    hTask = vSubtask->hTask;

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _hTask$[ebp], edx

; 4964 : 
; 4965 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9135
$L9136:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9135:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$L9137

; 4967 :       bGenkeyNeededArray[ k ] = FALSE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bGenkeyNeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 4968 :       bFK_NeededArray[ k ] = FALSE;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 4969 : 
; 4970 :       if ( lpViewArray[ k ] == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $L9138

; 4971 :          continue;

	jmp	SHORT $L9136
$L9138:

; 4972 : 
; 4973 :       // Check to see if the View has genkeys.  If it does then make sure the
; 4974 :       // genkey handler has been loaded.
; 4975 :       if ( lpViewOD_Array[ k ]->bGenkey )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 9
	and	eax, 1
	test	eax, eax
	je	$L9145

; 4977 :          if ( hGKHandler == 0 )

	cmp	DWORD PTR _hGKHandler$[ebp], 0
	jne	SHORT $L9140

; 4979 :             hGKHandler = lpViewOD_Array[ k ]->hGKHandler;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR _hGKHandler$[ebp], ecx

; 4980 : 
; 4981 :             // Make sure that the GKHandler has been set.
; 4982 :             if ( hGKHandler == 0 )

	cmp	DWORD PTR _hGKHandler$[ebp], 0
	jne	SHORT $L9141

; 4984 :                zCHAR    szMsg[ 256 ];
; 4985 : 
; 4986 :                zsprintf( szMsg, "No GenKey handler set for LOD: %s",
; 4987 :                          lpViewOD_Array[ k ]->szName );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewOD_Array$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0CC@KCFL@No?5GenKey?5handler?5set?5for?5LOD?3?5?$CF@ ; `string'
	lea	edx, DWORD PTR _szMsg$9142[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 4988 :                SysMessageBox( vSubtask, szlOE_SystemError, szMsg, 1 );

	push	1
	lea	eax, DWORD PTR _szMsg$9142[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 4989 :                return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9108
$L9141:

; 4992 :          else

	jmp	SHORT $L9145
$L9140:

; 4994 :             // Make sure that all the views have the same GKHandler.
; 4995 :             if ( lpViewOD_Array[ k ]->hGKHandler != hGKHandler )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+212]
	cmp	eax, DWORD PTR _hGKHandler$[ebp]
	je	SHORT $L9145

; 4997 :                SysMessageBox( vSubtask, szlOE_SystemError,
; 4998 :                               "OIs have different GenKey handlers", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0CD@FKJO@OIs?5have?5different?5GenKey?5handle@ ; `string'
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 4999 :                return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9108
$L9145:

; 5003 : 
; 5004 :       // Go through entity instance looking for entities that need genkeys.
; 5005 :       // Also check to see if the EI needs to set a foreign key.
; 5006 :       for ( lpEntityInstance = zGETPTR( lpViewOI_Array[ k ]->hRootEntityInstance );
; 5007 :             lpEntityInstance;
; 5008 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9149
$L9150:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9149:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9151

; 5010 :          LPVIEWENTITY lpViewEntity;
; 5011 :          LPVIEWATTRIB lpViewAttrib;
; 5012 :          zPVOID       pDummy;
; 5013 :          zULONG       uLth;
; 5014 : 
; 5015 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$9152[ebp], eax

; 5016 : 
; 5017 :          // Entities on a derived path don't get a genkey or a foreign key.
; 5018 :          if ( lpViewEntity->bDerivedPath )

	mov	edx, DWORD PTR _lpViewEntity$9152[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9157
$L9159:

; 5020 :             // If an EI is down a derived path then all children are also a
; 5021 :             // derived path.  We can try to save a little time by ignoring
; 5022 :             // all the children.
; 5023 :             while ( lpEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $L9160

; 5024 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9159
$L9160:

; 5025 : 
; 5026 :             continue;

	jmp	SHORT $L9150
$L9157:

; 5028 : 
; 5029 :          // Check to see if the EI needs to set some foreign keys.
; 5030 :          // NOTE!
; 5031 :          // NOTE! The logic here matches the logic that is in
; 5032 :          // NOTE! fnCommitPreLoops( ). Any changes here should be reflected
; 5033 :          // NOTE! there.
; 5034 :          // NOTE!
; 5035 :          if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	jne	$L9162

; 5037 :             // DGC 99.07.02
; 5038 :             // If the EI is flagged as created and the entity doesn't have
; 5039 :             // create authority then make sure that there is a linked EI in
; 5040 :             // the current cluster that does have create authority.
; 5041 :             if ( lpEntityInstance->u.nInd.bCreated &&
; 5042 :                  lpViewEntity->bCreate == FALSE &&
; 5043 :                  lpViewEntity->bDupInstance == FALSE ) //BL, 2000.01.04 Bugfix Repository

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9163
	mov	edx, DWORD PTR _lpViewEntity$9152[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9163
	mov	ecx, DWORD PTR _lpViewEntity$9152[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 25					; 00000019H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9163

; 5045 :                fnCheckCreateDeleteFlags( lpEntityInstance, lpViewArray,
; 5046 :                                          lpViewOD_Array, lpViewOI_Array,
; 5047 :                                          nViewCount, TRUE );

	push	1
	mov	ax, WORD PTR _nViewCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI_Array$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD_Array$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnCheckCreateDeleteFlags@24
$L9163:

; 5049 : 
; 5050 :             if ( lpEntityInstance->u.nInd.bCreated
; 5051 : #if ( VIEWENT_RULES )
; 5052 :                   && lpViewEntity->bCreate
; 5053 : #endif
; 5054 :                )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $L9164
	mov	ecx, DWORD PTR _lpViewEntity$9152[ebp]
	mov	edx, DWORD PTR [ecx+235]
	and	edx, 1
	test	edx, edx
	je	SHORT $L9164

; 5056 :                // Foreign keys need to be set later.
; 5057 :                bFK_NeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5058 :                lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4194304				; 00400000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5060 :             else

	jmp	SHORT $L9166
$L9164:

; 5062 :                if ( lpEntityInstance->u.nInd.bIncluded &&
; 5063 :                     lpEntityInstance->hParent          &&
; 5064 : #if ( VIEWENT_RULES )
; 5065 :                     lpViewEntity->bInclude &&
; 5066 : #endif
; 5067 :                     ( lpEntityInstance->u.nInd.bCreated == FALSE
; 5068 : #if ( VIEWENT_RULES )
; 5069 :                       || lpViewEntity->bCreate == FALSE
; 5070 : #endif
; 5071 :                   ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	je	SHORT $L9166
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $L9166
	mov	edx, DWORD PTR _lpViewEntity$9152[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L9166
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	je	SHORT $L9167
	mov	eax, DWORD PTR _lpViewEntity$9152[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9166
$L9167:

; 5073 :                   // Foreign keys need to be set later.
; 5074 :                   bFK_NeededArray[ k ] = TRUE;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [eax+edx], 1

; 5075 :                   lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 4194304				; 00400000H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$L9166:

; 5079 :          else

	jmp	$L9172
$L9162:

; 5081 :             if ( lpEntityInstance->u.nInd.bCreated == FALSE &&
; 5082 :                  lpEntityInstance->u.nInd.bIncluded == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	jne	$L9172
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	jne	$L9172

; 5084 :                if ( lpEntityInstance->u.nInd.bExcluded
; 5085 : #if ( VIEWENT_RULES )
; 5086 :                     && lpViewEntity->bExclude
; 5087 : #endif
; 5088 :                   )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	SHORT $L9170
	mov	ecx, DWORD PTR _lpViewEntity$9152[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L9170

; 5090 :                   bFK_NeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5091 :                   lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4194304				; 00400000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5093 :                else

	jmp	SHORT $L9172
$L9170:

; 5094 :                if ( lpEntityInstance->u.nInd.bDeleted
; 5095 : #if ( VIEWENT_RULES )
; 5096 :                     && lpViewEntity->bDelete
; 5097 : #endif
; 5098 :                   )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L9172
	mov	ecx, DWORD PTR _lpViewEntity$9152[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	je	SHORT $L9172

; 5100 :                   bFK_NeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5101 :                   lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4194304				; 00400000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9172:

; 5105 : 
; 5106 :          // At this point we've determined whether an EI needs an FK.  From
; 5107 :          // this point on we're only worried about genkeys.
; 5108 : 
; 5109 :          // If NoGenKey flag is set then we already created a genkey for
; 5110 :          // another linked instance.
; 5111 :          if ( lpEntityInstance->u.nInd.bNoGenKey )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 21					; 00000015H
	and	eax, 1
	test	eax, eax
	je	SHORT $L9173

; 5112 :             continue;

	jmp	$L9150
$L9173:

; 5113 : 
; 5114 :          // We only create genkeys for EIs that were created.  If it's
; 5115 :          // created make sure it's not also deleted.
; 5116 :          if ( lpEntityInstance->u.nInd.bCreated == FALSE ||
; 5117 :               lpEntityInstance->u.nInd.bDeleted )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	je	SHORT $L9175
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 3
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9174
$L9175:

; 5119 :             continue;

	jmp	$L9150
$L9174:

; 5121 : 
; 5122 : #if ( VIEWENT_RULES )
; 5123 :          if ( lpViewEntity->bCreate == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$9152[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9176

; 5124 :             continue;

	jmp	$L9150
$L9176:

; 5125 : #endif
; 5126 : 
; 5127 :          if ( lpViewEntity->bGenkey == FALSE )

	mov	ecx, DWORD PTR _lpViewEntity$9152[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 15					; 0000000fH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9177

; 5128 :             continue;

	jmp	$L9150
$L9177:

; 5129 : 
; 5130 :          // Check to see if the attribute is NULL.  If it is not then
; 5131 :          // we'll ignore it.
; 5132 :          for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 5133 :                lpViewAttrib->bGenkey == FALSE;
; 5134 :                lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewEntity$9152[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9153[ebp], eax
	jmp	SHORT $L9180
$L9181:
	mov	edx, DWORD PTR _lpViewAttrib$9153[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9153[ebp], eax
$L9180:
	mov	ecx, DWORD PTR _lpViewAttrib$9153[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9182

; 5136 :             ; // nothing needs to be done here
; 5137 :          }

	jmp	SHORT $L9181
$L9182:

; 5138 : 
; 5139 :          if ( fnGetAttrAddrFromEntityInstance( (zCOREMEM) &pDummy,
; 5140 :                                                &uLth, lpEntityInstance,
; 5141 :                                                lpViewAttrib ) != -1 )

	mov	eax, DWORD PTR _lpViewAttrib$9153[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _uLth$9155[ebp]
	push	edx
	lea	eax, DWORD PTR _pDummy$9154[ebp]
	push	eax
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	movsx	ecx, ax
	cmp	ecx, -1
	je	SHORT $L9184

; 5143 :             continue;   // Attrib is not null so ignore it.

	jmp	$L9150
$L9184:

; 5145 : 
; 5146 :          // If genkey work object hasn't been activated, then activate it.
; 5147 :          if ( *lpKZGKHWOB == 0 )

	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L9185

; 5149 :             SfActivateSysEmptyOI( lpKZGKHWOB, "KZGKHWOB", vSubtask, zSINGLE );

	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08HFJA@KZGKHWOB?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16

; 5150 :             CreateEntity( *lpKZGKHWOB, "KZGKHWOB", zPOS_FIRST );

	push	1
	push	OFFSET FLAT:??_C@_08HFJA@KZGKHWOB?$AA@	; `string'
	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_CreateEntity@12

; 5151 :             SetNameForView( *lpKZGKHWOB, "_KZGKHWOB", 0, zLEVEL_TASK );

	push	2
	push	0
	push	OFFSET FLAT:??_C@_09JOKA@_KZGKHWOB?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SetNameForView@16
$L9185:

; 5153 : 
; 5154 :          // lpKZGKHWOB is a work object that contains an entity for each
; 5155 :          // entity instance in the OI being committed and the number of
; 5156 :          // entity instances that need genkeys.
; 5157 :          //
; 5158 :          // If the lpViewEntity of the current entity instance is the same
; 5159 :          // as the previous entity instance, then increment the count in
; 5160 :          // lpKZGKHWOB by 1.  If they are different, then we need to find
; 5161 :          // the entity instance in lpKZGKHWOB that corresponds with the
; 5162 :          // current lpEntityInstance.  If one is not found, then it needs
; 5163 :          // to be created.
; 5164 :          if ( lpViewEntity != lpLastInsertedViewEntity )

	mov	eax, DWORD PTR _lpViewEntity$9152[ebp]
	cmp	eax, DWORD PTR _lpLastInsertedViewEntity$[ebp]
	je	$L9189

; 5166 :             // lpViewEntity for current lpEntityInstance does not match
; 5167 :             // last lpEntityInstance.  Try to find the entity in lpKZGKHWOB
; 5168 :             // that corresponds with the lpViewEntity.
; 5169 :             nRC = SetCursorFirstEntityByInteger( *lpKZGKHWOB, "Genkey",
; 5170 :                                                  "EntityID",
; 5171 :                                                  lpViewEntity->lEREntTok, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _lpViewEntity$9152[ebp]
	mov	edx, DWORD PTR [ecx+195]
	push	edx
	push	OFFSET FLAT:??_C@_08OHJM@EntityID?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SetCursorFirstEntityByInteger@20
	mov	WORD PTR _nRC$[ebp], ax

; 5172 :             if ( nRC == zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $L9192

; 5174 :                // Entity was found--increment genkey count by 1.
; 5175 :                AddToAttributeFromInteger( *lpKZGKHWOB, "Genkey",
; 5176 :                                           "EntityCount", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0M@KMCA@EntityCount?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_AddToAttributeFromInteger@16

; 5178 :             else

	jmp	$L9194
$L9192:

; 5180 :                LPDATARECORD lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$9152[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$9195[ebp], eax

; 5181 : 
; 5182 :                // Entity not found--create entity and initialize.
; 5183 :                CreateEntity( *lpKZGKHWOB, "Genkey", zPOS_FIRST );

	push	1
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_CreateEntity@12

; 5184 :                SetAttributeFromInteger( *lpKZGKHWOB, "Genkey",
; 5185 :                                         "EntityID", lpViewEntity->lEREntTok );

	mov	eax, DWORD PTR _lpViewEntity$9152[ebp]
	mov	ecx, DWORD PTR [eax+195]
	push	ecx
	push	OFFSET FLAT:??_C@_08OHJM@EntityID?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SetAttributeFromInteger@16

; 5186 :                SetAttributeFromInteger( *lpKZGKHWOB, "Genkey",
; 5187 :                                         "EntityCount", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0M@KMCA@EntityCount?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SetAttributeFromInteger@16

; 5188 :                SetAttributeFromString( *lpKZGKHWOB, "Genkey",
; 5189 :                                        "TableName", lpDataRecord->szRecordName );

	mov	eax, DWORD PTR _lpDataRecord$9195[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET FLAT:??_C@_09JMBN@TableName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SetAttributeFromString@16

; 5190 :                SetAttributeFromString( *lpKZGKHWOB, "Genkey",
; 5191 :                                        "EntityName", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$9152[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SetAttributeFromString@16
$L9194:

; 5193 : 
; 5194 :             lpLastInsertedViewEntity = lpViewEntity;

	mov	eax, DWORD PTR _lpViewEntity$9152[ebp]
	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], eax

; 5196 :          else

	jmp	SHORT $L9199
$L9189:

; 5197 :             AddToAttributeFromInteger( *lpKZGKHWOB, "Genkey", "EntityCount", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0M@KMCA@EntityCount?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_AddToAttributeFromInteger@16
$L9199:

; 5198 : 
; 5199 :          bGenkeyNeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bGenkeyNeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5200 :          lpEntityInstance->u.nInd.bGenKeyNeeded = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 1048576				; 00100000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5201 : 
; 5202 :          // Set a flag for all linked instances to keep another genkey from
; 5203 :          // being created.
; 5204 :          if ( lpEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $L9206

; 5206 :             LPENTITYINSTANCE lpLinked;
; 5207 : 
; 5208 :             for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 5209 :                   lpLinked != lpEntityInstance;
; 5210 :                   lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$9201[ebp], eax
	jmp	SHORT $L9204
$L9205:
	mov	edx, DWORD PTR _lpLinked$9201[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$9201[ebp], eax
$L9204:
	mov	ecx, DWORD PTR _lpLinked$9201[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L9206

; 5212 :                lpLinked->u.nInd.bNoGenKey = TRUE;

	mov	edx, DWORD PTR _lpLinked$9201[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 2097152				; 00200000H
	mov	ecx, DWORD PTR _lpLinked$9201[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5213 :             }

	jmp	SHORT $L9205
$L9206:

; 5215 : 
; 5216 :       } // for ( lpEntityInstance )...

	jmp	$L9150
$L9151:

; 5217 :    } // for ( k = 0; k < nViewCount; k++ )

	jmp	$L9136
$L9137:

; 5218 : 
; 5219 :    // If the Genkey handler work object has been defined, then call the
; 5220 :    // genkey handler to start transactions.
; 5221 :    if ( *lpKZGKHWOB )

	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$L9215

; 5223 :       if ( fnGetGKHandlerOper( *lpKZGKHWOB, lpCurrentTask, hGKHandler,
; 5224 :                                (zlpPGKHOPER) ppGKOper ) == zCALL_ERROR )

	mov	eax, DWORD PTR _ppGKOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hGKHandler$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fnGetGKHandlerOper
	add	esp, 16					; 00000010H
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $L9209

; 5226 :          LPTASK lpTask = zGETPTR( vSubtask->hTask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$9210[ebp], eax

; 5227 :          // "KZOEE082 - Error starting Genkey handler"
; 5228 :          fnIssueCoreError( lpTask, vSubtask, 16, 82, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	82					; 00000052H
	push	16					; 00000010H
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$9210[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5229 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9108
$L9209:

; 5231 : 
; 5232 :       // Call DBHandler routine to issue start of transaction.
; 5233 :       nRC = (**ppGKOper)( DBH_StartGenkey, vSubtask, 0, 0, *lpKZGKHWOB );

	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	64					; 00000040H
	mov	ecx, DWORD PTR _ppGKOper$[ebp]
	call	DWORD PTR [ecx]
	mov	WORD PTR _nRC$[ebp], ax

; 5234 :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L9212

; 5235 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L9108
$L9212:

; 5236 : 
; 5237 :       // Now set the gen keys.
; 5238 :       lpLastInsertedViewEntity = 0;

	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], 0

; 5239 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9213
$L9214:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9213:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$L9215

; 5241 :          // If we didn't find any genkeys for this view then skip it.
; 5242 :          if ( bGenkeyNeededArray[ k ] == FALSE )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bGenkeyNeededArray$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $L9216

; 5243 :             continue;

	jmp	SHORT $L9214
$L9216:

; 5244 : 
; 5245 :          // Go through entity instance looking for entities that need genkeys.
; 5246 :          for ( lpEntityInstance = zGETPTR( lpViewOI_Array[ k ]->hRootEntityInstance );
; 5247 :                lpEntityInstance;
; 5248 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9219
$L9220:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9219:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9221

; 5250 :             LPVIEWENTITY lpViewEntity;
; 5251 :             LPVIEWATTRIB lpViewAttrib;
; 5252 :             zPVOID       pDummy;
; 5253 :             zULONG       uLth;
; 5254 : 
; 5255 :             // Look for an EI that needs a genkey.
; 5256 :             if ( lpEntityInstance->u.nInd.bGenKeyNeeded == FALSE )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 20					; 00000014H
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9226

; 5257 :                continue;

	jmp	SHORT $L9220
$L9226:

; 5258 : 
; 5259 :             lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$9222[ebp], eax

; 5260 : 
; 5261 :             // Check to see if the attribute is NULL.  If it is not then
; 5262 :             // we'll ignore it.
; 5263 :             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 5264 :                   lpViewAttrib->bGenkey == FALSE;
; 5265 :                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$9222[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9223[ebp], eax
	jmp	SHORT $L9230
$L9231:
	mov	eax, DWORD PTR _lpViewAttrib$9223[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9223[ebp], eax
$L9230:
	mov	edx, DWORD PTR _lpViewAttrib$9223[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9232

; 5267 :                ; // nothing needs to be done here
; 5268 :             }

	jmp	SHORT $L9231
$L9232:

; 5269 : 
; 5270 :             if ( fnGetAttrAddrFromEntityInstance( (zCOREMEM) &pDummy,
; 5271 :                                                   &uLth, lpEntityInstance,
; 5272 :                                                   lpViewAttrib ) != -1 )

	mov	ecx, DWORD PTR _lpViewAttrib$9223[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	lea	eax, DWORD PTR _uLth$9225[ebp]
	push	eax
	lea	ecx, DWORD PTR _pDummy$9224[ebp]
	push	ecx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	movsx	edx, ax
	cmp	edx, -1
	je	SHORT $L9234

; 5274 :                continue;   // attrib is not null so ignore it

	jmp	$L9220
$L9234:

; 5276 : 
; 5277 :             if ( lpViewEntity != lpLastInsertedViewEntity )

	mov	eax, DWORD PTR _lpViewEntity$9222[ebp]
	cmp	eax, DWORD PTR _lpLastInsertedViewEntity$[ebp]
	je	SHORT $L9235

; 5279 :                // lpViewEntity for current lpEntityInstance does not match
; 5280 :                // last lpEntityInstance.  Try to find the entity in lpKZGKHWOB
; 5281 :                // that corresponds with the lpViewEntity.
; 5282 :                nRC = SetCursorFirstEntityByInteger( *lpKZGKHWOB, "Genkey",
; 5283 :                                                     "EntityID",
; 5284 :                                                     lpViewEntity->lEREntTok, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _lpViewEntity$9222[ebp]
	mov	edx, DWORD PTR [ecx+195]
	push	edx
	push	OFFSET FLAT:??_C@_08OHJM@EntityID?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06JEOF@Genkey?$AA@	; `string'
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SetCursorFirstEntityByInteger@20
	mov	WORD PTR _nRC$[ebp], ax

; 5285 : 
; 5286 :                lpLastInsertedViewEntity = lpViewEntity;

	mov	edx, DWORD PTR _lpViewEntity$9222[ebp]
	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], edx
$L9235:

; 5288 : 
; 5289 :             fnEstablishViewForInstance( lpViewArray[ k ], 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 5290 : 
; 5291 :             // Tell genkey handler to set attribute value.
; 5292 :             nRC = (**ppGKOper)( DBH_GetGenkey, lpViewArray[ k ],
; 5293 :                                 lpViewOD_Array[ k ],
; 5294 :                                 lpViewEntity, *lpKZGKHWOB );

	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$9222[ebp]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	push	128					; 00000080H
	mov	ecx, DWORD PTR _ppGKOper$[ebp]
	call	DWORD PTR [ecx]
	mov	WORD PTR _nRC$[ebp], ax

; 5295 :             if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L9236

; 5296 :                return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9108
$L9236:

; 5297 : 
; 5298 :          } // for ( lpEntityInstance )...

	jmp	$L9220
$L9221:

; 5299 : 
; 5300 :       } // for ( k = 0; k < nViewCount; k++ )

	jmp	$L9214
$L9215:

; 5303 : 
; 5304 :    //
; 5305 :    // Now copy FKs.  We have to loop possibly many times to set the FKs.  It's
; 5306 :    // possible that the source for a FK is a FK from yet another EI.  We don't
; 5307 :    // want to copy a FK until we know that the source for a FK has been
; 5308 :    // properly set.  We also want to make sure we set the FK's for the EIs that
; 5309 :    // have been excluded/deleted before we copy FKs for the included/created.
; 5310 :    //
; 5311 :    bHiddenOnly = TRUE;  // We'll start by setting FKs for hidden EIs only.

	mov	BYTE PTR _bHiddenOnly$[ebp], 1

; 5312 :    nDebugCnt   = 0;     // We'll keep a counter in case we get an infinite loop.

	mov	WORD PTR _nDebugCnt$[ebp], 0

; 5313 :    bSettingFKs = TRUE;

	mov	BYTE PTR _bSettingFKs$[ebp], 1
$L9238:

; 5314 :    while ( bSettingFKs )

	mov	eax, DWORD PTR _bSettingFKs$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L9239

; 5316 :       // We'll hope that we're done setting FKs after this iteration.  If we
; 5317 :       // find we need to set more FKs then we'll turn it back on.
; 5318 :       bSettingFKs = FALSE;

	mov	BYTE PTR _bSettingFKs$[ebp], 0

; 5319 : 
; 5320 :       if ( nDebugCnt++ > 100 )

	movsx	ecx, WORD PTR _nDebugCnt$[ebp]
	mov	dx, WORD PTR _nDebugCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nDebugCnt$[ebp], dx
	cmp	ecx, 100				; 00000064H
	jle	SHORT $L9240

; 5322 :          SysMessageBox( vSubtask, szlOE_SystemError,
; 5323 :                         "Infinite loop trying to set FKs?", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0CB@PLOF@Infinite?5loop?5trying?5to?5set?5FKs?$DP@ ; `string'
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 5324 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9108
$L9240:

; 5326 : 
; 5327 :       for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9242
$L9243:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9242:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$L9244

; 5329 :          // If we didn't find any FKs for this view then skip it.
; 5330 :          if ( bFK_NeededArray[ k ] == FALSE )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bFK_NeededArray$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $L9245

; 5331 :             continue;

	jmp	SHORT $L9243
$L9245:

; 5332 : 
; 5333 :          // Let's hope that this view doesn't need FKs set after this
; 5334 :          // iteration.  If it does then we'll turn the flag back on.
; 5335 :          bFK_NeededArray[ k ] = FALSE;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 5336 : 
; 5337 :          // Go through entity instance looking for entities that need genkeys.
; 5338 :          // Also check to see if the EI needs to set a foreign key.
; 5339 :          for ( lpEntityInstance = zGETPTR( lpViewOI_Array[ k ]->hRootEntityInstance );
; 5340 :                lpEntityInstance;
; 5341 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9248
$L9249:
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9248:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9250

; 5343 :             LPVIEWENTITY lpViewEntity;
; 5344 : 
; 5345 :             // If the EI isn't flagged as needing a FK then skip it.
; 5346 :             if ( lpEntityInstance->u.nInd.bForeignKeys == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 22					; 00000016H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9252

; 5347 :                continue;

	jmp	SHORT $L9249
$L9252:

; 5348 : 
; 5349 :             // Entities on a derived path don't get a FK set..
; 5350 :             lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$9251[ebp], eax

; 5351 :             if ( lpViewEntity->bDerivedPath )

	mov	edx, DWORD PTR _lpViewEntity$9251[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9254
$L9256:

; 5353 :                // If an EI is down a derived path then all children are also a
; 5354 :                // derived path.  We can try to save a little time by ignoring
; 5355 :                // all the children.
; 5356 :                while ( lpEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $L9257

; 5357 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9256
$L9257:

; 5358 : 
; 5359 :                continue;

	jmp	SHORT $L9249
$L9254:

; 5361 : 
; 5362 :             // If the EI is not hidden and we're setting FKs for hidden EIs
; 5363 :             // only then set flags for another try.
; 5364 :             if ( lpEntityInstance->u.nInd.bHidden == FALSE && bHiddenOnly )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9259
	mov	eax, DWORD PTR _bHiddenOnly$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L9259

; 5366 :                bFK_NeededArray[ k ] = TRUE;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [edx+ecx], 1

; 5367 :                bSettingFKs = TRUE;

	mov	BYTE PTR _bSettingFKs$[ebp], 1

; 5368 :                continue;

	jmp	$L9249
$L9259:

; 5370 : 
; 5371 :             // Call a function to set the FK.  If the return code is 1 then
; 5372 :             // we couldn't set the FK because a source value hasn't been set
; 5373 :             // yet and we'll have to try again later.
; 5374 :             if ( fnSetForeignKeysForInstance( lpEntityInstance ) == 1 )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnSetForeignKeysForInstance@4
	movsx	ecx, ax
	cmp	ecx, 1
	jne	SHORT $L9260

; 5376 :                bFK_NeededArray[ k ] = TRUE;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [eax+edx], 1

; 5377 :                bSettingFKs = TRUE;

	mov	BYTE PTR _bSettingFKs$[ebp], 1
$L9260:

; 5379 : 
; 5380 :          } // for ( lpEntityInstance )...

	jmp	$L9249
$L9250:

; 5381 : 
; 5382 :       } // for ( k = 0; k < nViewCount; k++ )

	jmp	$L9243
$L9244:

; 5383 : 
; 5384 :       // After one iteration we can set non-hidden FKs.
; 5385 :       bHiddenOnly = FALSE;

	mov	BYTE PTR _bHiddenOnly$[ebp], 0

; 5386 : 
; 5387 :    } // while ( bSettingFKs )...

	jmp	$L9238
$L9239:

; 5388 : 
; 5389 :    return( 0 );

	xor	ax, ax
$L9108:

; 5390 : 
; 5391 : } // fnInitializeGenKeys

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_fnInitializeGenKeys@28 ENDP
_TEXT	ENDS
PUBLIC	_fnMarkDuplicateRelationship@8
_TEXT	SEGMENT
_lpEntityInstance$ = 8
_bIncludeFlag$ = 12
_lpViewOI$ = -20
_lpViewEntity$ = -8
_lpLnkViewEntity$ = -16
_lpParent$ = -4
_lpLnkParent$ = -12
_lpLnkEntityInstance$ = -24
_lpWrkEntityInstance$9284 = -28
_lpGrandParent$9310 = -32
_fnMarkDuplicateRelationship@8 PROC NEAR

; 5399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 5400 :    LPVIEWOI         lpViewOI;
; 5401 :    LPVIEWENTITY     lpViewEntity;
; 5402 :    LPVIEWENTITY     lpLnkViewEntity;
; 5403 :    LPENTITYINSTANCE lpParent;
; 5404 :    LPENTITYINSTANCE lpLnkParent;
; 5405 :    LPENTITYINSTANCE lpLnkEntityInstance;
; 5406 : 
; 5407 :    // Return 0 if instance passed is not linked
; 5408 :    if ( lpEntityInstance->hNextLinked == 0 )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	jne	SHORT $L9273

; 5409 :       return( 0 );

	xor	ax, ax
	jmp	$L9266
$L9273:

; 5410 : 
; 5411 :    // Get Object instance for entity instance
; 5412 :    lpViewOI     = zGETPTR( lpEntityInstance->hViewOI );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 5413 :    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5414 :    lpParent     = zGETPTR( lpEntityInstance->hParent );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$[ebp], eax

; 5415 : 
; 5416 :    // If the parent isn't linked then there are no duplicate relationships.
; 5417 :    if ( lpParent == 0 || lpParent->hNextLinked == 0 )

	cmp	DWORD PTR _lpParent$[ebp], 0
	je	SHORT $L9278
	mov	ecx, DWORD PTR _lpParent$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $L9277
$L9278:

; 5418 :       return( 0 );

	xor	ax, ax
	jmp	$L9266
$L9277:

; 5419 : 
; 5420 :    // Duplicate relationship searching phase I, see if a linked instance to
; 5421 :    // the target instance in the same object instance represents the
; 5422 :    // same relationship type AND has the same parent
; 5423 :    for ( lpLnkEntityInstance = zGETPTR( lpEntityInstance->hNextLinked );
; 5424 :          lpLnkEntityInstance != lpEntityInstance;
; 5425 :          lpLnkEntityInstance = zGETPTR( lpLnkEntityInstance->hNextLinked ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
	jmp	SHORT $L9281
$L9282:
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
$L9281:
	mov	eax, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	$L9283

; 5427 :       LPENTITYINSTANCE lpWrkEntityInstance;
; 5428 : 
; 5429 :       // Check to make sure linked EI has a parent--it is possible for a root
; 5430 :       // to be flagged as included and we don't care about roots.
; 5431 :       if ( lpLnkEntityInstance->u.nInd.bDeleted  ||
; 5432 :            lpLnkEntityInstance->hParent == 0 )

	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9286
	mov	eax, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	DWORD PTR [eax+30], 0
	jne	SHORT $L9285
$L9286:

; 5434 :          continue;

	jmp	SHORT $L9282
$L9285:

; 5436 : 
; 5437 :       // Check for appropriate include/exclude flag.
; 5438 :       if ( bIncludeFlag )

	mov	ecx, DWORD PTR _bIncludeFlag$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L9287

; 5440 :          if ( lpLnkEntityInstance->u.nInd.bIncluded == FALSE ||
; 5441 :               lpLnkEntityInstance->u.nInd.bExcluded )

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	je	SHORT $L9289
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L9288
$L9289:

; 5443 :             continue;

	jmp	SHORT $L9282
$L9288:

; 5446 :       else

	jmp	SHORT $L9291
$L9287:

; 5448 :          if ( lpLnkEntityInstance->u.nInd.bIncluded ||
; 5449 :               lpLnkEntityInstance->u.nInd.bExcluded == FALSE )

	mov	eax, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9292
	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9291
$L9292:

; 5451 :             continue;

	jmp	$L9282
$L9291:

; 5454 : 
; 5455 :       lpLnkViewEntity = zGETPTR( lpLnkEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkViewEntity$[ebp], eax

; 5456 : 
; 5457 :       // Linked EI must have the same relationship and it can't be derived.
; 5458 :       if ( lpLnkViewEntity->lERRelTok != lpViewEntity->lERRelTok ||
; 5459 :            lpLnkViewEntity->bDerivedPath )

	mov	eax, DWORD PTR _lpLnkViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	jne	SHORT $L9295
	mov	eax, DWORD PTR _lpLnkViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9294
$L9295:

; 5461 :          continue;

	jmp	$L9282
$L9294:

; 5463 : 
; 5464 :       // Now check to see if the parent of the linked EI is linked to the
; 5465 :       // parent of the original EI.  If it is then the linked EI and the
; 5466 :       // original EI have the same relationship.
; 5467 : 
; 5468 :       lpLnkParent = zGETPTR( lpLnkEntityInstance->hParent );

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkParent$[ebp], eax

; 5469 : 
; 5470 :       for ( lpWrkEntityInstance = zGETPTR( lpLnkParent->hNextLinked );
; 5471 :             lpWrkEntityInstance && lpWrkEntityInstance != lpLnkParent;
; 5472 :             lpWrkEntityInstance = zGETPTR( lpWrkEntityInstance->hNextLinked ) )

	mov	ecx, DWORD PTR _lpLnkParent$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$9284[ebp], eax
	jmp	SHORT $L9299
$L9300:
	mov	eax, DWORD PTR _lpWrkEntityInstance$9284[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$9284[ebp], eax
$L9299:
	cmp	DWORD PTR _lpWrkEntityInstance$9284[ebp], 0
	je	SHORT $L9301
	mov	edx, DWORD PTR _lpWrkEntityInstance$9284[ebp]
	cmp	edx, DWORD PTR _lpLnkParent$[ebp]
	je	SHORT $L9301

; 5474 :          if ( lpWrkEntityInstance == lpParent )

	mov	eax, DWORD PTR _lpWrkEntityInstance$9284[ebp]
	cmp	eax, DWORD PTR _lpParent$[ebp]
	jne	SHORT $L9302

; 5476 :             // The parents of the two linked EIs are also linked.  Set flag
; 5477 :             // and break loop.
; 5478 :             if ( bIncludeFlag )

	mov	ecx, DWORD PTR _bIncludeFlag$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L9303

; 5479 :                lpLnkEntityInstance->u.nInd.bDBHIncluded = TRUE;

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, -128				; ffffff80H
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5480 :             else

	jmp	SHORT $L9304
$L9303:

; 5481 :                lpLnkEntityInstance->u.nInd.bDBHExcluded = TRUE;

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9304:

; 5482 : 
; 5483 :             break;

	jmp	SHORT $L9301
$L9302:

; 5485 :       }

	jmp	SHORT $L9300
$L9301:

; 5486 :    }

	jmp	$L9282
$L9283:

; 5487 : 
; 5488 :    // Duplicate relationship searching, phase II, see if the parent of
; 5489 :    // the instance has a linked instance representing the same relationship
; 5490 :    // type which is also a child of one of the targets linked instances.
; 5491 :    // (i.e. the same relationship instance inverted).
; 5492 :    for ( lpLnkParent = zGETPTR( lpParent->hNextLinked );
; 5493 :          lpLnkParent != lpParent;
; 5494 :          lpLnkParent = zGETPTR( lpLnkParent->hNextLinked ) )

	mov	edx, DWORD PTR _lpParent$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkParent$[ebp], eax
	jmp	SHORT $L9307
$L9308:
	mov	ecx, DWORD PTR _lpLnkParent$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkParent$[ebp], eax
$L9307:
	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	cmp	eax, DWORD PTR _lpParent$[ebp]
	je	$L9309

; 5496 :       LPENTITYINSTANCE lpGrandParent;
; 5497 : 
; 5498 :       // Check for appropriate include/exclude flag.
; 5499 :       if ( bIncludeFlag )

	mov	ecx, DWORD PTR _bIncludeFlag$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L9311

; 5501 :          if ( lpLnkParent->u.nInd.bIncluded == FALSE ||
; 5502 :               lpLnkParent->u.nInd.bExcluded )

	mov	edx, DWORD PTR _lpLnkParent$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	je	SHORT $L9313
	mov	ecx, DWORD PTR _lpLnkParent$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L9312
$L9313:

; 5504 :             continue;

	jmp	SHORT $L9308
$L9312:

; 5507 :       else

	jmp	SHORT $L9315
$L9311:

; 5509 :          if ( lpLnkParent->u.nInd.bIncluded || lpLnkParent->u.nInd.bExcluded == FALSE )

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9316
	mov	edx, DWORD PTR _lpLnkParent$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9315
$L9316:

; 5510 :             continue;

	jmp	SHORT $L9308
$L9315:

; 5512 : 
; 5513 :       lpLnkViewEntity = zGETPTR( lpLnkParent->hViewEntity );

	mov	ecx, DWORD PTR _lpLnkParent$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkViewEntity$[ebp], eax

; 5514 : 
; 5515 :       // Check to see if the relationship for the EI linked to the parent is
; 5516 :       // the same as the relationship of the original EI.
; 5517 :       if ( lpLnkViewEntity->lERRelTok != lpViewEntity->lERRelTok )

	mov	eax, DWORD PTR _lpLnkViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	je	SHORT $L9318

; 5518 :          continue;  // Nope.

	jmp	$L9308
$L9318:

; 5519 : 
; 5520 :       // OK, we have an EI (lpLnkParent) that has the same relationship as
; 5521 :       // lpEntityInstance.  Check to see if the parent of lpLnkParent (lpGrandParent)
; 5522 :       // is linked with lpEntityInstance.  If they are linked then lpLnkParent
; 5523 :       // has the same physical relationship as lpEntityInstance.
; 5524 :       lpGrandParent = zGETPTR( lpLnkParent->hParent );

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGrandParent$9310[ebp], eax

; 5525 :       for ( lpLnkEntityInstance = zGETPTR( lpEntityInstance->hNextLinked );
; 5526 :             lpLnkEntityInstance != lpEntityInstance;
; 5527 :             lpLnkEntityInstance = zGETPTR( lpLnkEntityInstance->hNextLinked ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
	jmp	SHORT $L9322
$L9323:
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
$L9322:
	mov	eax, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L9324

; 5529 :          if ( lpLnkEntityInstance == lpGrandParent )

	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpGrandParent$9310[ebp]
	jne	SHORT $L9325

; 5531 :             // If we've found an inverted structure in the same
; 5532 :             // object instance which is the same relationship type, set flag.
; 5533 :             if ( bIncludeFlag )

	mov	edx, DWORD PTR _bIncludeFlag$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L9326

; 5534 :                lpLnkParent->u.nInd.bDBHIncluded = TRUE;

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ch, -128				; ffffff80H
	mov	edx, DWORD PTR _lpLnkParent$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 5535 :             else

	jmp	SHORT $L9327
$L9326:

; 5536 :                lpLnkParent->u.nInd.bDBHExcluded = TRUE;

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _lpLnkParent$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L9327:

; 5537 : 
; 5538 :             break;

	jmp	SHORT $L9324
$L9325:

; 5540 :       }

	jmp	SHORT $L9323
$L9324:

; 5541 :    }

	jmp	$L9308
$L9309:

; 5542 : 
; 5543 :    return( 0 );

	xor	ax, ax
$L9266:

; 5544 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnMarkDuplicateRelationship@8 ENDP
_TEXT	ENDS
PUBLIC	_fnCommitPreLoops
EXTRN	_fnCreateAttributeRecord:NEAR
EXTRN	_fnEntityInstanceIsDead@4:NEAR
EXTRN	_fnGetAttribFlagsPtr@8:NEAR
_TEXT	SEGMENT
_lpView$ = 12
_plpLastEntityInstance$ = 16
_plHiddenCnt$ = 20
_lpViewOD$ = -16
_lpViewOI$ = -36
_lpViewCsr$ = -8
_lpViewEntity$ = -28
_lpLastInsertedViewEntity$ = -4
_lpEntityInstance$ = -24
_lpRootEntityInstance$ = -12
_lpDataRecord$ = -44
_lpViewAttrib$ = -32
_lpRelRecord$ = -40
_nRC$ = -20
_uLth$9363 = -48
_lSeq$9364 = -60
_lpSeqPtr$9365 = -52
_lpTwin$9366 = -56
_lpAttribFlags$9380 = -64
_fnCommitPreLoops PROC NEAR

; 5575 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 5576 :    LPVIEWOD             lpViewOD;
; 5577 :    LPVIEWOI             lpViewOI;
; 5578 :    LPVIEWCSR            lpViewCsr;
; 5579 :    LPVIEWENTITY         lpViewEntity;
; 5580 :    LPVIEWENTITY         lpLastInsertedViewEntity;
; 5581 :    LPENTITYINSTANCE     lpEntityInstance;
; 5582 :    LPENTITYINSTANCE     lpRootEntityInstance;
; 5583 :    LPDATARECORD         lpDataRecord;
; 5584 :    LPVIEWATTRIB         lpViewAttrib;
; 5585 :    LPRELRECORD          lpRelRecord;
; 5586 :    zSHORT               nRC;
; 5587 : 
; 5588 :    lpLastInsertedViewEntity = 0;

	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], 0

; 5589 : 
; 5590 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 5591 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 5592 :    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 5593 :    lpRootEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$[ebp], eax

; 5594 : 
; 5595 :    // Change the "hidden" indicator to false if the entity instance was
; 5596 :    // deleted.  This will allow the db-handler to access the entity instance.
; 5597 :    *plHiddenCnt = 0;

	mov	edx, DWORD PTR _plHiddenCnt$[ebp]
	mov	DWORD PTR [edx], 0

; 5598 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 5599 :    for ( lpEntityInstance = lpRootEntityInstance;
; 5600 :          lpEntityInstance;
; 5601 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9354
$L9355:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9354:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9356

; 5603 :       // Keep track of the last valid EI.
; 5604 :       *plpLastEntityInstance = lpEntityInstance;

	mov	eax, DWORD PTR _plpLastEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax], ecx

; 5605 : 
; 5606 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5607 : 
; 5608 :       // If it is a derived path, skip it
; 5609 :       if ( lpViewEntity->bDerivedPath )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	test	edx, edx
	je	SHORT $L9358

; 5610 :          continue;

	jmp	SHORT $L9355
$L9358:

; 5611 : 
; 5612 :       lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 5613 : 
; 5614 :       // If it has no data record, skip it
; 5615 :       if ( lpDataRecord == 0 )

	cmp	DWORD PTR _lpDataRecord$[ebp], 0
	jne	SHORT $L9360

; 5616 :          continue;

	jmp	SHORT $L9355
$L9360:

; 5617 : 
; 5618 :       lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 5619 : 
; 5620 :       // If the entity for the current entity instance has an automatic
; 5621 :       // sequence attribute AND it is the first twin under its parent,
; 5622 :       // ensure that the sequence numbers for all the twins are correct.
; 5623 :       if ( lpViewEntity->bAutoSeq &&
; 5624 :            lpEntityInstance->hPrevTwin == 0 &&  // Must be first twin.
; 5625 :            lpEntityInstance->hNextTwin )   // Don't bother if only 1 twin.

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 20					; 00000014H
	and	edx, 1
	test	edx, edx
	je	$L9374
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	$L9374
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	$L9374

; 5627 :          zULONG           uLth;
; 5628 :          zLONG            lSeq;
; 5629 :          zPLONG           lpSeqPtr;
; 5630 :          LPENTITYINSTANCE lpTwin;
; 5631 : 
; 5632 :          // First, find the autoseq view attrib.
; 5633 :          lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L9369:

; 5634 :          while ( lpViewAttrib->bAutoSeq == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9370

; 5635 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L9369
$L9370:

; 5636 : 
; 5637 :          // For each of the twins, set the seq attribute.
; 5638 :          lSeq = 1;

	mov	DWORD PTR _lSeq$9364[ebp], 1

; 5639 :          lpTwin = lpEntityInstance;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpTwin$9366[ebp], edx
$L9373:

; 5640 :          while ( lpTwin )

	cmp	DWORD PTR _lpTwin$9366[ebp], 0
	je	$L9374

; 5642 :             // If the twin wasn't deleted, then set it's sequence number.
; 5643 :             if ( lpTwin->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpTwin$9366[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	jne	$L9375

; 5645 :                // Make sure the entity instance has a data record.
; 5646 :                if ( lpTwin->hPersistRecord == 0 )

	mov	edx, DWORD PTR _lpTwin$9366[ebp]
	cmp	DWORD PTR [edx+60], 0
	jne	SHORT $L9376

; 5647 :                   fnCreateAttributeRecord( zGETPTR( lpViewOI->hAllocTask ),
; 5648 :                                            lpViewEntity, lpTwin );

	mov	eax, DWORD PTR _lpTwin$9366[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnCreateAttributeRecord
	add	esp, 12					; 0000000cH
$L9376:

; 5649 : 
; 5650 :                fnGetAttrAddrFromEntityInstance( (zCOREMEM) &lpSeqPtr, &uLth,
; 5651 :                                                 lpTwin, lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTwin$9366[ebp]
	push	edx
	lea	eax, DWORD PTR _uLth$9363[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSeqPtr$9365[ebp]
	push	ecx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H

; 5652 : 
; 5653 :                // Only update sequence attribute if the value of the seqence
; 5654 :                // attribute in the entity is different from the local counter.
; 5655 :                if ( *lpSeqPtr != lSeq )

	mov	edx, DWORD PTR _lpSeqPtr$9365[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lSeq$9364[ebp]
	je	SHORT $L9379

; 5657 :                   LPATTRIBFLAGS lpAttribFlags;
; 5658 : 
; 5659 :                   *lpSeqPtr = lSeq;

	mov	ecx, DWORD PTR _lpSeqPtr$9365[ebp]
	mov	edx, DWORD PTR _lSeq$9364[ebp]
	mov	DWORD PTR [ecx], edx

; 5660 :                   lpTwin->u.nInd.bSequenceUpdt = TRUE;

	mov	eax, DWORD PTR _lpTwin$9366[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 524288				; 00080000H
	mov	edx, DWORD PTR _lpTwin$9366[ebp]
	mov	DWORD PTR [edx+6], ecx

; 5661 : 
; 5662 :                   // Since changing the attribute value via a pointer doesn't
; 5663 :                   // change the attrib flag do so now.
; 5664 :                   lpAttribFlags = fnGetAttribFlagsPtr( lpTwin, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTwin$9366[ebp]
	push	ecx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$9380[ebp], eax

; 5665 :                   lpAttribFlags->u.bFlags.bUpdated = TRUE;

	mov	edx, DWORD PTR _lpAttribFlags$9380[ebp]
	mov	eax, DWORD PTR [edx]
	or	al, 2
	mov	ecx, DWORD PTR _lpAttribFlags$9380[ebp]
	mov	DWORD PTR [ecx], eax

; 5666 : 
; 5667 :                   // Turn off the bDBHUpdated flag (if it's on) so that we
; 5668 :                   // make sure the entity is updated.  If the entity instance
; 5669 :                   // is linked with someone else it's possible that the
; 5670 :                   // entity was updated through the other link.
; 5671 :                   lpEntityInstance->u.nInd.bDBHUpdated = FALSE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -131073				; fffdffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9379:

; 5673 : 
; 5674 :                lSeq++;

	mov	edx, DWORD PTR _lSeq$9364[ebp]
	add	edx, 1
	mov	DWORD PTR _lSeq$9364[ebp], edx
$L9375:

; 5676 : 
; 5677 :             lpTwin = zGETPTR( lpTwin->hNextTwin );

	mov	eax, DWORD PTR _lpTwin$9366[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTwin$9366[ebp], eax

; 5678 :          }

	jmp	$L9373
$L9374:

; 5680 : 
; 5681 :       if ( lpEntityInstance->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9383

; 5683 :          // Increment Hidden counter
; 5684 :          (*plHiddenCnt)++;

	mov	ecx, DWORD PTR _plHiddenCnt$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _plHiddenCnt$[ebp]
	mov	DWORD PTR [eax], edx

; 5685 : 
; 5686 :          // Unhide the instance so the DBHandler can access it unless it is
; 5687 :          // "dead".  If it's "dead" the the DBHandler shouldn't care about it.
; 5688 :          if ( !fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnEntityInstanceIsDead@4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L9383

; 5689 :             lpEntityInstance->u.nInd.bHidden = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ch, -5					; fffffffbH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L9383:

; 5691 : 
; 5692 :    }  // for ( lpEntityInstance )...

	jmp	$L9355
$L9356:

; 5693 : 
; 5694 :    return( 0 );

	xor	ax, ax

; 5695 : 
; 5696 : } // fnCommitPreLoops

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCommitPreLoops ENDP
_TEXT	ENDS
PUBLIC	_fnCleanupInstance
PUBLIC	_fnDropViewCsr
EXTRN	_fnResetCursorForViewChildren:NEAR
EXTRN	_fnReclaimHiddenInstances@4:NEAR
EXTRN	_fnInstanceLinkedToInstance:NEAR
_TEXT	SEGMENT
_lpView$ = 8
_lHiddenCnt$ = 12
_lpViewCsr$ = -4
_lpViewOI$ = -28
_lpViewEntity$ = -16
_lpRootEntityInstance$ = -8
_lpEntityInstance$ = -12
_lpNextLinked$ = -24
_lpWrkViewCsr$ = -20
_lpNextViewCsr$9403 = -32
_lpViewEntityCsr$9408 = -40
_uIdx$9409 = -36
_lpViewAttrib$9423 = -48
_lpParent$9424 = -44
_lpAttribFlags$9433 = -52
_lpLinkedViewEntity$9441 = -56
_lpLinkedViewEntity$9461 = -60
_fnCleanupInstance PROC NEAR

; 5718 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 5719 :    LPVIEWCSR         lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 5720 :    LPVIEWOI          lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 5721 :    LPVIEWENTITY      lpViewEntity;
; 5722 :    LPENTITYINSTANCE  lpRootEntityInstance;
; 5723 :    LPENTITYINSTANCE  lpEntityInstance;
; 5724 :    LPENTITYINSTANCE  lpNextLinked;
; 5725 :    LPVIEWCSR         lpWrkViewCsr;
; 5726 : 
; 5727 :    // Clean up any view cursors which point to a hidden entity
; 5728 :    // If the root was deleted, delete all view cursors except the one
; 5729 :    // used in this call - REMOVED 1/22/93...Causes reclamation problems and
; 5730 :    // also does not account for multiple roots in the instance, the
; 5731 :    // reclamation code below will clean up the instance except for
; 5732 :    // the deleted root, This is enough cleanup under the circumstances
; 5733 :    // 1/22/93 ... Gig
; 5734 :    lpRootEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$[ebp], eax

; 5735 :    lpWrkViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewCsr$[ebp], eax
$L9401:

; 5736 :    while ( lpWrkViewCsr )

	cmp	DWORD PTR _lpWrkViewCsr$[ebp], 0
	je	$L9402

; 5738 :       LPVIEWCSR lpNextViewCsr;
; 5739 : 
; 5740 :       lpNextViewCsr = zGETPTR( lpWrkViewCsr->hNextViewCsr );

	mov	edx, DWORD PTR _lpWrkViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewCsr$9403[ebp], eax

; 5741 : 
; 5742 :       // Get rid of any view cursors whose parent entity instance has been
; 5743 :       // deleted
; 5744 :       lpEntityInstance = zGETPTR( lpWrkViewCsr->hViewParentEntityInstance );

	mov	ecx, DWORD PTR _lpWrkViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 5745 :       if ( lpEntityInstance && lpEntityInstance->u.nInd.bHidden )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L9406
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9406

; 5746 :          fnDropViewCsr( lpWrkViewCsr );

	mov	edx, DWORD PTR _lpWrkViewCsr$[ebp]
	push	edx
	call	_fnDropViewCsr
	add	esp, 4

; 5747 :       else

	jmp	$L9413
$L9406:

; 5749 :          // Go through all view entity cursors (except the root) and set all
; 5750 :          // cursors pointing to a hidden instance to unset.
; 5751 :          LPVIEWENTITYCSR lpViewEntityCsr;
; 5752 :          zUSHORT         uIdx;
; 5753 : 
; 5754 :          // Turn Off Hierarchical stuff in ViewCsr
; 5755 :          lpViewCsr->hHierRootEntityInstance = 0;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [eax+22], 0

; 5756 :          lpViewCsr->hHierEntityInstance = 0;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [ecx+26], 0

; 5757 : 
; 5758 :          lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$9408[ebp], eax

; 5759 :          lpViewEntityCsr++;  // Skip the root.

	mov	ecx, DWORD PTR _lpViewEntityCsr$9408[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpViewEntityCsr$9408[ebp], ecx

; 5760 :          for ( uIdx = 2; uIdx <= lpViewCsr->uEntities; uIdx++ )

	mov	WORD PTR _uIdx$9409[ebp], 2
	jmp	SHORT $L9411
$L9412:
	mov	dx, WORD PTR _uIdx$9409[ebp]
	add	dx, 1
	mov	WORD PTR _uIdx$9409[ebp], dx
$L9411:
	mov	eax, DWORD PTR _uIdx$9409[ebp]
	and	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+34]
	cmp	eax, edx
	jg	SHORT $L9413

; 5762 :             lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$9408[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 5763 :             if ( lpEntityInstance && lpEntityInstance != UNSET_CSR &&
; 5764 :                  lpEntityInstance->u.nInd.bHidden )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L9416
	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	je	SHORT $L9416
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9416

; 5766 :                if ( lpEntityInstance != lpRootEntityInstance )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpRootEntityInstance$[ebp]
	je	SHORT $L9417

; 5768 :                   lpViewEntityCsr->hEntityInstance = UNSET_CSR;

	mov	edx, DWORD PTR _lpViewEntityCsr$9408[ebp]
	mov	DWORD PTR [edx+26], 1
$L9417:

; 5772 : 
; 5773 :                fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$9408[ebp]
	push	eax
	call	_fnResetCursorForViewChildren
	add	esp, 4
$L9416:

; 5775 : 
; 5776 :             lpViewEntityCsr++;

	mov	ecx, DWORD PTR _lpViewEntityCsr$9408[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpViewEntityCsr$9408[ebp], ecx

; 5777 :          }

	jmp	SHORT $L9412
$L9413:

; 5779 : 
; 5780 :       lpWrkViewCsr = lpNextViewCsr;

	mov	edx, DWORD PTR _lpNextViewCsr$9403[ebp]
	mov	DWORD PTR _lpWrkViewCsr$[ebp], edx

; 5781 :    }

	jmp	$L9401
$L9402:

; 5782 : 
; 5783 :    // Now un-mark all created, updated and included instances and
; 5784 :    // remove any deleted instances
; 5785 :    for ( lpEntityInstance = lpRootEntityInstance;
; 5786 :          lpEntityInstance;
; 5787 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9420
$L9421:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9420:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9422

; 5789 :       LPVIEWATTRIB     lpViewAttrib;
; 5790 :       LPENTITYINSTANCE lpParent;
; 5791 : 
; 5792 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5793 : 
; 5794 :       // Skip the entity if the DBH didn't do anything
; 5795 :       if ( lpEntityInstance->u.nInd.bDBHCreated == FALSE &&
; 5796 :            lpEntityInstance->u.nInd.bDBHIncluded == FALSE &&
; 5797 :            lpEntityInstance->u.nInd.bDBHDeleted == FALSE &&
; 5798 :            lpEntityInstance->u.nInd.bDBHExcluded == FALSE &&
; 5799 :            lpEntityInstance->u.nInd.bDBHUpdated == FALSE )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9426
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 15					; 0000000fH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9426
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9426
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 16					; 00000010H
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9426
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 17					; 00000011H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9426

; 5801 :          continue;

	jmp	SHORT $L9421
$L9426:

; 5803 : 
; 5804 :       lpEntityInstance->u.nInd.bCreated =
; 5805 :          lpEntityInstance->u.nInd.bUpdated =
; 5806 :          lpEntityInstance->u.nInd.bDeleted =
; 5807 :          lpEntityInstance->u.nInd.bIncluded =
; 5808 :          lpEntityInstance->u.nInd.bExcluded = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 5809 : 
; 5810 :       // If the EI was not updated, deleted, or created then we are done with
; 5811 :       // this entity.
; 5812 :       if ( lpEntityInstance->u.nInd.bDBHCreated == FALSE &&
; 5813 :            lpEntityInstance->u.nInd.bDBHDeleted == FALSE &&
; 5814 :            lpEntityInstance->u.nInd.bDBHUpdated == FALSE )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9427
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9427
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 17					; 00000011H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9427

; 5816 :          continue;

	jmp	$L9421
$L9427:

; 5818 : 
; 5819 :       // Turn off the updated flag for each of the attributes.
; 5820 :       for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 5821 :             lpViewAttrib;
; 5822 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9423[ebp], eax
	jmp	SHORT $L9430
$L9431:
	mov	edx, DWORD PTR _lpViewAttrib$9423[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9423[ebp], eax
$L9430:
	cmp	DWORD PTR _lpViewAttrib$9423[ebp], 0
	je	SHORT $L9432

; 5824 :          LPATTRIBFLAGS lpAttribFlags;
; 5825 : 
; 5826 :          // Skip non-persistent attributes.
; 5827 :          if ( lpViewAttrib->bPersist == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$9423[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9434

; 5828 :             continue;

	jmp	SHORT $L9431
$L9434:

; 5829 : 
; 5830 :          lpAttribFlags = fnGetAttribFlagsPtr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$9423[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$9433[ebp], eax

; 5831 :          lpAttribFlags->u.bFlags.bUpdated = FALSE;

	mov	edx, DWORD PTR _lpAttribFlags$9433[ebp]
	mov	eax, DWORD PTR [edx]
	and	al, -3					; fffffffdH
	mov	ecx, DWORD PTR _lpAttribFlags$9433[ebp]
	mov	DWORD PTR [ecx], eax

; 5832 :       }

	jmp	SHORT $L9431
$L9432:

; 5833 : 
; 5834 :       // Set flags for other linked instances.  If this instance isn't linked
; 5835 :       // then go on to next one.
; 5836 :       if ( lpEntityInstance->hNextLinked == 0 )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	jne	SHORT $L9435

; 5837 :          continue;

	jmp	$L9421
$L9435:

; 5838 : 
; 5839 :       for ( lpNextLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 5840 :             lpNextLinked != lpEntityInstance;
; 5841 :             lpNextLinked = zGETPTR( lpNextLinked->hNextLinked ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax
	jmp	SHORT $L9438
$L9439:
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax
$L9438:
	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	$L9440

; 5843 :          LPVIEWENTITY lpLinkedViewEntity = zGETPTR( lpNextLinked->hViewEntity );

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedViewEntity$9441[ebp], eax

; 5844 : 
; 5845 :          // Turn off flags in linked entities depending on what the DBHandler
; 5846 :          // did to the current EI.
; 5847 :          if ( lpEntityInstance->u.nInd.bDBHCreated )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	test	edx, edx
	je	SHORT $L9443

; 5848 :             lpNextLinked->u.nInd.bCreated = FALSE;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L9443:

; 5849 : 
; 5850 :          if ( lpEntityInstance->u.nInd.bDBHUpdated )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 17					; 00000011H
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9444

; 5851 :             lpNextLinked->u.nInd.bUpdated = FALSE;

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	al, -5					; fffffffbH
	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9444:

; 5852 : 
; 5853 :          if ( lpEntityInstance->u.nInd.bDBHDeleted )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9445

; 5854 :             lpNextLinked->u.nInd.bDeleted = FALSE;

	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -9					; fffffff7H
	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [eax+6], edx
$L9445:

; 5855 : 
; 5856 :          // Do some more processing if the EI is included/excluded.  If not
; 5857 :          // inc/exc then skip it.
; 5858 :          if ( lpEntityInstance->u.nInd.bDBHIncluded == FALSE &&
; 5859 :               lpEntityInstance->u.nInd.bDBHExcluded == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 15					; 0000000fH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9446
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 16					; 00000010H
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9446

; 5861 :             continue;

	jmp	$L9439
$L9446:

; 5863 : 
; 5864 :          // If lpEntityInstance and lpNextLinked have the same relationship
; 5865 :          // with their respective parents then we don't want to inc/exc the
; 5866 :          // lpNextLinked because it's already been done.  If the two EIs are
; 5867 :          // in the same OI then they must have the same linked parents.
; 5868 :          if ( lpNextLinked->hViewOI == lpEntityInstance->hViewOI ||
; 5869 :               ( lpLinkedViewEntity->lERRelTok == lpViewEntity->lERRelTok &&
; 5870 :                 fnInstanceLinkedToInstance( zGETPTR( lpNextLinked->hParent ),
; 5871 :                                             zGETPTR( lpEntityInstance->hParent ) ) ) )

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+10]
	je	SHORT $L9450
	mov	edx, DWORD PTR _lpLinkedViewEntity$9441[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+199]
	cmp	ecx, DWORD PTR [eax+199]
	jne	SHORT $L9452
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInstanceLinkedToInstance
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L9452
$L9450:

; 5873 :             if ( lpEntityInstance->u.nInd.bDBHIncluded )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 15					; 0000000fH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9451

; 5874 :                lpNextLinked->u.nInd.bIncluded = FALSE;

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	al, -33					; ffffffdfH
	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9451:

; 5875 : 
; 5876 :             if ( lpEntityInstance->u.nInd.bDBHExcluded )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 16					; 00000010H
	and	eax, 1
	test	eax, eax
	je	SHORT $L9452

; 5877 :                lpNextLinked->u.nInd.bExcluded = FALSE;

	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [eax+6], edx
$L9452:

; 5879 :       }

	jmp	$L9439
$L9440:

; 5880 : 
; 5881 :       // if the instance has a parent and the parent is linked, see
; 5882 :       // if one of the linked parents is an inverted representation
; 5883 :       // of the same relationship
; 5884 :       lpParent = zGETPTR( lpEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$9424[ebp], eax

; 5885 :       if ( lpParent == 0 || lpParent->hNextLinked == 0 )

	cmp	DWORD PTR _lpParent$9424[ebp], 0
	je	SHORT $L9455
	mov	eax, DWORD PTR _lpParent$9424[ebp]
	cmp	DWORD PTR [eax+42], 0
	jne	SHORT $L9454
$L9455:

; 5886 :          continue;

	jmp	$L9421
$L9454:

; 5887 : 
; 5888 :       for ( lpNextLinked = zGETPTR( lpParent->hNextLinked );
; 5889 :             lpNextLinked != lpParent;
; 5890 :             lpNextLinked = zGETPTR( lpNextLinked->hNextLinked ) )

	mov	ecx, DWORD PTR _lpParent$9424[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax
	jmp	SHORT $L9458
$L9459:
	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax
$L9458:
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	cmp	edx, DWORD PTR _lpParent$9424[ebp]
	je	SHORT $L9460

; 5892 :          LPVIEWENTITY lpLinkedViewEntity = zGETPTR( lpNextLinked->hViewEntity );

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedViewEntity$9461[ebp], eax

; 5893 : 
; 5894 :          if ( lpNextLinked->hParent &&
; 5895 :               lpLinkedViewEntity->lERRelTok == lpViewEntity->lERRelTok &&
; 5896 :               fnInstanceLinkedToInstance( zGETPTR( lpNextLinked->hParent ),
; 5897 :                                           lpEntityInstance ) )

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	SHORT $L9464
	mov	eax, DWORD PTR _lpLinkedViewEntity$9461[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	jne	SHORT $L9464
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInstanceLinkedToInstance
	add	esp, 8
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L9464

; 5899 :             lpNextLinked->u.nInd.bIncluded = FALSE;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 5900 :             lpNextLinked->u.nInd.bExcluded = FALSE;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L9464:

; 5902 :       }

	jmp	$L9459
$L9460:

; 5903 : 
; 5904 :    } // for each lpEntityInstance...

	jmp	$L9421
$L9422:

; 5905 : 
; 5906 :    // Call fnReclaim to clean up deleted instances
; 5907 :    if ( lHiddenCnt )

	cmp	DWORD PTR _lHiddenCnt$[ebp], 0
	je	SHORT $L9465

; 5908 :       fnReclaimHiddenInstances( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnReclaimHiddenInstances@4
$L9465:

; 5909 : 
; 5910 : } // fnCleanupInstance

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCleanupInstance ENDP
_TEXT	ENDS
PUBLIC	_fnDeleteLocksOnTwins@24
PUBLIC	??_C@_03LNBB@?$EA?$CFs?$AA@			; `string'
PUBLIC	_fnCreateConcatKey@16
;	COMDAT ??_C@_03LNBB@?$EA?$CFs?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_03LNBB@?$EA?$CFs?$AA@ DB '@%s', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_vLock$ = 12
_lpFirstEntityInstance$ = 16
_lpView$ = 20
_bLOD_Lock$ = 24
_lpLockEntity$ = -8
_lpViewEntity$ = -56
_lpViewAttrib$ = -64
_lpKeyViewAttrib$ = -224
_lpEntityInstance$ = -52
_lpLockEntityCsr$ = -432
_lpViewOD$ = -4
_szKeyString$ = -428
_szLockName$ = -48
_nKeyCnt$ = -60
_nRC$ = -12
_lpLockEntityInstance$9506 = -436
_fnDeleteLocksOnTwins@24 PROC NEAR

; 5921 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 436				; 000001b4H

; 5922 :    LPVIEWENTITY      lpLockEntity;
; 5923 :    LPVIEWENTITY      lpViewEntity;
; 5924 :    LPVIEWATTRIB      lpViewAttrib;
; 5925 :    LPVIEWATTRIB      lpKeyViewAttrib[ zMAX_KEYS_FOR_LOCK ];
; 5926 :    LPENTITYINSTANCE  lpEntityInstance;
; 5927 :    LPVIEWENTITYCSR   lpLockEntityCsr;
; 5928 :    LPVIEWOD          lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 5929 :    zCHAR             szKeyString[ zMAX_KEYLTH_FOR_LOCK + 1 ];
; 5930 :    zCHAR             szLockName[ 35 ];
; 5931 :    zSHORT            nKeyCnt;
; 5932 :    zSHORT            nRC = zCALL_ERROR;       // Assume error.

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 5933 : 
; 5934 :    lpViewEntity = zGETPTR( lpFirstEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5935 : 
; 5936 :    // To save time later find all the keys in the LOD and store them in a table.
; 5937 :    nKeyCnt = 0;

	mov	WORD PTR _nKeyCnt$[ebp], 0

; 5938 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 5939 :          lpViewAttrib;
; 5940 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L9495
$L9496:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L9495:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $L9497

; 5942 :       if ( lpViewAttrib->bKey )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $L9498

; 5943 :          lpKeyViewAttrib[ nKeyCnt++ ] = lpViewAttrib;

	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeyViewAttrib$[ebp+ecx*4], edx
	mov	ax, WORD PTR _nKeyCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nKeyCnt$[ebp], ax
$L9498:

; 5944 :    }

	jmp	SHORT $L9496
$L9497:

; 5945 : 
; 5946 :    // Get the lpViewEntity and lpLockEntityCsr for the lock OI.
; 5947 :    lpLockEntity = fnValidViewEntity( &lpLockEntityCsr, vLock, "ZeidonLock", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpLockEntity$[ebp], eax

; 5948 : 
; 5949 :    if ( bLOD_Lock )

	mov	eax, DWORD PTR _bLOD_Lock$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L9499

; 5951 :       // We are checking a LOD level lock so we set LockName to the name of
; 5952 :       // the LOD.
; 5953 :       zstrcpy( szLockName, lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _szLockName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 5955 :    else

	jmp	SHORT $L9500
$L9499:

; 5957 :       // We are checking a lock at the entity level so use the name of the
; 5958 :       // entity for the LockName.  In addition, to handle the rare case where
; 5959 :       // a LOD and entity name are the same we prefix all entity names with
; 5960 :       // a '@' because it's an invalid character for entity names.  This
; 5961 :       // insures that the LockName for the entity does not match a LOD name.
; 5962 :       zsprintf( szLockName, "@%s", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET FLAT:??_C@_03LNBB@?$EA?$CFs?$AA@	; `string'
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9500:

; 5964 : 
; 5965 :    // Loop through each of the twin entities and create a locking record.  We
; 5966 :    // are going to cheat by then turning off the Create flag and turning on
; 5967 :    // the Delete and Hidden flags.  This will allow us to delete the lock
; 5968 :    // records off the DB without activating them first.
; 5969 :    for ( lpEntityInstance = lpFirstEntityInstance;
; 5970 :          lpEntityInstance;
; 5971 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $L9503
$L9504:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9503:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9505

; 5973 :       LPENTITYINSTANCE lpLockEntityInstance;
; 5974 : 
; 5975 :       // We don't care about instances that have been created.  Created
; 5976 :       // entities won't have a locking record because they where just created.
; 5977 :       // Same for included entities.
; 5978 :       if ( lpEntityInstance->u.nInd.bCreated ||
; 5979 :            lpEntityInstance->u.nInd.bIncluded )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9508
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	test	edx, edx
	je	SHORT $L9507
$L9508:

; 5980 :          continue;

	jmp	SHORT $L9504
$L9507:

; 5981 : 
; 5982 :       // Create the concat key string.
; 5983 :       fnCreateConcatKey( szKeyString, lpEntityInstance,
; 5984 :                          lpKeyViewAttrib, nKeyCnt );

	mov	ax, WORD PTR _nKeyCnt$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpKeyViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	lea	eax, DWORD PTR _szKeyString$[ebp]
	push	eax
	call	_fnCreateConcatKey@16

; 5985 : 
; 5986 :       if ( fnCreateEntity( vLock, lpLockEntity, lpLockEntityCsr,
; 5987 :                            zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	ecx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnCreateEntity@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9510

; 5988 :          goto EndOfFunction;

	jmp	$EndOfFunction$9511
$L9510:

; 5989 : 
; 5990 :       if ( fnSetLockingAttributes( lpCurrentTask,
; 5991 :                                    vLock, lpLockEntity, lpLockEntityCsr,
; 5992 :                                    szLockName, szKeyString, 0, 0, 0 ) != 0 )

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _szKeyString$[ebp]
	push	edx
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnSetLockingAttributes@36
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9512

; 5993 :          goto EndOfFunction;

	jmp	SHORT $EndOfFunction$9511
$L9512:

; 5994 : 
; 5995 :       // Here's where we cheat -- turn off Create flag and turn on the
; 5996 :       // Delete/Hidden flags so that when we commit the OI the locking
; 5997 :       // records will be deleted.
; 5998 :       lpLockEntityInstance = zGETPTR( lpLockEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLockEntityInstance$9506[ebp], eax

; 5999 :       lpLockEntityInstance->u.nInd.bCreated = FALSE;

	mov	edx, DWORD PTR _lpLockEntityInstance$9506[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	al, -3					; fffffffdH
	mov	ecx, DWORD PTR _lpLockEntityInstance$9506[ebp]
	mov	DWORD PTR [ecx+6], eax

; 6000 :       lpLockEntityInstance->u.nInd.bDeleted = lpLockEntityInstance->u.nInd.bHidden = TRUE;

	mov	edx, DWORD PTR _lpLockEntityInstance$9506[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 4
	mov	ecx, DWORD PTR _lpLockEntityInstance$9506[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpLockEntityInstance$9506[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	al, 8
	mov	ecx, DWORD PTR _lpLockEntityInstance$9506[ebp]
	mov	DWORD PTR [ecx+6], eax

; 6001 : 
; 6002 :    } // for ( lpEntityInstance...)

	jmp	$L9504
$L9505:

; 6003 : 
; 6004 :    // If we get here then everything is OK.
; 6005 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$9511:

; 6006 : 
; 6007 : EndOfFunction:
; 6008 : 
; 6009 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 6010 : 
; 6011 : } // fnDeleteLocksOnTwins

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnDeleteLocksOnTwins@24 ENDP
_TEXT	ENDS
PUBLIC	_fnRemoveLocksOnOIs@16
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_lpViewCluster$ = 12
_nViewCount$ = 16
_vLock$ = -8
_tViewArrayBlock$ = -80
_vSubtask$ = -88
_bDropLocks$ = -16
_k$ = -84
_nRC$ = -12
_lpViewOD$9537 = -96
_lpViewCsr$9538 = -92
_lpViewOI$9539 = -100
_lpEntityInstance$9554 = -104
_lpViewEntity$9560 = -108
_lpViewCsr$9571 = -112
_lpViewOI$9572 = -116
_fnRemoveLocksOnOIs@16 PROC NEAR

; 6019 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	edi

; 6020 :    ViewClusterRecord vLock;
; 6021 :    VIEWARRAYBLOCK    tViewArrayBlock = {0};

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	mov	ecx, 15					; 0000000fH
	xor	eax, eax
	lea	edi, DWORD PTR _tViewArrayBlock$[ebp+4]
	rep stosd

; 6022 :    zVIEW             vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 6023 :    zBOOL             bDropLocks;
; 6024 :    zSHORT            k;
; 6025 :    zSHORT            nRC = zCALL_ERROR;       // Assume error.

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 6026 : 
; 6027 :    vLock.vOI = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 6028 :    vLock.lControl = 0;

	mov	DWORD PTR _vLock$[ebp+4], 0

; 6029 : 
; 6030 :    // vSubtask is just the first valid view in the list.
; 6031 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9530
$L9531:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9530:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $L9532

; 6033 :       if ( lpViewCluster[ k ].vOI )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	je	SHORT $L9533

; 6035 :          vSubtask = lpViewCluster[ k ].vOI;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _vSubtask$[ebp], ecx

; 6036 :          break;

	jmp	SHORT $L9532
$L9533:

; 6038 :    }

	jmp	SHORT $L9531
$L9532:

; 6039 : 
; 6040 :    bDropLocks = FALSE;

	mov	BYTE PTR _bDropLocks$[ebp], 0

; 6041 : 
; 6042 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9534
$L9535:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9534:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$L9536

; 6044 :       LPVIEWOD  lpViewOD;
; 6045 :       LPVIEWCSR lpViewCsr;
; 6046 :       LPVIEWOI  lpViewOI;
; 6047 : 
; 6048 :       if ( lpViewCluster[ k ].vOI == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	jne	SHORT $L9540

; 6049 :          continue;

	jmp	SHORT $L9535
$L9540:

; 6050 : 
; 6051 :       if ( lpViewCluster[ k ].lControl & zCOMMIT_KEEPLOCKS )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $L9541

; 6052 :          continue;

	jmp	SHORT $L9535
$L9541:

; 6053 : 
; 6054 :       lpViewOD  = zGETPTR( lpViewCluster[ k ].vOI->hViewOD );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$9537[ebp], eax

; 6055 :       lpViewCsr = zGETPTR( lpViewCluster[ k ].vOI->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$9538[ebp], eax

; 6056 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$9538[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$9539[ebp], eax

; 6057 : 
; 6058 :       // If view wasn't activated with locking forget about it.
; 6059 :       if ( lpViewOI->bIsLocked == FALSE )

	mov	edx, DWORD PTR _lpViewOI$9539[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 7
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9545

; 6060 :          continue;

	jmp	$L9535
$L9545:

; 6061 : 
; 6062 :       // If bDropLocks is FALSE then we haven't created the vLock object yet.
; 6063 :       if ( bDropLocks == FALSE )

	mov	ecx, DWORD PTR _bDropLocks$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L9546

; 6065 :          // Create an empty lock OI.
; 6066 :          if ( fnDeclareView( &vLock.vOI, lpCurrentTask, vSubtask,
; 6067 :                              "ZPLOCKO", FALSE ) != 0 )

	push	0
	push	OFFSET FLAT:??_C@_07KIPN@ZPLOCKO?$AA@	; `string'
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnDeclareView@20
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9547

; 6069 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9523
$L9547:

; 6071 : 
; 6072 :          if ( fnActivateEmptyObjectInstance( lpCurrentTask,
; 6073 :                                              vLock.vOI, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9548

; 6075 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9523
$L9548:

; 6077 : 
; 6078 :          // Set flag to indicate:
; 6079 :          //    o The lock OI has been created.
; 6080 :          //    o We need to commit the lock object so that locks are removed.
; 6081 :          bDropLocks = TRUE;

	mov	BYTE PTR _bDropLocks$[ebp], 1
$L9546:

; 6083 : 
; 6084 :       // If the view has LOD-level locking release the LOD-level lock.
; 6085 :       if ( lpViewOD->nLock > zLL_PESSIMISTIC )

	mov	eax, DWORD PTR _lpViewOD$9537[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+236]
	cmp	ecx, 3
	jle	SHORT $L9551

; 6087 :          if ( fnDeleteLocksOnTwins( lpCurrentTask, vLock.vOI,
; 6088 :                                     zGETPTR( lpViewOI->hRootEntityInstance ),
; 6089 :                                     lpViewCluster[ k ].vOI,
; 6090 :                                     TRUE, lpViewOI ) != 0 )

	mov	edx, DWORD PTR _lpViewOI$9539[ebp]
	push	edx
	push	1
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$9539[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnDeleteLocksOnTwins@24
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9551

; 6092 :             goto EndOfFunction;

	jmp	$EndOfFunction$9552
$L9551:

; 6095 : 
; 6096 :       // If the view has entity-level locking release the entity-level lock.
; 6097 :       if ( lpViewOD->nEntityLock > zLL_PESSIMISTIC )

	mov	edx, DWORD PTR _lpViewOD$9537[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+237]
	cmp	eax, 3
	jle	$L9559

; 6099 :          LPENTITYINSTANCE lpEntityInstance;
; 6100 : 
; 6101 :          for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 6102 :                lpEntityInstance;
; 6103 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewOI$9539[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$9554[ebp], eax
	jmp	SHORT $L9557
$L9558:
	mov	eax, DWORD PTR _lpEntityInstance$9554[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$9554[ebp], eax
$L9557:
	cmp	DWORD PTR _lpEntityInstance$9554[ebp], 0
	je	SHORT $L9559

; 6105 :             LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$9554[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$9560[ebp], eax

; 6106 : 
; 6107 :             // If entity has no locking skip it.
; 6108 :             if ( lpViewEntity->nLock == 0 )

	mov	ecx, DWORD PTR _lpViewEntity$9560[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+230]
	test	edx, edx
	jne	SHORT $L9562

; 6109 :                continue;

	jmp	SHORT $L9558
$L9562:

; 6110 : 
; 6111 :             // If the instance is not the first twin then skip it.
; 6112 :             if ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$9554[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $L9563

; 6113 :                continue;

	jmp	SHORT $L9558
$L9563:

; 6114 : 
; 6115 :             if ( fnDeleteLocksOnTwins( lpCurrentTask, vLock.vOI,
; 6116 :                                        lpEntityInstance,
; 6117 :                                        lpViewCluster[ k ].vOI, FALSE,
; 6118 :                                        lpViewOI ) != 0 )

	mov	ecx, DWORD PTR _lpViewOI$9539[ebp]
	push	ecx
	push	0
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$9554[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnDeleteLocksOnTwins@24
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9564

; 6120 :                nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 6121 :                break;

	jmp	SHORT $L9559
$L9564:

; 6123 : 
; 6124 :          } // for ( lpEntityInstance )...

	jmp	SHORT $L9558
$L9559:

; 6126 : 
; 6127 :    } // for ( k = 0... )...

	jmp	$L9535
$L9536:

; 6128 : 
; 6129 :    // If we didn't find any views that should be locked then get out.
; 6130 :    if ( bDropLocks == FALSE )

	mov	eax, DWORD PTR _bDropLocks$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L9565

; 6132 :       nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 6133 :       goto EndOfFunction;

	jmp	$EndOfFunction$9552
$L9565:

; 6135 : 
; 6136 :    // Now commit the lock OI.  This should delete the locks.
; 6137 :    if ( fnInitViewArrayBlock( &tViewArrayBlock, 1 ) != 0 )

	push	1
	lea	ecx, DWORD PTR _tViewArrayBlock$[ebp]
	push	ecx
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9566

; 6138 :       goto EndOfFunction;

	jmp	$EndOfFunction$9552
$L9566:

; 6139 : 
; 6140 :    if ( fnCommitObjectInstance( &vLock, &vLock.vOI, 1, 0, lpCurrentTask,
; 6141 :                                 0, &tViewArrayBlock ) != 0 )

	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	1
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnCommitObjectInstance@28
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9567

; 6143 :       goto EndOfFunction;

	jmp	$EndOfFunction$9552
$L9567:

; 6145 : 
; 6146 :    // Flag all the OI's as no longer locked.
; 6147 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9568
$L9569:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9568:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L9570

; 6149 :       LPVIEWCSR lpViewCsr;
; 6150 :       LPVIEWOI  lpViewOI;
; 6151 : 
; 6152 :       if ( lpViewCluster[ k ].vOI == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	jne	SHORT $L9573

; 6153 :          continue;

	jmp	SHORT $L9569
$L9573:

; 6154 : 
; 6155 :       if ( lpViewCluster[ k ].lControl & zCOMMIT_KEEPLOCKS )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $L9574

; 6156 :          continue;

	jmp	SHORT $L9569
$L9574:

; 6157 : 
; 6158 :       lpViewCsr = zGETPTR( lpViewCluster[ k ].vOI->hViewCsr );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$9571[ebp], eax

; 6159 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$9571[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$9572[ebp], eax

; 6160 : 
; 6161 :       lpViewOI->bIsLocked = FALSE;

	mov	ecx, DWORD PTR _lpViewOI$9572[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	dl, 127					; 0000007fH
	mov	eax, DWORD PTR _lpViewOI$9572[ebp]
	mov	DWORD PTR [eax+36], edx

; 6162 : 
; 6163 :    } // for ( k = 0... )...

	jmp	SHORT $L9569
$L9570:

; 6164 : 
; 6165 :    // If we get here then everything's OK.
; 6166 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$9552:

; 6167 : 
; 6168 : EndOfFunction:
; 6169 :    if ( vLock.vOI )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $L9577

; 6170 :       fnDropView( vLock.vOI );

	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnDropView@4
$L9577:

; 6171 : 
; 6172 :    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 6173 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L9523:

; 6174 : 
; 6175 : } // fnRemoveLocksOnOIs

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnRemoveLocksOnOIs@16 ENDP
_TEXT	ENDS
PUBLIC	_fnCommitSingleOI@16
PUBLIC	??_C@_0BL@CNGJ@Couldn?8t?5find?5original?5OI?$CB?$AA@ ; `string'
PUBLIC	??_C@_0CG@PFIF@?$CIoi?$CJ?5Activating?5Optimistic?5Check@ ; `string'
PUBLIC	??_C@_0DB@NCB@?$CIoi?$CJ?5Error?5loading?5Optimistic?5ch@ ; `string'
PUBLIC	??_C@_0CG@JDBO@?$CIoi?$CJ?5Optimistic?5locking?5compare?5@ ; `string'
EXTRN	_fnCompareOI_ToOI:NEAR
EXTRN	_fnResetViewFromSubobject:NEAR
;	COMDAT ??_C@_0BL@CNGJ@Couldn?8t?5find?5original?5OI?$CB?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BL@CNGJ@Couldn?8t?5find?5original?5OI?$CB?$AA@ DB 'Couldn''t find '
	DB	'original OI!', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@PFIF@?$CIoi?$CJ?5Activating?5Optimistic?5Check@
_DATA	SEGMENT
??_C@_0CG@PFIF@?$CIoi?$CJ?5Activating?5Optimistic?5Check@ DB '(oi) Activa'
	DB	'ting Optimistic Check view', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DB@NCB@?$CIoi?$CJ?5Error?5loading?5Optimistic?5ch@
_DATA	SEGMENT
??_C@_0DB@NCB@?$CIoi?$CJ?5Error?5loading?5Optimistic?5ch@ DB '(oi) Error '
	DB	'loading Optimistic check view.  RC = ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@JDBO@?$CIoi?$CJ?5Optimistic?5locking?5compare?5@
_DATA	SEGMENT
??_C@_0CG@JDBO@?$CIoi?$CJ?5Optimistic?5locking?5compare?5@ DB '(oi) Optim'
	DB	'istic locking compare RC = ', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_lpCurrentTask$ = 16
_lpTaskDBHandler$ = 20
_lpViewOD$ = -20
_lpViewOI$ = -48
_lpViewCsr$ = -4
_lpViewEntity$ = -36
_lpEntityInstance$ = -32
_lpLastEntityInstance$ = -40
_lpRootEntityInstance$ = -16
_lpLinked$ = -12
_pOper$ = -44
_lpPtr$ = -28
_lHiddenCnt$ = -52
_nRC$ = -24
_bRelational$ = -8
_lpTask$9606 = -56
_vCheckView$9610 = -64
_lCmprCntrl$9611 = -60
_lpTask$9617 = -68
_lpTask$9625 = -72
_bDelete$9656 = -76
_lpVE_Parent$9658 = -80
_lpVE_NextHier$9659 = -88
_lpEI_Parent$9660 = -84
_fnCommitSingleOI@16 PROC NEAR

; 6203 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 6204 :    LPVIEWOD             lpViewOD;
; 6205 :    LPVIEWOI             lpViewOI;
; 6206 :    LPVIEWCSR            lpViewCsr;
; 6207 :    LPVIEWENTITY         lpViewEntity;
; 6208 :    LPENTITYINSTANCE     lpEntityInstance;
; 6209 :    LPENTITYINSTANCE     lpLastEntityInstance;
; 6210 :    LPENTITYINSTANCE     lpRootEntityInstance;
; 6211 :    LPENTITYINSTANCE     lpLinked;
; 6212 :    zPDBHOPER            pOper = lpTaskDBHandler->pfDBHandlerOper;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _pOper$[ebp], ecx

; 6213 :    zPVOID               lpPtr = lpTaskDBHandler->lpConnection;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR _lpPtr$[ebp], eax

; 6214 :    zLONG                lHiddenCnt;
; 6215 :    zSHORT               nRC;
; 6216 : 
; 6217 :    // DGC 1998/11/17
; 6218 :    // We have code that is special just for relational DBs.  At the moment we
; 6219 :    // only support relational DBs so I'm setting the following variable to
; 6220 :    // be always TRUE.  When we support other DB types we'll have to do
; 6221 :    // something different.
; 6222 :    zBOOL                bRelational = TRUE;

	mov	BYTE PTR _bRelational$[ebp], 1

; 6223 : 
; 6224 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6225 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6226 :    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 6227 : 
; 6228 :    nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Object | DBH_NewObject, 0,
; 6229 :                    lpViewOD, 0, lpView, 0, &lpPtr );

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	16392					; 00004008H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6230 : 
; 6231 :    // Make sure OI does not contain versioned instances.
; 6232 :    if ( lpViewOI->nVersionedInstances )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	je	SHORT $L9605

; 6234 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$9606[ebp], eax

; 6235 :       //  "KZOEE076 - Object instance contains versioned entity instances"
; 6236 :       fnIssueCoreError( lpTask, lpView, 8, 76, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	76					; 0000004cH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$9606[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6237 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9587
$L9605:

; 6239 : 
; 6240 :    // Check to see if the OI was activated using optmistic locking.
; 6241 :    if ( lpViewOI->lActivateControl & zACTIVATE_WITH_LOCKING &&
; 6242 :         (lpViewOD->nLock == zLL_OPTIMISTIC_NOINC ||
; 6243 :          lpViewOD->nLock == zLL_OPTIMISTIC_CMPRALL) )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	and	ecx, 67108864				; 04000000H
	test	ecx, ecx
	je	$L9624
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+236]
	cmp	eax, 1
	je	SHORT $L9609
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	cmp	edx, 2
	jne	$L9624
$L9609:

; 6245 :       zVIEW vCheckView;
; 6246 :       zLONG lCmprCntrl;
; 6247 : 
; 6248 :       // Since we have optimistic locking, we should have a copy of the
; 6249 :       // original OI (the OI after it was loaded).  Make sure we got it.
; 6250 :       if ( lpViewOI->vOriginalOI == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L9612

; 6252 :          // This should never happen (if it does it's a core error) so we'll
; 6253 :          // just use SysMessageBox.
; 6254 :          SysMessageBox( lpView, "Internal Core Error",
; 6255 :                         "Couldn't find original OI!", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0BL@CNGJ@Couldn?8t?5find?5original?5OI?$CB?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BE@LIH@Internal?5Core?5Error?$AA@ ; `string'
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 6256 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9587
$L9612:

; 6258 : 
; 6259 :       // Now activate the OI again using the qualification object but
; 6260 :       // WITHOUT optimistic locking.
; 6261 :       TraceLineS( "(oi) Activating Optimistic Check view", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CG@PFIF@?$CIoi?$CJ?5Activating?5Optimistic?5Check@ ; `string'
	call	_TraceLineS@8

; 6262 :       nRC = ActivateObjectInstance( &vCheckView, lpViewOD->szName,
; 6263 :                                     lpView, zGETPTR( lpViewOI->vQualOI ),
; 6264 :                                     (lpViewOI->lActivateControl &
; 6265 :                                                ~(zACTIVATE_WITH_LOCKING)) );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, -67108865				; fbffffffH
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _vCheckView$9610[ebp]
	push	edx
	call	_ActivateObjectInstance@20
	mov	WORD PTR _nRC$[ebp], ax

; 6266 :       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $L9616

; 6268 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$9617[ebp], eax

; 6269 :          // We've got an error loading the optimistic check view, so get out.
; 6270 :          if ( vCheckView )

	cmp	DWORD PTR _vCheckView$9610[ebp], 0
	je	SHORT $L9619

; 6271 :             DropView( vCheckView );

	mov	eax, DWORD PTR _vCheckView$9610[ebp]
	push	eax
	call	_DropView@4
$L9619:

; 6272 : 
; 6273 :          TraceLineI( "(oi) Error loading Optimistic check view.  RC = ", nRC );

	movsx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DB@NCB@?$CIoi?$CJ?5Error?5loading?5Optimistic?5ch@ ; `string'
	call	_TraceLineI@8

; 6274 : 
; 6275 :          // "KZOEE092 - Couldn't re-activate OI for optimistic lock check",
; 6276 :          fnIssueCoreError( lpTask, lpView, 8, 92, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	92					; 0000005cH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$9617[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6277 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9587
$L9616:

; 6279 : 
; 6280 :       // We're about to compare the OIs but first check to see if we should
; 6281 :       // ignore non-key values for include-only entities.
; 6282 :       lCmprCntrl = zCOMPAREOI_PERSISTONLY | zCOMPAREOI_RETURN;

	mov	DWORD PTR _lCmprCntrl$9611[ebp], 2

; 6283 :       if ( lpViewOD->nLock == zLL_OPTIMISTIC_NOINC )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	cmp	edx, 1
	jne	SHORT $L9621

; 6284 :          lCmprCntrl |= zCOMPAREOI_IGNOREINC;

	mov	eax, DWORD PTR _lCmprCntrl$9611[ebp]
	or	al, 1
	mov	DWORD PTR _lCmprCntrl$9611[ebp], eax
$L9621:

; 6285 : 
; 6286 :       // We now have a copy of the original OI and the current one.  Compare
; 6287 :       // the two and see if they are the same.  If they are not, then there
; 6288 :       // is an error.
; 6289 :       nRC = fnCompareOI_ToOI( zGETPTR( lpViewOI->vOriginalOI ), vCheckView,
; 6290 :                               lCmprCntrl );

	mov	ecx, DWORD PTR _lCmprCntrl$9611[ebp]
	push	ecx
	mov	edx, DWORD PTR _vCheckView$9610[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnCompareOI_ToOI
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 6291 :       TraceLineI( "(oi) Optimistic locking compare RC = ", nRC );

	movsx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CG@JDBO@?$CIoi?$CJ?5Optimistic?5locking?5compare?5@ ; `string'
	call	_TraceLineI@8

; 6292 :       DropView( vCheckView );  // We no longer need this...

	mov	eax, DWORD PTR _vCheckView$9610[ebp]
	push	eax
	call	_DropView@4

; 6293 :       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L9624

; 6295 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$9625[ebp], eax

; 6296 :          // "KZOEE093 - Optimistic locking error -- OI has changed since it was activated",
; 6297 :          fnIssueCoreError( lpTask, lpView, 8, 93, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	93					; 0000005dH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$9625[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6298 :          return( zOPTIMISTIC_LOCK_ERROR );

	mov	ax, -5					; fffffffbH
	jmp	$L9587
$L9624:

; 6302 : 
; 6303 :    // Perform some pre-commit stuff.  fnCommitPreLoops does:
; 6304 :    //    o  Sets any auto-sequence attributes.
; 6305 :    //    o  Turns off "hidden" flag so db-handler can access all data.
; 6306 :    nRC = fnCommitPreLoops( lpCurrentTask, lpView, &lpLastEntityInstance,
; 6307 :                            &lHiddenCnt );

	lea	eax, DWORD PTR _lHiddenCnt$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpLastEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCommitPreLoops
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 6308 :    if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L9627

; 6309 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L9587
$L9627:

; 6310 : 
; 6311 :    lpRootEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$[ebp], eax

; 6312 : 
; 6313 :    // Now we pass the chain once each to do relationship deletes, deletes,
; 6314 :    // relationship inserts, and updates. The delete passes are done in reverse
; 6315 :    // hierarchical order so deletes occur from the bottom up.
; 6316 : 
; 6317 :    //==============================================================
; 6318 :    // PASS Number 1, do excludes (relationship deletes).
; 6319 :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$L9633

; 6321 :       for ( lpEntityInstance = lpLastEntityInstance;
; 6322 :             lpEntityInstance && nRC == 0;
; 6323 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier ) )

	mov	edx, DWORD PTR _lpLastEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $L9631
$L9632:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9631:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9633
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$L9633

; 6325 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6326 : 
; 6327 :          // EIs down a derived path don't get committed to the database.
; 6328 :          // Since all children of a derived EI are also derived we can skip
; 6329 :          // the twins of the current EI.
; 6330 :          if ( lpViewEntity->bDerivedPath )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9635
$L9637:

; 6332 :             while ( lpEntityInstance->hPrevTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $L9638

; 6333 :                lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9637
$L9638:

; 6334 : 
; 6335 :             continue;

	jmp	SHORT $L9632
$L9635:

; 6337 : 
; 6338 : #if ( VIEWENT_RULES )
; 6339 :          // Skip the EI if we don't allow excluding this entity.
; 6340 :          if ( lpViewEntity->bExclude == FALSE )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9640

; 6341 :             continue;

	jmp	SHORT $L9632
$L9640:

; 6342 : #endif
; 6343 : 
; 6344 :          // Exclude entity if the entity...
; 6345 :          if ( lpEntityInstance->u.nInd.bExcluded             && // was excluded...
; 6346 :               lpEntityInstance->u.nInd.bDBHExcluded == FALSE && // wasn't committed...
; 6347 :               lpEntityInstance->u.nInd.bIncluded == FALSE    && // wasn't inc'd and...
; 6348 :               lpEntityInstance->u.nInd.bCreated == FALSE )      // wasn't created

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	test	ecx, ecx
	je	$L9641
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 16					; 00000010H
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9641
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9641
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9641

; 6350 :             // Set entity cursor to point to lpEntityInstance.
; 6351 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6352 : 
; 6353 :             // Call DBHandler routine.
; 6354 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_DeleteRel, 0,
; 6355 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	0
	push	32776					; 00008008H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6356 : 
; 6357 :             lpEntityInstance->u.nInd.bDBHExcluded = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 65536				; 00010000H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6358 : 
; 6359 :             // Set the bDBHExcluded flag for all linked EIs that have the
; 6360 :             // exact same relationship.
; 6361 :             fnMarkDuplicateRelationship( lpEntityInstance, FALSE );

	push	0
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnMarkDuplicateRelationship@8
$L9641:

; 6363 : 
; 6364 :       }  // for ( lpEntityInstance ...)...

	jmp	$L9632
$L9633:

; 6367 : 
; 6368 :    //==============================================================
; 6369 :    // PASS Number 2, do deletes.
; 6370 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$L9647

; 6372 :       for ( lpEntityInstance = lpLastEntityInstance;
; 6373 :             lpEntityInstance && nRC == 0;
; 6374 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier ) )

	mov	eax, DWORD PTR _lpLastEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9645
$L9646:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9645:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9647
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L9647

; 6376 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6377 : 
; 6378 :          // EIs down a derived path don't get committed to the database.
; 6379 :          // Since all children of a derived EI are also derived we can skip
; 6380 :          // the twins of the current EI.
; 6381 :          if ( lpViewEntity->bDerivedPath )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9649
$L9651:

; 6383 :             while ( lpEntityInstance->hPrevTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $L9652

; 6384 :                lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9651
$L9652:

; 6385 : 
; 6386 :             continue;

	jmp	SHORT $L9646
$L9649:

; 6388 : 
; 6389 : #if ( VIEWENT_RULES )
; 6390 :          // If we don't allow deletes then skip it.
; 6391 :          if ( lpViewEntity->bDelete == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9654

; 6392 :             continue;

	jmp	SHORT $L9646
$L9654:

; 6393 : #endif
; 6394 : 
; 6395 :          // Delete entity if prev dbcall was OK and the entity...
; 6396 :          if ( lpEntityInstance->u.nInd.bDeleted             && // was deleted and...
; 6397 :               lpEntityInstance->u.nInd.bDBHDeleted == FALSE && // wasn't committed and...
; 6398 :               lpEntityInstance->u.nInd.bCreated == FALSE    && // wasn't created and...
; 6399 :               lpEntityInstance->u.nInd.bIncluded == FALSE )    // wasn't included

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	je	$L9679
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	jne	$L9679
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	$L9679
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	test	edx, edx
	jne	$L9679

; 6401 :             zBOOL bDelete = FALSE;  // process each entity normally

	mov	BYTE PTR _bDelete$9656[ebp], 0

; 6402 : 
; 6403 :             // Set entity cursor to point to lpEntityInstance.
; 6404 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6405 : 
; 6406 :             // Start dks ... 2006.01.25
; 6407 :             if ( lpEntityInstance->hParent )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	$L9665

; 6409 :                LPVIEWENTITY      lpVE_Parent;
; 6410 :                LPVIEWENTITY      lpVE_NextHier;
; 6411 :                LPENTITYINSTANCE  lpEI_Parent;
; 6412 : 
; 6413 :                lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6414 :                lpVE_NextHier = zGETPTR( lpViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVE_NextHier$9659[ebp], eax

; 6415 :                lpVE_Parent = zGETPTR( lpViewEntity->hParent );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVE_Parent$9658[ebp], eax

; 6416 :                lpEI_Parent = zGETPTR( lpEntityInstance->hParent );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI_Parent$9660[ebp], eax

; 6417 :                if ( lpEI_Parent->u.nInd.bDeleted &&    // parent was deleted and...
; 6418 :                     lpViewEntity->bPDelete &&          // entity has ParentDelete behavior and...
; 6419 :                     lpVE_Parent->bSingleKey &&         // parent entity is single key and...
; 6420 :                     lpEntityInstance->hPrevTwin &&     // more than one instance to delete and...
; 6421 :                     lpViewEntity->bDerivedPath == FALSE && // cannot be derived
; 6422 :                     (lpVE_NextHier == 0 ||
; 6423 :                      lpVE_NextHier->hParent != lpEntityInstance->hViewEntity) )  // cannot have child entities

	mov	edx, DWORD PTR _lpEI_Parent$9660[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L9665
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 7
	and	edx, 1
	test	edx, edx
	je	SHORT $L9665
	mov	eax, DWORD PTR _lpVE_Parent$9658[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 16					; 00000010H
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9665
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $L9665
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9665
	cmp	DWORD PTR _lpVE_NextHier$9659[ebp], 0
	je	SHORT $L9666
	mov	edx, DWORD PTR _lpVE_NextHier$9659[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+2]
	je	SHORT $L9665
$L9666:

; 6425 :                   // This should be the condition we are looking for ... dks ... 2006.01.25
; 6426 :                   bDelete = TRUE;       // call DBHandler once in the loop below

	mov	BYTE PTR _bDelete$9656[ebp], 1
$L9665:

; 6429 :             // End dks ... 2006.01.25
; 6430 : 
; 6431 :             // Call DBHandler routine.
; 6432 :             if ( bDelete )  // dks ... 2006.01.25

	mov	edx, DWORD PTR _bDelete$9656[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L9667

; 6434 :                lpEntityInstance->u.nInd.bDBHDeleteAll = TRUE;  // call delete special case

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 262144				; 00040000H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6435 :                nRC = (*pOper)( (zLONG) lpView->hTask,
; 6436 :                                DBH_Entity | DBH_Delete | DBH_DeleteAll, 0,
; 6437 :                                lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	33796					; 00008404H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$L9670:

; 6438 : 
; 6439 :                // Flag each twin that message has been sent to handler.
; 6440 :                while ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $L9671

; 6442 :                   lpEntityInstance->u.nInd.bDBHDeleted = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	dh, 64					; 00000040H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6443 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 6444 :                }

	jmp	SHORT $L9670
$L9671:

; 6446 :             else

	jmp	SHORT $L9673
$L9667:

; 6448 :                // This is the only original code prior to 2006.01.25
; 6449 :                nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_Delete, 0,
; 6450 :                                lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	32772					; 00008004H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$L9673:

; 6452 : 
; 6453 :             // Flag that message has been sent to handler.
; 6454 :             lpEntityInstance->u.nInd.bDBHDeleted = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ch, 64					; 00000040H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6455 : 
; 6456 :             // Turn on the DBHDeleted flag for all linked instances.  This
; 6457 :             // will keep them from being deleted again.
; 6458 :             for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 6459 :                   lpLinked && lpLinked != lpEntityInstance;
; 6460 :                   lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
	jmp	SHORT $L9677
$L9678:
	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
$L9677:
	cmp	DWORD PTR _lpLinked$[ebp], 0
	je	SHORT $L9679
	mov	ecx, DWORD PTR _lpLinked$[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L9679

; 6462 :                lpLinked->u.nInd.bDBHDeleted = TRUE;

	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 64					; 00000040H
	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 6463 :             }

	jmp	SHORT $L9678
$L9679:

; 6465 : 
; 6466 :       }  // while ( lpEntityInstance && nRC == 0 )...

	jmp	$L9646
$L9647:

; 6469 : 
; 6470 :    //==============================================================
; 6471 :    // PASS Number 3, do creates.
; 6472 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$L9684

; 6474 :       for ( lpEntityInstance = lpRootEntityInstance;
; 6475 :             lpEntityInstance && nRC == 0;
; 6476 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9682
$L9683:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9682:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9684
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L9684

; 6478 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6479 : 
; 6480 :          // EIs down a derived path don't get committed to the database.
; 6481 :          // Since all children of a derived EI are also derived we can skip
; 6482 :          // the twins of the current EI.
; 6483 :          if ( lpViewEntity->bDerivedPath )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9686
$L9688:

; 6485 :             while ( lpEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $L9689

; 6486 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9688
$L9689:

; 6487 : 
; 6488 :             continue;

	jmp	SHORT $L9683
$L9686:

; 6490 : 
; 6491 : #if ( VIEWENT_RULES )
; 6492 :          // If we don't allow creates then skip it.
; 6493 :          if ( lpViewEntity->bCreate == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9691

; 6494 :             continue;

	jmp	SHORT $L9683
$L9691:

; 6495 : #endif
; 6496 : 
; 6497 :          // Create the entity if the entity...
; 6498 :          if ( lpEntityInstance->u.nInd.bDBHCreated == FALSE && // not committed and...
; 6499 :               lpEntityInstance->u.nInd.bCreated             && // was created and...
; 6500 :               lpEntityInstance->u.nInd.bDeleted == FALSE    && // wasn't deleted and...
; 6501 :               lpEntityInstance->u.nInd.bHidden == FALSE )      // is not hidden

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	test	edx, edx
	jne	$L9698
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	je	$L9698
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	$L9698
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	jne	$L9698

; 6503 :             // Set entity cursor to point to lpEntityInstance.
; 6504 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6505 : 
; 6506 :             // Call DBHandler routine.
; 6507 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_Insert, 0,
; 6508 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	32769					; 00008001H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6509 : 
; 6510 :             // Flag that message sent to handler
; 6511 :             lpEntityInstance->u.nInd.bDBHCreated = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 32					; 00000020H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 6512 : 
; 6513 :             // Turn on the dbh flag for all linked instances.  This will
; 6514 :             // keep them from being created again.
; 6515 :             for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 6516 :                   lpLinked && lpLinked != lpEntityInstance;
; 6517 :                   lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
	jmp	SHORT $L9696
$L9697:
	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
$L9696:
	cmp	DWORD PTR _lpLinked$[ebp], 0
	je	SHORT $L9698
	mov	eax, DWORD PTR _lpLinked$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L9698

; 6519 :                lpLinked->u.nInd.bDBHCreated = TRUE;

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	dh, 32					; 00000020H
	mov	eax, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6520 : 
; 6521 :                // If the linked instance is flagged as created then we need
; 6522 :                // to set it's included flag on so that the *relationship*
; 6523 :                // is still created.
; 6524 :                if ( lpLinked->u.nInd.bCreated )

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	je	SHORT $L9699

; 6525 :                   lpLinked->u.nInd.bIncluded = TRUE;

	mov	eax, DWORD PTR _lpLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L9699:

; 6526 :             }

	jmp	SHORT $L9697
$L9698:

; 6528 :       } // for ( lpEntityInstance && nRC == 0 )

	jmp	$L9683
$L9684:

; 6531 : 
; 6532 :    //==============================================================
; 6533 :    // PASS Number 4, do insert relationships
; 6534 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L9704

; 6536 :       for ( lpEntityInstance = lpRootEntityInstance;
; 6537 :             lpEntityInstance && nRC == 0;
; 6538 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx
	jmp	SHORT $L9702
$L9703:
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9702:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9704
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$L9704

; 6540 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6541 : 
; 6542 :          // EIs down a derived path don't get committed to the database.
; 6543 :          // Since all children of a derived EI are also derived we can skip
; 6544 :          // the twins of the current EI.
; 6545 :          if ( lpViewEntity->bDerivedPath )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	test	edx, edx
	je	SHORT $L9706
$L9708:

; 6547 :             while ( lpEntityInstance->hNextTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $L9709

; 6548 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9708
$L9709:

; 6549 : 
; 6550 :             continue;

	jmp	SHORT $L9703
$L9706:

; 6552 : 
; 6553 : #if ( VIEWENT_RULES )
; 6554 :          // If we don't allow includes then skip it.
; 6555 :          if ( lpViewEntity->bInclude == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 3
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9711

; 6556 :             continue;

	jmp	SHORT $L9703
$L9711:

; 6557 : #endif
; 6558 : 
; 6559 :          // If the entity doesn't have a parent (i.e. it's the root) then
; 6560 :          // we don't want to include it...there's nothing to include.  So
; 6561 :          // just flag it as already included.
; 6562 :          if ( lpEntityInstance->hParent == 0 )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+30], 0
	jne	SHORT $L9712

; 6564 :             lpEntityInstance->u.nInd.bDBHIncluded = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ch, -128				; ffffff80H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6565 :             continue;

	jmp	$L9703
$L9712:

; 6567 : 
; 6568 :          // Include relationship if prev dbcall was OK and the entity...
; 6569 :          if ( lpEntityInstance->u.nInd.bIncluded             && // was included and...
; 6570 :               lpEntityInstance->u.nInd.bExcluded == FALSE    && // wasn't committed and...
; 6571 :               lpEntityInstance->u.nInd.bDBHIncluded == FALSE && // wasn't committed and...
; 6572 :               lpEntityInstance->u.nInd.bHidden == FALSE )       // is not hidden.

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	je	$L9713
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9713
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 15					; 0000000fH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9713
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9713

; 6574 :             // Set entity cursor to point to lpEntityInstance.
; 6575 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6576 : 
; 6577 :             // Call DBHandler routine.
; 6578 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_InsertRel, 0,
; 6579 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	0
	push	32770					; 00008002H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6580 : 
; 6581 :             lpEntityInstance->u.nInd.bDBHIncluded = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	dh, -128				; ffffff80H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6582 : 
; 6583 :             // Set the bDBHIncluded flag for all linked EIs that have the
; 6584 :             // exact same relationship as lpEntityInstance.
; 6585 :             fnMarkDuplicateRelationship( lpEntityInstance, TRUE );

	push	1
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnMarkDuplicateRelationship@8
$L9713:

; 6587 :       } // for ( lpEntityInstance != lpStopInstance && nRC == 0 )

	jmp	$L9703
$L9704:

; 6589 : 
; 6590 :    //==============================================================
; 6591 :    // PASS Number 5, do entity updates
; 6592 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$L9719

; 6594 :       for ( lpEntityInstance = lpRootEntityInstance;
; 6595 :             lpEntityInstance && nRC == 0;
; 6596 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9717
$L9718:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9717:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9719
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L9719

; 6598 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6599 : 
; 6600 :          // EIs down a derived path don't get committed to the database.
; 6601 :          // Since all children of a derived EI are also derived we can skip
; 6602 :          // the twins of the current EI.
; 6603 :          if ( lpViewEntity->bDerivedPath )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9721
$L9723:

; 6605 :             while ( lpEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $L9724

; 6606 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9723
$L9724:

; 6607 : 
; 6608 :             continue;

	jmp	SHORT $L9718
$L9721:

; 6610 : 
; 6611 : #if ( VIEWENT_RULES )
; 6612 :          if ( lpViewEntity->bUpdate == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9727

; 6614 :             // the DB is relational and we need to update because of an
; 6615 :             // included or excluded entity.
; 6616 :             if ( bRelational == FALSE ||
; 6617 :                  (lpEntityInstance->u.nInd.bIncluded == FALSE &&
; 6618 :                   lpEntityInstance->u.nInd.bExcluded == FALSE) )

	mov	ecx, DWORD PTR _bRelational$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L9728
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	test	eax, eax
	jne	SHORT $L9727
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	jne	SHORT $L9727
$L9728:

; 6620 :                continue;

	jmp	$L9718
$L9727:

; 6623 : #endif
; 6624 : 
; 6625 :          // Update entity if the entity...
; 6626 :          if ( lpEntityInstance->u.nInd.bDBHUpdated == FALSE && // not already updated...
; 6627 :               lpEntityInstance->u.nInd.bUpdated == TRUE     && // was updated and...
; 6628 :               lpEntityInstance->u.nInd.bHidden == FALSE     && // isn't hidden and...
; 6629 :               lpEntityInstance->u.nInd.bCreated == FALSE    && // wasn't created and...
; 6630 :               lpEntityInstance->u.nInd.bDeleted == FALSE )     // wasn't deleted and...

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 17					; 00000011H
	and	ecx, 1
	test	ecx, ecx
	jne	$L9729
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	cmp	eax, 1
	jne	$L9729
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	jne	$L9729
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	$L9729
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	$L9729

; 6632 :             // Set entity cursor to point to lpEntityInstance.
; 6633 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6634 : 
; 6635 :             // Call DBHandler routine.
; 6636 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_Update, 0,
; 6637 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	32784					; 00008010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6638 : 
; 6639 :             // Flag that message sent to handler
; 6640 :             lpEntityInstance->u.nInd.bDBHUpdated = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 131072				; 00020000H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6641 : 
; 6642 :             // If the EI is flagged as excluded then we have updated the EI
; 6643 :             // to blank out an empty key so now flag it as hidden.
; 6644 :             if ( lpEntityInstance->u.nInd.bExcluded )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L9731

; 6645 :                lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 4
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9731:

; 6646 : 
; 6647 :             // Turn on the dbh flag for all linked instances.  This will
; 6648 :             // keep them from being updated again.
; 6649 :             for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 6650 :                   lpLinked && lpLinked != lpEntityInstance;
; 6651 :                   lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
	jmp	SHORT $L9734
$L9735:
	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
$L9734:
	cmp	DWORD PTR _lpLinked$[ebp], 0
	je	SHORT $L9736
	mov	eax, DWORD PTR _lpLinked$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L9736

; 6653 :                lpLinked->u.nInd.bDBHUpdated = TRUE;

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 131072				; 00020000H
	mov	eax, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6654 :             }

	jmp	SHORT $L9735
$L9736:

; 6656 :          else

	jmp	SHORT $L9738
$L9729:

; 6657 :          if ( lpEntityInstance->u.nInd.bSequenceUpdt )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 19					; 00000013H
	and	edx, 1
	test	edx, edx
	je	SHORT $L9738

; 6659 :             // Set entity cursor to point to lpEntityInstance.
; 6660 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6661 : 
; 6662 :             // Call DBHandler routine.
; 6663 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_UpdateSeq, 0,
; 6664 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	34816					; 00008800H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6665 : 
; 6666 :             // Flag that message sent to handler
; 6667 :             lpEntityInstance->u.nInd.bDBHUpdated = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 131072				; 00020000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9738:

; 6669 :       }  // for ( lpEntityInstance && nRC == 0 )...

	jmp	$L9718
$L9719:

; 6671 : 
; 6672 :    //==============================================================
; 6673 :    // All deletes, updates, and inserts have been performed.
; 6674 : 
; 6675 :    // Turn the hidden flag back on for deleted/excluded instances.
; 6676 :    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 6677 :          lpEntityInstance;
; 6678 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9742
$L9743:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9742:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L9744

; 6680 :       if ( lpEntityInstance->u.nInd.bDeleted ||
; 6681 :            lpEntityInstance->u.nInd.bExcluded )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 3
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9746
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	SHORT $L9745
$L9746:

; 6683 :          lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	dh, 4
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$L9745:

; 6685 :    }

	jmp	SHORT $L9743
$L9744:

; 6686 : 
; 6687 :    // If the view is left at a subobject after processing, reset it
; 6688 :    // back to the top level
; 6689 :    while ( fnResetViewFromSubobject( lpView ) == 0 );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetViewFromSubobject
	add	esp, 4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L9749
	jmp	SHORT $L9744
$L9749:

; 6690 : 
; 6691 :    if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $L9752

; 6693 :       if ( nRC < zDUPLICATE_ROOT )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -4					; fffffffcH
	jge	SHORT $L9751

; 6694 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L9587
$L9751:

; 6695 :       else
; 6696 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L9587
$L9752:

; 6698 : 
; 6699 :    return( 0 ); // Everything OK.

	xor	ax, ax
$L9587:

; 6700 : 
; 6701 : } // fnCommitSingleOI

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnCommitSingleOI@16 ENDP
_TEXT	ENDS
PUBLIC	_fnDropObjectInstance
_TEXT	SEGMENT
_lpViewCluster$ = 8
_lpViewArray$ = 12
_nViewCount$ = 16
_pnViewErrorIdx$ = 20
_lpCurrentTask$ = 24
_lControl$ = 28
_pViewArrayBlock$ = 32
_lpViewOD$ = -8
_lpViewOI$ = -48
_lpViewCsr$ = -4
_lpTaskDBHandler$ = -32
_lpEntityInstance$ = -20
_pGKOper$ = -52
_pOper$ = -24
_lpPtr$ = -16
_lpKZGKHWOB$ = -44
_vSubtask$ = -40
_bTransactionStartedHere$ = -28
_k$ = -36
_nRC$ = -12
_vTemp$9827 = -56
_fnCommitObjectInstance@28 PROC NEAR

; 6733 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 6734 :    LPVIEWOD             lpViewOD;
; 6735 :    LPVIEWOI             lpViewOI;
; 6736 :    LPVIEWCSR            lpViewCsr;
; 6737 :    LPTASKDBHANDLER      lpTaskDBHandler;
; 6738 :    LPENTITYINSTANCE     lpEntityInstance;
; 6739 :    zPGKHOPER            pGKOper = 0;

	mov	DWORD PTR _pGKOper$[ebp], 0

; 6740 :    zPDBHOPER            pOper;
; 6741 :    zPVOID               lpPtr;
; 6742 :    zVIEW                lpKZGKHWOB;
; 6743 :    zVIEW                vSubtask;
; 6744 :    zBOOL                bTransactionStartedHere;
; 6745 :    zSHORT               k;
; 6746 :    zSHORT               nRC;
; 6747 : 
; 6748 :    // Find the first non-zero view in the list.  We'll use this to pass into
; 6749 :    // the DBHandler so that the DBH knows what DB where dealing with.
; 6750 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9781
$L9782:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9781:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $L9783

; 6752 :       if ( lpViewCluster[ k ].vOI )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	je	SHORT $L9784

; 6754 :          vSubtask = lpViewCluster[ k ].vOI;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _vSubtask$[ebp], ecx

; 6755 :          break;

	jmp	SHORT $L9783
$L9784:

; 6757 :    }

	jmp	SHORT $L9782
$L9783:

; 6758 : 
; 6759 :    // Turn off the DBH flags for all entity instances.  This allows
; 6760 :    // us to figure out if the entity instance was processed.
; 6761 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9785
$L9786:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9785:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$L9787

; 6763 :       if ( lpViewArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $L9788

; 6764 :          continue;

	jmp	SHORT $L9786
$L9788:

; 6765 : 
; 6766 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6767 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6768 : 
; 6769 :       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 6770 :             lpEntityInstance;
; 6771 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9793
$L9794:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9793:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9795

; 6773 :          lpEntityInstance->u.nInd.bDBHCreated =
; 6774 :             lpEntityInstance->u.nInd.bDBHIncluded  =
; 6775 :             lpEntityInstance->u.nInd.bDBHDeleted   =
; 6776 :             lpEntityInstance->u.nInd.bDBHExcluded  =
; 6777 :             lpEntityInstance->u.nInd.bDBHUpdated   =
; 6778 :             lpEntityInstance->u.nInd.bSequenceUpdt =
; 6779 :             lpEntityInstance->u.nInd.bGenKeyNeeded =
; 6780 :             lpEntityInstance->u.nInd.bNoGenKey     =
; 6781 :             lpEntityInstance->u.nInd.bForeignKeys  = 0;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -4194305				; ffbfffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -2097153				; ffdfffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -1048577				; ffefffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -524289				; fff7ffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -131073				; fffdffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -65537				; fffeffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, -65					; ffffffbfH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, 127					; 0000007fH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, -33					; ffffffdfH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 6782 :       }

	jmp	$L9794
$L9795:

; 6783 :    }

	jmp	$L9786
$L9787:

; 6784 : 
; 6785 :    // Initialize the genkey handler and create the genkeys.  This will also
; 6786 :    // determine if any EI's need to have foreign keys set.
; 6787 :    lpKZGKHWOB = 0;

	mov	DWORD PTR _lpKZGKHWOB$[ebp], 0

; 6788 :    nRC = fnInitializeGenKeys( lpViewArray, nViewCount, pnViewErrorIdx,
; 6789 :                               lpCurrentTask, &lpKZGKHWOB, &pGKOper,
; 6790 :                               pViewArrayBlock );

	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	push	edx
	lea	eax, DWORD PTR _pGKOper$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	push	eax
	mov	cx, WORD PTR _nViewCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	push	edx
	call	_fnInitializeGenKeys@28
	mov	WORD PTR _nRC$[ebp], ax

; 6791 :    if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L9796

; 6792 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9767
$L9796:

; 6793 : 
; 6794 :    // Make sure that DBHandler is out there.
; 6795 :    lpTaskDBHandler = fnGetDBHandlerOper( lpCurrentTask, vSubtask, &pOper );

	lea	ecx, DWORD PTR _pOper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnGetDBHandlerOper@12
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax

; 6796 :    if ( lpTaskDBHandler == 0 )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	jne	SHORT $L9797

; 6797 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9767
$L9797:

; 6798 : 
; 6799 :    if ( lpTaskDBHandler->bTranStarted )

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	and	edx, 1
	test	edx, edx
	je	SHORT $L9798

; 6801 :       bTransactionStartedHere = FALSE;

	mov	BYTE PTR _bTransactionStartedHere$[ebp], 0

; 6802 :       lpPtr = lpTaskDBHandler->lpConnection;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	mov	DWORD PTR _lpPtr$[ebp], ecx

; 6804 :    else

	jmp	SHORT $L9799
$L9798:

; 6806 :       // Call DBHandler routine to issue start of transaction.
; 6807 :       lpViewOD = zGETPTR( vSubtask->hViewOD );

	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 6808 :       lpPtr = 0;

	mov	DWORD PTR _lpPtr$[ebp], 0

; 6809 :       nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 6810 :                       DBH_Object | DBH_TranBegin, DBH_StoreOI, lpViewOD,
; 6811 :                       0, vSubtask, 0, &lpPtr );

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	2
	push	16385					; 00004001H
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6812 :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L9803

; 6813 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9767
$L9803:

; 6814 : 
; 6815 :       bTransactionStartedHere = TRUE;

	mov	BYTE PTR _bTransactionStartedHere$[ebp], 1

; 6816 :       lpTaskDBHandler->bTranStarted = TRUE;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	or	ecx, 1
	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [edx+26], ecx

; 6817 :       lpTaskDBHandler->lpConnection = lpPtr;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR _lpPtr$[ebp]
	mov	DWORD PTR [eax+18], ecx
$L9799:

; 6819 : 
; 6820 :    // Commit each view separately.
; 6821 :    for ( k = 0; k < nViewCount && nRC >= 0; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9804
$L9805:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L9804:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $L9806
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L9806

; 6823 :       // If the view is 0 then we're not supposed to commit it (maybe it
; 6824 :       // wasn't changed?) so just skip it.
; 6825 :       if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $L9807

; 6826 :          continue;

	jmp	SHORT $L9805
$L9807:

; 6827 : 
; 6828 :       nRC = fnCommitSingleOI( lpViewArray[ k ], lControl, lpCurrentTask,
; 6829 :                               lpTaskDBHandler );

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_fnCommitSingleOI@16
	mov	WORD PTR _nRC$[ebp], ax

; 6830 : 
; 6831 :       // If there was an error then stop committing.
; 6832 :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L9808

; 6834 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $L9809

; 6835 :             *pnViewErrorIdx = k;

	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	cx, WORD PTR _k$[ebp]
	mov	WORD PTR [eax], cx
$L9809:

; 6836 : 
; 6837 :          break;

	jmp	SHORT $L9806
$L9808:

; 6839 :    }

	jmp	SHORT $L9805
$L9806:

; 6840 : 
; 6841 :    // If genkey work object defined, call genkey handler to commit genkeys.
; 6842 :    if ( lpKZGKHWOB )

	cmp	DWORD PTR _lpKZGKHWOB$[ebp], 0
	je	SHORT $L9810

; 6844 :       if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $L9811

; 6845 :          (*pGKOper)( DBH_Commit, vSubtask, 0, 0, lpKZGKHWOB );

	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	2
	call	DWORD PTR _pGKOper$[ebp]

; 6846 :       else

	jmp	SHORT $L9812
$L9811:

; 6847 :          (*pGKOper)( DBH_Rollback, vSubtask, 0, 0, lpKZGKHWOB );

	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	4
	call	DWORD PTR _pGKOper$[ebp]
$L9812:

; 6848 : 
; 6849 :       fnDropObjectInstance( lpKZGKHWOB );

	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	ecx
	call	_fnDropObjectInstance
	add	esp, 4
$L9810:

; 6851 : 
; 6852 :    // End the transaction if the transaction was started in this function call.
; 6853 :    if ( bTransactionStartedHere || lControl & zCOMMIT_FORCETRAN )

	mov	edx, DWORD PTR _bTransactionStartedHere$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L9814
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $L9818
$L9814:

; 6855 :       // We're about to close the transaction so set flag.
; 6856 :       lpTaskDBHandler->bTranStarted = FALSE;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [eax+26], edx

; 6857 :       lpTaskDBHandler->lpConnection = 0;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [ecx+18], 0

; 6858 : 
; 6859 :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L9815

; 6861 :          // Call DBHandler routine to issue rollback.
; 6862 :          (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 6863 :                    DBH_Object | DBH_Rollback, 0, lpViewOD,
; 6864 :                    0, vSubtask, 0, &lpPtr );

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	16388					; 00004004H
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]

; 6866 :       else

	jmp	SHORT $L9818
$L9815:

; 6868 :          // Incremental update succeeded; issue commit to DBhandler.
; 6869 :          nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 6870 :                          DBH_Object | DBH_Commit, DBH_StoreOI, lpViewOD, 0,
; 6871 :                          vSubtask, 0, &lpPtr );

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	2
	push	16386					; 00004002H
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$L9818:

; 6874 : 
; 6875 :    // If view was activated with locking then delete the locks.
; 6876 :    if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L9822

; 6878 :       // A LOD has been committed using pessimistic locks.  Delete the locks
; 6879 :       // on the LODs.
; 6880 :       if ( fnRemoveLocksOnOIs( lpCurrentTask, lpViewCluster,
; 6881 :                                nViewCount, pnViewErrorIdx ) != 0 )

	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	push	eax
	mov	cx, WORD PTR _nViewCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnRemoveLocksOnOIs@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9822

; 6883 :          nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H
$L9822:

; 6886 : 
; 6887 :    // If the transaction failed, return an error.
; 6888 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L9823

; 6889 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L9767
$L9823:

; 6890 : 
; 6891 :    // If the commit is OK and we have optimistic locking, then drop the
; 6892 :    // "old" OI and replace it with a copy of the new OI.
; 6893 :    for ( k = 0; k < nViewCount; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L9824
$L9825:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9824:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$L9826

; 6895 :       zVIEW vTemp;
; 6896 : 
; 6897 :       if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $L9828

; 6898 :          continue;

	jmp	SHORT $L9825
$L9828:

; 6899 : 
; 6900 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6901 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6902 : 
; 6903 :       if ( lpViewOI->lActivateControl & zACTIVATE_WITH_LOCKING &&
; 6904 :            (lpViewOD->nLock == zLL_OPTIMISTIC_NOINC ||
; 6905 :             lpViewOD->nLock == zLL_OPTIMISTIC_CMPRALL) )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, 67108864				; 04000000H
	test	eax, eax
	je	$L9831
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+236]
	cmp	edx, 1
	je	SHORT $L9832
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+236]
	cmp	ecx, 2
	jne	SHORT $L9831
$L9832:

; 6907 :          fnDropView( zGETPTR( lpViewOI->vOriginalOI ) );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4

; 6908 :          ActivateOI_FromOI_ForTask( &vTemp, lpViewArray[ k ], 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	lea	ecx, DWORD PTR _vTemp$9827[ebp]
	push	ecx
	call	_ActivateOI_FromOI_ForTask@16

; 6909 :          lpViewOI->vOriginalOI = zGETHNDL( vTemp );

	mov	edx, DWORD PTR _vTemp$9827[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 6910 :          vTemp->bOrigView      = TRUE;

	mov	edx, DWORD PTR _vTemp$9827[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, -128				; ffffff80H
	mov	ecx, DWORD PTR _vTemp$9827[ebp]
	mov	DWORD PTR [ecx+30], eax

; 6911 :          vTemp->bViewLocked    = TRUE;

	mov	edx, DWORD PTR _vTemp$9827[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _vTemp$9827[ebp]
	mov	DWORD PTR [ecx+30], eax

; 6912 :          vTemp->hMainOI        = lpViewCsr->hViewOI;

	mov	edx, DWORD PTR _vTemp$9827[ebp]
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR [edx+26], ecx
$L9831:

; 6914 : 
; 6915 :       if ( (lControl & zCOMMIT_NOCLEANUP) == 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 256				; 00000100H
	test	edx, edx
	jne	SHORT $L9835

; 6917 :          // Clean-up and reclaim hidden (i.e. deleted) instances.
; 6918 :          fnCleanupInstance( lpViewArray[ k ], 1 );

	push	1
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_fnCleanupInstance
	add	esp, 8
$L9835:

; 6920 : 
; 6921 :       // Mark the object instance as not updated.
; 6922 :       lpViewOI->bUpdated = lpViewOI->bUpdatedFile = 0;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 6923 :    }

	jmp	$L9825
$L9826:

; 6924 : 
; 6925 :    return( 0 );

	xor	ax, ax
$L9767:

; 6926 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_fnCommitObjectInstance@28 ENDP
_TEXT	ENDS
PUBLIC	_fnPutDataToFile@20
EXTRN	_SysWriteLine@12:NEAR
EXTRN	_SysWriteLineLth@20:NEAR
_TEXT	SEGMENT
_lpTaskView$ = 8
_lpvData$ = 12
_pchBuffer$ = 16
_ulLth$ = 20
_lpFileData$ = -4
_fnPutDataToFile@20 PROC NEAR

; 6934 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 6935 :    LPFILEDATA lpFileData = (LPFILEDATA) lpvData;

	mov	eax, DWORD PTR _lpvData$[ebp]
	mov	DWORD PTR _lpFileData$[ebp], eax

; 6936 : 
; 6937 :    if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $L9850

; 6938 :       return( SysWriteLineLth( lpTaskView, lpFileData->hFile, pchBuffer, ulLth, TRUE ) );

	push	1
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFileData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_SysWriteLineLth@20
	jmp	SHORT $L9851
$L9850:

; 6939 :    else
; 6940 :       return( SysWriteLine( lpTaskView, lpFileData->hFile, pchBuffer ) );

	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysWriteLine@12
$L9851:

; 6941 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnPutDataToFile@20 ENDP
_TEXT	ENDS
PUBLIC	_UUENCODE_NextEncodedLine@16
PUBLIC	_fnWriteOI_ToTextStream
PUBLIC	??_C@_0L@BBG@mOITAG?5?$CFlx?$AA@		; `string'
PUBLIC	??_C@_0BA@JENH@mOITAG?5?5?5?5?5?5?$CFlx?$AA@	; `string'
PUBLIC	??_C@_0N@OMJF@mOIFLAGS?5?$CFlx?$AA@		; `string'
PUBLIC	??_C@_0BA@GFPC@mOIFLAGS?5?5?5?5?$CFlx?$AA@	; `string'
PUBLIC	??_C@_05HEAD@?$CFx?5?$CFx?$AA@			; `string'
PUBLIC	??_C@_09GLEP@mETAG?5?$CFlx?$AA@			; `string'
PUBLIC	??_C@_0P@DBLN@mETAG?5?5?5?5?5?5?$CFlx?$AA@	; `string'
PUBLIC	??_C@_09KKHA@mEKEY?5?$CFlx?$AA@			; `string'
PUBLIC	??_C@_0P@IJFA@mEKEY?5?5?5?5?5?5?$CFlx?$AA@	; `string'
PUBLIC	??_C@_04NHOC@?0?$CFlx?$AA@			; `string'
PUBLIC	??_C@_07HIC@a?$CFlx?$CFs?5?$AA@			; `string'
PUBLIC	??_C@_04DCMN@?$CFs?$CFs?$AA@			; `string'
PUBLIC	??_C@_06IACC@a?$CF?99s?5?$AA@			; `string'
PUBLIC	??_C@_04KPK@a?5?$CFx?$AA@			; `string'
PUBLIC	??_C@_0FA@OBP@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Src?5View?5E@ ; `string'
PUBLIC	??_C@_0DN@MLKO@Error?5writing?5OI?3?5ER?5Tokens?5don?8@ ; `string'
PUBLIC	??_C@_08GN@i?$CFlx?5?$CFlx?$AA@			; `string'
PUBLIC	??_C@_05KPKL@c?$CFx?50?$AA@			; `string'
PUBLIC	??_C@_07BFPN@c?$CFx?5?$CFlx?$AA@		; `string'
EXTRN	_fnGetStringFromAttribute:NEAR
EXTRN	_fnGetIntegerFromAttribute:NEAR
EXTRN	_fnGetAddrForAttribute:NEAR
EXTRN	_fnDisplayEntityInstance:NEAR
EXTRN	_fnGetAttributeLength:NEAR
EXTRN	_strlen:NEAR
EXTRN	__imp__atol:NEAR
EXTRN	__imp___ltoa:NEAR
;	COMDAT ??_C@_0L@BBG@mOITAG?5?$CFlx?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0L@BBG@mOITAG?5?$CFlx?$AA@ DB 'mOITAG %lx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JENH@mOITAG?5?5?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_0BA@JENH@mOITAG?5?5?5?5?5?5?$CFlx?$AA@ DB 'mOITAG      %lx', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@OMJF@mOIFLAGS?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_0N@OMJF@mOIFLAGS?5?$CFlx?$AA@ DB 'mOIFLAGS %lx', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GFPC@mOIFLAGS?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_0BA@GFPC@mOIFLAGS?5?5?5?5?$CFlx?$AA@ DB 'mOIFLAGS    %lx', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_05HEAD@?$CFx?5?$CFx?$AA@
_DATA	SEGMENT
??_C@_05HEAD@?$CFx?5?$CFx?$AA@ DB '%x %x', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GLEP@mETAG?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_09GLEP@mETAG?5?$CFlx?$AA@ DB 'mETAG %lx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@DBLN@mETAG?5?5?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_0P@DBLN@mETAG?5?5?5?5?5?5?$CFlx?$AA@ DB 'mETAG      %lx', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_09KKHA@mEKEY?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_09KKHA@mEKEY?5?$CFlx?$AA@ DB 'mEKEY %lx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@IJFA@mEKEY?5?5?5?5?5?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_0P@IJFA@mEKEY?5?5?5?5?5?5?$CFlx?$AA@ DB 'mEKEY      %lx', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NHOC@?0?$CFlx?$AA@
_DATA	SEGMENT
??_C@_04NHOC@?0?$CFlx?$AA@ DB ',%lx', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HIC@a?$CFlx?$CFs?5?$AA@
_DATA	SEGMENT
??_C@_07HIC@a?$CFlx?$CFs?5?$AA@ DB 'a%lx%s ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DCMN@?$CFs?$CFs?$AA@
_DATA	SEGMENT
??_C@_04DCMN@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IACC@a?$CF?99s?5?$AA@
_DATA	SEGMENT
??_C@_06IACC@a?$CF?99s?5?$AA@ DB 'a%-9s ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04KPK@a?5?$CFx?$AA@
_DATA	SEGMENT
??_C@_04KPK@a?5?$CFx?$AA@ DB 'a %x', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FA@OBP@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Src?5View?5E@
_DATA	SEGMENT
??_C@_0FA@OBP@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Src?5View?5E@ DB '('
	DB	'oi) Error (OD: %s) - Src View Entity: %s Token: %d  View Enti'
	DB	'ty: %s Token = %d', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DN@MLKO@Error?5writing?5OI?3?5ER?5Tokens?5don?8@
_DATA	SEGMENT
??_C@_0DN@MLKO@Error?5writing?5OI?3?5ER?5Tokens?5don?8@ DB 'Error writing'
	DB	' OI: ER Tokens don''t match for linked entities!', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GN@i?$CFlx?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_08GN@i?$CFlx?5?$CFlx?$AA@ DB 'i%lx %lx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KPKL@c?$CFx?50?$AA@
_DATA	SEGMENT
??_C@_05KPKL@c?$CFx?50?$AA@ DB 'c%x 0', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07BFPN@c?$CFx?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_07BFPN@c?$CFx?5?$CFlx?$AA@ DB 'c%x %lx', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_lpfnStreamFunc$ = 12
_lpvData$ = 16
_bIncremental$ = 20
_lControl$ = 24
_lpApp$ = -352
_lpViewOD$ = -12
_lpViewOI$ = -404
_lpViewEntity$ = -28
_lpViewAttrib$ = -40
_lpViewCsr$ = -4
_lpEntityInstance$ = -24
_ViewEntityCsr$ = -400
_lpTask$ = -32
_lpAttribFlags$ = -364
_pchAttr$ = -20
_pchBuffer$ = -36
_szWorkString$ = -348
_lLastLinkedInstance$ = -368
_lHierCount$ = -408
_ulLth$ = -360
_uPos$ = -48
_bMsgBox$ = -44
_nLevel$ = -8
_k$ = -356
_nRC$ = -16
_uFlags$9909 = -412
_bEntityIsCompressed$9925 = -424
_pchBufferEnd$9926 = -416
_bValuesStored$9927 = -420
_lTemp$9949 = -428
_lpLinked$9975 = -432
_l$9997 = -436
_bStringContainsSpecialChars$10007 = -452
_szAttribFlags$10008 = -448
_szAttribName$10017 = -504
_pch$10021 = -508
_cStreamType$10032 = -512
_bAttribIsNull$10062 = -516
_l$10064 = -520
_szLth$10075 = -540
_lpSourceEntityInstance$10084 = -544
_lpTask$10113 = -556
_vWork$10115 = -548
_lpWorkViewEntityCsr$10116 = -552
_lpSrcViewEntity$10122 = -560
_lpViewEntityCsr$10138 = -572
_lpCurrentEI$10139 = -568
_lInstanceCount$10140 = -564
_lpSrchInstance$10154 = -576
_bNoTwins$10155 = -580
_fnWriteOI_ToTextStream PROC NEAR

; 6957 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 584				; 00000248H

; 6958 :    LPAPP                lpApp;
; 6959 :    LPVIEWOD             lpViewOD;
; 6960 :    LPVIEWOI             lpViewOI;
; 6961 :    LPVIEWENTITY         lpViewEntity;
; 6962 :    LPVIEWATTRIB         lpViewAttrib;
; 6963 :    LPVIEWCSR            lpViewCsr;
; 6964 :    LPENTITYINSTANCE     lpEntityInstance;
; 6965 :    ViewEntityCsrRecord  ViewEntityCsr;
; 6966 :    LPTASK               lpTask;
; 6967 :    LPATTRIBFLAGS        lpAttribFlags;
; 6968 :    zPCHAR               pchAttr;
; 6969 :    zPCHAR               pchBuffer = 0;

	mov	DWORD PTR _pchBuffer$[ebp], 0

; 6970 :    zCHAR                szWorkString[ 300 ];
; 6971 :    zLONG                lLastLinkedInstance;
; 6972 :    zLONG                lHierCount;
; 6973 :    zULONG               ulLth;
; 6974 :    zULONG               uPos;
; 6975 :    zBOOL                bMsgBox = TRUE;

	mov	BYTE PTR _bMsgBox$[ebp], 1

; 6976 :    zSHORT               nLevel;
; 6977 :    zSHORT               k;
; 6978 :    zSHORT               nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 6979 : 
; 6980 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6981 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6982 :    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 6983 :    lpApp     = zGETPTR( lpViewOD->hApp );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 6984 :    lpTask    = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 6985 : 
; 6986 :    // If user wants entity tags, write out the tag for the OI.
; 6987 :    if ( lControl & zENTITY_TAGS )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 524288				; 00080000H
	test	ecx, ecx
	je	SHORT $L9890

; 6989 :       if ( lControl & zCOMPRESSED )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L9891

; 6990 :          zsprintf( szWorkString, "mOITAG %lx", (zLONG) lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@BBG@mOITAG?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 6991 :       else

	jmp	SHORT $L9894
$L9891:

; 6992 :          zsprintf( szWorkString, "mOITAG      %lx", (zLONG) lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BA@JENH@mOITAG?5?5?5?5?5?5?$CFlx?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9894:

; 6993 : 
; 6994 :       if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9897

; 6995 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9863
$L9897:

; 6997 :    else

	jmp	SHORT $L9902
$L9890:

; 6998 :    if ( lpViewOI->lTag )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $L9902

; 7000 :       // If the tag for the current OI is non-zero, then we'll write it.
; 7001 :       if ( lControl & zCOMPRESSED )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L9900

; 7002 :          zsprintf( szWorkString, "mOITAG %lx", lpViewOI->lTag );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	push	OFFSET FLAT:??_C@_0L@BBG@mOITAG?5?$CFlx?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7003 :       else

	jmp	SHORT $L9901
$L9900:

; 7004 :          zsprintf( szWorkString, "mOITAG      %lx", lpViewOI->lTag );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	push	OFFSET FLAT:??_C@_0BA@JENH@mOITAG?5?5?5?5?5?5?$CFlx?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9901:

; 7005 : 
; 7006 :       if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9902

; 7007 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9863
$L9902:

; 7009 : 
; 7010 :    // Set some flags.
; 7011 :    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 7012 :          lpEntityInstance;
; 7013 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9905
$L9906:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9905:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L9907

; 7015 :       lpEntityInstance->u.nInd.bWritten =
; 7016 :          lpEntityInstance->u.nInd.bRecordOwner = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ch, -17					; ffffffefH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 7017 : 
; 7018 :       lpEntityInstance->lHierCount = 0;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+54], 0

; 7019 :    }

	jmp	SHORT $L9906
$L9907:

; 7020 : 
; 7021 :    // We need to write some information about the OI.
; 7022 :    if ( lControl & zINCREMENTAL )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 65536				; 00010000H
	test	ecx, ecx
	je	$L9917

; 7024 :       zULONG uFlags = 0;

	mov	DWORD PTR _uFlags$9909[ebp], 0

; 7025 : 
; 7026 :       uFlags = 0;

	mov	DWORD PTR _uFlags$9909[ebp], 0

; 7027 :       if ( lpViewOI->bIsLocked )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 7
	and	eax, 1
	test	eax, eax
	je	SHORT $L9910

; 7028 :          uFlags |= zOI_ISLOCKED;

	mov	ecx, DWORD PTR _uFlags$9909[ebp]
	or	ecx, 1
	mov	DWORD PTR _uFlags$9909[ebp], ecx
$L9910:

; 7029 : 
; 7030 :       if ( lpView->bReadOnly )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	je	SHORT $L9911

; 7031 :          uFlags |= zOI_READONLY;

	mov	ecx, DWORD PTR _uFlags$9909[ebp]
	or	ecx, 2
	mov	DWORD PTR _uFlags$9909[ebp], ecx
$L9911:

; 7032 : 
; 7033 :       if ( uFlags )

	cmp	DWORD PTR _uFlags$9909[ebp], 0
	je	SHORT $L9917

; 7035 :          if ( lControl & zCOMPRESSED )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L9913

; 7036 :             zsprintf( szWorkString, "mOIFLAGS %lx", uFlags );

	mov	eax, DWORD PTR _uFlags$9909[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0N@OMJF@mOIFLAGS?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7037 :          else

	jmp	SHORT $L9915
$L9913:

; 7038 :             zsprintf( szWorkString, "mOIFLAGS    %lx", uFlags );

	mov	edx, DWORD PTR _uFlags$9909[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BA@GFPC@mOIFLAGS?5?5?5?5?$CFlx?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9915:

; 7039 : 
; 7040 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9917

; 7041 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L9863
$L9917:

; 7044 : 
; 7045 :    // If we are writting the OI in a compressed format, we need a buffer.
; 7046 :    if ( lControl & zCOMPRESSED )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L9918

; 7048 :       // Allocate a buffer to contain attribute data for an entity.
; 7049 :       pchBuffer = fnAllocDataspace( lpTask->hFirstDataHeader,
; 7050 :                                     zENTITY_BUFFER_SIZE, 0, 0, iBuffer );

	push	10105					; 00002779H
	push	0
	push	0
	push	10000					; 00002710H
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pchBuffer$[ebp], eax

; 7051 :       pchBuffer = zGETPTR( pchBuffer );

	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchBuffer$[ebp], eax
$L9918:

; 7053 : 
; 7054 :    // write out the entity instances
; 7055 :    lpAttribFlags = 0;

	mov	DWORD PTR _lpAttribFlags$[ebp], 0

; 7056 :    lHierCount = 0;

	mov	DWORD PTR _lHierCount$[ebp], 0

; 7057 :    lLastLinkedInstance = -1;      // last linked relative instance counter

	mov	DWORD PTR _lLastLinkedInstance$[ebp], -1

; 7058 :    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 7059 :          lpEntityInstance;
; 7060 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9922
$L9923:
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9922:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L9924

; 7062 :       zBOOL  bEntityIsCompressed;
; 7063 :       zPCHAR pchBufferEnd;
; 7064 :       zBOOL  bValuesStored;
; 7065 : 
; 7066 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 7067 : 
; 7068 :       // This entity can be compressed if:
; 7069 :       // o  lControl specifies compression.
; 7070 :       // o  The max size of all the attributes for the entity is smaller
; 7071 :       //    then the buffer we set up to hold all the attribute values.
; 7072 :       bEntityIsCompressed = lControl & zCOMPRESSED &&
; 7073 :                             lpViewEntity->ulMaxLth < zENTITY_BUFFER_SIZE;

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L12812
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [ecx+203], 10000		; 00002710H
	jae	SHORT $L12812
	mov	DWORD PTR -584+[ebp], 1
	jmp	SHORT $L12813
$L12812:
	mov	DWORD PTR -584+[ebp], 0
$L12813:
	mov	dl, BYTE PTR -584+[ebp]
	mov	BYTE PTR _bEntityIsCompressed$9925[ebp], dl

; 7074 : 
; 7075 : #if 0
; 7076 :       // DGC 02/25/98
; 7077 :       // Following code is called and may be (?) needed.
; 7078 :       if ( bIncremental &&
; 7079 :            lpEntityInstance->u.nInd.bExcluded &&
; 7080 :            lpEntityInstance->u.nInd.bDeleted &&
; 7081 :            lpEntityInstance->u.nInd.bCreated == FALSE &&
; 7082 :            lpEntityInstance->u.nInd.bIncluded == FALSE &&
; 7083 :            lpEntityInstance->u.nInd.bRelOwner &&
; 7084 :            lpViewEntity->bDelete == FALSE &&
; 7085 :            lpViewEntity->bExclude )
; 7086 :       {
; 7087 :          LPENTITYINSTANCE lpDupInstance;
; 7088 :          LPVIEWENTITY     lpDupViewEntity;
; 7089 : 
; 7090 :          lpDupInstance = lpEntityInstance;
; 7091 :          for ( ; ; )
; 7092 :          {
; 7093 :             lpDupInstance = fnFindDuplicateRelationship( lpDupInstance, 1, 0 );
; 7094 :             if ( lpDupInstance == 0 || lpDupInstance == lpEntityInstance )
; 7095 :                break;
; 7096 : 
; 7097 :             lpDupViewEntity = zGETPTR( lpDupInstance->hViewEntity );
; 7098 :             if ( lpDupInstance->u.nInd.bDeleted &&
; 7099 :                  lpDupViewEntity->bDerivedPath == FALSE &&
; 7100 :                  lpDupViewEntity->bDelete )
; 7101 :             {
; 7102 :                lpEntityInstance->u.nInd.bExcluded = FALSE;
; 7103 :                break;
; 7104 :             }
; 7105 :             else
; 7106 :             {
; 7107 :                lpDupInstance->u.nInd.bRelOwner = FALSE;
; 7108 :             }
; 7109 :          }
; 7110 :       }
; 7111 : #endif
; 7112 : 
; 7113 :       // Look to see if the current instance should be written out.  If
; 7114 :       // not we'll skip it and go on to the next one.  All non-hidden
; 7115 :       // instances get written so we'll look for that first.
; 7116 :       if ( lpEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	je	$L9930

; 7118 :          // The EI is hidden.  Don't write the current EI if we're not
; 7119 :          // writing incrementals or if the EI is dead.
; 7120 :          if ( bIncremental == FALSE ||
; 7121 :               fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	edx, DWORD PTR _bIncremental$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L9931
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnEntityInstanceIsDead@4
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9930
$L9931:

; 7123 :             nLevel = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nLevel$[ebp], ax

; 7124 : 
; 7125 :             for ( lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );
; 7126 :                   lpEntityInstance;
; 7127 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L9934
$L9935:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L9934:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L9936

; 7129 :                if ( lpEntityInstance->nLevel <= nLevel )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	eax, ecx
	jg	SHORT $L9937

; 7130 :                   break;

	jmp	SHORT $L9936
$L9937:

; 7131 :             }

	jmp	SHORT $L9935
$L9936:

; 7132 : 
; 7133 :             if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $L9938

; 7134 :                break;

	jmp	$L9924
$L9938:

; 7135 :             else
; 7136 :                lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 7137 : 
; 7138 :             // Continue with the next EI.
; 7139 :             continue;

	jmp	$L9923
$L9930:

; 7142 : 
; 7143 :       lpEntityInstance->lHierCount = lHierCount++;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR _lHierCount$[ebp]
	mov	DWORD PTR [ecx+54], edx
	mov	eax, DWORD PTR _lHierCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _lHierCount$[ebp], eax

; 7144 : 
; 7145 :       // Build the entity name line.
; 7146 :       szWorkString[ 0 ] = 'e';

	mov	BYTE PTR _szWorkString$[ebp], 101	; 00000065H

; 7147 :       if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L9941

; 7149 :          // Use the hierarchical number instead of the entity name.
; 7150 :          zsprintf( szWorkString + 1, "%x %x", lpViewEntity->nHierNbr,
; 7151 :                    lpEntityInstance->nLevel );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	push	edx
	push	OFFSET FLAT:??_C@_05HEAD@?$CFx?5?$CFx?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp+1]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 7152 :          k = zstrlen( szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 7154 :       else

	jmp	$L9943
$L9941:

; 7156 :          zstrcpy( szWorkString + 1, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp+1]
	push	eax
	call	_strcpy
	add	esp, 8

; 7157 :          k = zstrlen( szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 7158 : 
; 7159 :          szWorkString[ k++ ] = ' ';

	movsx	edx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 32	; 00000020H
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L9945:

; 7160 :          while ( k < 11 )

	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 11					; 0000000bH
	jge	SHORT $L9946

; 7161 :             szWorkString[ k++ ] = ' ';

	movsx	edx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 32	; 00000020H
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $L9945
$L9946:

; 7162 : 
; 7163 :          zltoa( lpEntityInstance->nLevel, &szWorkString[ k ] );

	push	10					; 0000000aH
	movsx	ecx, WORD PTR _k$[ebp]
	lea	edx, DWORD PTR _szWorkString$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7164 :          k = zstrlen( szWorkString );

	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax
$L9943:

; 7166 : 
; 7167 :       // if we are writing an incremental file, write out the indicators.
; 7168 :       if ( bIncremental )

	mov	eax, DWORD PTR _bIncremental$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L9948

; 7170 :          szWorkString[ k++ ] = ',';

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 44	; 0000002cH
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 7171 :          zbtoa( lpEntityInstance->u.nIndicators, &szWorkString[ k ] );

	push	10					; 0000000aH
	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7172 : 
; 7173 :          if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L9948

; 7175 :             zLONG lTemp;
; 7176 : 
; 7177 :             // Convert number for decimal format to hexadecimal.
; 7178 :             lTemp = zatol( &szWorkString[ k ] );

	movsx	edx, WORD PTR _k$[ebp]
	lea	eax, DWORD PTR _szWorkString$[ebp+edx]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lTemp$9949[ebp], eax

; 7179 :             zltox( lTemp, &szWorkString[ k ] );

	push	16					; 00000010H
	movsx	ecx, WORD PTR _k$[ebp]
	lea	edx, DWORD PTR _szWorkString$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _lTemp$9949[ebp]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$L9948:

; 7182 : 
; 7183 :       // Write out the entity name.
; 7184 :       if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L9950

; 7185 :          goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L9950:

; 7186 : 
; 7187 :       // If user wants entity tags, write it.
; 7188 :       if ( lControl & zENTITY_TAGS )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 524288				; 00080000H
	test	edx, edx
	je	SHORT $L9952

; 7190 :          if ( lControl & zCOMPRESSED )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L9953

; 7191 :             zsprintf( szWorkString, "mETAG %lx", (zLONG) lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_09GLEP@mETAG?5?$CFlx?$AA@ ; `string'
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7192 :          else

	jmp	SHORT $L9956
$L9953:

; 7193 :             zsprintf( szWorkString, "mETAG      %lx", (zLONG) lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0P@DBLN@mETAG?5?5?5?5?5?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9956:

; 7194 : 
; 7195 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9959

; 7196 :             goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L9959:

; 7198 :       else

	jmp	SHORT $L9964
$L9952:

; 7199 :       if ( lpEntityInstance->lTag )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+46], 0
	je	SHORT $L9964

; 7201 :          // If the tag for the current entity instance is non-zero, then we'll
; 7202 :          // write it.
; 7203 :          if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L9962

; 7204 :             zsprintf( szWorkString, "mETAG %lx", lpEntityInstance->lTag );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+46]
	push	eax
	push	OFFSET FLAT:??_C@_09GLEP@mETAG?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7205 :          else

	jmp	SHORT $L9963
$L9962:

; 7206 :             zsprintf( szWorkString, "mETAG      %lx", lpEntityInstance->lTag );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+46]
	push	eax
	push	OFFSET FLAT:??_C@_0P@DBLN@mETAG?5?5?5?5?5?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9963:

; 7207 : 
; 7208 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9964

; 7209 :             goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L9964:

; 7211 : 
; 7212 :       if ( lControl & zENTITY_KEYS )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2097152				; 00200000H
	test	eax, eax
	je	SHORT $L9970

; 7214 :          if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L9966

; 7215 :             zsprintf( szWorkString, "mEKEY %lx", lpEntityInstance->ulKey );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+50]
	push	eax
	push	OFFSET FLAT:??_C@_09KKHA@mEKEY?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7216 :          else

	jmp	SHORT $L9968
$L9966:

; 7217 :             zsprintf( szWorkString, "mEKEY      %lx", lpEntityInstance->ulKey );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+50]
	push	eax
	push	OFFSET FLAT:??_C@_0P@IJFA@mEKEY?5?5?5?5?5?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L9968:

; 7218 : 
; 7219 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9970

; 7220 :             goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L9970:

; 7222 : 
; 7223 :       // If the EI has already been written (this means it's linked to another
; 7224 :       // EI that has already been written) and it has no non-persist record,
; 7225 :       // then we don't need to write it's attribute values.
; 7226 :       lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 7227 :       if ( lpEntityInstance->u.nInd.bWritten )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 12					; 0000000cH
	and	eax, 1
	test	eax, eax
	je	SHORT $L9973

; 7229 :          lLastLinkedInstance = lpEntityInstance->lHierCount;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+54]
	mov	DWORD PTR _lLastLinkedInstance$[ebp], edx

; 7230 : 
; 7231 :          if ( lpEntityInstance->u.nInd.bHidden == FALSE &&
; 7232 :               lpEntityInstance->hNonPersistRecord == FALSE )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9973
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+64], 0
	jne	SHORT $L9973

; 7234 :             bEntityIsCompressed = FALSE; // Make sure we don't write anything

	mov	BYTE PTR _bEntityIsCompressed$9925[ebp], 0

; 7235 :             lpViewAttrib = 0;

	mov	DWORD PTR _lpViewAttrib$[ebp], 0
$L9973:

; 7238 : 
; 7239 :       // Set flag to indicate that entity instance has been written to
; 7240 :       // the stream.  Let's also mark all the linked instances.
; 7241 :       if ( lpEntityInstance->u.nInd.bWritten == FALSE &&
; 7242 :            lpEntityInstance->hNextLinked )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9980
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $L9980

; 7244 :          LPENTITYINSTANCE lpLinked;
; 7245 : 
; 7246 :          // Set the record owner.  This means that this EI will not have
; 7247 :          // link lines written (e.g. "i38,102") for it.
; 7248 :          lpEntityInstance->u.nInd.bRecordOwner = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 7249 : 
; 7250 :          for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );
; 7251 :                lpLinked != lpEntityInstance;
; 7252 :                lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$9975[ebp], eax
	jmp	SHORT $L9978
$L9979:
	mov	edx, DWORD PTR _lpLinked$9975[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$9975[ebp], eax
$L9978:
	mov	ecx, DWORD PTR _lpLinked$9975[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L9980

; 7254 :             // For a little insurance we'll only set the flags for EIs in
; 7255 :             // the same OI.
; 7256 :             if ( lpLinked->hViewOI == lpEntityInstance->hViewOI )

	mov	edx, DWORD PTR _lpLinked$9975[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+10]
	jne	SHORT $L9981

; 7257 :                lpLinked->u.nInd.bWritten = TRUE;

	mov	edx, DWORD PTR _lpLinked$9975[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 16					; 00000010H
	mov	ecx, DWORD PTR _lpLinked$9975[ebp]
	mov	DWORD PTR [ecx+6], eax
$L9981:

; 7258 :          }

	jmp	SHORT $L9979
$L9980:

; 7260 : 
; 7261 :       lpEntityInstance->u.nInd.bWritten = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 16					; 00000010H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 7262 : 
; 7263 :       // Some stuff needs to be done if we're storing in compressed format...
; 7264 :       if ( bEntityIsCompressed )

	mov	edx, DWORD PTR _bEntityIsCompressed$9925[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L9982

; 7266 :          // pchBufferEnd points to the first unused byte in the compression
; 7267 :          // buffer.
; 7268 :          pchBufferEnd = pchBuffer;

	mov	eax, DWORD PTR _pchBuffer$[ebp]
	mov	DWORD PTR _pchBufferEnd$9926[ebp], eax

; 7269 : 
; 7270 :          // In rare cases an entity will have all NULL attribute
; 7271 :          // values (this will usually occur when an instance is linked).
; 7272 :          // If that happens, don't bother writting the attribute values.
; 7273 :          bValuesStored = FALSE;

	mov	BYTE PTR _bValuesStored$9927[ebp], 0
$L9982:

; 7275 : 
; 7276 :       ViewEntityCsr.hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _ViewEntityCsr$[ebp+26], eax

; 7277 : 
; 7278 :       // Write the attribute values.
; 7279 :       for ( ;              // assigned above
; 7280 :             lpViewAttrib;
; 7281 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	jmp	SHORT $L9985
$L9986:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L9985:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$L9987

; 7283 :          static AttribFlagsRecord ZeroAttribFlags = { 0 };
; 7284 : 
; 7285 :          // If attribute is derived, don't bother.
; 7286 :          if ( lpViewAttrib->szDerivedOper[ 0 ] &&
; 7287 :               lpViewAttrib->bPersist == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+213]
	test	edx, edx
	je	SHORT $L9990
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9990

; 7289 :             continue;

	jmp	SHORT $L9986
$L9990:

; 7291 : 
; 7292 :          // If we are only writing keys and this attr isn't a key then skip it.
; 7293 :          if ( lControl & zWRITE_KEYS_ONLY && lpViewAttrib->bKey == FALSE )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1048576				; 00100000H
	test	edx, edx
	je	SHORT $L9991
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L9991

; 7294 :             continue;

	jmp	SHORT $L9986
$L9991:

; 7295 : 
; 7296 :          // Get a pointer to the attribute flags if we are writing incremental
; 7297 :          // flags.  If we're not writing incremental then we'll leave the ptr
; 7298 :          // as it is--WHICH HAD BETTER BE 0.
; 7299 :          if ( bIncremental )

	mov	edx, DWORD PTR _bIncremental$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L9993

; 7301 :             lpAttribFlags = fnGetAttribFlagsPtr( lpEntityInstance,
; 7302 :                                                  lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$[ebp], eax

; 7303 : 
; 7304 :             // If lpAttribFlags is 0 then this means that a data record
; 7305 :             // (i.e. data stick) has been created for this attrib.  Just set
; 7306 :             // lpAttribFlags to point to a 0 flag record.
; 7307 :             if ( lpAttribFlags == 0 )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	jne	SHORT $L9993

; 7308 :                lpAttribFlags = &ZeroAttribFlags;

	mov	DWORD PTR _lpAttribFlags$[ebp], OFFSET FLAT:_?ZeroAttribFlags@?BJ@??fnWriteOI_ToTextStream@@9@9
$L9993:

; 7310 : 
; 7311 :          if ( bEntityIsCompressed && lpViewAttrib->cType != zTYPE_BLOB )

	mov	edx, DWORD PTR _bEntityIsCompressed$9925[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	$L9994
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	je	$L9994

; 7313 :             // If the entity is linked with another, then we don't need to store
; 7314 :             // the attribute value, but we do need to store a dummy value in the
; 7315 :             // attribute buffer.
; 7316 :             if ( lpViewAttrib->bPersist &&
; 7317 :                  lpEntityInstance->lHierCount == lLastLinkedInstance )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	test	eax, eax
	je	SHORT $L9995
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+54]
	cmp	edx, DWORD PTR _lLastLinkedInstance$[ebp]
	jne	SHORT $L9995

; 7319 :                *pchBufferEnd++ = 0;

	mov	eax, DWORD PTR _pchBufferEnd$9926[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pchBufferEnd$9926[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchBufferEnd$9926[ebp], ecx

; 7320 :                continue;

	jmp	$L9986
$L9995:

; 7322 : 
; 7323 :             if ( lpViewAttrib->cType == zTYPE_INTEGER )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $L9996

; 7325 :                zLONG l;
; 7326 : 
; 7327 :                if ( fnGetIntegerFromAttribute( &l, lpView, &ViewEntityCsr,
; 7328 :                                                lpViewAttrib ) != 0 )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _l$9997[ebp]
	push	ecx
	call	_fnGetIntegerFromAttribute
	add	esp, 16					; 00000010H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L9998

; 7330 :                   // Integer is null so set null value.
; 7331 :                   *pchBufferEnd = 0;

	mov	eax, DWORD PTR _pchBufferEnd$9926[ebp]
	mov	BYTE PTR [eax], 0

; 7333 :                else

	jmp	SHORT $L10001
$L9998:

; 7334 :                if ( l >= 0 )

	cmp	DWORD PTR _l$9997[ebp], 0
	jl	SHORT $L10000

; 7335 :                   zltox( l, pchBufferEnd );

	push	16					; 00000010H
	mov	ecx, DWORD PTR _pchBufferEnd$9926[ebp]
	push	ecx
	mov	edx, DWORD PTR _l$9997[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7336 :                else

	jmp	SHORT $L10001
$L10000:

; 7338 :                   *pchBufferEnd = '-';

	mov	eax, DWORD PTR _pchBufferEnd$9926[ebp]
	mov	BYTE PTR [eax], 45			; 0000002dH

; 7339 :                   zltox( l * -1, pchBufferEnd + 1 );

	push	16					; 00000010H
	mov	ecx, DWORD PTR _pchBufferEnd$9926[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _l$9997[ebp]
	imul	edx, -1
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$L10001:

; 7342 :             else

	jmp	SHORT $L10002
$L9996:

; 7343 :                fnGetStringFromAttribute( pchBufferEnd, zENTITY_BUFFER_SIZE,
; 7344 :                                          lpView, &ViewEntityCsr,
; 7345 :                                          lpViewAttrib, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	10000					; 00002710H
	mov	eax, DWORD PTR _pchBufferEnd$9926[ebp]
	push	eax
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
$L10002:

; 7346 : 
; 7347 :             // Check to see if we have a valid (i.e. non-null) attribute
; 7348 :             // value.  If we do, then we've stored a "real" value.
; 7349 :             if ( *pchBufferEnd )

	mov	ecx, DWORD PTR _pchBufferEnd$9926[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L10003

; 7350 :                bValuesStored = TRUE;

	mov	BYTE PTR _bValuesStored$9927[ebp], 1
$L10003:

; 7351 : 
; 7352 :             pchBufferEnd += zstrlen( pchBufferEnd ) + 1;

	mov	eax, DWORD PTR _pchBufferEnd$9926[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchBufferEnd$9926[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchBufferEnd$9926[ebp], edx

; 7353 : 
; 7354 :             // If the attrib flags is not 0 then we need to write them as well.
; 7355 :             if ( lpAttribFlags )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $L10004

; 7357 :                zltox( (zLONG) lpAttribFlags->u.uFlags, pchBufferEnd );

	push	16					; 00000010H
	mov	eax, DWORD PTR _pchBufferEnd$9926[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7358 :                pchBufferEnd += zstrlen( pchBufferEnd ) + 1;

	mov	eax, DWORD PTR _pchBufferEnd$9926[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchBufferEnd$9926[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchBufferEnd$9926[ebp], edx
$L10004:

; 7362 :          else

	jmp	$L10073
$L9994:

; 7364 :             zBOOL bStringContainsSpecialChars;
; 7365 :             zCHAR szAttribFlags[ 12 ];
; 7366 : 
; 7367 :             // If the current entity instance is a linked instance then we
; 7368 :             // don't need to store the attribute values because they'll be
; 7369 :             // included from the linked instance.  This is only TRUE for
; 7370 :             // persistent attributes.  Non-persistent attrs need to be stored
; 7371 :             // with the current EI.
; 7372 :             if ( lpViewAttrib->bPersist &&
; 7373 :                  lpEntityInstance->lHierCount == lLastLinkedInstance )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10009
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+54]
	cmp	eax, DWORD PTR _lLastLinkedInstance$[ebp]
	jne	SHORT $L10009

; 7375 :                continue;

	jmp	$L9986
$L10009:

; 7377 : 
; 7378 :             // If lpAttribFlags is not 0 then we're supposed to send the
; 7379 :             // attrib flags for each attribute.  To save space we won't bother
; 7380 :             // sending the flags if they are all off.
; 7381 :             if ( lpAttribFlags && lpAttribFlags->u.uFlags == 0 )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $L10010
	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L10010

; 7382 :                lpAttribFlags = 0;   // Indicates: don't bother sending flags.

	mov	DWORD PTR _lpAttribFlags$[ebp], 0
$L10010:

; 7383 : 
; 7384 :             // If the attrib flags is not 0 then set up string.
; 7385 :             if ( lpAttribFlags )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $L10011

; 7386 :                zsprintf( szAttribFlags, ",%lx", lpAttribFlags->u.uFlags );

	mov	edx, DWORD PTR _lpAttribFlags$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHOC@?0?$CFlx?$AA@	; `string'
	lea	ecx, DWORD PTR _szAttribFlags$10008[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7387 :             else

	jmp	SHORT $L10013
$L10011:

; 7388 :                szAttribFlags[ 0 ] = 0;

	mov	BYTE PTR _szAttribFlags$10008[ebp], 0
$L10013:

; 7389 : 
; 7390 :             // If we are here and zCOMPRESSED has been specified, then
; 7391 :             // the entity can't be compressed for some reason (the attribute
; 7392 :             // might be a blob, etc.) but we can still save a few bytes by
; 7393 :             // using XVATOK instead of the name.
; 7394 :             if ( lControl & zCOMPRESSED )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L10014

; 7395 :                zsprintf( szWorkString, "a%lx%s ", lpViewAttrib->lXVAAttTok,
; 7396 :                          szAttribFlags );

	lea	eax, DWORD PTR _szAttribFlags$10008[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+181]
	push	edx
	push	OFFSET FLAT:??_C@_07HIC@a?$CFlx?$CFs?5?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 7397 :             else

	jmp	SHORT $L10016
$L10014:

; 7399 :                zCHAR szAttribName[ 50 ];
; 7400 : 
; 7401 :                zsprintf( szAttribName, "%s%s", lpViewAttrib->szName,
; 7402 :                          szAttribFlags );

	lea	ecx, DWORD PTR _szAttribFlags$10008[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_04DCMN@?$CFs?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szAttribName$10017[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 7403 :                zsprintf( szWorkString, "a%-9s ", szAttribName );

	lea	ecx, DWORD PTR _szAttribName$10017[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_06IACC@a?$CF?99s?5?$AA@ ; `string'
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L10016:

; 7405 : 
; 7406 :             k = zstrlen( szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 7407 : 
; 7408 :             fnGetAddrForAttribute( &pchAttr, lpView, &ViewEntityCsr, 0,
; 7409 :                                    lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _ViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchAttr$[ebp]
	push	ecx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 7410 : 
; 7411 :             // If we are dealing with a string, check to see if
; 7412 :             // it contains any special chars (e.g. '\n'). If it does, then
; 7413 :             // we have to store the string as a blob.
; 7414 :             bStringContainsSpecialChars = FALSE;

	mov	BYTE PTR _bStringContainsSpecialChars$10007[ebp], 0

; 7415 :             if ( lpViewAttrib->cType == zTYPE_STRING )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 83					; 00000053H
	jne	SHORT $L10026

; 7417 :                zPCHAR pch = pchAttr;

	mov	ecx, DWORD PTR _pchAttr$[ebp]
	mov	DWORD PTR _pch$10021[ebp], ecx

; 7418 : 
; 7419 :                // We also store the string as a blob if it has more than
; 7420 :                // 254 chars.
; 7421 :                if ( zstrlen( pch ) > 254 )

	mov	edx, DWORD PTR _pch$10021[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 254				; 000000feH
	jbe	SHORT $L10022

; 7422 :                   bStringContainsSpecialChars = TRUE;

	mov	BYTE PTR _bStringContainsSpecialChars$10007[ebp], 1

; 7423 :                else

	jmp	SHORT $L10026
$L10022:

; 7424 :                   while ( pch[ 0 ] )

	mov	eax, DWORD PTR _pch$10021[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L10026

; 7426 :                      if ( CHAR_IS_SPECIAL( pch[ 0 ] ) )

	mov	edx, DWORD PTR _pch$10021[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jae	SHORT $L10029

; 7428 :                         bStringContainsSpecialChars = TRUE;

	mov	BYTE PTR _bStringContainsSpecialChars$10007[ebp], 1

; 7429 :                         break;

	jmp	SHORT $L10026
$L10029:

; 7431 : 
; 7432 :                      pch++;

	mov	ecx, DWORD PTR _pch$10021[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$10021[ebp], ecx

; 7433 :                   }

	jmp	SHORT $L10022
$L10026:

; 7435 : 
; 7436 :             if ( lpViewAttrib->cType == zTYPE_BLOB ||
; 7437 :                  bStringContainsSpecialChars )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	je	SHORT $L10031
	mov	ecx, DWORD PTR _bStringContainsSpecialChars$10007[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	$L10030
$L10031:

; 7439 :                zCHAR cStreamType;
; 7440 : 
; 7441 :                if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $L10033

; 7443 :                   fnGetAttributeLength( &ulLth, lpView,
; 7444 :                                         zGETPTR( ViewEntityCsr.hEntityInstance ),
; 7445 :                                         lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ViewEntityCsr$[ebp+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 7446 :                   cStreamType = zTYPE_BLOB;

	mov	BYTE PTR _cStreamType$10032[ebp], 66	; 00000042H

; 7448 :                else

	jmp	SHORT $L10035
$L10033:

; 7450 :                   ulLth = zstrlen( pchAttr ) + 1;

	mov	edx, DWORD PTR _pchAttr$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _ulLth$[ebp], eax

; 7451 :                   if ( ulLth == 1 )

	cmp	DWORD PTR _ulLth$[ebp], 1
	jne	SHORT $L10036

; 7452 :                      ulLth = 0;

	mov	DWORD PTR _ulLth$[ebp], 0
$L10036:

; 7453 : 
; 7454 :                   cStreamType = zTYPE_STRING;

	mov	BYTE PTR _cStreamType$10032[ebp], 83	; 00000053H
$L10035:

; 7456 : 
; 7457 :                // If the attribute has a length, then write the length and
; 7458 :                // then the value.
; 7459 :                if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	$L10037

; 7461 :                   // If we're storing a string with "special" chars, then the
; 7462 :                   // first byte before the length is the "special" flag.
; 7463 :                   if ( bStringContainsSpecialChars )

	mov	eax, DWORD PTR _bStringContainsSpecialChars$10007[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L10038

; 7464 :                      szWorkString[ k++ ] = zSTRING_STORED_AS_BLOB;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 31	; 0000001fH
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 7465 :                   else

	jmp	SHORT $L10040
$L10038:

; 7466 :                   if ( lControl & zENCODE_BLOBS )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 4194304				; 00400000H
	test	eax, eax
	je	SHORT $L10040

; 7467 :                      szWorkString[ k++ ] = zBLOB_STORED_ENCODED;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 85	; 00000055H
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L10040:

; 7468 : 
; 7469 :                   zltoa( ulLth, &szWorkString[ k ] );

	push	10					; 0000000aH
	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7470 : 
; 7471 :                   // write out the attribute name and length
; 7472 :                   if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0,
; 7473 :                                           zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L10041

; 7474 :                      goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10041:

; 7475 : 
; 7476 :                   // write out the data
; 7477 :                   if ( cStreamType == zTYPE_BLOB && (lControl & zENCODE_BLOBS) )

	movsx	ecx, BYTE PTR _cStreamType$10032[ebp]
	cmp	ecx, 66					; 00000042H
	jne	$L10042
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 4194304				; 00400000H
	test	edx, edx
	je	SHORT $L10042

; 7479 :                      uPos = 0;

	mov	DWORD PTR _uPos$[ebp], 0
$L10044:

; 7480 :                      while ( UUENCODE_NextEncodedLine( szWorkString, pchAttr,
; 7481 :                                                        ulLth, &uPos ) == 1)

	lea	eax, DWORD PTR _uPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAttr$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_UUENCODE_NextEncodedLine@16
	movsx	ecx, ax
	cmp	ecx, 1
	jne	SHORT $L10045

; 7483 :                         //TraceLineS( "Encoded Line: ", szWorkString);
; 7484 :                         if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, cStreamType ) )

	mov	dl, BYTE PTR _cStreamType$10032[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L10046

; 7485 :                            goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10046:

; 7486 :                      }

	jmp	SHORT $L10044
$L10045:

; 7487 : 
; 7488 :                      //TraceLineS( "Encoded Line: ", szWorkString);
; 7489 :                      if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, cStreamType ) )

	mov	cl, BYTE PTR _cStreamType$10032[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10047

; 7490 :                         goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10047:

; 7492 :                   else

	jmp	$L10056
$L10042:

; 7493 :                   if ( cStreamType == zTYPE_STRING )

	movsx	eax, BYTE PTR _cStreamType$10032[ebp]
	cmp	eax, 83					; 00000053H
	jne	$L10049

; 7495 :                      // PAS 03/09/2001 - to eliminate x00 in the portable
; 7496 :                      //                  files, we temporarily change the
; 7497 :                      //                  byte to the char 0.
; 7498 :                      if ( lControl & zNO_NULL_STRING_TERM )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 8388608				; 00800000H
	test	ecx, ecx
	je	SHORT $L10050

; 7500 :                         pchAttr[ ulLth - 1 ] = '0';

	mov	edx, DWORD PTR _pchAttr$[ebp]
	add	edx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [edx-1], 48			; 00000030H

; 7501 :                         if ( (*lpfnStreamFunc)( lpView, lpvData, pchAttr,
; 7502 :                                                 ulLth, cStreamType ) )

	mov	al, BYTE PTR _cStreamType$10032[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAttr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10051

; 7504 :                            pchAttr[ ulLth - 1 ] = 0;

	mov	eax, DWORD PTR _pchAttr$[ebp]
	add	eax, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [eax-1], 0

; 7505 :                            goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10051:

; 7507 :                         else
; 7508 :                            pchAttr[ ulLth - 1 ] = 0;

	mov	ecx, DWORD PTR _pchAttr$[ebp]
	add	ecx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [ecx-1], 0

; 7513 :                      else

	jmp	SHORT $L10054
$L10050:

; 7515 :                         if ( (*lpfnStreamFunc)( lpView, lpvData, pchAttr,
; 7516 :                                                 ulLth, cStreamType ) )

	mov	dl, BYTE PTR _cStreamType$10032[ebp]
	push	edx
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchAttr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10054

; 7518 :                            goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10054:

; 7522 :                   else

	jmp	SHORT $L10056
$L10049:

; 7523 :                   if ( (*lpfnStreamFunc)( lpView, lpvData, pchAttr,
; 7524 :                                           ulLth, cStreamType ) )

	mov	dl, BYTE PTR _cStreamType$10032[ebp]
	push	edx
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchAttr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10056

; 7526 :                      goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10056:

; 7529 :                else

	jmp	SHORT $L10060
$L10037:

; 7530 :                if ( lpAttribFlags )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $L10060

; 7532 :                   // We need to write the attrib flags so write the attribute
; 7533 :                   // value as NULL.
; 7534 :                   if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $L10059

; 7536 :                      // Add "0" to the end of the string.
; 7537 :                      szWorkString[ k++ ] = '0';

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 48	; 00000030H
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L10059:

; 7539 : 
; 7540 :                   // Null-terminate the string.
; 7541 :                   szWorkString[ k++ ] = 0;

	movsx	eax, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 0
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx

; 7542 : 
; 7543 :                   // Write it.
; 7544 :                   if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0,
; 7545 :                                           zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10060

; 7547 :                      goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10060:

; 7551 :             else

	jmp	$L10073
$L10030:

; 7553 :                zBOOL bAttribIsNull;
; 7554 : 
; 7555 :                // Check to see if we are writing compressed.  This might happen
; 7556 :                // if there are too many attributes to write in the compress
; 7557 :                // buffer.
; 7558 :                if ( lControl & zCOMPRESSED &&
; 7559 :                     lpViewAttrib->cType == zTYPE_INTEGER )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	$L10063
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 76					; 0000004cH
	jne	$L10063

; 7561 :                   zLONG l;
; 7562 : 
; 7563 :                   // We are writing a compressed file so convert the value to
; 7564 :                   // a hex number.
; 7565 :                   if ( fnGetIntegerFromAttribute( &l, lpView, &ViewEntityCsr,
; 7566 :                                                   lpViewAttrib ) == -1 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$10064[ebp]
	push	eax
	call	_fnGetIntegerFromAttribute
	add	esp, 16					; 00000010H
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $L10065

; 7568 :                      bAttribIsNull = TRUE;

	mov	BYTE PTR _bAttribIsNull$10062[ebp], 1

; 7569 : 
; 7570 :                      // Write the attribute value as a '*' to indicate that the
; 7571 :                      // integer is null.
; 7572 :                      szWorkString[ k++ ] = '*';

	movsx	edx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 42	; 0000002aH
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax

; 7573 :                      szWorkString[ k++ ] = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 0
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 7575 :                   else

	jmp	SHORT $L10066
$L10065:

; 7577 :                      bAttribIsNull = FALSE;

	mov	BYTE PTR _bAttribIsNull$10062[ebp], 0

; 7578 : 
; 7579 :                      if ( l < 0 )

	cmp	DWORD PTR _l$10064[ebp], 0
	jge	SHORT $L10067

; 7581 :                         szWorkString[ k++ ] = '-';

	movsx	eax, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 45	; 0000002dH
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx

; 7582 :                         l = l * -1;

	mov	edx, DWORD PTR _l$10064[ebp]
	imul	edx, -1
	mov	DWORD PTR _l$10064[ebp], edx
$L10067:

; 7584 : 
; 7585 :                      zltox( l, &szWorkString[ k ] );

	push	16					; 00000010H
	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _l$10064[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$L10066:

; 7588 :                else

	jmp	SHORT $L10070
$L10063:

; 7590 :                   if ( fnGetStringFromAttribute( &szWorkString[ k ], 255,
; 7591 :                                                  lpView,
; 7592 :                                                  &ViewEntityCsr,
; 7593 :                                                  lpViewAttrib, 0 ) == -1 )

	push	0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	255					; 000000ffH
	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax]
	push	ecx
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $L10069

; 7595 :                      bAttribIsNull = TRUE;

	mov	BYTE PTR _bAttribIsNull$10062[ebp], 1

; 7597 :                   else

	jmp	SHORT $L10070
$L10069:

; 7598 :                      bAttribIsNull = FALSE;

	mov	BYTE PTR _bAttribIsNull$10062[ebp], 0
$L10070:

; 7600 : 
; 7601 :                // Write the value if it's not null OR if there are attribute
; 7602 :                // flags.  If there are attrib flags then we need to
; 7603 :                // keep track of null values.
; 7604 :                if ( bAttribIsNull == FALSE || lpAttribFlags )

	mov	eax, DWORD PTR _bAttribIsNull$10062[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L10072
	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $L10073
$L10072:

; 7606 :                   if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0,
; 7607 :                                           zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10073

; 7609 :                      goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10073:

; 7616 : 
; 7617 :       } // for ( lpViewAttrib... )...

	jmp	$L9986
$L9987:

; 7618 : 
; 7619 :       if ( bEntityIsCompressed && bValuesStored )

	mov	edx, DWORD PTR _bEntityIsCompressed$9925[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	$L10074
	mov	eax, DWORD PTR _bValuesStored$9927[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L10074

; 7621 :          zCHAR szLth[ 20 ];
; 7622 : 
; 7623 :          ulLth = (zULONG) (pchBufferEnd - pchBuffer);

	mov	ecx, DWORD PTR _pchBufferEnd$9926[ebp]
	sub	ecx, DWORD PTR _pchBuffer$[ebp]
	mov	DWORD PTR _ulLth$[ebp], ecx

; 7624 : 
; 7625 :          // Set first char to 'a' to indicate that it's attribute data.
; 7626 :          // The next char is a space to differentiate it with a normal
; 7627 :          // attribute value line.
; 7628 :          zsprintf( szLth, "a %x", ulLth );

	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04KPK@a?5?$CFx?$AA@	; `string'
	lea	eax, DWORD PTR _szLth$10075[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7629 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szLth, zstrlen( szLth ),
; 7630 :                                  zTYPE_STRING ) )

	push	83					; 00000053H
	lea	ecx, DWORD PTR _szLth$10075[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _szLth$10075[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10078

; 7632 :             goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10078:

; 7634 : 
; 7635 :          // Now send the buffer.
; 7636 :          if ( (*lpfnStreamFunc)( lpView, lpvData, pchBuffer, ulLth, zTYPE_STRING ) )

	push	83					; 00000053H
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10079

; 7637 :             goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10079:

; 7639 :       else

	jmp	SHORT $L10082
$L10074:

; 7641 :          if ( (lControl & zCOMPRESSED) == 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	test	edx, edx
	jne	SHORT $L10082

; 7643 :             // Write a blank line just to make things look pretty.
; 7644 :             if ( (*lpfnStreamFunc)( lpView, lpvData, "", 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10082

; 7645 :                goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10082:

; 7648 : 
; 7649 :    } // for ( lpEntityInstance... )...

	jmp	$L9923
$L9924:

; 7650 : 
; 7651 :    // If any intra-object linked instances were found, create
; 7652 :    // link records now.
; 7653 :    if ( lLastLinkedInstance > -1 )

	cmp	DWORD PTR _lLastLinkedInstance$[ebp], -1
	jle	$L10089

; 7655 :       LPENTITYINSTANCE lpSourceEntityInstance;
; 7656 : 
; 7657 :       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 7658 :             lpEntityInstance;
; 7659 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L10087
$L10088:
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L10087:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L10089

; 7661 :          // If we've gone past the last linked instance break.
; 7662 :          if ( lpEntityInstance->lHierCount > lLastLinkedInstance )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+54]
	cmp	edx, DWORD PTR _lLastLinkedInstance$[ebp]
	jle	SHORT $L10090

; 7663 :             break;

	jmp	$L10089
$L10090:

; 7664 : 
; 7665 :          // Look to see if the current instance should be written out.  If
; 7666 :          // not we'll skip it and go on to the next one.  All non-hidden
; 7667 :          // instances get written so we'll look for that first.
; 7668 :          if ( lpEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	je	$L10092

; 7670 :             // We'll skip hidden entities if:
; 7671 :             // o  We aren't writing incrementals
; 7672 :             //    -or-
; 7673 :             // o  The EI is "dead" e.g. created and deleted.
; 7674 :             if ( bIncremental == FALSE ||
; 7675 :                  fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	edx, DWORD PTR _bIncremental$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L10093
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnEntityInstanceIsDead@4
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10092
$L10093:

; 7677 :                // The current instance should not be written to the file.
; 7678 :                // This also means that it's children should not be written.
; 7679 :                // Skip the children.
; 7680 :                nLevel = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nLevel$[ebp], ax

; 7681 :                for ( lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );
; 7682 :                      lpEntityInstance;
; 7683 :                      lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L10096
$L10097:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L10096:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L10098

; 7685 :                   if ( lpEntityInstance->nLevel <= nLevel )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	eax, ecx
	jg	SHORT $L10099

; 7686 :                      break;

	jmp	SHORT $L10098
$L10099:

; 7687 :                }

	jmp	SHORT $L10097
$L10098:

; 7688 : 
; 7689 :                // If no more instance break loop.
; 7690 :                if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $L10100

; 7691 :                   break;

	jmp	$L10089
$L10100:

; 7692 : 
; 7693 :                // Do the following so that when the 'for' loop gets the next
; 7694 :                // entity instance it will be the one we want.
; 7695 :                lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 7696 : 
; 7697 :                // Skip the hidden instance.
; 7698 :                continue;

	jmp	$L10088
$L10092:

; 7701 : 
; 7702 :          // If the entity is not linked to another entity then there are no
; 7703 :          // link cards to write, so skip it.
; 7704 :          if ( lpEntityInstance->hNextLinked == 0 )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $L10102

; 7705 :             continue;

	jmp	$L10088
$L10102:

; 7706 : 
; 7707 :          // If the entity is the record owner then we don't write link cards.
; 7708 :          // Link cards are written for the non-record owner.
; 7709 :          if ( lpEntityInstance->u.nInd.bRecordOwner )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	je	SHORT $L10103

; 7710 :             continue;

	jmp	$L10088
$L10103:

; 7711 : 
; 7712 :          // Look for the record owner in the same OI.
; 7713 :          lpSourceEntityInstance = zGETPTR( lpEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceEntityInstance$10084[ebp], eax
$L10106:

; 7714 :          while ( lpSourceEntityInstance->hViewOI != lpEntityInstance->hViewOI ||
; 7715 :                  lpSourceEntityInstance->u.nInd.bRecordOwner == FALSE )

	mov	eax, DWORD PTR _lpSourceEntityInstance$10084[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [eax+10]
	cmp	edx, DWORD PTR [ecx+10]
	jne	SHORT $L10108
	mov	eax, DWORD PTR _lpSourceEntityInstance$10084[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 6
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L10107
$L10108:

; 7717 :             lpSourceEntityInstance =
; 7718 :                                  zGETPTR( lpSourceEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpSourceEntityInstance$10084[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceEntityInstance$10084[ebp], eax

; 7719 :             if ( lpSourceEntityInstance == lpEntityInstance )

	mov	ecx, DWORD PTR _lpSourceEntityInstance$10084[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	jne	SHORT $L10110

; 7720 :                break;

	jmp	SHORT $L10107
$L10110:

; 7721 :          }

	jmp	SHORT $L10106
$L10107:

; 7722 : 
; 7723 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 7724 : 
; 7725 :          // If lpSourceEntityInstance == lpEntityInstance then no other
; 7726 :          // linked instances where found in the loop above.
; 7727 :          if ( lpSourceEntityInstance == lpEntityInstance )

	mov	ecx, DWORD PTR _lpSourceEntityInstance$10084[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	jne	$L10112

; 7729 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$10113[ebp], eax

; 7730 :             zVIEW           vWork;
; 7731 :             LPVIEWENTITYCSR lpWorkViewEntityCsr;
; 7732 : 
; 7733 :             CreateViewFromViewForTask( &vWork, lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vWork$10115[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 7734 :             lpWorkViewEntityCsr =
; 7735 :                fnEstablishViewForInstance( vWork, 0, lpSourceEntityInstance );

	mov	eax, DWORD PTR _lpSourceEntityInstance$10084[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vWork$10115[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpWorkViewEntityCsr$10116[ebp], eax
$L10118:

; 7736 : 
; 7737 :             while ( lpWorkViewEntityCsr )

	cmp	DWORD PTR _lpWorkViewEntityCsr$10116[ebp], 0
	je	SHORT $L10119

; 7739 :                fnDisplayEntityInstance( vWork, lpWorkViewEntityCsr, 0, 0 );

	push	0
	push	0
	mov	edx, DWORD PTR _lpWorkViewEntityCsr$10116[ebp]
	push	edx
	mov	eax, DWORD PTR _vWork$10115[ebp]
	push	eax
	call	_fnDisplayEntityInstance
	add	esp, 16					; 00000010H

; 7740 :                lpWorkViewEntityCsr = zGETPTR( lpWorkViewEntityCsr->hParent );

	mov	ecx, DWORD PTR _lpWorkViewEntityCsr$10116[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEntityCsr$10116[ebp], eax

; 7741 :             }

	jmp	SHORT $L10118
$L10119:

; 7742 : 
; 7743 :             DropView( vWork );

	mov	eax, DWORD PTR _vWork$10115[ebp]
	push	eax
	call	_DropView@4

; 7744 : 
; 7745 :             // "KZOEE078 - Internal error, linked instance "
; 7746 :             // "           has no visible owner"
; 7747 :             fnIssueCoreError( lpTask, lpView, 16, 78, (zLONG) 0,
; 7748 :                               lpViewEntity->szName, 0 );

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	78					; 0000004eH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$10113[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$L10112:

; 7754 :             LPVIEWENTITY lpSrcViewEntity;
; 7755 : 
; 7756 :             lpViewEntity    = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 7757 :             lpSrcViewEntity = zGETPTR( lpSourceEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSourceEntityInstance$10084[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$10122[ebp], eax

; 7758 : 
; 7759 :             if ( lpSrcViewEntity->lEREntTok != lpViewEntity->lEREntTok )

	mov	edx, DWORD PTR _lpSrcViewEntity$10122[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	je	SHORT $L10127

; 7761 :                TraceLine( "(oi) Error (OD: %s) - Src View Entity: %s Token: %d  View Entity: %s Token = %d",
; 7762 :                           lpViewOD->szName, lpSrcViewEntity->szName, lpSrcViewEntity->lEREntTok,
; 7763 :                           lpViewEntity->szName, lpViewEntity->lEREntTok );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+195]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$10122[ebp]
	mov	eax, DWORD PTR [edx+195]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntity$10122[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET FLAT:??_C@_0FA@OBP@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Src?5View?5E@ ; `string'
	call	_TraceLine
	add	esp, 24					; 00000018H

; 7764 :                if ( bMsgBox )

	mov	eax, DWORD PTR _bMsgBox$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L10127

; 7766 :                   bMsgBox = FALSE;

	mov	BYTE PTR _bMsgBox$[ebp], 0

; 7767 :                   SysMessageBox( lpView, szlOE_SystemError,
; 7768 :                                  "Error writing OI: ER Tokens don't match for linked entities!", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0DN@MLKO@Error?5writing?5OI?3?5ER?5Tokens?5don?8@ ; `string'
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysMessageBox@16
$L10127:

; 7772 : #endif
; 7773 : 
; 7774 :          if ( lControl & zCOMPRESSED )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L10129

; 7776 :             zsprintf( szWorkString, "i%lx %lx",
; 7777 :                       lpEntityInstance->lHierCount,
; 7778 :                       lpSourceEntityInstance->lHierCount );

	mov	ecx, DWORD PTR _lpSourceEntityInstance$10084[ebp]
	mov	edx, DWORD PTR [ecx+54]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+54]
	push	ecx
	push	OFFSET FLAT:??_C@_08GN@i?$CFlx?5?$CFlx?$AA@ ; `string'
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 7780 :          else

	jmp	$L10131
$L10129:

; 7782 :             szWorkString[ 0 ] = 'i';

	mov	BYTE PTR _szWorkString$[ebp], 105	; 00000069H

; 7783 :             zltoa( lpEntityInstance->lHierCount, &szWorkString[ 1 ] );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _szWorkString$[ebp+1]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+54]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7784 :             k = zstrlen( szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax
$L10132:

; 7787 :                szWorkString[ k++ ] = ' ';

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 32	; 00000020H
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 7788 :             } while ( k < 11 );

	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 11					; 0000000bH
	jl	SHORT $L10132

; 7789 : 
; 7790 :             zltoa( lpSourceEntityInstance->lHierCount, &szWorkString[ k ] );

	push	10					; 0000000aH
	movsx	ecx, WORD PTR _k$[ebp]
	lea	edx, DWORD PTR _szWorkString$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _lpSourceEntityInstance$10084[ebp]
	mov	ecx, DWORD PTR [eax+54]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$L10131:

; 7792 : 
; 7793 :          if ( lpEntityInstance->lHierCount != lpSourceEntityInstance->lHierCount )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpSourceEntityInstance$10084[ebp]
	mov	ecx, DWORD PTR [edx+54]
	cmp	ecx, DWORD PTR [eax+54]
	je	SHORT $L10136

; 7795 :             if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10136

; 7796 :                goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10136:

; 7798 : 
; 7799 :       } // for ...

	jmp	$L10088
$L10089:

; 7802 : 
; 7803 :    //
; 7804 :    // Check to see if we need to save the cursor positions.
; 7805 :    //
; 7806 :    // We save the cursor positions by storing each entity cursor as:
; 7807 :    //    cent-#, absolute-entity-instance-#
; 7808 :    // The numbers are stored as hex values.  For example, the root cursor
; 7809 :    // would be saved as:
; 7810 :    //    c1, 1
; 7811 :    // Absence of the cursor record means the cursor is null.
; 7812 :    //
; 7813 :    // Note: if lpEntityInstance->u.nInd.bWritten is 0, then the entity
; 7814 :    // instance wasn't written to the stream.
; 7815 :    //
; 7816 :    if ( lControl & zSAVE_CURSORS )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	$L10146

; 7818 :       LPVIEWENTITYCSR  lpViewEntityCsr;
; 7819 :       LPENTITYINSTANCE lpCurrentEI;
; 7820 :       zLONG            lInstanceCount;
; 7821 : 
; 7822 :       lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 7823 :       lInstanceCount = 1;

	mov	DWORD PTR _lInstanceCount$10140[ebp], 1

; 7824 : 
; 7825 :       for ( lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );
; 7826 :             lpViewEntityCsr;
; 7827 :             lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier ) )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$10138[ebp], eax
	jmp	SHORT $L10144
$L10145:
	mov	edx, DWORD PTR _lpViewEntityCsr$10138[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$10138[ebp], eax
$L10144:
	cmp	DWORD PTR _lpViewEntityCsr$10138[ebp], 0
	je	$L10146

; 7829 :          // If the entity cursor is NULL then ignore this cursor.
; 7830 :          if ( lpViewEntityCsr->hEntityInstance == 0 )

	mov	ecx, DWORD PTR _lpViewEntityCsr$10138[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	SHORT $L10147

; 7831 :             continue;

	jmp	SHORT $L10145
$L10147:

; 7832 : 
; 7833 :          if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	edx, DWORD PTR _lpViewEntityCsr$10138[ebp]
	cmp	DWORD PTR [edx+26], 1
	jne	SHORT $L10149

; 7835 :             zsprintf( szWorkString, "c%x 0", lpViewEntityCsr->nHierNbr );

	mov	eax, DWORD PTR _lpViewEntityCsr$10138[ebp]
	movsx	ecx, WORD PTR [eax+24]
	push	ecx
	push	OFFSET FLAT:??_C@_05KPKL@c?$CFx?50?$AA@	; `string'
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7836 : 
; 7837 :             if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L10151

; 7838 :                goto EndOfFunction;

	jmp	$EndOfFunction$9951
$L10151:

; 7839 : 
; 7840 :             continue;

	jmp	$L10145
$L10149:

; 7842 : 
; 7843 :          lpCurrentEI = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$10138[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentEI$10139[ebp], eax

; 7844 : 
; 7845 :          if ( lpCurrentEI->u.nInd.bWritten == FALSE )

	mov	eax, DWORD PTR _lpCurrentEI$10139[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	test	ecx, ecx
	jne	$L10153

; 7847 :             LPENTITYINSTANCE lpSrchInstance;
; 7848 :             zBOOL            bNoTwins = TRUE;

	mov	BYTE PTR _bNoTwins$10155[ebp], 1

; 7849 : 
; 7850 :             // The current entity instance wasn't written to the stream.  If
; 7851 :             // none of it's twins were written to the stream then the cursor
; 7852 :             // is considered NULL.
; 7853 : 
; 7854 :             // Search previous twins.
; 7855 :             for ( lpSrchInstance = zGETPTR( lpCurrentEI->hPrevTwin );
; 7856 :                   lpSrchInstance;
; 7857 :                   lpSrchInstance = zGETPTR( lpSrchInstance->hPrevTwin ) )

	mov	edx, DWORD PTR _lpCurrentEI$10139[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$10154[ebp], eax
	jmp	SHORT $L10158
$L10159:
	mov	ecx, DWORD PTR _lpSrchInstance$10154[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$10154[ebp], eax
$L10158:
	cmp	DWORD PTR _lpSrchInstance$10154[ebp], 0
	je	SHORT $L10160

; 7859 :                if ( lpSrchInstance->u.nInd.bWritten )

	mov	eax, DWORD PTR _lpSrchInstance$10154[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10161

; 7861 :                   bNoTwins = FALSE;

	mov	BYTE PTR _bNoTwins$10155[ebp], 0

; 7862 :                   break;

	jmp	SHORT $L10160
$L10161:

; 7864 :             }

	jmp	SHORT $L10159
$L10160:

; 7865 : 
; 7866 :             // Search next twins.
; 7867 :             if ( bNoTwins )

	mov	edx, DWORD PTR _bNoTwins$10155[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L10167

; 7869 :                for ( lpSrchInstance = zGETPTR( lpCurrentEI->hNextTwin );
; 7870 :                      lpSrchInstance;
; 7871 :                      lpSrchInstance = zGETPTR( lpSrchInstance->hNextTwin ) )

	mov	eax, DWORD PTR _lpCurrentEI$10139[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$10154[ebp], eax
	jmp	SHORT $L10165
$L10166:
	mov	edx, DWORD PTR _lpSrchInstance$10154[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$10154[ebp], eax
$L10165:
	cmp	DWORD PTR _lpSrchInstance$10154[ebp], 0
	je	SHORT $L10167

; 7873 :                   if ( lpSrchInstance->u.nInd.bWritten )

	mov	ecx, DWORD PTR _lpSrchInstance$10154[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 12					; 0000000cH
	and	edx, 1
	test	edx, edx
	je	SHORT $L10168

; 7875 :                      bNoTwins = FALSE;

	mov	BYTE PTR _bNoTwins$10155[ebp], 0

; 7876 :                      break;

	jmp	SHORT $L10167
$L10168:

; 7878 :                }

	jmp	SHORT $L10166
$L10167:

; 7880 : 
; 7881 :             // If we didn't find any twins then the cursor is considered
; 7882 :             // NULL so don't write the cursor record to the stream.
; 7883 :             if ( bNoTwins )

	mov	eax, DWORD PTR _bNoTwins$10155[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L10169

; 7884 :                continue;

	jmp	$L10145
$L10169:

; 7885 : 
; 7886 :             // Cursor points to invalid entity but the entity does have
; 7887 :             // valid twins, so send record indicating that the cursor is
; 7888 :             // currently not set.
; 7889 :             zsprintf( szWorkString, "c%x 0", lpViewEntityCsr->nHierNbr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$10138[ebp]
	movsx	edx, WORD PTR [ecx+24]
	push	edx
	push	OFFSET FLAT:??_C@_05KPKL@c?$CFx?50?$AA@	; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7891 :          else

	jmp	SHORT $L10170
$L10153:

; 7893 :             for ( ;
; 7894 :                   lpEntityInstance != lpCurrentEI;
; 7895 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	jmp	SHORT $L10172
$L10173:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L10172:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpCurrentEI$10139[ebp]
	je	SHORT $L10174

; 7897 :                // If the entity instance wasn't written to the stream, then
; 7898 :                // don't bother counting it.
; 7899 :                if ( lpEntityInstance->u.nInd.bWritten == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 12					; 0000000cH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L10175

; 7900 :                   continue;

	jmp	SHORT $L10173
$L10175:

; 7901 : 
; 7902 :                lInstanceCount++;

	mov	eax, DWORD PTR _lInstanceCount$10140[ebp]
	add	eax, 1
	mov	DWORD PTR _lInstanceCount$10140[ebp], eax

; 7903 :             }

	jmp	SHORT $L10173
$L10174:

; 7904 : 
; 7905 :             zsprintf( szWorkString, "c%x %lx", lpViewEntityCsr->nHierNbr,
; 7906 :                       lInstanceCount );

	mov	ecx, DWORD PTR _lInstanceCount$10140[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$10138[ebp]
	movsx	eax, WORD PTR [edx+24]
	push	eax
	push	OFFSET FLAT:??_C@_07BFPN@c?$CFx?5?$CFlx?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
$L10170:

; 7908 : 
; 7909 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10177

; 7910 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$9951
$L10177:

; 7911 :       }

	jmp	$L10145
$L10146:

; 7913 : 
; 7914 :    // If we get here then everything's OK.
; 7915 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$9951:

; 7916 : 
; 7917 : EndOfFunction:
; 7918 : 
; 7919 :    if ( pchBuffer )

	cmp	DWORD PTR _pchBuffer$[ebp], 0
	je	SHORT $L10178

; 7920 :       fnFreeDataspace( pchBuffer );

	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
$L10178:

; 7921 : 
; 7922 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L9863:

; 7923 : 
; 7924 : } // fnWriteOI_ToTextStream

	mov	esp, ebp
	pop	ebp
	ret	0
_fnWriteOI_ToTextStream ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@LHOF@mCONTROL?5?$CFlx?$AA@		; `string'
PUBLIC	??_C@_04JJOE@ZEND?$AA@				; `string'
PUBLIC	??_C@_0BD@BCKI@?$CI?$CFs?$CJ?5?$DN?5?$CFlf?5seconds?$AA@ ; `string'
PUBLIC	??_C@_0CI@BFCD@?$CIoi?$CJ?5Total?5time?5for?5SfWriteOI_To@ ; `string'
PUBLIC	_fnDateTimeFormat
PUBLIC	_SfWriteOI_ToStream@20
PUBLIC	??_C@_08ION@?5?5?5?5?5?5?5?5?$AA@		; `string'
EXTRN	_SysTranslateString@8:NEAR
EXTRN	_memset:NEAR
EXTRN	_szlReleaseCompatible:DWORD
EXTRN	_szlReleaseCurrent:DWORD
EXTRN	_szlNewPortableHeader:DWORD
EXTRN	_szlmZeidon:DWORD
EXTRN	_MiSetOI_ReleaseForView@8:NEAR
EXTRN	_MiCompareOI_ToRelease@8:NEAR
;	COMDAT ??_C@_08ION@?5?5?5?5?5?5?5?5?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_08ION@?5?5?5?5?5?5?5?5?$AA@ DB '        ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@LHOF@mCONTROL?5?$CFlx?$AA@
_DATA	SEGMENT
??_C@_0N@LHOF@mCONTROL?5?$CFlx?$AA@ DB 'mCONTROL %lx', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04JJOE@ZEND?$AA@
_DATA	SEGMENT
??_C@_04JJOE@ZEND?$AA@ DB 'ZEND', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@BCKI@?$CI?$CFs?$CJ?5?$DN?5?$CFlf?5seconds?$AA@
_DATA	SEGMENT
??_C@_0BD@BCKI@?$CI?$CFs?$CJ?5?$DN?5?$CFlf?5seconds?$AA@ DB '(%s) = %lf s'
	DB	'econds', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@BFCD@?$CIoi?$CJ?5Total?5time?5for?5SfWriteOI_To@
_DATA	SEGMENT
??_C@_0CI@BFCD@?$CIoi?$CJ?5Total?5time?5for?5SfWriteOI_To@ DB '(oi) Total'
	DB	' time for SfWriteOI_ToStream ', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_sz$10256 = -292
_lpView$ = 8
_cpcHeaderName$ = 12
_lControl$ = 16
_lpfnStreamFunc$ = 20
_lpvData$ = 24
_lpCurrentTask$ = -192
_lpViewOD$ = -108
_lpViewOI$ = -180
_lpViewCsr$ = -24
_FileHeader$ = -104
_pchLine$ = -28
_pchFileNmp$ = -188
_szDateTime$ = -20
_szTemp$ = -164
_lTickCount$ = -184
_bOptimistic$ = -168
_bIncremental$ = -176
_k$ = -172
_nRC$ = -112
_SfWriteOI_ToStream@20 PROC NEAR

; 7933 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH

; 7934 :    LPTASK               lpCurrentTask;
; 7935 :    LPVIEWOD             lpViewOD;
; 7936 :    LPVIEWOI             lpViewOI;
; 7937 :    LPVIEWCSR            lpViewCsr;
; 7938 :    FileHeaderRecord     FileHeader;
; 7939 :    zPCHAR               pchLine;
; 7940 :    zPCHAR               pchFileNmp;
; 7941 :    zCHAR                szDateTime[ 20 ];
; 7942 :    zCHAR                szTemp[ 50 ];
; 7943 :    zLONG                lTickCount;
; 7944 :    zBOOL                bOptimistic;
; 7945 :    zBOOL                bIncremental;
; 7946 :    zSHORT               k;
; 7947 :    zSHORT               nRC;
; 7948 : 
; 7949 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10204

; 7950 :       lTickCount = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTickCount$[ebp], eax
$L10204:

; 7951 : 
; 7952 :    // If task not active or disabled, return zCALL_ERROR.
; 7953 :    lpCurrentTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 7954 : 
; 7955 :    // Validate that the view passed is valid
; 7956 :    if ( fnValidViewCsr( lpCurrentTask, lpView ) == 0 )

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidViewCsr
	add	esp, 8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L10206

; 7957 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10189
$L10206:

; 7958 : 
; 7959 :    lpViewOD  = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 7960 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 7961 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 7962 : 
; 7963 :    // Make sure OI does not contain versioned instances
; 7964 :    if ( lpViewOI->nVersionedInstances )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	je	SHORT $L10210

; 7965 : #if 0  // DGC 1999.06.04  No longer an error?  It seems like we should be able
; 7966 :        // to pass OIs even if they have versions.  We will, however, only
; 7967 :        // perform Reclaim if there are no versions (we wouldn't want to get
; 7968 :        // rid of something we want).
; 7969 :    {
; 7970 :       //  "KZOEE076 - Object instance contains versioned entity instances"
; 7971 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 76, 0, 0, 0 );
; 7972 :       return( zCALL_ERROR );
; 7973 :    }
; 7974 : 
; 7975 :    // Get rid of all deadwood instances (e.g. entities that have been created
; 7976 :    // AND deleted).
; 7977 :    fnReclaimHiddenInstances( lpViewOI );
; 7978 : 
; 7979 : #else
; 7980 :       ;
; 7981 :    else

	jmp	SHORT $L10211
$L10210:

; 7982 :       // Get rid of all deadwood instances (e.g. entities that have been created
; 7983 :       // AND deleted).
; 7984 :       fnReclaimHiddenInstances( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnReclaimHiddenInstances@4
$L10211:

; 7985 : #endif
; 7986 : 
; 7987 :    // build header record
; 7988 :    zmemset( &FileHeader.chTypeIndicator, ' ', sizeof( FileHeaderRecord ) );

	push	73					; 00000049H
	push	32					; 00000020H
	lea	ecx, DWORD PTR _FileHeader$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 7989 : 
; 7990 :    // Set bIncremental and bBinary
; 7991 :    if ( lControl & zINCREMENTAL )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 65536				; 00010000H
	test	edx, edx
	je	SHORT $L10213

; 7992 :       bIncremental = TRUE;

	mov	BYTE PTR _bIncremental$[ebp], 1

; 7993 :    else

	jmp	SHORT $L10214
$L10213:

; 7994 :       bIncremental = FALSE;

	mov	BYTE PTR _bIncremental$[ebp], 0
$L10214:

; 7995 : 
; 7996 :    // If the view has an "original OI" then the view was activated with
; 7997 :    // optimistic locking and we need to send the original OI as well.
; 7998 :    if ( lpViewOI->vOriginalOI )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $L10215

; 7999 :       bOptimistic = TRUE;

	mov	BYTE PTR _bOptimistic$[ebp], 1

; 8000 :    else

	jmp	SHORT $L10216
$L10215:

; 8001 :       bOptimistic = FALSE;

	mov	BYTE PTR _bOptimistic$[ebp], 0
$L10216:

; 8002 : 
; 8003 :    // We store information now as bit-flags.
; 8004 :    FileHeader.chTypeIndicator[ 0 ] = szlNewPortableHeader[ 0 ];

	mov	ecx, DWORD PTR _szlNewPortableHeader
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _FileHeader$[ebp], dl

; 8005 : 
; 8006 :    // DGC 1999.05.07
; 8007 :    // Used to be binary indicator.  Now it determines if the ER date is store
; 8008 :    // with with a compressed OI.  This flag can be re-used for something else
; 8009 :    // when all customers are using post-9j core.
; 8010 :    FileHeader.chTypeIndicator[ 1 ] = '1'; // This release always store date.

	mov	BYTE PTR _FileHeader$[ebp+1], 49	; 00000031H

; 8011 : 
; 8012 :    if ( bIncremental )

	mov	eax, DWORD PTR _bIncremental$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L10217

; 8013 :       FileHeader.chTypeIndicator[ 2 ] = '1';

	mov	BYTE PTR _FileHeader$[ebp+2], 49	; 00000031H

; 8014 :    else

	jmp	SHORT $L10218
$L10217:

; 8015 :       FileHeader.chTypeIndicator[ 2 ] = '0';

	mov	BYTE PTR _FileHeader$[ebp+2], 48	; 00000030H
$L10218:

; 8016 : 
; 8017 :    if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L10219

; 8018 :       FileHeader.chTypeIndicator[ 3 ] = '1';

	mov	BYTE PTR _FileHeader$[ebp+3], 49	; 00000031H

; 8019 :    else

	jmp	SHORT $L10220
$L10219:

; 8020 :       FileHeader.chTypeIndicator[ 3 ] = '0';

	mov	BYTE PTR _FileHeader$[ebp+3], 48	; 00000030H
$L10220:

; 8021 : 
; 8022 :    if ( bOptimistic )

	mov	edx, DWORD PTR _bOptimistic$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L10221

; 8023 :       FileHeader.chTypeIndicator[ 4 ] = '1';

	mov	BYTE PTR _FileHeader$[ebp+4], 49	; 00000031H

; 8024 :    else

	jmp	SHORT $L10222
$L10221:

; 8025 :       FileHeader.chTypeIndicator[ 4 ] = '0';

	mov	BYTE PTR _FileHeader$[ebp+4], 48	; 00000030H
$L10222:

; 8026 : 
; 8027 : #ifdef USE_ATTRIBFLAGS
; 8028 :    // Using attribute flags logic.
; 8029 :    if ( bIncremental )
; 8030 :       FileHeader.chTypeIndicator[ 5 ] = '1';
; 8031 :    else
; 8032 :       FileHeader.chTypeIndicator[ 5 ] = '0';
; 8033 : #else
; 8034 :    // Reserved for later use...
; 8035 :    FileHeader.chTypeIndicator[ 5 ] = '-';

	mov	BYTE PTR _FileHeader$[ebp+5], 45	; 0000002dH

; 8036 : #endif
; 8037 : 
; 8038 :    zstrcpy( FileHeader.szZeidon, szlmZeidon );

	mov	eax, DWORD PTR _szlmZeidon
	push	eax
	lea	ecx, DWORD PTR _FileHeader$[ebp+6]
	push	ecx
	call	_strcpy
	add	esp, 8

; 8039 : 
; 8040 :    pchFileNmp = (zPCHAR) cpcHeaderName;

	mov	edx, DWORD PTR _cpcHeaderName$[ebp]
	mov	DWORD PTR _pchFileNmp$[ebp], edx

; 8041 :    pchLine    = (zPCHAR) cpcHeaderName;

	mov	eax, DWORD PTR _cpcHeaderName$[ebp]
	mov	DWORD PTR _pchLine$[ebp], eax
$L10227:

; 8042 :    while ( (pchLine = zstrchr( pchLine, cDirSep )) != 0 )

	movsx	ecx, BYTE PTR _cDirSep
	push	ecx
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchLine$[ebp], eax
	cmp	DWORD PTR _pchLine$[ebp], 0
	je	SHORT $L10228

; 8044 :       pchLine++;

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchLine$[ebp], eax

; 8045 :       pchFileNmp = pchLine;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	mov	DWORD PTR _pchFileNmp$[ebp], ecx

; 8046 :    }

	jmp	SHORT $L10227
$L10228:

; 8047 : 
; 8048 :    // we are building the header record for this file and realize that the
; 8049 :    // file name we are copying to FileHeader.szFileName may be longer than
; 8050 :    // sizeof( FileHeader.szFileName ).  This is OK since the FileHeader
; 8051 :    // structure is large enough to accomodate an overwrite.
; 8052 :    zstrcpy( FileHeader.szFileName, pchFileNmp );

	mov	edx, DWORD PTR _pchFileNmp$[ebp]
	push	edx
	lea	eax, DWORD PTR _FileHeader$[ebp+16]
	push	eax
	call	_strcpy
	add	esp, 8

; 8053 :    pchLine = zstrchr( FileHeader.szFileName, '.' );

	push	46					; 0000002eH
	lea	ecx, DWORD PTR _FileHeader$[ebp+16]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchLine$[ebp], eax

; 8054 :    if ( pchLine )

	cmp	DWORD PTR _pchLine$[ebp], 0
	je	SHORT $L10230

; 8056 :       zstrcpy( pchLine, "        " );

	push	OFFSET FLAT:??_C@_08ION@?5?5?5?5?5?5?5?5?$AA@ ; `string'
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 8057 :       pchLine[ 0 ] = 0;

	mov	eax, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [eax], 0
$L10230:

; 8059 : 
; 8060 :    SysTranslateString( FileHeader.szFileName, 'U' );

	push	85					; 00000055H
	lea	ecx, DWORD PTR _FileHeader$[ebp+16]
	push	ecx
	call	_SysTranslateString@8

; 8061 :    zstrcpy( FileHeader.szObjectType, lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _FileHeader$[ebp+25]
	push	eax
	call	_strcpy
	add	esp, 8

; 8062 :    SysGetDateTime( szDateTime );

	lea	ecx, DWORD PTR _szDateTime$[ebp]
	push	ecx
	call	_SysGetDateTime@4

; 8063 :    fnDateTimeFormat( szDateTime, FileHeader.szDate, FileHeader.szTime );

	lea	edx, DWORD PTR _FileHeader$[ebp+45]
	push	edx
	lea	eax, DWORD PTR _FileHeader$[ebp+34]
	push	eax
	lea	ecx, DWORD PTR _szDateTime$[ebp]
	push	ecx
	call	_fnDateTimeFormat
	add	esp, 12					; 0000000cH

; 8064 :    // Even if this is not a MetaOI, we should force the release level for
; 8065 :    // all files to be at the minimal level of the software.
; 8066 :    if ( MiCompareOI_ToRelease( lpView, szlReleaseCompatible ) < 0 )

	mov	edx, DWORD PTR _szlReleaseCompatible
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_MiCompareOI_ToRelease@8
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $L10232

; 8068 :       MiSetOI_ReleaseForView( lpView, szlReleaseCompatible );

	mov	edx, DWORD PTR _szlReleaseCompatible
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_MiSetOI_ReleaseForView@8
$L10232:

; 8070 : 
; 8071 :    // if we are using new features, force to current Release
; 8072 :    if ( (lControl & zENCODE_BLOBS) || (lControl & zNO_NULL_STRING_TERM) )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 4194304				; 00400000H
	test	ecx, ecx
	jne	SHORT $L10234
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 8388608				; 00800000H
	test	edx, edx
	je	SHORT $L10233
$L10234:

; 8074 :       MiSetOI_ReleaseForView( lpView, szlReleaseCurrent );

	mov	eax, DWORD PTR _szlReleaseCurrent
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_MiSetOI_ReleaseForView@8
$L10233:

; 8076 : 
; 8077 :    zstrcpy( FileHeader.szRelease, lpViewOI->szRelease );  // dks 3/5/96

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	lea	eax, DWORD PTR _FileHeader$[ebp+54]
	push	eax
	call	_strcpy
	add	esp, 8

; 8078 :    pchLine = FileHeader.chTypeIndicator;

	lea	ecx, DWORD PTR _FileHeader$[ebp]
	mov	DWORD PTR _pchLine$[ebp], ecx

; 8079 :    for ( k = 0; k < sizeof( FileHeaderRecord ); k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L10236
$L10237:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L10236:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 73					; 00000049H
	jae	SHORT $L10238

; 8081 :       if ( pchLine[ k ] == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $L10239

; 8082 :          pchLine[ k ] = ' ';

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [edx+ecx], 32			; 00000020H
$L10239:

; 8083 :    }

	jmp	SHORT $L10237
$L10238:

; 8084 : 
; 8085 :    FileHeader.nEntityInstanceRecordSize = 0;

	mov	WORD PTR _FileHeader$[ebp+63], 0

; 8086 : 
; 8087 :    if ( (*lpfnStreamFunc)( lpView, lpvData, (zPCHAR) &FileHeader,
; 8088 :                            0, zTYPE_STRING ) == zCALL_ERROR )

	push	83					; 00000053H
	push	0
	lea	eax, DWORD PTR _FileHeader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	eax, ax
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L10241

; 8090 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10189
$L10241:

; 8092 : 
; 8093 :    // Write the ER date from the OD if we have incrementals.
; 8094 :    if ( bIncremental &&
; 8095 :         (*lpfnStreamFunc)( lpView, lpvData, lpViewOD->szER_Date,
; 8096 :                            0, zTYPE_STRING ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _bIncremental$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L10242
	push	83					; 00000053H
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 248				; 000000f8H
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $L10242

; 8098 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10189
$L10242:

; 8100 : 
; 8101 :    // Write the flags used to activate the OI.
; 8102 :    if ( lpViewOI->lActivateControl )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $L10245

; 8104 :       zsprintf( szTemp, "mCONTROL %lx", lpViewOI->lActivateControl );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	push	OFFSET FLAT:??_C@_0N@LHOF@mCONTROL?5?$CFlx?$AA@ ; `string'
	lea	eax, DWORD PTR _szTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 8105 :       if ( (*lpfnStreamFunc)( lpView, lpvData, szTemp, 0,
; 8106 :                               zTYPE_STRING ) == zCALL_ERROR )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szTemp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $L10245

; 8108 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10189
$L10245:

; 8111 : 
; 8112 :    nRC = fnWriteOI_ToTextStream( lpView, lpfnStreamFunc, lpvData,
; 8113 :                                  bIncremental, lControl );

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	al, BYTE PTR _bIncremental$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpfnStreamFunc$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnWriteOI_ToTextStream
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 8114 : 
; 8115 :    // Write the original OI for optimistic locking.
; 8116 :    if ( nRC == 0 && bOptimistic )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L10246
	mov	edx, DWORD PTR _bOptimistic$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L10246

; 8118 :       if ( (*lpfnStreamFunc)( lpView, lpvData, "ZEND",
; 8119 :                               0, zTYPE_STRING ) == zCALL_ERROR )

	push	83					; 00000053H
	push	0
	push	OFFSET FLAT:??_C@_04JJOE@ZEND?$AA@	; `string'
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $L10247

; 8121 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10189
$L10247:

; 8123 : 
; 8124 :       // Write the OI to the text stream but don't save the cursors.
; 8125 :       nRC = fnWriteOI_ToTextStream( zGETPTR( lpViewOI->vOriginalOI ),
; 8126 :                                     lpfnStreamFunc,
; 8127 :                                     lpvData, bIncremental,
; 8128 :                                     ( lControl & ~zSAVE_CURSORS ) );

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, -262145				; fffbffffH
	push	eax
	mov	cl, BYTE PTR _bIncremental$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpfnStreamFunc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnWriteOI_ToTextStream
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$L10246:

; 8130 : 
; 8131 :    // Write the qualification OI for optimistic locking.
; 8132 :    if ( nRC == 0 && bOptimistic )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $L10252
	mov	ecx, DWORD PTR _bOptimistic$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L10252

; 8134 :       if ( (*lpfnStreamFunc)( lpView, lpvData, "ZEND",
; 8135 :                               0, zTYPE_STRING ) == zCALL_ERROR )

	push	83					; 00000053H
	push	0
	push	OFFSET FLAT:??_C@_04JJOE@ZEND?$AA@	; `string'
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $L10251

; 8137 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10189
$L10251:

; 8139 : 
; 8140 :       // Write the OI to the text stream but don't save the cursors.
; 8141 :       if ( lpViewOI->vQualOI )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $L10252

; 8142 :          nRC = fnWriteOI_ToTextStream( zGETPTR( lpViewOI->vQualOI ),
; 8143 :                                        lpfnStreamFunc,
; 8144 :                                        lpvData, bIncremental,
; 8145 :                                        ( lControl & ~zSAVE_CURSORS ) );

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, -262145				; fffbffffH
	push	eax
	mov	cl, BYTE PTR _bIncremental$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpfnStreamFunc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnWriteOI_ToTextStream
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$L10252:

; 8147 : 
; 8148 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $L10254

; 8149 :       lpViewOI->bUpdatedFile = 0;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$L10254:

; 8150 : 
; 8151 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	and	edx, 1
	test	edx, edx
	je	SHORT $L10255

; 8153 :       zCHAR sz[ 100 ];
; 8154 : 
; 8155 :       zsprintf( sz, "(%s) = %lf seconds", lpViewOD->szName,
; 8156 :                 (double) ( SysGetTickCount( ) - lTickCount ) / zTICKS_PER_SECOND );

	call	_SysGetTickCount@0
	sub	eax, DWORD PTR _lTickCount$[ebp]
	mov	DWORD PTR -300+[ebp], eax
	mov	DWORD PTR -300+[ebp+4], 0
	fild	QWORD PTR -300+[ebp]
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET FLAT:??_C@_0BD@BCKI@?$CI?$CFs?$CJ?5?$DN?5?$CFlf?5seconds?$AA@ ; `string'
	lea	ecx, DWORD PTR _sz$10256[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 8157 :       TraceLineS( "(oi) Total time for SfWriteOI_ToStream ", sz );

	lea	edx, DWORD PTR _sz$10256[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CI@BFCD@?$CIoi?$CJ?5Total?5time?5for?5SfWriteOI_To@ ; `string'
	call	_TraceLineS@8
$L10255:

; 8159 : 
; 8160 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L10189:

; 8161 : 
; 8162 : } // SfWriteOI_ToStream

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SfWriteOI_ToStream@20 ENDP
_TEXT	ENDS
PUBLIC	_CommitOI_ToFile@12
EXTRN	_SysCloseFileWithControl@16:NEAR
_TEXT	SEGMENT
_lpView$ = 8
_cpcFileName$ = 12
_lControl$ = 16
_lpCurrentTask$ = -2084
_FileData$ = -2076
_szOpenFileName$ = -2060
_szWork$ = -1028
_hFile$ = -2080
_nTrys$ = -1032
_nRC$ = -2064
_lpApp$10277 = -2088
_CommitOI_ToFile@12 PROC NEAR

; 8187 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2088				; 00000828H

; 8188 :    LPTASK         lpCurrentTask;
; 8189 :    FileDataRecord FileData;
; 8190 :    zCHAR          szOpenFileName[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 8191 :    zCHAR          szWork[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 8192 :    zLONG          hFile;
; 8193 :    zSHORT         nTrys;
; 8194 :    zSHORT         nRC;
; 8195 : 
; 8196 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 8197 :    if ( (lpCurrentTask = fnOperationCall( iCommitOI_ToFile, lpView,
; 8198 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	61					; 0000003dH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L10274

; 8200 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10266
$L10274:

; 8202 : 
; 8203 : // DGC 9/23/96
; 8204 : // I changed the logic: if the file name is not qualfied, use the object dir
; 8205 : // for the application. I repeated this change in CommitOI_ToFile.
; 8206 :    if ( zstrchr( cpcFileName, cDirSep ) == 0 )

	movsx	ecx, BYTE PTR _cDirSep
	push	ecx
	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $L10276

; 8208 :       LPAPP lpApp;
; 8209 : 
; 8210 :       fnGetApplicationForSubtask( &lpApp, lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpApp$10277[ebp]
	push	ecx
	call	_fnGetApplicationForSubtask@8

; 8211 :       if ( lpApp )

	cmp	DWORD PTR _lpApp$10277[ebp], 0
	je	SHORT $L10278

; 8212 :          zstrcpy( szWork, lpApp->szObjectDir );

	mov	edx, DWORD PTR _lpApp$10277[ebp]
	add	edx, 347				; 0000015bH
	push	edx
	lea	eax, DWORD PTR _szWork$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 8213 :       else

	jmp	SHORT $L10279
$L10278:

; 8215 :          lpApp = zGETPTR( AnchorBlock->hSystemApp );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$10277[ebp], eax

; 8216 :          zstrcpy( szWork, lpApp->szObjectDir );

	mov	eax, DWORD PTR _lpApp$10277[ebp]
	add	eax, 347				; 0000015bH
	push	eax
	lea	ecx, DWORD PTR _szWork$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$L10279:

; 8218 : 
; 8219 :       SysAppendcDirSep( szWork );

	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 8221 :    else

	jmp	SHORT $L10281
$L10276:

; 8222 :       szWork[ 0 ] = 0;

	mov	BYTE PTR _szWork$[ebp], 0
$L10281:

; 8223 : 
; 8224 :    zstrcat( szWork, cpcFileName );

	mov	eax, DWORD PTR _cpcFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWork$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 8225 :    SysConvertEnvironmentString( szOpenFileName, szWork );

	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	call	_SysConvertEnvironmentString@8

; 8226 : 
; 8227 :    // Open the file for the object instance data ... this file really should
; 8228 :    // exist, but it may already be open.  So we will try more than once to
; 8229 :    // open it before giving up.
; 8230 :    hFile = -1;

	mov	DWORD PTR _hFile$[ebp], -1

; 8231 :    nTrys = 0;

	mov	WORD PTR _nTrys$[ebp], 0
$L10283:

; 8232 :    while ( hFile == -1 && nTrys++ < 10 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $L10284
	movsx	ecx, WORD PTR _nTrys$[ebp]
	mov	dx, WORD PTR _nTrys$[ebp]
	add	dx, 1
	mov	WORD PTR _nTrys$[ebp], dx
	cmp	ecx, 10					; 0000000aH
	jge	SHORT $L10284

; 8234 :       hFile = SysOpenFile( lpView, szOpenFileName,
; 8235 :                 COREFILE_CREATE | COREFILE_WRITELINE_BUFFERED | COREFILE_BACKUP );

	push	4129					; 00001021H
	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 8236 :       if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $L10285

; 8237 :          SysWait( 500 );

	push	500					; 000001f4H
	call	_SysWait@4
$L10285:

; 8238 :    }

	jmp	SHORT $L10283
$L10284:

; 8239 : 
; 8240 :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $L10286

; 8242 :       //  "KZOEE071 - Error opening instance file "
; 8243 :       fnIssueCoreError( lpCurrentTask, lpView, 16, 71, 0, cpcFileName, 0 );

	push	0
	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	push	0
	push	71					; 00000047H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8244 :       fnOperationReturn( iCommitOI_ToFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	61					; 0000003dH
	call	_fnOperationReturn
	add	esp, 8

; 8245 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10266
$L10286:

; 8247 : 
; 8248 :    FileData.pchFileName = (zPCHAR) cpcFileName;

	mov	eax, DWORD PTR _cpcFileName$[ebp]
	mov	DWORD PTR _FileData$[ebp], eax

; 8249 :    FileData.hFile       = hFile;

	mov	ecx, DWORD PTR _hFile$[ebp]
	mov	DWORD PTR _FileData$[ebp+4], ecx

; 8250 :    FileData.lLine       = 0;

	mov	DWORD PTR _FileData$[ebp+8], 0

; 8251 : 
; 8252 :    nRC = SfWriteOI_ToStream( lpView, cpcFileName, lControl,
; 8253 :                              fnPutDataToFile, (zPVOID) &FileData );

	lea	edx, DWORD PTR _FileData$[ebp]
	push	edx
	push	OFFSET FLAT:_fnPutDataToFile@20
	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SfWriteOI_ToStream@20
	mov	WORD PTR _nRC$[ebp], ax

; 8254 : 
; 8255 :    if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L10289

; 8256 :       SysCloseFileWithControl( lpView, hFile, 0, CLOSEFILE_ABORT_BACKUP );

	push	1
	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysCloseFileWithControl@16

; 8257 :    else

	jmp	SHORT $L10290
$L10289:

; 8258 :       nRC = SysCloseFileWithControl( lpView, hFile, 0, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysCloseFileWithControl@16
	mov	WORD PTR _nRC$[ebp], ax
$L10290:

; 8259 : 
; 8260 :    fnOperationReturn( iCommitOI_ToFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	61					; 0000003dH
	call	_fnOperationReturn
	add	esp, 8

; 8261 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L10266:

; 8262 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_CommitOI_ToFile@12 ENDP
_lpView$ = 8
_lpCurrentTask$ = -8
_nRC$ = -4
_DropObjectInstance@4 PROC NEAR

; 8285 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 8286 :    LPTASK            lpCurrentTask;
; 8287 :    zSHORT            nRC;
; 8288 : 
; 8289 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 8290 :    if ( (lpCurrentTask = fnOperationCall( iDropObjectInstance, lpView,
; 8291 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	70					; 00000046H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L10296

; 8293 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L10293
$L10296:

; 8295 : 
; 8296 :    // Call fnDropObjectInstance with current view
; 8297 :    nRC = fnDropObjectInstance( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropObjectInstance
	add	esp, 4
	mov	WORD PTR _nRC$[ebp], ax

; 8298 : 
; 8299 :    fnOperationReturn( iDropObjectInstance, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	70					; 00000046H
	call	_fnOperationReturn
	add	esp, 8

; 8300 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L10293:

; 8301 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DropObjectInstance@4 ENDP
_TEXT	ENDS
PUBLIC	_ObjectInstanceUpdated@4
_TEXT	SEGMENT
_lpView$ = 8
_lpCurrentTask$ = -16
_lpViewCsr$ = -4
_lpViewOI$ = -12
_nRC$ = -8
_ObjectInstanceUpdated@4 PROC NEAR

; 8321 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 8322 :    LPTASK            lpCurrentTask;
; 8323 :    LPVIEWCSR         lpViewCsr;
; 8324 :    LPVIEWOI          lpViewOI;
; 8325 :    zSHORT            nRC;
; 8326 : 
; 8327 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 8328 :    if ( (lpCurrentTask = fnOperationCall( iObjectInstanceUpdated, lpView,
; 8329 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	118					; 00000076H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L10304

; 8331 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L10299
$L10304:

; 8333 : 
; 8334 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 8335 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8336 :    nRC = lpViewOI->bUpdated;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 4
	and	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 8337 : 
; 8338 :    fnOperationReturn( iObjectInstanceUpdated, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	118					; 00000076H
	call	_fnOperationReturn
	add	esp, 8

; 8339 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L10299:

; 8340 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_ObjectInstanceUpdated@4 ENDP
_TEXT	ENDS
PUBLIC	_ObjectInstanceUpdatedFromFile@4
_TEXT	SEGMENT
_lpView$ = 8
_lpCurrentTask$ = -16
_lpViewCsr$ = -4
_lpViewOI$ = -12
_nRC$ = -8
_ObjectInstanceUpdatedFromFile@4 PROC NEAR

; 8361 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 8362 :    LPTASK            lpCurrentTask;
; 8363 :    LPVIEWCSR         lpViewCsr;
; 8364 :    LPVIEWOI          lpViewOI;
; 8365 :    zSHORT            nRC;
; 8366 : 
; 8367 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 8368 :    if ( (lpCurrentTask = fnOperationCall( iObjectInstanceUpdatedFromFile,
; 8369 :                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	130					; 00000082H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L10314

; 8371 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L10309
$L10314:

; 8373 : 
; 8374 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 8375 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8376 :    nRC       = lpViewOI->bUpdatedFile;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 5
	and	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 8377 : 
; 8378 :    fnOperationReturn( iObjectInstanceUpdatedFromFile, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	130					; 00000082H
	call	_fnOperationReturn
	add	esp, 8

; 8379 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L10309:

; 8380 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_ObjectInstanceUpdatedFromFile@4 ENDP
_TEXT	ENDS
PUBLIC	_fnDropViewOI
_TEXT	SEGMENT
_lpViewCsr$ = 8
_lpViewOI$ = -28
_hViewCsr$ = -24
_lpViewSubobject$ = -12
_lpSelectedInstance$ = -16
_lpView$ = -4
_bMutexLocked$ = -20
_nRC$ = -8
_lpViewOD$10332 = -32
_ViewCluster$10335 = -40
_nState$10338 = -44
_lpCurrentTask$10339 = -48
_lpWorkViewCsr$10347 = -52
_fnDropViewCsr PROC NEAR

; 8402 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 8403 :    LPVIEWOI           lpViewOI;
; 8404 :    LPVIEWCSR          hViewCsr = (LPVIEWCSR) zGETHNDL( lpViewCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hViewCsr$[ebp], eax

; 8405 :    LPVIEWSUBOBJECT    lpViewSubobject;
; 8406 :    LPSELECTEDINSTANCE lpSelectedInstance;
; 8407 :    zVIEW              lpView;
; 8408 :    zBOOL              bMutexLocked;
; 8409 :    zSHORT             nRC;
; 8410 : 
; 8411 :    if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	jne	SHORT $L10329

; 8412 :       return( 0 );

	xor	ax, ax
	jmp	$L10319
$L10329:

; 8413 : 
; 8414 :    lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8415 : 
; 8416 : #ifdef __ACTIVATE_CONSTRAINTS__
; 8417 :    // Check to see if we are dropping the last ViewCsr for the OI.  If we are
; 8418 :    // then we need to call the DropOI constraint.
; 8419 :    if ( lpViewOI->hFirstViewCsr == hViewCsr && lpViewCsr->hNextViewCsr == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	cmp	ecx, DWORD PTR _hViewCsr$[ebp]
	jne	$L10337
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+2], 0
	jne	$L10337

; 8421 :       LPVIEWOD lpViewOD;
; 8422 : 
; 8423 :       // We are dropping the last view csr which means we are dropping the
; 8424 :       // OI as well.
; 8425 :       lpView   = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax

; 8426 : 
; 8427 :       // If the OI has pessimistic locking then commit the OI to drop the
; 8428 :       // locks.
; 8429 :       if ( lpViewOI->bIsLocked )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 7
	and	eax, 1
	test	eax, eax
	je	SHORT $L10334

; 8431 :          ViewClusterRecord ViewCluster;
; 8432 : 
; 8433 :          ViewCluster.vOI      = lpView;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR _ViewCluster$10335[ebp], ecx

; 8434 :          ViewCluster.lControl = zCOMMIT_DROPLOCKSONLY;

	mov	DWORD PTR _ViewCluster$10335[ebp+4], 2048 ; 00000800H

; 8435 : 
; 8436 :          // We need to commit the object to release the pessimistic lock.
; 8437 :          nRC = CommitMultipleOIs( &ViewCluster, 1, 0, zCOMMIT_DROPLOCKSONLY );

	push	2048					; 00000800H
	push	0
	push	1
	lea	edx, DWORD PTR _ViewCluster$10335[ebp]
	push	edx
	call	_CommitMultipleOIs@16
	mov	WORD PTR _nRC$[ebp], ax
$L10334:

; 8439 : 
; 8440 :       // If object has drop oi constraint active, check for objections.
; 8441 :       lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$10332[ebp], eax

; 8442 :       if ( lpViewOD->bDropOIConstraint )

	mov	edx, DWORD PTR _lpViewOD$10332[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 6
	and	eax, 1
	test	eax, eax
	je	SHORT $L10337

; 8444 :          zSHORT nState = 0;

	mov	WORD PTR _nState$10338[ebp], 0

; 8445 :          LPTASK lpCurrentTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$10339[ebp], eax

; 8446 : 
; 8447 :          if ( lpCurrentTask->bShutdown )

	mov	eax, DWORD PTR _lpCurrentTask$10339[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10341

; 8448 :             nState += zOCE_STATE_SHUTDOWN;

	mov	dx, WORD PTR _nState$10338[ebp]
	add	dx, 2
	mov	WORD PTR _nState$10338[ebp], dx
$L10341:

; 8449 : 
; 8450 :          fnInvokeOCEOperation( zGETPTR( lpViewCsr->hView ),
; 8451 :                                lpCurrentTask, zOCE_DROPOI, nState );

	mov	ax, WORD PTR _nState$10338[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _lpCurrentTask$10339[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H

; 8452 :          lpViewOI->bDropConstraintInvoked = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$L10337:

; 8455 : #endif
; 8456 : 
; 8457 :    if ( lpViewOI->hTask == AnchorBlock->hMainTask )  // added dks

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [ecx+14]
	cmp	eax, DWORD PTR [edx+106]
	jne	SHORT $L10343

; 8459 :       bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$[ebp], 1

; 8460 :       zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 8462 :    else

	jmp	SHORT $L10344
$L10343:

; 8463 :       bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$[ebp], 0
$L10344:

; 8464 : 
; 8465 :    // Unchain ViewCsr from View OI.
; 8466 :    if ( lpViewOI->hFirstViewCsr == hViewCsr )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	cmp	edx, DWORD PTR _hViewCsr$[ebp]
	jne	SHORT $L10345

; 8467 :       lpViewOI->hFirstViewCsr = lpViewCsr->hNextViewCsr;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+10], edx

; 8468 :    else

	jmp	SHORT $L10346
$L10345:

; 8470 :       LPVIEWCSR lpWorkViewCsr;
; 8471 : 
; 8472 :       lpWorkViewCsr = zGETPTR( lpViewOI->hFirstViewCsr ); // blew on this line 2006.07.03 dks

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewCsr$10347[ebp], eax
$L10350:

; 8473 :       while ( lpWorkViewCsr->hNextViewCsr != hViewCsr )

	mov	edx, DWORD PTR _lpWorkViewCsr$10347[ebp]
	mov	eax, DWORD PTR [edx+2]
	cmp	eax, DWORD PTR _hViewCsr$[ebp]
	je	SHORT $L10351

; 8474 :          lpWorkViewCsr = zGETPTR( lpWorkViewCsr->hNextViewCsr );

	mov	ecx, DWORD PTR _lpWorkViewCsr$10347[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewCsr$10347[ebp], eax
	jmp	SHORT $L10350
$L10351:

; 8475 : 
; 8476 :       lpWorkViewCsr->hNextViewCsr = lpViewCsr->hNextViewCsr;

	mov	eax, DWORD PTR _lpWorkViewCsr$10347[ebp]
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+2], edx
$L10346:

; 8478 : 
; 8479 :    while ( lpViewCsr->hFirstViewSubobject )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $L10355

; 8481 :       lpViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 8482 :       lpViewCsr->hFirstViewSubobject = lpViewSubobject->hNextViewSubobject;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+30], edx

; 8483 :       fnFreeDataspace( lpViewSubobject );

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 8484 :    }

	jmp	SHORT $L10346
$L10355:

; 8485 : 
; 8486 :    while ( lpViewCsr->hFirstSelectedInstance )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	SHORT $L10359

; 8488 :       lpSelectedInstance = zGETPTR( lpViewCsr->hFirstSelectedInstance );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSelectedInstance$[ebp], eax

; 8489 :       lpViewCsr->hFirstSelectedInstance =
; 8490 :                               lpSelectedInstance->hNextSelectedInstance;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR _lpSelectedInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+42], eax

; 8491 :       fnFreeDataspace( lpSelectedInstance );

	mov	ecx, DWORD PTR _lpSelectedInstance$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 8492 :    }

	jmp	SHORT $L10355
$L10359:

; 8493 : 
; 8494 :    // If the view which used to point to us *still* points to us, then
; 8495 :    // zero out the pointer since we are going away.
; 8496 :    lpView = zGETPTR( lpViewCsr->hView );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax

; 8497 :    if ( lpView && lpView->hViewCsr == hViewCsr )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $L10362
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	cmp	edx, DWORD PTR _hViewCsr$[ebp]
	jne	SHORT $L10362

; 8498 :       lpView->hViewCsr = 0;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+10], 0
$L10362:

; 8499 : 
; 8500 :    fnFreeDataspace( lpViewCsr );  // should this line be moved to after the following if block?? dks 2006.07.19

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 8501 : 
; 8502 :    // If the ViewOI has no more cursors, drop it!
; 8503 :    if ( lpViewOI->hFirstViewCsr == 0 )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+10], 0
	jne	SHORT $L10363

; 8504 :       fnDropViewOI( lpViewOI );  // dks 2006.09.18 error while cleaning up client OE

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnDropViewOI
	add	esp, 4
$L10363:

; 8505 : 
; 8506 :    if ( bMutexLocked )

	mov	ecx, DWORD PTR _bMutexLocked$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L10364

; 8507 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$L10364:

; 8508 : 
; 8509 :    return( 0 );

	xor	ax, ax
$L10319:

; 8510 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropViewCsr ENDP
_lpView$ = 8
_lpViewOI$ = -20
_lpViewCsr$ = -4
_lpFirstViewCsr$ = -12
_lpCurrentView$ = -8
_lpLastView$ = -16
_fnDropObjectInstance PROC NEAR

; 8529 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 8530 :    LPVIEWOI          lpViewOI;
; 8531 :    LPVIEWCSR         lpViewCsr;
; 8532 :    LPVIEWCSR         lpFirstViewCsr;
; 8533 :    zVIEW             lpCurrentView;
; 8534 :    zVIEW             lpLastView;
; 8535 : 
; 8536 :    // If no ViewCsr, go home ...
; 8537 :    if ( lpView->hViewCsr == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $L10373

; 8538 :       return( 0 );

	xor	ax, ax
	jmp	$L10367
$L10373:

; 8539 : 
; 8540 :    // Get pointers to ViewOI and task owning the ViewOI.
; 8541 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 8542 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax
$L10377:

; 8543 : 
; 8544 : // {
; 8545 : //    LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );
; 8546 : //    TraceLine( "DropObjectInstance: 0x%08x   LOD: %s",
; 8547 : //               lpView, lpViewOD->szName );
; 8548 : //    if ( zstrcmp( "KZMSGQOO", lpViewOD->szName ) == 0 )
; 8549 : //       SysMessageBox( lpView, "Dropping LOD", lpViewOD->szName, 0 );
; 8550 : // }
; 8551 : 
; 8552 :    // Find the last view cursor for the ViewOI.
; 8553 :    while ( lpViewCsr->hNextViewCsr )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+2], 0
	je	SHORT $L10378

; 8554 :       lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
	jmp	SHORT $L10377
$L10378:

; 8555 : 
; 8556 :    // Drop all the views.  When the last view is dropped, fnDropView will
; 8557 :    // drop the object instance.  The DropObjectInstance constraint will
; 8558 :    // be called then.
; 8559 :    lpLastView = zGETPTR( lpViewCsr->hView );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastView$[ebp], eax

; 8560 :    lpCurrentView = 0;

	mov	DWORD PTR _lpCurrentView$[ebp], 0
$L10381:

; 8563 :       lpFirstViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewCsr$[ebp], eax

; 8564 :       lpCurrentView = zGETPTR( lpFirstViewCsr->hView );

	mov	eax, DWORD PTR _lpFirstViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentView$[ebp], eax

; 8565 :       fnDropView( lpCurrentView );

	mov	edx, DWORD PTR _lpCurrentView$[ebp]
	push	edx
	call	_fnDropView@4

; 8566 : 
; 8567 :    }  while ( lpCurrentView != lpLastView );

	mov	eax, DWORD PTR _lpCurrentView$[ebp]
	cmp	eax, DWORD PTR _lpLastView$[ebp]
	jne	SHORT $L10381

; 8568 : 
; 8569 :    return( 0 );

	xor	ax, ax
$L10367:

; 8570 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropObjectInstance ENDP
_TEXT	ENDS
PUBLIC	_fnClearLinks@4
_TEXT	SEGMENT
_lpEntityInstance$ = 8
_lpNextLinked$ = -4
_lpSearchLink$ = -12
_hEntityInstance$ = -8
_fnClearLinks@4 PROC NEAR

; 8574 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 8575 :    LPENTITYINSTANCE lpNextLinked;
; 8576 :    LPENTITYINSTANCE lpSearchLink;
; 8577 :    LPENTITYINSTANCE hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hEntityInstance$[ebp], eax

; 8578 : 
; 8579 :    lpNextLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax

; 8580 : 
; 8581 :    if ( lpNextLinked->hNextLinked == hEntityInstance )

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	cmp	ecx, DWORD PTR _hEntityInstance$[ebp]
	jne	SHORT $L10395

; 8582 :       lpNextLinked->hNextLinked = 0;

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+42], 0

; 8583 :    else

	jmp	SHORT $L10396
$L10395:

; 8585 :       lpSearchLink = lpNextLinked;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$L10398:

; 8586 :       while ( lpSearchLink->hNextLinked != hEntityInstance )

	mov	ecx, DWORD PTR _lpSearchLink$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	cmp	edx, DWORD PTR _hEntityInstance$[ebp]
	je	SHORT $L10399

; 8587 :          lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
	jmp	SHORT $L10398
$L10399:

; 8588 : 
; 8589 :       lpSearchLink->hNextLinked = lpEntityInstance->hNextLinked;

	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
$L10396:

; 8591 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnClearLinks@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@GGJF@Trying?5to?5drop?5original?5OI?5but?5i@ ; `string'
EXTRN	_fnDeleteAttributeRecord:NEAR
EXTRN	_fnRemoveEntityFromDebugChange@4:NEAR
;	COMDAT ??_C@_0CP@GGJF@Trying?5to?5drop?5original?5OI?5but?5i@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CP@GGJF@Trying?5to?5drop?5original?5OI?5but?5i@ DB 'Trying to drop'
	DB	' original OI but it''s not there!', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpViewOI$ = 8
_lpEntityInstance$ = -4
_lpNextEntityInstance$ = -16
_lpLastEntityInstance$ = -12
_lpSearchLink$ = -20
_lpSearchVsn$ = -28
_lpOwningTask$ = -8
_bPrevVersion$ = -24
_vOriginalOI$10413 = -32
_lpPrevVsn$10435 = -36
_lpViewEntity$10454 = -40
_lpNextVsn$10458 = -44
_lpNextVsn$10484 = -48
_lpPrevVsn$10487 = -52
_lpNextLinked$10490 = -56
_lpSearchViewOI$10505 = -60
_fnDropViewOI PROC NEAR

; 8607 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 8608 :    LPENTITYINSTANCE  lpEntityInstance;
; 8609 :    LPENTITYINSTANCE  lpNextEntityInstance;
; 8610 :    LPENTITYINSTANCE  lpLastEntityInstance;
; 8611 :    LPENTITYINSTANCE  lpSearchLink;
; 8612 :    LPENTITYINSTANCE  lpSearchVsn;
; 8613 :    LPTASK            lpOwningTask;
; 8614 :    zBOOL             bPrevVersion;
; 8615 : 
; 8616 :    lpOwningTask = zGETPTR( lpViewOI->hTask );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 8617 : 
; 8618 :    // If the ViewOI is in a task being shutdown and does not have any
; 8619 :    // instances shared with the system task, skip freeing up the instance
; 8620 :    // data, it will go away on completion of task cleanup.
; 8621 :    // If the task is running as a server task then we won't free memory
; 8622 :    // because it will be shut down shortly.
; 8623 :    // Things are unfortunately not working as suggested in the comment above.
; 8624 :    // So always do a drop, even when the task is a server task and is being
; 8625 :    // shutdown (US).
; 8626 :    // Check to see if we have any locking OI's.  If we do, drop them.
; 8627 :    if ( lpViewOI->vOriginalOI )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $L10418

; 8629 :       zVIEW vOriginalOI = zGETPTR( lpViewOI->vOriginalOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vOriginalOI$10413[ebp], eax

; 8630 : 
; 8631 :       // DGC 05/05/97
; 8632 :       // Following check shouldn't be needed once I fix a bug.
; 8633 :       if ( vOriginalOI->nTableID != iView )

	mov	edx, DWORD PTR _vOriginalOI$10413[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10021				; 00002725H
	je	SHORT $L10415

; 8635 :          fnSysMessageBox( zGETPTR( lpViewOI->hTask ), szlOE_SystemError,
; 8636 :                           "Trying to drop original OI but it's not there!", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0CP@GGJF@Trying?5to?5drop?5original?5OI?5but?5i@ ; `string'
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnSysMessageBox@16

; 8638 :       else

	jmp	SHORT $L10418
$L10415:

; 8639 :          fnDropView( vOriginalOI );

	mov	ecx, DWORD PTR _vOriginalOI$10413[ebp]
	push	ecx
	call	_fnDropView@4
$L10418:

; 8641 : 
; 8642 :    if ( lpViewOI->vQualOI )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $L10419

; 8643 :       fnDropView( zGETPTR( lpViewOI->vQualOI ) );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4
$L10419:

; 8644 : 
; 8645 :    // If there are any outstanding versioned instances, find the
; 8646 :    // last entity instance in the object instance and work backward
; 8647 :    // from there to clean up outstanding versioned chains until all
; 8648 :    // versions are gone. First, find the last instance in the chain.
; 8649 :    if ( lpViewOI->nVersionedInstances )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	je	SHORT $L10421

; 8651 :       lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L10424:

; 8652 :       while ( lpEntityInstance->hNextHier )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+14], 0
	je	SHORT $L10425

; 8654 :          if ( lpEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $L10426

; 8655 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 8656 :          else

	jmp	SHORT $L10428
$L10426:

; 8657 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L10428:

; 8658 :       }

	jmp	SHORT $L10424
$L10425:

; 8659 : 
; 8660 :       lpLastEntityInstance = lpEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpLastEntityInstance$[ebp], eax
$L10421:

; 8662 : 
; 8663 :    // Delete the instance data associated with the ViewOI.
; 8664 : // AnchorBlock->nStatus = 101; // DGC debugging hack.
; 8665 :    if ( lpViewOI->hRootEntityInstance )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	$L10433
$L10432:

; 8668 :       lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0

; 8669 : 
; 8670 :       // If there are versioned instances out there, let's clean them
; 8671 :       // up!!!  Go to the end of the chain and find one.
; 8672 :       if ( lpViewOI->nVersionedInstances )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	je	$L10448

; 8674 :          LPENTITYINSTANCE lpPrevVsn;
; 8675 : 
; 8676 :          lpEntityInstance = lpLastEntityInstance;

	mov	ecx, DWORD PTR _lpLastEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx

; 8677 :          lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$10435[ebp], eax
$L10438:

; 8678 : 
; 8679 :          // Search for an entity instance which has an outstanding
; 8680 :          // previous version.
; 8681 :          while ( lpEntityInstance &&
; 8682 :                  (lpPrevVsn == 0 || lpPrevVsn->u.nInd.bPrevVsnRoot == FALSE) )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L10439
	cmp	DWORD PTR _lpPrevVsn$10435[ebp], 0
	je	SHORT $L10440
	mov	ecx, DWORD PTR _lpPrevVsn$10435[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 9
	and	edx, 1
	test	edx, edx
	jne	SHORT $L10439
$L10440:

; 8684 :             // Since temporal entitys have no previous version, simply
; 8685 :             // unmark them and subtract 1 from the version count.
; 8686 :             if ( lpEntityInstance->u.nInd.bTemporal )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10442

; 8688 :                lpEntityInstance->u.nInd.bTemporal = 0;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, -9					; fffffff7H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 8689 :                lpViewOI->nVersionedInstances--;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [ecx+22], ax

; 8690 :                if ( lpViewOI->nVersionedInstances == 0 )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	jne	SHORT $L10442

; 8692 :                   lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0

; 8693 :                   break;

	jmp	SHORT $L10439
$L10442:

; 8696 : 
; 8697 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 8698 :             if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L10444

; 8699 :                lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$10435[ebp], eax
$L10444:

; 8700 :          }

	jmp	$L10438
$L10439:

; 8701 : 
; 8702 :          if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L10446

; 8703 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 8704 :          else

	jmp	SHORT $L10448
$L10446:

; 8705 :             lpViewOI->nVersionedInstances = 0;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [ecx+22], 0
$L10448:

; 8707 : 
; 8708 :       // If no entity instance found which is a previous version, go
; 8709 :       // for the main entity instance chain!!
; 8710 :       if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $L10449

; 8712 :          lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 8713 :          lpViewOI->hRootEntityInstance = 0;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+26], 0
$L10449:

; 8715 : 
; 8716 :       // Clean up the entity instances.
; 8717 :       while ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L10453

; 8719 :          LPVIEWENTITY lpViewEntity;
; 8720 : 
; 8721 :          lpNextEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextEntityInstance$[ebp], eax

; 8722 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$10454[ebp], eax

; 8723 : 
; 8724 :          // If there are versioned instances in this instance, zero
; 8725 :          // all records for newer versions linked to this instance
; 8726 :          // whose record matches the link instance record.
; 8727 :          if ( lpEntityInstance->hNextVsn )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+34], 0
	je	$L10476

; 8729 :             LPENTITYINSTANCE lpNextVsn;
; 8730 : 
; 8731 :             // If there are linked instances to the old version of an
; 8732 :             // entity instance, see if the prev-version indicator needs
; 8733 :             // to be unset for all the linked instances because the
; 8734 :             // new version is being dropped by fnDropViewOI.
; 8735 :             if ( lpEntityInstance->hNextLinked )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	$L10470

; 8737 :                bPrevVersion = FALSE;

	mov	BYTE PTR _bPrevVersion$[ebp], 0

; 8738 :                lpSearchLink = zGETPTR( lpEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$L10462:

; 8739 :                while ( lpSearchLink && lpSearchLink != lpEntityInstance )

	cmp	DWORD PTR _lpSearchLink$[ebp], 0
	je	SHORT $L10463
	mov	ecx, DWORD PTR _lpSearchLink$[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L10463

; 8741 :                   if ( lpSearchLink->hNextVsn )

	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $L10464

; 8743 :                      bPrevVersion = TRUE;

	mov	BYTE PTR _bPrevVersion$[ebp], 1

; 8744 :                      break;

	jmp	SHORT $L10463
$L10464:

; 8746 : 
; 8747 :                   lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax

; 8748 :                }

	jmp	SHORT $L10462
$L10463:

; 8749 : 
; 8750 :                if ( bPrevVersion == 0 )

	mov	edx, DWORD PTR _bPrevVersion$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L10470

; 8752 :                   lpSearchLink = zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$L10469:

; 8753 :                   while ( lpSearchLink &&
; 8754 :                           lpSearchLink != lpEntityInstance )

	cmp	DWORD PTR _lpSearchLink$[ebp], 0
	je	SHORT $L10470
	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	cmp	edx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $L10470

; 8756 :                      lpSearchLink->u.nInd.bPrevVersion = FALSE;

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ch, -2					; fffffffeH
	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 8757 :                      lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax

; 8758 :                   }

	jmp	SHORT $L10469
$L10470:

; 8761 : 
; 8762 :             // If the newer version record matches the older version
; 8763 :             // record (because the entity is NOT UPDATEABLE), clear
; 8764 :             // all the record pointers in the newer versions so we do
; 8765 :             // not attempt to free the same record multiple times.
; 8766 :             lpNextVsn = zGETPTR( lpEntityInstance->hNextVsn );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+34]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextVsn$10458[ebp], eax

; 8767 :             if ( lpNextVsn->hPersistRecord == lpEntityInstance->hPersistRecord )

	mov	ecx, DWORD PTR _lpNextVsn$10458[ebp]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	cmp	eax, DWORD PTR [edx+60]
	jne	SHORT $L10476

; 8769 :                lpSearchVsn = lpNextVsn;

	mov	ecx, DWORD PTR _lpNextVsn$10458[ebp]
	mov	DWORD PTR _lpSearchVsn$[ebp], ecx
$L10475:

; 8770 :                while ( lpSearchVsn )

	cmp	DWORD PTR _lpSearchVsn$[ebp], 0
	je	SHORT $L10476

; 8772 :                   lpSearchVsn->hPersistRecord = 0;

	mov	edx, DWORD PTR _lpSearchVsn$[ebp]
	mov	DWORD PTR [edx+60], 0

; 8773 :                   lpSearchLink = zGETPTR( lpSearchVsn->hNextLinked );

	mov	eax, DWORD PTR _lpSearchVsn$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$L10479:

; 8774 :                   while ( lpSearchLink && lpSearchLink != lpSearchVsn )

	cmp	DWORD PTR _lpSearchLink$[ebp], 0
	je	SHORT $L10480
	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	cmp	edx, DWORD PTR _lpSearchVsn$[ebp]
	je	SHORT $L10480

; 8776 :                      lpSearchLink->hPersistRecord = 0;

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	DWORD PTR [eax+60], 0

; 8777 :                      lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	ecx, DWORD PTR _lpSearchLink$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax

; 8778 :                   }

	jmp	SHORT $L10479
$L10480:

; 8779 : 
; 8780 :                   lpSearchVsn = zGETPTR( lpSearchVsn->hNextVsn );

	mov	eax, DWORD PTR _lpSearchVsn$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchVsn$[ebp], eax

; 8781 :                }

	jmp	SHORT $L10475
$L10476:

; 8784 : 
; 8785 :          // Reset version pointers.
; 8786 :          if ( lpEntityInstance->hNextVsn )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $L10483

; 8788 :             LPENTITYINSTANCE lpNextVsn =
; 8789 :                                  zGETPTR( lpEntityInstance->hNextVsn );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextVsn$10484[ebp], eax

; 8790 : 
; 8791 :             lpNextVsn->hPrevVsn = lpEntityInstance->hPrevVsn;

	mov	edx, DWORD PTR _lpNextVsn$10484[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	mov	DWORD PTR [edx+38], ecx
$L10483:

; 8793 : 
; 8794 :          if ( lpEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $L10486

; 8796 :             LPENTITYINSTANCE lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$10487[ebp], eax

; 8797 : 
; 8798 :             lpPrevVsn->hNextVsn = lpEntityInstance->hNextVsn;

	mov	edx, DWORD PTR _lpPrevVsn$10487[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	mov	DWORD PTR [edx+34], ecx
$L10486:

; 8800 : 
; 8801 :          // If the entity instance is linked, remove the entity instance
; 8802 :          // from the link chain.
; 8803 :          if ( lpEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $L10489

; 8805 :             LPENTITYINSTANCE lpNextLinked =
; 8806 :                               zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$10490[ebp], eax

; 8807 : 
; 8808 :             if ( lpNextLinked->hNextLinked == zGETHNDL( lpEntityInstance ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpNextLinked$10490[ebp]
	cmp	DWORD PTR [ecx+42], eax
	jne	SHORT $L10493

; 8809 :                lpNextLinked->hNextLinked = 0;

	mov	edx, DWORD PTR _lpNextLinked$10490[ebp]
	mov	DWORD PTR [edx+42], 0

; 8810 :             else

	jmp	SHORT $L10494
$L10493:

; 8812 :                lpSearchLink = lpNextLinked;

	mov	eax, DWORD PTR _lpNextLinked$10490[ebp]
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$L10497:

; 8813 :                while ( lpSearchLink->hNextLinked !=
; 8814 :                                              zGETHNDL( lpEntityInstance ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	cmp	DWORD PTR [edx+42], eax
	je	SHORT $L10498

; 8815 :                   lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
	jmp	SHORT $L10497
$L10498:

; 8816 : 
; 8817 :                lpSearchLink->hNextLinked = lpEntityInstance->hNextLinked;

	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
$L10494:

; 8820 :          else

	jmp	SHORT $L10500
$L10489:

; 8821 :             fnDeleteAttributeRecord( lpViewEntity, lpEntityInstance, TRUE );  // dks 2006.09.18 error while cleaning up client OE

	push	1
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$10454[ebp]
	push	eax
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH
$L10500:

; 8822 : 
; 8823 :          fnDeleteAttributeRecord( lpViewEntity, lpEntityInstance, FALSE );

	push	0
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$10454[ebp]
	push	edx
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH

; 8824 :          fnRemoveEntityFromDebugChange( lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRemoveEntityFromDebugChange@4

; 8825 :          fnFreeDataspace( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 8826 :          lpEntityInstance = lpNextEntityInstance;

	mov	edx, DWORD PTR _lpNextEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx

; 8827 :       }

	jmp	$L10449
$L10453:

; 8828 : 
; 8829 :       // Get out when no root instance exists any more.
; 8830 :       if ( lpViewOI->hRootEntityInstance == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $L10501

; 8831 :          break;

	jmp	SHORT $L10433
$L10501:

; 8832 :    }

	jmp	$L10432
$L10433:

; 8833 : 
; 8834 : // AnchorBlock->nStatus = AnchorInitialized;
; 8835 : 
; 8836 :    // Free the ViewOI.
; 8837 :    if ( lpOwningTask->hFirstViewOI == zGETHNDL( lpViewOI ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	cmp	DWORD PTR [edx+98], eax
	jne	SHORT $L10503

; 8838 :       lpOwningTask->hFirstViewOI = lpViewOI->hNextViewOI;

	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+98], edx

; 8839 :    else

	jmp	SHORT $L10507
$L10503:

; 8841 :       LPVIEWOI lpSearchViewOI;
; 8842 : 
; 8843 :       lpSearchViewOI = zGETPTR( lpOwningTask->hFirstViewOI );

	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	mov	ecx, DWORD PTR [eax+98]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewOI$10505[ebp], eax

; 8844 :       if ( lpSearchViewOI )

	cmp	DWORD PTR _lpSearchViewOI$10505[ebp], 0
	je	SHORT $L10507
$L10510:

; 8846 :          while ( lpSearchViewOI->hNextViewOI != zGETHNDL( lpViewOI ) )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSearchViewOI$10505[ebp]
	cmp	DWORD PTR [ecx+2], eax
	je	SHORT $L10511

; 8847 :             lpSearchViewOI = zGETPTR( lpSearchViewOI->hNextViewOI );

	mov	edx, DWORD PTR _lpSearchViewOI$10505[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewOI$10505[ebp], eax
	jmp	SHORT $L10510
$L10511:

; 8848 : 
; 8849 :          lpSearchViewOI->hNextViewOI = lpViewOI->hNextViewOI;

	mov	ecx, DWORD PTR _lpSearchViewOI$10505[ebp]
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+2], eax
$L10507:

; 8852 : 
; 8853 :    fnFreeDataspace( lpViewOI );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 8854 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropViewOI ENDP
_TEXT	ENDS
EXTRN	_fnCreateEntityCsrHandle@12:NEAR
EXTRN	_UfStringToDateTime@8:NEAR
_TEXT	SEGMENT
_lpView$ = 12
_lControl$ = 16
_hInstanceOwningTask$ = -32
_lpInstanceOwningTask$ = -44
_lpViewOD$ = -36
_lpViewOI$ = -60
_lpViewCsr$ = -28
_lpViewEntity$ = -40
_lpViewEntityCsr$ = -64
_szDateTime$ = -24
_hViewOI$ = -52
_hViewCsr$ = -56
_uEntities$ = -4
_nHierNbr$ = -48
_lpParentViewEntityCsr$10557 = -68
_fnActivateEmptyObjectInstance PROC NEAR

; 8885 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 8886 :    LPTASK            hInstanceOwningTask;
; 8887 :    LPTASK            lpInstanceOwningTask;
; 8888 :    LPVIEWOD          lpViewOD;
; 8889 :    LPVIEWOI          lpViewOI;
; 8890 :    LPVIEWCSR         lpViewCsr;
; 8891 :    LPVIEWENTITY      lpViewEntity;
; 8892 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 8893 :    zCHAR             szDateTime[ 20 ];
; 8894 :    zPVOID            hViewOI;
; 8895 :    zPVOID            hViewCsr;
; 8896 :    zUSHORT           uEntities;
; 8897 :    zSHORT            nHierNbr;
; 8898 : 
; 8899 :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 8900 : 
; 8901 :    // Determine the task which owns the instance, NOTE, this task
; 8902 :    // should be returned by fnValidView in the future since fnValidView
; 8903 :    // has already done the same search! Gig...9/1/92
; 8904 :    if ( lpView->bApplicationView )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $L10533

; 8905 :       hInstanceOwningTask = AnchorBlock->hMainTask;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	mov	DWORD PTR _hInstanceOwningTask$[ebp], edx

; 8906 :    else

	jmp	SHORT $L10534
$L10533:

; 8907 :       hInstanceOwningTask = lpView->hTask;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hInstanceOwningTask$[ebp], ecx
$L10534:

; 8908 : 
; 8909 :    lpInstanceOwningTask = zGETPTR( hInstanceOwningTask );

	mov	edx, DWORD PTR _hInstanceOwningTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInstanceOwningTask$[ebp], eax

; 8910 : 
; 8911 :    // Create a ViewOI Record
; 8912 :    // NOTE: We create view oi records in the main dataspace so all
; 8913 :    // tasks can go through the ViewOI's on clean-up to determine if
; 8914 :    // an application is in use
; 8915 :    hViewOI = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,
; 8916 :                                sizeof( ViewOI_Record ), 1, 0, iViewOI );

	push	10018					; 00002722H
	push	0
	push	1
	push	65					; 00000041H
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewOI$[ebp], eax

; 8917 :    lpViewOI = zGETPTR( hViewOI );

	mov	edx, DWORD PTR _hViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8918 :    if ( lpViewOI == 0 )

	cmp	DWORD PTR _lpViewOI$[ebp], 0
	jne	SHORT $L10538

; 8920 :    // fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );
; 8921 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10519
$L10538:

; 8923 : 
; 8924 :    // Get the count of entities.
; 8925 :    uEntities = lpViewOD->uEntities;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	cx, WORD PTR [eax+234]
	mov	WORD PTR _uEntities$[ebp], cx

; 8926 : 
; 8927 :    // Allocate space for View
; 8928 :    // Create a ViewOI Record
; 8929 :    hViewCsr = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,
; 8930 :                                 sizeof( ViewCsrRecord ) + (zULONG)
; 8931 :                                   (uEntities * sizeof( ViewEntityCsrRecord )),
; 8932 :                                 1, 0, iViewCsr );

	push	10019					; 00002723H
	push	0
	push	1
	mov	edx, DWORD PTR _uEntities$[ebp]
	and	edx, 65535				; 0000ffffH
	imul	edx, 30					; 0000001eH
	add	edx, 46					; 0000002eH
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewCsr$[ebp], eax

; 8933 :    lpViewCsr = zGETPTR( hViewCsr );

	mov	edx, DWORD PTR _hViewCsr$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 8934 :    if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	jne	SHORT $L10543

; 8936 :       fnFreeDataspace( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 8937 :    // fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );
; 8938 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10519
$L10543:

; 8940 : 
; 8941 :    // Set up View OI record
; 8942 :    lpViewOI->hViewOD            = zGETHNDL( lpViewOD );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+6], eax

; 8943 :    lpViewOI->hFirstViewCsr      = hViewCsr;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR _hViewCsr$[ebp]
	mov	DWORD PTR [eax+10], ecx

; 8944 :    lpViewOI->hTask              = hInstanceOwningTask;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR _hInstanceOwningTask$[ebp]
	mov	DWORD PTR [edx+14], eax

; 8945 :    lpViewOI->hAllocTask         = hInstanceOwningTask;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR _hInstanceOwningTask$[ebp]
	mov	DWORD PTR [ecx+18], edx

; 8946 : 
; 8947 :    // Put date time stamp into View OI record.
; 8948 :    SysGetDateTime( szDateTime );

	lea	eax, DWORD PTR _szDateTime$[ebp]
	push	eax
	call	_SysGetDateTime@4

; 8949 :    UfStringToDateTime( szDateTime, (LPDATETIME) &(lpViewOI->DateTime) );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	add	ecx, 30					; 0000001eH
	push	ecx
	lea	edx, DWORD PTR _szDateTime$[ebp]
	push	edx
	call	_UfStringToDateTime@8

; 8950 :    zstrcpy( lpViewOI->szRelease, szlReleaseCompatible );  // initialize release for compatiblity

	mov	eax, DWORD PTR _szlReleaseCompatible
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	call	_strcpy
	add	esp, 8

; 8951 : 
; 8952 :    // Mark View OI as read only if requested, and the View also ...
; 8953 :    if ( lControl & zREADONLY )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2048				; 00000800H
	test	edx, edx
	je	SHORT $L10546

; 8955 :       lpViewOI->bReadOnly = TRUE;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 4
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx
$L10546:

; 8957 : 
; 8958 :    if ( lControl & zMULTIPLE )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $L10547

; 8959 :       lpViewOI->bMultipleRootLevels = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 1
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 8960 :    else

	jmp	SHORT $L10548
$L10547:

; 8961 :       lpViewOI->bMultipleRootLevels = FALSE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$L10548:

; 8962 : 
; 8963 :    // Set up View Cursor Record
; 8964 :    lpViewCsr->hView             = zGETHNDL( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [edx+6], eax

; 8965 :    lpViewCsr->hViewOI           = hViewOI;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR _hViewOI$[ebp]
	mov	DWORD PTR [eax+10], ecx

; 8966 :    lpViewCsr->uEntities         = uEntities;

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	ax, WORD PTR _uEntities$[ebp]
	mov	WORD PTR [edx+34], ax

; 8967 :    lpViewCsr->nCurrentSelectSet = 0x0001;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	WORD PTR [ecx+36], 1

; 8968 : 
; 8969 :    // Set the View Csr in the View
; 8970 :    lpView->hViewCsr             = hViewCsr;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR _hViewCsr$[ebp]
	mov	DWORD PTR [edx+10], eax

; 8971 : 
; 8972 :    // Initialize ViewEntityCsr records
; 8973 :    lpViewEntity    = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 8974 :    lpViewEntityCsr = (LPVIEWENTITYCSR) (lpViewCsr + 1);

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	add	eax, 46					; 0000002eH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 8975 : 
; 8976 :    // Double assignment ...
; 8977 :    lpViewCsr->hRootViewEntityCsr  =         // continued ...
; 8978 :    lpViewCsr->hFirstOD_EntityCsr =
; 8979 :                   fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, 0 );

	push	0
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [ecx+14], eax
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR [edx+18], ecx

; 8980 :    nHierNbr = 1;

	mov	WORD PTR _nHierNbr$[ebp], 1
$L10553:

; 8983 :       lpViewEntityCsr->nTableID    = iViewEntityCsr;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	WORD PTR [edx], 10023			; 00002727H

; 8984 :       lpViewEntityCsr->hViewCsr    = hViewCsr;

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR _hViewCsr$[ebp]
	mov	DWORD PTR [eax+18], ecx

; 8985 :       lpViewEntityCsr->hNextHier   =
; 8986 :                   fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, 1 );

	push	1
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+2], eax

; 8987 :       lpViewEntityCsr->hViewEntity = zGETHNDL( lpViewEntity );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+14], eax

; 8988 :       lpViewEntityCsr->nLevel      = lpViewEntity->nLevel;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	cx, WORD PTR [eax+215]
	mov	WORD PTR [edx+22], cx

; 8989 :       lpViewEntityCsr->nHierNbr    = nHierNbr;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ax, WORD PTR _nHierNbr$[ebp]
	mov	WORD PTR [edx+24], ax

; 8990 :       nHierNbr++;

	mov	cx, WORD PTR _nHierNbr$[ebp]
	add	cx, 1
	mov	WORD PTR _nHierNbr$[ebp], cx

; 8991 : 
; 8992 :       if ( lpViewEntity->hPrevHier )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+6], 0
	je	SHORT $L10556

; 8994 :          LPVIEWENTITYCSR lpParentViewEntityCsr;
; 8995 : 
; 8996 :          lpViewEntityCsr->hPrevHier =
; 8997 :                   fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, -1 );

	push	-1
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnCreateEntityCsrHandle@12
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+6], eax

; 8998 :          lpParentViewEntityCsr = zGETPTR( lpViewEntityCsr->hPrevHier );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntityCsr$10557[ebp], eax
$L10560:

; 8999 :          while ( lpParentViewEntityCsr->nLevel >= lpViewEntityCsr->nLevel )

	mov	edx, DWORD PTR _lpParentViewEntityCsr$10557[ebp]
	movsx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	cmp	eax, edx
	jl	SHORT $L10561

; 9001 :             lpParentViewEntityCsr = zGETPTR( lpParentViewEntityCsr->hPrevHier );

	mov	eax, DWORD PTR _lpParentViewEntityCsr$10557[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntityCsr$10557[ebp], eax

; 9002 :          }

	jmp	SHORT $L10560
$L10561:

; 9003 : 
; 9004 :          lpViewEntityCsr->hParent =
; 9005 :                fnCreateEntityCsrHandle( lpParentViewEntityCsr, lpViewCsr, 0 );

	push	0
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParentViewEntityCsr$10557[ebp]
	push	eax
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+10], eax
$L10556:

; 9009 : 
; 9010 :       lpViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9011 : 
; 9012 :       if ( lpViewEntity )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $L10564

; 9013 :          lpViewEntityCsr++;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], ecx

; 9014 :       else

	jmp	SHORT $L10565
$L10564:

; 9016 :          lpViewEntityCsr->hNextHier = 0;  // end ViewEntityCsr chain

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+2], 0

; 9017 :          break;

	jmp	SHORT $L10554
$L10565:

; 9019 :    }

	jmp	$L10553
$L10554:

; 9020 : 
; 9021 :    // Chain ViewOI to the application task
; 9022 :    lpViewOI->hNextViewOI = lpInstanceOwningTask->hFirstViewOI;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR _lpInstanceOwningTask$[ebp]
	mov	edx, DWORD PTR [ecx+98]
	mov	DWORD PTR [eax+2], edx

; 9023 :    lpInstanceOwningTask->hFirstViewOI = hViewOI;

	mov	eax, DWORD PTR _lpInstanceOwningTask$[ebp]
	mov	ecx, DWORD PTR _hViewOI$[ebp]
	mov	DWORD PTR [eax+98], ecx

; 9024 : 
; 9025 :    return( 0 );

	xor	ax, ax
$L10519:

; 9026 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnActivateEmptyObjectInstance ENDP
_TEXT	ENDS
PUBLIC	_fnAddHangingEntity@8
PUBLIC	??_C@_0BO@NIPI@?9?5ParentEntity?5?$DN?$DN?5ChildEntity?$AA@ ; `string'
PUBLIC	??_C@_0BI@NMHK@?$CIoi?$CJ?5Hangin?5key?5error?$CB?5?$AA@ ; `string'
EXTRN	_fnAttributeValueNull:NEAR
EXTRN	_StoreValueInRecord@20:NEAR
EXTRN	_GetValueFromRecord@24:NEAR
;	COMDAT ??_C@_0BO@NIPI@?9?5ParentEntity?5?$DN?$DN?5ChildEntity?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BO@NIPI@?9?5ParentEntity?5?$DN?$DN?5ChildEntity?$AA@ DB '- ParentE'
	DB	'ntity == ChildEntity', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@NMHK@?$CIoi?$CJ?5Hangin?5key?5error?$CB?5?$AA@
_DATA	SEGMENT
??_C@_0BI@NMHK@?$CIoi?$CJ?5Hangin?5key?5error?$CB?5?$AA@ DB '(oi) Hangin '
	DB	'key error! ', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_lpChildEntity$ = 12
_lpChildDataRecord$ = -12
_lpChildRelRecord$ = -4
_lpRelField$ = -16
_bEntityCreated$ = -8
_lpParentEntity$10583 = -36
_lpTargetAttrib$10584 = -44
_lpSrcAttrib$10585 = -40
_lpTargetDataField$10586 = -52
_lpSrcDataField$10587 = -32
_lpViewEntityCsr$10588 = -56
_lpEntityInstance$10589 = -28
_pchPtr$10590 = -24
_chType$10591 = -20
_ulLth$10592 = -48
_fnAddHangingEntity@8 PROC NEAR

; 9044 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 9045 :    LPDATARECORD lpChildDataRecord = zGETPTR( lpChildEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpChildEntity$[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildDataRecord$[ebp], eax

; 9046 :    LPRELRECORD  lpChildRelRecord  = zGETPTR( lpChildDataRecord->hFirstRelRecord );

	mov	edx, DWORD PTR _lpChildDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildRelRecord$[ebp], eax

; 9047 :    LPRELFIELD   lpRelField;
; 9048 :    zBOOL        bEntityCreated = FALSE;

	mov	BYTE PTR _bEntityCreated$[ebp], 0

; 9049 : 
; 9050 :    for ( lpRelField = zGETPTR( lpChildRelRecord->hFirstRelField );
; 9051 :          lpRelField;
; 9052 :          lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	mov	ecx, DWORD PTR _lpChildRelRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax
	jmp	SHORT $L10580
$L10581:
	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax
$L10580:
	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	$L10582

; 9054 :       LPVIEWENTITY     lpParentEntity;
; 9055 :       LPVIEWATTRIB     lpTargetAttrib;
; 9056 :       LPVIEWATTRIB     lpSrcAttrib;
; 9057 :       LPDATAFIELD      lpTargetDataField;
; 9058 :       LPDATAFIELD      lpSrcDataField;
; 9059 :       LPVIEWENTITYCSR  lpViewEntityCsr;
; 9060 :       LPENTITYINSTANCE lpEntityInstance;
; 9061 :       zPCHAR           pchPtr;
; 9062 :       zCHAR            chType;
; 9063 :       zULONG           ulLth;
; 9064 : 
; 9065 :       // Check to see if the Rel field (the target field) is not-null.  Note
; 9066 :       // the the rel field had better be in a parent entity!
; 9067 :       lpTargetDataField = zGETPTR( lpRelField->hRelDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTargetDataField$10586[ebp], eax

; 9068 :       lpTargetAttrib    = zGETPTR( lpTargetDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpTargetDataField$10586[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTargetAttrib$10584[ebp], eax

; 9069 :       lpParentEntity    = zGETPTR( lpTargetAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpTargetAttrib$10584[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentEntity$10583[ebp], eax

; 9070 : 
; 9071 :       if ( lpParentEntity == lpChildEntity )

	mov	edx, DWORD PTR _lpParentEntity$10583[ebp]
	cmp	edx, DWORD PTR _lpChildEntity$[ebp]
	jne	SHORT $L10596

; 9073 :          TraceLineS( "(oi) Hangin key error! ", "- ParentEntity == ChildEntity" );

	push	OFFSET FLAT:??_C@_0BO@NIPI@?9?5ParentEntity?5?$DN?$DN?5ChildEntity?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@NMHK@?$CIoi?$CJ?5Hangin?5key?5error?$CB?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9074 :          continue;

	jmp	SHORT $L10581
$L10596:

; 9076 : 
; 9077 :       // Get the entity csr.
; 9078 :       fnValidViewEntity( &lpViewEntityCsr, lpView, lpParentEntity->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpParentEntity$10583[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$10588[ebp]
	push	edx
	call	_fnValidViewEntity@16

; 9079 : 
; 9080 :       if ( fnAttributeValueNull( lpView,
; 9081 :                                  zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 9082 :                                  lpTargetAttrib ) )

	mov	eax, DWORD PTR _lpTargetAttrib$10584[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$10588[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnAttributeValueNull
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10600

; 9084 :          continue;

	jmp	$L10581
$L10600:

; 9086 : 
; 9087 :       // If we get here then the target attrib is not null.  This means we
; 9088 :       // need to create an entity instance (if not already created) and
; 9089 :       // copy the attribute value.
; 9090 : 
; 9091 :       if ( bEntityCreated == FALSE )

	mov	edx, DWORD PTR _bEntityCreated$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L10601

; 9093 :          // Get the entity csr.
; 9094 :          fnValidViewEntity( &lpViewEntityCsr, lpView, lpChildEntity->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpChildEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$10588[ebp]
	push	edx
	call	_fnValidViewEntity@16

; 9095 : 
; 9096 :          fnCreateEntity( lpView, lpChildEntity, lpViewEntityCsr, zPOS_NEXT, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _lpViewEntityCsr$10588[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpChildEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnCreateEntity@20

; 9097 :          lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$10588[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$10589[ebp], eax

; 9098 :          lpEntityInstance->u.nInd.bHangingEntity = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$10589[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	al, 1
	mov	ecx, DWORD PTR _lpEntityInstance$10589[ebp]
	mov	DWORD PTR [ecx+6], eax

; 9099 : 
; 9100 :          bEntityCreated = TRUE;

	mov	BYTE PTR _bEntityCreated$[ebp], 1
$L10601:

; 9102 : 
; 9103 :       GetValueFromRecord( lpView, lpParentEntity, lpTargetAttrib, &pchPtr,
; 9104 :                           &chType, &ulLth );

	lea	edx, DWORD PTR _ulLth$10592[ebp]
	push	edx
	lea	eax, DWORD PTR _chType$10591[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchPtr$10590[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTargetAttrib$10584[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParentEntity$10583[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_GetValueFromRecord@24

; 9105 : 
; 9106 :       lpSrcDataField = zGETPTR( lpRelField->hSrcDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcDataField$10587[ebp], eax

; 9107 :       lpSrcAttrib    = zGETPTR( lpSrcDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpSrcDataField$10587[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcAttrib$10585[ebp], eax

; 9108 : 
; 9109 :       StoreValueInRecord( lpView, lpChildEntity, lpSrcAttrib, pchPtr, ulLth );

	mov	eax, DWORD PTR _ulLth$10592[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchPtr$10590[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcAttrib$10585[ebp]
	push	edx
	mov	eax, DWORD PTR _lpChildEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_StoreValueInRecord@20

; 9110 :    }

	jmp	$L10581
$L10582:

; 9111 : 
; 9112 :    return( 0 );

	xor	ax, ax

; 9113 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnAddHangingEntity@8 ENDP
_TEXT	ENDS
PUBLIC	_fnCreateQualification@36
EXTRN	_fnValidViewAttrib:NEAR
EXTRN	_fnSetEntityCursor:NEAR
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_lpView$ = 12
_pvQual$ = 16
_plpViewEntityCsr$ = 20
_pchEntitySpec$ = 24
_pchEntityName$ = 28
_pchAttributeName$ = 32
_pchOper$ = 36
_pchValue$ = 40
_lpViewEntity$ = -4
_lpViewAttrib$ = -12
_lpViewEntityCsr$ = -20
_vQual$ = -8
_lCnt$ = -16
_pchAttribName$10655 = -24
_fnCreateQualification@36 PROC NEAR

; 9126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 9127 :    LPVIEWENTITY      lpViewEntity;
; 9128 :    LPVIEWATTRIB      lpViewAttrib;
; 9129 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 9130 :    zVIEW             vQual;
; 9131 :    zLONG             lCnt;
; 9132 : 
; 9133 :    if ( *pvQual == 0 )

	mov	eax, DWORD PTR _pvQual$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L10633

; 9135 :       if ( fnDeclareView( pvQual, lpCurrentTask, lpView,
; 9136 :                           "KZDBHQUA", TRUE ) != 0 )

	push	1
	push	OFFSET FLAT:??_C@_08ILBJ@KZDBHQUA?$AA@	; `string'
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvQual$[ebp]
	push	eax
	call	_fnDeclareView@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10632

; 9138 :          *pvQual = 0;

	mov	edx, DWORD PTR _pvQual$[ebp]
	mov	DWORD PTR [edx], 0

; 9139 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10625
$L10632:

; 9141 : 
; 9142 :       if ( fnActivateEmptyObjectInstance( lpCurrentTask, *pvQual,
; 9143 :                                           zSINGLE ) != 0 )

	push	0
	mov	eax, DWORD PTR _pvQual$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L10633

; 9145 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10625
$L10633:

; 9148 : 
; 9149 :    vQual = *pvQual;

	mov	ecx, DWORD PTR _pvQual$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _vQual$[ebp], edx

; 9150 : 
; 9151 :    // If pchEntitySpec was supplied, then create an entity spec.
; 9152 :    if ( pchEntitySpec )

	cmp	DWORD PTR _pchEntitySpec$[ebp], 0
	je	$L10641

; 9154 :       // Get lpViewEntity, lpViewEntityCsr, and lpViewAttrib.
; 9155 :       lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, vQual, "EntitySpec", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9156 :       lpViewAttrib = fnValidViewAttrib( vQual, lpViewEntity, "EntityName", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 9157 : 
; 9158 :       // Make sure entity spec doesn't already exist.
; 9159 :       if ( fnSetEntityCursor( vQual, lpViewEntity, lpViewEntityCsr,
; 9160 :                               lpViewAttrib, zPOS_FIRST | zQUAL_STRING,
; 9161 :                               (zPVOID) pchEntitySpec,
; 9162 :                               0, 0, 0, 0, 0, lpCurrentTask ) != zCURSOR_SET )

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _pchEntitySpec$[ebp]
	push	edx
	push	1025					; 00000401H
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10641

; 9164 :          if ( fnCreateEntity( vQual, lpViewEntity, lpViewEntityCsr,
; 9165 :                               zPOS_NEXT, FALSE ) != 0 )

	push	0
	push	3
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_fnCreateEntity@20
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10639

; 9167 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10625
$L10639:

; 9169 : 
; 9170 :          if ( fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9171 :                                           (zPVOID) pchEntitySpec, 'S', 0, 0,
; 9172 :                                           lpCurrentTask, 0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	0
	push	83					; 00000053H
	mov	ecx, DWORD PTR _pchEntitySpec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L10641

; 9174 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10625
$L10641:

; 9178 : 
; 9179 :    // If no oper was supplied we're done.
; 9180 :    if ( pchOper == 0 )

	cmp	DWORD PTR _pchOper$[ebp], 0
	jne	SHORT $L10642

; 9181 :       return( 0 );

	xor	ax, ax
	jmp	$L10625
$L10642:

; 9182 : 
; 9183 :    if ( plpViewEntityCsr )

	cmp	DWORD PTR _plpViewEntityCsr$[ebp], 0
	je	SHORT $L10643

; 9185 :       if ( *plpViewEntityCsr )

	mov	eax, DWORD PTR _plpViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L10644

; 9187 :          // User supplied valid cursor so use it.
; 9188 :          lpViewEntityCsr = *plpViewEntityCsr;

	mov	ecx, DWORD PTR _plpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], edx

; 9189 :          lpViewEntity    = zGETPTR( (*plpViewEntityCsr)->hViewEntity );

	mov	eax, DWORD PTR _plpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9191 :       else

	jmp	SHORT $L10646
$L10644:

; 9193 :          // Get lpViewEntity and plpViewEntityCsr.
; 9194 :          lpViewEntity    = fnValidViewEntity( plpViewEntityCsr, vQual, "QualAttrib", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	mov	ecx, DWORD PTR _plpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9195 :          lpViewEntityCsr = *plpViewEntityCsr;

	mov	edx, DWORD PTR _plpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
$L10646:

; 9198 :    else

	jmp	SHORT $L10647
$L10643:

; 9200 :       lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, vQual, "QualAttrib", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$L10647:

; 9202 : 
; 9203 :    // Create the new qual attrib.
; 9204 :    if ( fnCreateEntity( vQual, lpViewEntity, lpViewEntityCsr,
; 9205 :                         zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_fnCreateEntity@20
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L10649

; 9207 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10625
$L10649:

; 9209 : 
; 9210 :    // Loop through each of the view attribs.  When we find one we want, set
; 9211 :    // the value.  We keep track of the # of attributes we set so we don't
; 9212 :    // have to keep searching even when we've set all the values.
; 9213 :    lCnt = 0;

	mov	DWORD PTR _lCnt$[ebp], 0

; 9214 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 9215 :          lpViewAttrib;
; 9216 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L10652
$L10653:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L10652:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$L10654

; 9218 :       zPCHAR pchAttribName = lpViewAttrib->szName;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	mov	DWORD PTR _pchAttribName$10655[ebp], edx

; 9219 : 
; 9220 :       if ( zstrcmp( pchAttribName, "EntityName" ) == 0 )

	mov	eax, DWORD PTR _pchAttribName$10655[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR ??_C@_0L@LOJF@EntityName?$AA@
	cmp	ecx, edx
	jne	SHORT $L12826
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	mov	eax, DWORD PTR _pchAttribName$10655[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L12827
$L12826:
	mov	ecx, DWORD PTR _pchAttribName$10655[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR ??_C@_0L@LOJF@EntityName?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -28+[ebp], ecx
$L12827:
	cmp	DWORD PTR -28+[ebp], 0
	jne	SHORT $L10662

; 9222 :          if ( pchEntityName &&
; 9223 :               fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9224 :                                           (zPVOID) pchEntityName, 'S', 0, 0,
; 9225 :                                           lpCurrentTask, 0 ) != 0 )

	cmp	DWORD PTR _pchEntityName$[ebp], 0
	je	SHORT $L10664
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10664

; 9227 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10625
$L10664:

; 9229 : 
; 9230 :          if ( ++lCnt == 4 )

	mov	edx, DWORD PTR _lCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCnt$[ebp], edx
	cmp	DWORD PTR _lCnt$[ebp], 4
	jne	SHORT $L10665

; 9231 :             break;               // We've set all values so break.

	jmp	$L10654
$L10665:

; 9233 :       else

	jmp	$L10698
$L10662:

; 9234 :       if ( zstrcmp( pchAttribName, "AttributeName" ) == 0 )

	mov	eax, DWORD PTR _pchAttribName$10655[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR ??_C@_0O@JICG@AttributeName?$AA@
	cmp	ecx, edx
	jne	SHORT $L12828
	push	OFFSET FLAT:??_C@_0O@JICG@AttributeName?$AA@ ; `string'
	mov	eax, DWORD PTR _pchAttribName$10655[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -32+[ebp], eax
	jmp	SHORT $L12829
$L12828:
	mov	ecx, DWORD PTR _pchAttribName$10655[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR ??_C@_0O@JICG@AttributeName?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -32+[ebp], ecx
$L12829:
	cmp	DWORD PTR -32+[ebp], 0
	jne	SHORT $L10673

; 9236 :          if ( pchAttributeName &&
; 9237 :               fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9238 :                                           (zPVOID) pchAttributeName, 'S', 0, 0,
; 9239 :                                           lpCurrentTask, 0 ) != 0 )

	cmp	DWORD PTR _pchAttributeName$[ebp], 0
	je	SHORT $L10675
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10675

; 9241 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10625
$L10675:

; 9243 : 
; 9244 :          if ( ++lCnt == 4 )

	mov	edx, DWORD PTR _lCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCnt$[ebp], edx
	cmp	DWORD PTR _lCnt$[ebp], 4
	jne	SHORT $L10676

; 9245 :             break;               // We've set all values so break.

	jmp	$L10654
$L10676:

; 9247 :       else

	jmp	$L10698
$L10673:

; 9248 :       if ( zstrcmp( pchAttribName, "Oper" ) == 0 )

	mov	eax, DWORD PTR _pchAttribName$10655[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR ??_C@_04FKDH@Oper?$AA@
	cmp	ecx, edx
	jne	SHORT $L12830
	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	mov	eax, DWORD PTR _pchAttribName$10655[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -36+[ebp], eax
	jmp	SHORT $L12831
$L12830:
	mov	ecx, DWORD PTR _pchAttribName$10655[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR ??_C@_04FKDH@Oper?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -36+[ebp], ecx
$L12831:
	cmp	DWORD PTR -36+[ebp], 0
	jne	SHORT $L10684

; 9250 :          if ( fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9251 :                                           (zPVOID) pchOper, 'S', 0, 0,
; 9252 :                                           lpCurrentTask, 0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10686

; 9254 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10625
$L10686:

; 9256 : 
; 9257 :          if ( ++lCnt == 4 )

	mov	edx, DWORD PTR _lCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCnt$[ebp], edx
	cmp	DWORD PTR _lCnt$[ebp], 4
	jne	SHORT $L10687

; 9258 :             break;               // We've set all values so break.

	jmp	$L10654
$L10687:

; 9260 :       else

	jmp	$L10698
$L10684:

; 9261 :       if ( zstrcmp( pchAttribName, "Value" ) == 0 )

	mov	eax, DWORD PTR _pchAttribName$10655[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR ??_C@_05KBGO@Value?$AA@
	cmp	ecx, edx
	jne	SHORT $L12832
	push	OFFSET FLAT:??_C@_05KBGO@Value?$AA@	; `string'
	mov	eax, DWORD PTR _pchAttribName$10655[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -40+[ebp], eax
	jmp	SHORT $L12833
$L12832:
	mov	ecx, DWORD PTR _pchAttribName$10655[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR ??_C@_05KBGO@Value?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -40+[ebp], ecx
$L12833:
	cmp	DWORD PTR -40+[ebp], 0
	jne	SHORT $L10698

; 9263 :          if ( pchValue &&
; 9264 :               fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9265 :                                           (zPVOID) pchValue, 'S', 0, 0,
; 9266 :                                           lpCurrentTask, 0 ) != 0 )

	cmp	DWORD PTR _pchValue$[ebp], 0
	je	SHORT $L10697
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L10697

; 9268 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L10625
$L10697:

; 9270 : 
; 9271 :          if ( ++lCnt == 4 )

	mov	edx, DWORD PTR _lCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCnt$[ebp], edx
	cmp	DWORD PTR _lCnt$[ebp], 4
	jne	SHORT $L10698

; 9272 :             break;               // We've set all values so break.

	jmp	SHORT $L10654
$L10698:

; 9274 : 
; 9275 :    } // for...

	jmp	$L10653
$L10654:

; 9276 : 
; 9277 :    return( 0 );

	xor	ax, ax
$L10625:

; 9278 : 
; 9279 : } // fnCreateQualification

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_fnCreateQualification@36 ENDP
_TEXT	ENDS
PUBLIC	_fnFindKeyDelim@16
_TEXT	SEGMENT
_chCurrentDelim$ = 8
_pchStart$ = 12
_pchEnd$ = 16
_pchNewString$ = 20
_pchOldDelim$ = -12
_pchNewDelim$ = -8
_pch$ = -4
_fnFindKeyDelim@16 PROC NEAR

; 9295 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 9296 :    zPCHAR pchOldDelim;
; 9297 :    zPCHAR pchNewDelim;
; 9298 :    zPCHAR pch;
; 9299 : 
; 9300 :    if ( chCurrentDelim == 0 )

	movsx	eax, BYTE PTR _chCurrentDelim$[ebp]
	test	eax, eax
	jne	SHORT $L10713

; 9301 :       return( gszKeyDelimStr[ 0 ] );

	mov	al, BYTE PTR _gszKeyDelimStr
	jmp	$L10709
$L10713:

; 9302 : 
; 9303 :    // Look for current delim in string.
; 9304 :    pchOldDelim = zstrchr( gszKeyDelimStr, chCurrentDelim );

	movsx	ecx, BYTE PTR _chCurrentDelim$[ebp]
	push	ecx
	push	OFFSET FLAT:_gszKeyDelimStr
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchOldDelim$[ebp], eax

; 9305 : 
; 9306 :    // Point to next delim in string.
; 9307 :    pchNewDelim = pchOldDelim + 1;

	mov	edx, DWORD PTR _pchOldDelim$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchNewDelim$[ebp], edx
$L10717:

; 9308 : 
; 9309 :    // Look for next delim in gszKeyDelimStr not in buffer or new string.
; 9310 :    while ( zstrchr( pchNewString, *pchNewDelim ) )

	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pchNewString$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $L10718

; 9311 :       pchNewDelim++;

	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchNewDelim$[ebp], eax
	jmp	SHORT $L10717
$L10718:

; 9312 : 
; 9313 :    for ( pch = pchStart; pch < pchEnd; pch++ )

	mov	ecx, DWORD PTR _pchStart$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx
	jmp	SHORT $L10719
$L10720:
	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
$L10719:
	mov	eax, DWORD PTR _pch$[ebp]
	cmp	eax, DWORD PTR _pchEnd$[ebp]
	jae	SHORT $L10721

; 9315 :       if ( *pch == *pchNewDelim )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $L10722

; 9317 :          pchNewDelim++;

	mov	edx, DWORD PTR _pchNewDelim$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchNewDelim$[ebp], edx
$L10725:

; 9318 : 
; 9319 :          // Make sure new delim isn't in new string.
; 9320 :          while ( zstrchr( pchNewString, *pchNewDelim ) )

	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pchNewString$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $L10726

; 9321 :             pchNewDelim++;

	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchNewDelim$[ebp], eax
	jmp	SHORT $L10725
$L10726:

; 9322 : 
; 9323 :          // Reset pch to start looking at the beginning of the string again.
; 9324 :          pch = pchStart;

	mov	ecx, DWORD PTR _pchStart$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx

; 9325 : 
; 9326 :          continue;

	jmp	SHORT $L10720
$L10722:

; 9328 :    }

	jmp	SHORT $L10720
$L10721:

; 9329 : 
; 9330 :    // Convert all pchOldDelims to pchNewDelim.
; 9331 :    for ( pch = pchStart; pch < pchEnd; pch++ )

	mov	edx, DWORD PTR _pchStart$[ebp]
	mov	DWORD PTR _pch$[ebp], edx
	jmp	SHORT $L10727
$L10728:
	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$[ebp], eax
$L10727:
	mov	ecx, DWORD PTR _pch$[ebp]
	cmp	ecx, DWORD PTR _pchEnd$[ebp]
	jae	SHORT $L10729

; 9333 :       if ( *pch == *pchOldDelim )

	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchOldDelim$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $L10730

; 9334 :          *pch = *pchNewDelim;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	ecx, DWORD PTR _pchNewDelim$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
$L10730:

; 9335 :    }

	jmp	SHORT $L10728
$L10729:

; 9336 : 
; 9337 :    return( *pchNewDelim );

	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	mov	al, BYTE PTR [eax]
$L10709:

; 9338 : 
; 9339 : } // fnFindKeyDelim

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnFindKeyDelim@16 ENDP
_TEXT	ENDS
EXTRN	_ConvertDecimalToString@52:NEAR
EXTRN	_UfDateTimeToString@12:NEAR
_TEXT	SEGMENT
_pchKeyString$ = 8
_lpEntityInstance$ = 12
_lpKeyViewAttrib$ = 16
_nKeyCnt$ = 20
_lpViewOI$ = -20
_lpAllocTask$ = -4
_pch$ = -8
_chDelim$ = -12
_k$ = -16
_lpPtr$10750 = -24
_ulLth$10751 = -28
_fnCreateConcatKey@16 PROC NEAR

; 9351 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	push	edi

; 9352 :    LPVIEWOI lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 9353 :    LPTASK   lpAllocTask = zGETPTR( lpViewOI->hAllocTask );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAllocTask$[ebp], eax

; 9354 :    zPCHAR   pch;
; 9355 :    zCHAR    chDelim;
; 9356 :    zSHORT   k;
; 9357 : 
; 9358 :    // Get the default key delimiter.
; 9359 :    chDelim = fnFindKeyDelim( 0, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	0
	call	_fnFindKeyDelim@16
	mov	BYTE PTR _chDelim$[ebp], al

; 9360 : 
; 9361 :    // Because the delimiter can change, the first char will be the delimiter
; 9362 :    // for the string.
; 9363 :    pch = pchKeyString;

	mov	ecx, DWORD PTR _pchKeyString$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx

; 9364 : 
; 9365 :    // Go through each of the keys are retrieve the values.
; 9366 :    for ( k = 0; k < nKeyCnt; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L10747
$L10748:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L10747:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	cmp	eax, ecx
	jge	$L10749

; 9368 :       zPVOID  lpPtr;
; 9369 :       zULONG  ulLth;
; 9370 : 
; 9371 :       *pch++ = chDelim;

	mov	edx, DWORD PTR _pch$[ebp]
	mov	al, BYTE PTR _chDelim$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx

; 9372 : 
; 9373 :       // Get pointer to key value.
; 9374 :       if ( fnGetAttrAddrFromEntityInstance( (zCOREMEM) &lpPtr,
; 9375 :                                             &ulLth, lpEntityInstance,
; 9376 :                                             lpKeyViewAttrib[ k ] ) == -1 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpKeyViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	lea	eax, DWORD PTR _ulLth$10751[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpPtr$10750[ebp]
	push	ecx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $L10753

; 9378 :          // Key is null so just continue.
; 9379 :          continue;

	jmp	SHORT $L10748
$L10753:

; 9381 : 
; 9382 :       // Convert internal key value to string.
; 9383 :       switch ( lpKeyViewAttrib[ k ]->cType )
; 9384 :       {

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpKeyViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	movsx	eax, BYTE PTR [edx+202]
	mov	DWORD PTR -32+[ebp], eax
	mov	ecx, DWORD PTR -32+[ebp]
	sub	ecx, 76					; 0000004cH
	mov	DWORD PTR -32+[ebp], ecx
	cmp	DWORD PTR -32+[ebp], 8
	ja	SHORT $L10755
	mov	edx, DWORD PTR -32+[ebp]
	jmp	DWORD PTR $L12836[edx*4]
$L10758:

; 9385 :          case zTYPE_STRING:
; 9386 :             // Don't need to convert it--just copy it.
; 9387 :             zstrcpy( pch, (zPCHAR) lpPtr );

	mov	eax, DWORD PTR _lpPtr$10750[ebp]
	push	eax
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 9388 :             break;

	jmp	SHORT $L10755
$L10760:

; 9389 : 
; 9390 :          case zTYPE_INTEGER:
; 9391 :             zltoa( *((zPLONG) lpPtr), pch );

	push	10					; 0000000aH
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpPtr$10750[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 9392 :             break;

	jmp	SHORT $L10755
$L10762:

; 9393 : 
; 9394 :          case zTYPE_DECIMAL:
; 9395 :             ConvertDecimalToString( pch, lpKeyViewAttrib[ k ],
; 9396 :                                     *((zPDECIMAL) lpPtr), 0 );

	push	0
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	esi, DWORD PTR _lpPtr$10750[ebp]
	mov	edi, esp
	rep movsd
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpKeyViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_ConvertDecimalToString@52

; 9397 :             break;

	jmp	SHORT $L10755
$L10765:

; 9398 : 
; 9399 :          case zTYPE_BLOB:
; 9400 :             // No blobs should ever be keys.
; 9401 :             break;
; 9402 : 
; 9403 :          case zTYPE_DATETIME:
; 9404 :              UfDateTimeToString( (LPDATETIME) lpPtr, pch, 18 );

	push	18					; 00000012H
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpPtr$10750[ebp]
	push	ecx
	call	_UfDateTimeToString@12
$L10755:

; 9408 : 
; 9409 :       // Make sure that the delimiter is not in the new value.
; 9410 :       if ( zstrchr( pch, chDelim ) != 0 )

	movsx	edx, BYTE PTR _chDelim$[ebp]
	push	edx
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $L10768

; 9412 :          // The current delimiter exists in the key value so we must get a
; 9413 :          // new one.  fnFindKeyDelim will change all the old delims to match
; 9414 :          // the new delim.
; 9415 :          chDelim = fnFindKeyDelim( chDelim, pchKeyString, pch, pch );

	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchKeyString$[ebp]
	push	eax
	mov	cl, BYTE PTR _chDelim$[ebp]
	push	ecx
	call	_fnFindKeyDelim@16
	mov	BYTE PTR _chDelim$[ebp], al
$L10768:

; 9417 : 
; 9418 :       // Set pch to point to the end of the string.
; 9419 :       pch = zstrchr( pch, 0 );

	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pch$[ebp], eax

; 9420 : 
; 9421 :    } // for ( k... )

	jmp	$L10748
$L10749:

; 9422 : 
; 9423 :    return( 0 );

	xor	ax, ax

; 9424 : 
; 9425 : } // fnCreateConcatKey

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L12836:
	DD	$L10760
	DD	$L10762
	DD	$L10755
	DD	$L10755
	DD	$L10755
	DD	$L10755
	DD	$L10755
	DD	$L10758
	DD	$L10765
_fnCreateConcatKey@16 ENDP
_TEXT	ENDS
PUBLIC	_fnCheckLocksOnTwins@24
PUBLIC	??_C@_0BD@BKHK@LOD?5?8?$CFs?8?5is?5locked?$AA@	; `string'
PUBLIC	??_C@_0BG@JJPK@Entity?5?8?$CFs?8?5is?5locked?$AA@ ; `string'
PUBLIC	??_C@_0BC@NLCC@YYYY?9M?9D?5HH?3MI?3SS?$AA@	; `string'
PUBLIC	??_C@_0BH@NCBI@?$CIoi?$CJ?5Object?5locked?5by?5?$AA@ ; `string'
PUBLIC	??_C@_0BH@FDBN@?$CIoi?$CJ?5Object?5locked?5on?5?$AA@ ; `string'
PUBLIC	??_C@_0BJ@POBP@?$CIoi?$CJ?5Concatenated?5key?5?$DN?5?$AA@ ; `string'
EXTRN	_UfFormatDateTime@12:NEAR
EXTRN	_GetStringFromAttribute@16:NEAR
;	COMDAT ??_C@_0BD@BKHK@LOD?5?8?$CFs?8?5is?5locked?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BD@BKHK@LOD?5?8?$CFs?8?5is?5locked?$AA@ DB 'LOD ''%s'' is locked', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@JJPK@Entity?5?8?$CFs?8?5is?5locked?$AA@
_DATA	SEGMENT
??_C@_0BG@JJPK@Entity?5?8?$CFs?8?5is?5locked?$AA@ DB 'Entity ''%s'' is lo'
	DB	'cked', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@NLCC@YYYY?9M?9D?5HH?3MI?3SS?$AA@
_DATA	SEGMENT
??_C@_0BC@NLCC@YYYY?9M?9D?5HH?3MI?3SS?$AA@ DB 'YYYY-M-D HH:MI:SS', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NCBI@?$CIoi?$CJ?5Object?5locked?5by?5?$AA@
_DATA	SEGMENT
??_C@_0BH@NCBI@?$CIoi?$CJ?5Object?5locked?5by?5?$AA@ DB '(oi) Object lock'
	DB	'ed by ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@FDBN@?$CIoi?$CJ?5Object?5locked?5on?5?$AA@
_DATA	SEGMENT
??_C@_0BH@FDBN@?$CIoi?$CJ?5Object?5locked?5on?5?$AA@ DB '(oi) Object lock'
	DB	'ed on ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@POBP@?$CIoi?$CJ?5Concatenated?5key?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BJ@POBP@?$CIoi?$CJ?5Concatenated?5key?5?$DN?5?$AA@ DB '(oi) Concat'
	DB	'enated key = ', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_bLOD_Lock$ = 12
_bAllowReadOnly$ = 16
_lpView$ = 20
_lpFirstEntityInstance$ = 24
_lpViewOD$ = 28
_lpViewEntity$ = -60
_lpViewAttrib$ = -72
_lpKeyViewAttrib$ = -232
_lpEntityInstance$ = -56
_lpQualAttribEntityCsr$ = -4
_lpValueViewAttrib$ = -12
_vQual$ = -68
_vLock$ = -8
_szKeyString$ = -436
_szLockName$ = -52
_nKeyCnt$ = -64
_nRC$ = -16
_k$10810 = -440
_pch$10815 = -444
_szWhat$10818 = -544
_szMsg$10819 = -796
_szDate$10820 = -596
_fnCheckLocksOnTwins@24 PROC NEAR

; 9443 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 796				; 0000031cH

; 9444 :    LPVIEWENTITY      lpViewEntity;
; 9445 :    LPVIEWATTRIB      lpViewAttrib;
; 9446 :    LPVIEWATTRIB      lpKeyViewAttrib[ zMAX_KEYS_FOR_LOCK ];
; 9447 :    LPENTITYINSTANCE  lpEntityInstance;
; 9448 :    LPVIEWENTITYCSR   lpQualAttribEntityCsr = 0;

	mov	DWORD PTR _lpQualAttribEntityCsr$[ebp], 0

; 9449 :    LPVIEWATTRIB      lpValueViewAttrib;
; 9450 :    zVIEW             vQual = 0;

	mov	DWORD PTR _vQual$[ebp], 0

; 9451 :    zVIEW             vLock = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 9452 :    zCHAR             szKeyString[ zMAX_KEYLTH_FOR_LOCK + 1 ];
; 9453 :    zCHAR             szLockName[ 35 ];
; 9454 :    zSHORT            nKeyCnt;
; 9455 :    zSHORT            nRC = zCALL_ERROR;       // Assume everything error.

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 9456 : 
; 9457 :    lpViewEntity = zGETPTR( lpFirstEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9458 : 
; 9459 :    // To save time later find all the keys in the LOD and store them in a table.
; 9460 :    nKeyCnt = 0;

	mov	WORD PTR _nKeyCnt$[ebp], 0

; 9461 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 9462 :          lpViewAttrib;
; 9463 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L10799
$L10800:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L10799:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $L10801

; 9465 :       if ( lpViewAttrib->bKey )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10802

; 9466 :          lpKeyViewAttrib[ nKeyCnt++ ] = lpViewAttrib;

	movsx	edx, WORD PTR _nKeyCnt$[ebp]
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeyViewAttrib$[ebp+edx*4], eax
	mov	cx, WORD PTR _nKeyCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nKeyCnt$[ebp], cx
$L10802:

; 9467 :    }

	jmp	SHORT $L10800
$L10801:

; 9468 : 
; 9469 :    if ( bLOD_Lock )

	mov	edx, DWORD PTR _bLOD_Lock$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L10803

; 9471 :       // We are checking a LOD level lock so we set LockName to the name of
; 9472 :       // the LOD.
; 9473 :       zstrcpy( szLockName, lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 9475 :    else

	jmp	SHORT $L10804
$L10803:

; 9477 :       // We are checking a lock at the entity level so use the name of the
; 9478 :       // entity for the LockName.  In addition, to handle the rare case where
; 9479 :       // a LOD and entity name are the same we prefix all entity names with
; 9480 :       // a '@' because it's an invalid character for entity names.  This
; 9481 :       // insures that the LockName for the entity does not match a LOD name.
; 9482 :       zsprintf( szLockName, "@%s", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET FLAT:??_C@_03LNBB@?$EA?$CFs?$AA@	; `string'
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L10804:

; 9484 : 
; 9485 :    // Create EntitySpec and QualAttribs.  This creates a qual that
; 9486 :    // is analogous to:
; 9487 :    //    ACTIVATE view WHERE view.ZeidonLock.LOD_Name = lod-name AND
; 9488 :    //                        view.ZeidonLock.KeyValue = ?
; 9489 :    fnCreateQualification( lpCurrentTask, lpView, &vQual,
; 9490 :                           &lpQualAttribEntityCsr, "ZeidonLock", "ZeidonLock",
; 9491 :                           "LOD_Name", "=", szLockName );

	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_01KPOD@?$DN?$AA@	; `string'
	push	OFFSET FLAT:??_C@_08GDMG@LOD_Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	lea	edx, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _vQual$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCreateQualification@36

; 9492 :    fnCreateQualification( lpCurrentTask, lpView, &vQual,
; 9493 :                           &lpQualAttribEntityCsr, 0, 0, 0, "AND", 0 );

	push	0
	push	OFFSET FLAT:??_C@_03LACO@AND?$AA@	; `string'
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCreateQualification@36

; 9494 :    fnCreateQualification( lpCurrentTask, lpView, &vQual,
; 9495 :                           &lpQualAttribEntityCsr,
; 9496 :                           0, "ZeidonLock", "KeyValue", "=", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_01KPOD@?$DN?$AA@	; `string'
	push	OFFSET FLAT:??_C@_08GOHN@KeyValue?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	push	0
	lea	ecx, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vQual$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCreateQualification@36

; 9497 : 
; 9498 :    // Get the lpViewAttrib for the Value attribute for later use with
; 9499 :    // fnSetAttributeFromVariable.
; 9500 :    lpValueViewAttrib =
; 9501 :            fnValidViewAttrib( vQual,
; 9502 :                               zGETPTR( lpQualAttribEntityCsr->hViewEntity ),
; 9503 :                               "Value", 0 );

	push	0
	push	OFFSET FLAT:??_C@_05KBGO@Value?$AA@	; `string'
	mov	edx, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpValueViewAttrib$[ebp], eax

; 9504 : 
; 9505 :    // Loop through each of the root entities and make sure that none of the
; 9506 :    // key values already exist.
; 9507 :    for ( lpEntityInstance = lpFirstEntityInstance;
; 9508 :          lpEntityInstance;
; 9509 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $L10807
$L10808:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L10807:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L10809

; 9511 :       zSHORT k;
; 9512 : 
; 9513 :       // Create the concat key string and set the value in the qual object.
; 9514 :       fnCreateConcatKey( szKeyString, lpEntityInstance,
; 9515 :                          lpKeyViewAttrib, nKeyCnt );

	mov	dx, WORD PTR _nKeyCnt$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpKeyViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szKeyString$[ebp]
	push	edx
	call	_fnCreateConcatKey@16

; 9516 :       fnSetAttributeFromVariable( vQual, lpQualAttribEntityCsr,
; 9517 :                                   lpValueViewAttrib, (zPVOID) szKeyString,
; 9518 :                                   'S', 0, 0, lpCurrentTask, 0 );

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	0
	push	83					; 00000053H
	lea	ecx, DWORD PTR _szKeyString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpValueViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H

; 9519 : 
; 9520 : 
; 9521 :       k = ActivateObjectInstance( &vLock, "ZPLOCKO", lpView, vQual, 0 );

	push	0
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_07KIPN@ZPLOCKO?$AA@	; `string'
	lea	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_ActivateObjectInstance@20
	mov	WORD PTR _k$10810[ebp], ax

; 9522 :       if ( k < -1 )

	movsx	edx, WORD PTR _k$10810[ebp]
	cmp	edx, -1
	jge	SHORT $L10812

; 9523 :          goto EndOfFunction;

	jmp	$EndOfFunction$10813
$L10812:

; 9524 : 
; 9525 :       if ( k >= 0 )

	movsx	eax, WORD PTR _k$10810[ebp]
	test	eax, eax
	jl	$L10816

; 9527 :          zPCHAR pch;
; 9528 : 
; 9529 :          // Uh-oh -- we found a lock record matching the keys.  Check to see
; 9530 :          // if we can at least keep the view as read-only.
; 9531 :          GetAddrForAttribute( &pch, vLock, "ZeidonLock", "AllowRead" );

	push	OFFSET FLAT:??_C@_09NCPC@AllowRead?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch$10815[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 9532 :          if ( *pch != 'Y' || bAllowReadOnly == FALSE )

	mov	eax, DWORD PTR _pch$10815[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $L10817
	mov	edx, DWORD PTR _bAllowReadOnly$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	$L10816
$L10817:

; 9534 :             zCHAR szWhat[ 100 ];
; 9535 :             zCHAR szMsg[ 200 ];
; 9536 :             zCHAR szDate[ 50 ];
; 9537 : 
; 9538 :             // User attempted to get some sort of lock but it's already locked
; 9539 :             // OR
; 9540 :             // someone has an exclusive lock that doesn't even allow
; 9541 :             // read-only views so don't allow activate.
; 9542 : 
; 9543 :             if ( bLOD_Lock )

	mov	eax, DWORD PTR _bLOD_Lock$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L10821

; 9544 :                zsprintf( szWhat, "LOD '%s' is locked", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0BD@BKHK@LOD?5?8?$CFs?8?5is?5locked?$AA@ ; `string'
	lea	edx, DWORD PTR _szWhat$10818[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 9545 :             else

	jmp	SHORT $L10823
$L10821:

; 9546 :                zsprintf( szWhat, "Entity '%s' is locked", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET FLAT:??_C@_0BG@JJPK@Entity?5?8?$CFs?8?5is?5locked?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWhat$10818[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L10823:

; 9547 : 
; 9548 :             GetAddrForAttribute( &pch, vLock, "ZeidonLock", "UserName" );

	push	OFFSET FLAT:??_C@_08BJPE@UserName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _pch$10815[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 9549 :             GetStringFromAttribute( szMsg, vLock, "ZeidonLock", "Timestamp" );

	push	OFFSET FLAT:??_C@_09KMOL@Timestamp?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szMsg$10819[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 9550 :             UfFormatDateTime( szDate, szMsg, "YYYY-M-D HH:MI:SS" );

	push	OFFSET FLAT:??_C@_0BC@NLCC@YYYY?9M?9D?5HH?3MI?3SS?$AA@ ; `string'
	lea	eax, DWORD PTR _szMsg$10819[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDate$10820[ebp]
	push	ecx
	call	_UfFormatDateTime@12

; 9551 :             TraceLineS( "(oi) Object locked by ", pch );

	mov	edx, DWORD PTR _pch$10815[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BH@NCBI@?$CIoi?$CJ?5Object?5locked?5by?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9552 :             TraceLineS( "(oi) Object locked on ", szDate );

	lea	eax, DWORD PTR _szDate$10820[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BH@FDBN@?$CIoi?$CJ?5Object?5locked?5on?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9553 :             TraceLineS( "(oi) Concatenated key = ", szKeyString );

	lea	ecx, DWORD PTR _szKeyString$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BJ@POBP@?$CIoi?$CJ?5Concatenated?5key?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9554 :          // zsprintf( szMsg, "By '%s' on %s", pch, szDate );
; 9555 :          // fnIssueCoreError( lpTask, lpView, 16, 94, 0, szWhat, szMsg );
; 9556 : 
; 9557 :             nRC = zLOCK_ERROR;

	mov	WORD PTR _nRC$[ebp], -5			; fffffffbH

; 9558 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$10813
$L10816:

; 9561 : 
; 9562 :       // We don't need it anymore so...
; 9563 :       fnDropView( vLock );

	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDropView@4

; 9564 :       vLock = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 9565 : 
; 9566 :    } // for ( lpEntityInstance...)

	jmp	$L10808
$L10809:

; 9567 : 
; 9568 :    // If we get here then everything is OK.
; 9569 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$10813:

; 9570 : 
; 9571 : EndOfFunction:
; 9572 :    if ( vQual )

	cmp	DWORD PTR _vQual$[ebp], 0
	je	SHORT $L10829

; 9573 :       fnDropView( vQual );

	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnDropView@4
$L10829:

; 9574 : 
; 9575 :    if ( vLock )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $L10830

; 9576 :       fnDropView( vLock );

	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnDropView@4
$L10830:

; 9577 : 
; 9578 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 9579 : 
; 9580 : } // fnCheckLocksOnTwins

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnCheckLocksOnTwins@24 ENDP
_TEXT	ENDS
PUBLIC	_fnCompareEIAttrs@36
PUBLIC	_fnCheckForRecursiveLoop@8
PUBLIC	??_C@_0DH@OLHA@?$DN?$DN?$DN?$DN?5Activate?5error?3?5Infinite?5re@ ; `string'
PUBLIC	??_C@_0BB@JOON@Object?5Name?5?5?5?$DN?5?$AA@	; `string'
PUBLIC	??_C@_0BB@LMMD@Parent?5Entity?5?$DN?5?$AA@	; `string'
PUBLIC	??_C@_0BB@BHHL@Parent?5level?5?5?$DN?5?$AA@	; `string'
PUBLIC	??_C@_0BB@NJHF@Child?5Entity?5?5?$DN?5?$AA@	; `string'
PUBLIC	??_C@_0BB@IHNO@Child?5level?5?5?5?$DN?5?$AA@	; `string'
EXTRN	_DisplayEntityInstance@8:NEAR
;	COMDAT ??_C@_0DH@OLHA@?$DN?$DN?$DN?$DN?5Activate?5error?3?5Infinite?5re@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0DH@OLHA@?$DN?$DN?$DN?$DN?5Activate?5error?3?5Infinite?5re@ DB '==='
	DB	'= Activate error: Infinite recursive subobject ====', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@JOON@Object?5Name?5?5?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BB@JOON@Object?5Name?5?5?5?$DN?5?$AA@ DB 'Object Name   = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LMMD@Parent?5Entity?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BB@LMMD@Parent?5Entity?5?$DN?5?$AA@ DB 'Parent Entity = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@BHHL@Parent?5level?5?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BB@BHHL@Parent?5level?5?5?$DN?5?$AA@ DB 'Parent level  = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@NJHF@Child?5Entity?5?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BB@NJHF@Child?5Entity?5?5?$DN?5?$AA@ DB 'Child Entity  = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@IHNO@Child?5level?5?5?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BB@IHNO@Child?5level?5?5?5?$DN?5?$AA@ DB 'Child level   = ', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_lpEntityInstance$ = 12
_lpViewEntity$ = -8
_lpParent$ = -4
_lpKeys$ = -812
_lpViewAttrib$ = -816
_lpCurrentTask$ = -820
_nKeyCnt$ = -12
_lpParentViewEntity$10856 = -828
_bKeysMatch$10858 = -824
_k$10859 = -832
_lpParentViewAttrib$10865 = -836
_lpViewOD$10875 = -840
_fnCheckForRecursiveLoop@8 PROC NEAR

; 9863 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 840				; 00000348H

; 9864 :    LPVIEWENTITY     lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9865 :    LPENTITYINSTANCE lpParent;
; 9866 :    LPVIEWATTRIB     lpKeys[ 200 ];
; 9867 :    LPVIEWATTRIB     lpViewAttrib;
; 9868 :    LPTASK           lpCurrentTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 9869 :    zSHORT           nKeyCnt;
; 9870 : 
; 9871 :    // In an attempt to make things faster later let's get all the keys for
; 9872 :    // lpEntityInstance.
; 9873 :    nKeyCnt = 0;

	mov	WORD PTR _nKeyCnt$[ebp], 0

; 9874 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 9875 :          lpViewAttrib;
; 9876 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L10847
$L10848:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L10847:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $L10849

; 9878 :       if ( lpViewAttrib->bKey == FALSE )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $L10850

; 9879 :         continue;

	jmp	SHORT $L10848
$L10850:

; 9880 : 
; 9881 :       lpKeys[ nKeyCnt++ ] = lpViewAttrib;

	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeys$[ebp+ecx*4], edx
	mov	ax, WORD PTR _nKeyCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nKeyCnt$[ebp], ax

; 9882 :    }

	jmp	SHORT $L10848
$L10849:

; 9883 : 
; 9884 : 
; 9885 :    for ( lpParent = zGETPTR( lpEntityInstance->hParent );
; 9886 :          lpParent;
; 9887 :          lpParent = zGETPTR( lpParent->hParent ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$[ebp], eax
	jmp	SHORT $L10853
$L10854:
	mov	eax, DWORD PTR _lpParent$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$[ebp], eax
$L10853:
	cmp	DWORD PTR _lpParent$[ebp], 0
	je	$L10855

; 9889 :       LPVIEWENTITY lpParentViewEntity = zGETPTR( lpParent->hViewEntity );

	mov	edx, DWORD PTR _lpParent$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntity$10856[ebp], eax

; 9890 :       zBOOL        bKeysMatch;
; 9891 :       zSHORT       k;
; 9892 : 
; 9893 :       // We only care about the parent if it's also recursive.  If NONE of the
; 9894 :       // recursive flags are set then skip it.  It's possible--althought
; 9895 :       // highly unlikely--that the entity we are looking for also exists as
; 9896 :       // a non-recursive entity between the recursive parent & child.
; 9897 :       if ( lpParentViewEntity->bRecursiveSt  == 0 &&
; 9898 :            lpParentViewEntity->bRecursive    == 0 &&
; 9899 :            lpParentViewEntity->bRecursivePar == 0 )

	mov	ecx, DWORD PTR _lpParentViewEntity$10856[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	jne	SHORT $L10860
	mov	eax, DWORD PTR _lpParentViewEntity$10856[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L10860
	mov	edx, DWORD PTR _lpParentViewEntity$10856[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 29					; 0000001dH
	and	eax, 1
	test	eax, eax
	jne	SHORT $L10860

; 9901 :          continue;

	jmp	SHORT $L10854
$L10860:

; 9903 : 
; 9904 :       // The parent must be the same ER entity as the child.
; 9905 :       if ( lpParentViewEntity->lEREntTok != lpViewEntity->lEREntTok )

	mov	ecx, DWORD PTR _lpParentViewEntity$10856[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	je	SHORT $L10861

; 9906 :          continue;

	jmp	$L10854
$L10861:

; 9907 : 
; 9908 :       // Make sure the keys are different.  We will start by assuming they
; 9909 :       // are the same until proven otherwise.
; 9910 :       bKeysMatch = TRUE;

	mov	BYTE PTR _bKeysMatch$10858[ebp], 1

; 9911 :       for ( k = 0; k < nKeyCnt; k++ )

	mov	WORD PTR _k$10859[ebp], 0
	jmp	SHORT $L10862
$L10863:
	mov	cx, WORD PTR _k$10859[ebp]
	add	cx, 1
	mov	WORD PTR _k$10859[ebp], cx
$L10862:
	movsx	edx, WORD PTR _k$10859[ebp]
	movsx	eax, WORD PTR _nKeyCnt$[ebp]
	cmp	edx, eax
	jge	$L10864

; 9913 :          LPVIEWATTRIB lpParentViewAttrib;
; 9914 : 
; 9915 :          // Now find the key value in the parent.
; 9916 :          if ( lpViewEntity == lpParentViewEntity )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	ecx, DWORD PTR _lpParentViewEntity$10856[ebp]
	jne	SHORT $L10866

; 9917 :             lpParentViewAttrib = lpKeys[ k ];

	movsx	edx, WORD PTR _k$10859[ebp]
	mov	eax, DWORD PTR _lpKeys$[ebp+edx*4]
	mov	DWORD PTR _lpParentViewAttrib$10865[ebp], eax

; 9918 :          else

	jmp	SHORT $L10872
$L10866:

; 9920 :             // We have to hunt for it.
; 9921 :             for ( lpParentViewAttrib = zGETPTR( lpParentViewEntity->hFirstOD_Attrib );
; 9922 :                   lpParentViewAttrib->lERAttTok != lpKeys[ k ]->lERAttTok;
; 9923 :                   lpParentViewAttrib = zGETPTR( lpParentViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpParentViewEntity$10856[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewAttrib$10865[ebp], eax
	jmp	SHORT $L10870
$L10871:
	mov	eax, DWORD PTR _lpParentViewAttrib$10865[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewAttrib$10865[ebp], eax
$L10870:
	movsx	edx, WORD PTR _k$10859[ebp]
	mov	eax, DWORD PTR _lpKeys$[ebp+edx*4]
	mov	ecx, DWORD PTR _lpParentViewAttrib$10865[ebp]
	mov	edx, DWORD PTR [ecx+177]
	cmp	edx, DWORD PTR [eax+177]
	je	SHORT $L10872

; 9925 :                ; // nothing needs to be done here
; 9926 :             }

	jmp	SHORT $L10871
$L10872:

; 9928 : 
; 9929 :          if ( fnCompareEIAttrs( lpCurrentTask,
; 9930 :                                 0, lpParent, lpParentViewAttrib, 0,
; 9931 :                                 0, lpEntityInstance, lpKeys[ k ], 0 ) != 0 )

	push	0
	movsx	eax, WORD PTR _k$10859[ebp]
	mov	ecx, DWORD PTR _lpKeys$[ebp+eax*4]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _lpParentViewAttrib$10865[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpParent$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCompareEIAttrs@36
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L10873

; 9933 :             bKeysMatch = FALSE;

	mov	BYTE PTR _bKeysMatch$10858[ebp], 0

; 9934 :             break;

	jmp	SHORT $L10864
$L10873:

; 9936 :       }

	jmp	$L10863
$L10864:

; 9937 : 
; 9938 :       // If bKeysMatch is still TRUE then lpParent and lpEntityInstance
; 9939 :       // reference the same data.  This is an error that will cause an
; 9940 :       // infinite loop in the recursive subobject.
; 9941 :       if ( bKeysMatch )

	mov	ecx, DWORD PTR _bKeysMatch$10858[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	$L10874

; 9943 :          LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$10875[ebp], eax

; 9944 : 
; 9945 :          TraceLineS( "==== Activate error: Infinite recursive subobject ====", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0DH@OLHA@?$DN?$DN?$DN?$DN?5Activate?5error?3?5Infinite?5re@ ; `string'
	call	_TraceLineS@8

; 9946 :          TraceLineS( "Object Name   = ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$10875[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0BB@JOON@Object?5Name?5?5?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9947 :          TraceLineS( "Parent Entity = ", lpParentViewEntity->szName );

	mov	edx, DWORD PTR _lpParentViewEntity$10856[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET FLAT:??_C@_0BB@LMMD@Parent?5Entity?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9948 :          TraceLineI( "Parent level  = ", lpParent->nLevel );

	mov	eax, DWORD PTR _lpParent$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	push	ecx
	push	OFFSET FLAT:??_C@_0BB@BHHL@Parent?5level?5?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8

; 9949 :          TraceLineS( "Child Entity  = ", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET FLAT:??_C@_0BB@NJHF@Child?5Entity?5?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9950 :          TraceLineI( "Child level   = ", lpEntityInstance->nLevel );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	push	ecx
	push	OFFSET FLAT:??_C@_0BB@IHNO@Child?5level?5?5?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8

; 9951 :          DisplayEntityInstance( lpView, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_DisplayEntityInstance@8

; 9952 : 
; 9953 :          //  "KZOEE095 - Recursive error."
; 9954 :          fnIssueCoreError( lpCurrentTask, lpView, 16, 95, 0, lpViewOD->szName, 0 );

	push	0
	mov	ecx, DWORD PTR _lpViewOD$10875[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	0
	push	95					; 0000005fH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9955 : 
; 9956 :          return( TRUE );

	mov	ax, 1
	jmp	SHORT $L10836
$L10874:

; 9958 : 
; 9959 :    } // for each lpParent...

	jmp	$L10854
$L10855:

; 9960 : 
; 9961 :    // If we get here then everything must be OK.
; 9962 :    return( FALSE );

	xor	ax, ax
$L10836:

; 9963 : 
; 9964 : } // fnCheckForRecursiveLoop.

	mov	esp, ebp
	pop	ebp
	ret	8
_fnCheckForRecursiveLoop@8 ENDP
_TEXT	ENDS
PUBLIC	_fnLoadChildEntities
EXTRN	_fnSetViewToSubobject:NEAR
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_lpView$ = 12
_lpEntityInstance$ = 16
_lpQualView$ = 20
_pOper$ = 24
_lpPtr$ = 28
_lpViewOD$ = -12
_hViewEntity$ = -28
_lpViewEntity$ = -24
_lpChildViewEntity$ = -36
_hChildViewEntity$ = -8
_lpViewEntityCsr$ = -40
_lpChildEntityInstance$ = -16
_nEntityInstanceLevel$ = -4
_nReturnCode$ = -32
_nRC$ = -20
_lCurrentEREntTok$10910 = -44
_fnLoadChildEntities PROC NEAR

; 9998 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 9999 :    LPVIEWOD         lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 10000:    LPVIEWENTITY     hViewEntity;
; 10001:    LPVIEWENTITY     lpViewEntity;
; 10002:    LPVIEWENTITY     lpChildViewEntity;
; 10003:    LPVIEWENTITY     hChildViewEntity;
; 10004:    LPVIEWENTITYCSR  lpViewEntityCsr;
; 10005:    LPENTITYINSTANCE lpChildEntityInstance;
; 10006:    zSHORT           nEntityInstanceLevel;
; 10007:    zSHORT           nReturnCode = 0;

	mov	WORD PTR _nReturnCode$[ebp], 0

; 10008:    zSHORT           nRC;
; 10009: 
; 10010:    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10011:    nEntityInstanceLevel = lpEntityInstance->nLevel;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	dx, WORD PTR [ecx+58]
	mov	WORD PTR _nEntityInstanceLevel$[ebp], dx

; 10012: 
; 10013:    // If view entity is recursive, then reset lpViewEntity to point to the
; 10014:    // parent view entity that has the same EREntTok as the current lpViewEntity.
; 10015:    if ( lpViewEntity->bRecursive )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10914

; 10017:       zLONG lCurrentEREntTok;
; 10018: 
; 10019:       lCurrentEREntTok = lpViewEntity->lEREntTok;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+195]
	mov	DWORD PTR _lCurrentEREntTok$10910[ebp], eax

; 10020:       lpViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$L10913:

; 10021:       while ( lpViewEntity->lEREntTok != lCurrentEREntTok )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+195]
	cmp	ecx, DWORD PTR _lCurrentEREntTok$10910[ebp]
	je	SHORT $L10914

; 10022:          lpViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $L10913
$L10914:

; 10024: 
; 10025:    hViewEntity = zGETHNDL( lpViewEntity );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hViewEntity$[ebp], eax

; 10026: 
; 10027:    // The first child ViewEntity of the current lpViewEntity is the next
; 10028:    // view entity in hierachical order.
; 10029:    hChildViewEntity  = lpViewEntity->hNextHier;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR _hChildViewEntity$[ebp], eax

; 10030:    lpChildViewEntity = zGETPTR( hChildViewEntity );

	mov	ecx, DWORD PTR _hChildViewEntity$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildViewEntity$[ebp], eax

; 10031: 
; 10032:    // Check to see if there are child entity definitions.  If not, there are
; 10033:    // no children to load, so exit.  There is no child entity if:
; 10034:    //    o lpChildViewEntity is null (there are no entities after
; 10035:    //      lpViewEntity).
; 10036:    //    o The level number of the next view entity is "equal to" (which means
; 10037:    //      that the next view entity is a sibling) or "less than" (which means
; 10038:    //      that the next view entity is the sibling of an ancestor).
; 10039:    if ( lpChildViewEntity == 0 ||
; 10040:         lpChildViewEntity->nLevel <= lpViewEntity->nLevel )

	cmp	DWORD PTR _lpChildViewEntity$[ebp], 0
	je	SHORT $L10919
	mov	edx, DWORD PTR _lpChildViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jg	SHORT $L10918
$L10919:

; 10042:       return( 0 );

	xor	ax, ax
	jmp	$L10896
$L10918:

; 10044: 
; 10045:    // Load all the child entities of lpEntityInstance, starting with the first
; 10046:    // child entity definition via hierarchical ordering.  After loading a type
; 10047:    // of entity, find the next child entity type and (if there are more) load
; 10048:    // those.  Keep going until there are no more child entity types for
; 10049:    // lpEntityInstance.
; 10050: 
; 10051:    for ( ;
; 10052:          lpChildViewEntity;
; 10053:          lpChildViewEntity = zGETPTR( lpChildViewEntity->hNextSibling ) )

	jmp	SHORT $L10921
$L10922:
	mov	eax, DWORD PTR _lpChildViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+247]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildViewEntity$[ebp], eax
$L10921:
	cmp	DWORD PTR _lpChildViewEntity$[ebp], 0
	je	$L10923

; 10055:       hChildViewEntity = zGETHNDL( lpChildViewEntity );

	mov	edx, DWORD PTR _lpChildViewEntity$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hChildViewEntity$[ebp], eax

; 10056: 
; 10057:       // If the max cardinality of the child instance is 1 then it's possible
; 10058:       // that the child was already activated by the DBHandler.  Check to see
; 10059:       // if a child EI already exists.
; 10060:       if ( lpChildViewEntity->uCardMax == 1 )

	mov	eax, DWORD PTR _lpChildViewEntity$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+221]
	cmp	ecx, 1
	jne	$L10925

; 10062:          // Because the object might be recursive, we also
; 10063:          // need to check to make sure that the level of the child entity
; 10064:          // instance is exactly 1 more the the level of the parent entity.
; 10065:          lpChildEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax
$L10928:

; 10066:          while ( lpChildEntityInstance &&
; 10067:                  (lpChildEntityInstance->hViewEntity != hChildViewEntity ||
; 10068:                   lpChildEntityInstance->nLevel != nEntityInstanceLevel + 1) )

	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	je	SHORT $L10929
	mov	ecx, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hChildViewEntity$[ebp]
	jne	SHORT $L10930
	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nEntityInstanceLevel$[ebp]
	add	edx, 1
	cmp	ecx, edx
	je	SHORT $L10929
$L10930:

; 10070:             if ( lpChildEntityInstance->nLevel <= nEntityInstanceLevel )

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nEntityInstanceLevel$[ebp]
	cmp	ecx, edx
	jg	SHORT $L10931

; 10072:                lpChildEntityInstance = 0;

	mov	DWORD PTR _lpChildEntityInstance$[ebp], 0

; 10073:                break;

	jmp	SHORT $L10929
$L10931:

; 10075: 
; 10076:             while ( lpChildEntityInstance->hNextTwin )

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $L10934

; 10077:                lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax
	jmp	SHORT $L10931
$L10934:

; 10078: 
; 10079:             lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax

; 10080:          }

	jmp	SHORT $L10928
$L10929:

; 10081: 
; 10082:          nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 10084:       else

	jmp	SHORT $L10937
$L10925:

; 10085:          lpChildEntityInstance = 0;

	mov	DWORD PTR _lpChildEntityInstance$[ebp], 0
$L10937:

; 10086: 
; 10087:       // If lpChildEntityInstance is still 0 then we need to load it.
; 10088:       if ( lpChildEntityInstance == 0 )

	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	jne	$L10950

; 10090:          // If the child entity not either a derived path or a duplicate
; 10091:          // relationship path then attempt to load that entity.
; 10092:          if ( lpChildViewEntity->bDerivedPath == FALSE &&
; 10093:               lpChildViewEntity->bDupRelPath == FALSE )

	mov	edx, DWORD PTR _lpChildViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	test	eax, eax
	jne	$L10945
	mov	ecx, DWORD PTR _lpChildViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	test	edx, edx
	jne	$L10945

; 10095:             // Child entities couldn't be loaded via cacheing, so call the
; 10096:             // db-handler.
; 10097:             nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 10098:                             DBH_Entity | DBH_Load, 0, lpViewOD,
; 10099:                             lpChildViewEntity, lpView, lpQualView, lpPtr );

	mov	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpChildViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	0
	push	32800					; 00008020H
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 10100:             if ( nRC == zDB_DEADLOCK )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -3					; fffffffdH
	jne	SHORT $L10942

; 10101:                return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L10896
$L10942:

; 10102: 
; 10103:             if ( lpCurrentTask->bLoadAllocLimit )

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	test	edx, edx
	je	SHORT $L10943

; 10105:                lpCurrentTask->bLoadAllocLimit = FALSE;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	and	ch, -65					; ffffffbfH
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [edx+443], ecx

; 10106:                return( zMEMORY_LIMIT );

	mov	ax, -7					; fffffff9H
	jmp	$L10896
$L10943:

; 10108: 
; 10109:             if ( nRC < -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jge	SHORT $L10944

; 10110:                return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10896
$L10944:

; 10111: 
; 10112:             // Check to see if the activate limit was reached.
; 10113:             if ( nRC == 2 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, 2
	jne	SHORT $L10945

; 10114:                nReturnCode = 2;

	mov	WORD PTR _nReturnCode$[ebp], 2
$L10945:

; 10116: 
; 10117:          // If we didn't load any child entities see if we need to create a
; 10118:          // child entity because of the "hanging keys" problem.
; 10119:          if ( nRC == -1 && lpChildViewEntity->bHangingFKey )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jne	SHORT $L10946
	mov	eax, DWORD PTR _lpChildViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L10946

; 10120:             fnAddHangingEntity( lpView, lpChildViewEntity );

	mov	edx, DWORD PTR _lpChildViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnAddHangingEntity@8
$L10946:

; 10121: 
; 10122:          // If any children were loaded, call this proc recursively to load all
; 10123:          // of THEIR children.
; 10124: 
; 10125:          // Find the first child entity of lpChildViewEntity.
; 10126:          lpChildEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax
$L10949:

; 10127: 
; 10128:          // Now find the first child entity instance that matches
; 10129:          // lpChildViewEntity.  Because the object might be recursive, we also
; 10130:          // need to check to make sure that the level of the child entity
; 10131:          // instance is exactly 1 more the the level of the parent entity.
; 10132:          while ( lpChildEntityInstance &&
; 10133:                  (lpChildEntityInstance->hViewEntity != hChildViewEntity ||
; 10134:                   lpChildEntityInstance->nLevel != nEntityInstanceLevel + 1) )

	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	je	SHORT $L10950
	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hChildViewEntity$[ebp]
	jne	SHORT $L10951
	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nEntityInstanceLevel$[ebp]
	add	ecx, 1
	cmp	eax, ecx
	je	SHORT $L10950
$L10951:

; 10136:             if ( lpChildEntityInstance->nLevel <= nEntityInstanceLevel )

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nEntityInstanceLevel$[ebp]
	cmp	eax, ecx
	jg	SHORT $L10952

; 10138:                lpChildEntityInstance = 0;

	mov	DWORD PTR _lpChildEntityInstance$[ebp], 0

; 10139:                break;

	jmp	SHORT $L10950
$L10952:

; 10141: 
; 10142:             while ( lpChildEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $L10955

; 10143:                lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax
	jmp	SHORT $L10952
$L10955:

; 10144: 
; 10145:             lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax

; 10146:          }

	jmp	SHORT $L10949
$L10950:

; 10149: 
; 10150:       // If nRC == -1, then no children were loaded.
; 10151:       if ( nRC >= 0 && lpChildEntityInstance )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L10961
	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	je	$L10961
$L10960:

; 10153:          // Load the children of the just-loaded children.
; 10154:          while ( lpChildEntityInstance )

	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	je	$L10961

; 10156:             //
; 10157:             // Make lpChildEntityInstance the current instance.
; 10158:             //
; 10159:             lpViewEntityCsr =
; 10160:                 fnEstablishViewForInstance( lpView, 0, lpChildEntityInstance );

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 10161: 
; 10162:             // If the entity is flagged as recursive, then set the view to
; 10163:             // have the current child entity as the parent of the recursive
; 10164:             // relationship before calling fnLoadChildEntities.
; 10165:             if ( lpChildViewEntity->bRecursive )

	mov	ecx, DWORD PTR _lpChildViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	test	edx, edx
	je	$L10962

; 10167:                fnSetViewToSubobject( lpView, lpChildViewEntity,
; 10168:                                      lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpChildViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH

; 10169: 
; 10170:                // Check to make sure the recursive entity instance hasn't
; 10171:                // already been loaded as a parent.  If it has then this is
; 10172:                // an error because the OI has an infinite looping sub-object.
; 10173:                // If the return value is TRUE then there was an error.
; 10174:                if ( fnCheckForRecursiveLoop( lpView,
; 10175:                                              lpChildEntityInstance ) == 0 )

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnCheckForRecursiveLoop@8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L10967

; 10177:                   // Everything ok so load children.
; 10178:                   nRC = fnLoadChildEntities( lpCurrentTask, lpView,
; 10179:                                              lpChildEntityInstance, lpQualView,
; 10180:                                              pOper, lpPtr );

	mov	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnLoadChildEntities
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 10181:                   if ( nRC == zDB_DEADLOCK || nRC == zMEMORY_LIMIT )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -3					; fffffffdH
	je	SHORT $L10965
	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -7					; fffffff9H
	jne	SHORT $L10964
$L10965:

; 10182:                      return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L10896
$L10964:

; 10183: 
; 10184:                   if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L10966

; 10185:                      return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10896
$L10966:

; 10186: 
; 10187:                   if ( nRC == 2 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 2
	jne	SHORT $L10967

; 10188:                      nReturnCode = 2;

	mov	WORD PTR _nReturnCode$[ebp], 2
$L10967:

; 10190: 
; 10191:                fnResetViewFromSubobject( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetViewFromSubobject
	add	esp, 4

; 10193:             else

	jmp	SHORT $L10972
$L10962:

; 10195:                nRC = fnLoadChildEntities( lpCurrentTask, lpView,
; 10196:                                           lpChildEntityInstance, lpQualView,
; 10197:                                           pOper, lpPtr );

	mov	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnLoadChildEntities
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 10198:                if ( nRC == zDB_DEADLOCK || nRC == zMEMORY_LIMIT )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -3					; fffffffdH
	je	SHORT $L10970
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -7					; fffffff9H
	jne	SHORT $L10969
$L10970:

; 10199:                   return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L10896
$L10969:

; 10200: 
; 10201:                if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L10971

; 10202:                   return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L10896
$L10971:

; 10203: 
; 10204:                if ( nRC == 2 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 2
	jne	SHORT $L10972

; 10205:                   nReturnCode = 2;

	mov	WORD PTR _nReturnCode$[ebp], 2
$L10972:

; 10207: 
; 10208:             // Get next twin.
; 10209:             lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax

; 10210: 
; 10211:          }  // while ( lpChildEntityInstance )...

	jmp	$L10960
$L10961:

; 10214: 
; 10215:    } // for ( lpChildViewEntity )

	jmp	$L10922
$L10923:

; 10216: 
; 10217:    return( nReturnCode );

	mov	ax, WORD PTR _nReturnCode$[ebp]
$L10896:

; 10218: 
; 10219: }  // fnLoadChildEntities

	mov	esp, ebp
	pop	ebp
	ret	0
_fnLoadChildEntities ENDP
_TEXT	ENDS
PUBLIC	_fnSetLocksOnTwins@24
PUBLIC	??_C@_01PCJP@Y?$AA@				; `string'
;	COMDAT ??_C@_01PCJP@Y?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_01PCJP@Y?$AA@ DB 'Y', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_bLOD_Lock$ = 12
_lpView$ = 16
_lpFirstEntityInstance$ = 20
_lpViewOI$ = 24
_bAllowRead$ = 28
_vLock$ = -8
_lpViewEntity$ = -60
_lpViewAttrib$ = -132
_lpKeyViewAttrib$ = -292
_lpEntityInstance$ = -56
_lpViewEntityCsr$ = -500
_lpViewOD$ = -12
_tViewArrayBlock$ = -128
_szKeyString$ = -496
_szLockName$ = -52
_nKeyCnt$ = -64
_nRC$ = -16
_lpLockInstance$11017 = -504
_fnSetLocksOnTwins@24 PROC NEAR

; 10235: {

	push	ebp
	mov	ebp, esp
	sub	esp, 508				; 000001fcH
	push	edi

; 10236:    ViewClusterRecord vLock;
; 10237:    LPVIEWENTITY      lpViewEntity;
; 10238:    LPVIEWATTRIB      lpViewAttrib;
; 10239:    LPVIEWATTRIB      lpKeyViewAttrib[ zMAX_KEYS_FOR_LOCK ];
; 10240:    LPENTITYINSTANCE  lpEntityInstance;
; 10241:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 10242:    LPVIEWOD          lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 10243:    VIEWARRAYBLOCK    tViewArrayBlock = { 0 };

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	mov	ecx, 15					; 0000000fH
	xor	eax, eax
	lea	edi, DWORD PTR _tViewArrayBlock$[ebp+4]
	rep stosd

; 10244:    zCHAR             szKeyString[ zMAX_KEYLTH_FOR_LOCK + 1 ];
; 10245:    zCHAR             szLockName[ 35 ];
; 10246:    zSHORT            nKeyCnt;
; 10247:    zSHORT            nRC = zCALL_ERROR;       // Assume everything error.

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 10248: 
; 10249:    vLock.vOI = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 10250:    vLock.lControl = 0;

	mov	DWORD PTR _vLock$[ebp+4], 0

; 10251: 
; 10252:    lpViewEntity = zGETPTR( lpFirstEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10253: 
; 10254:    // To save time later find all the keys in the LOD and store them in a table.
; 10255:    nKeyCnt = 0;

	mov	WORD PTR _nKeyCnt$[ebp], 0

; 10256:    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 10257:          lpViewAttrib;
; 10258:          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L11004
$L11005:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L11004:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $L11006

; 10260:       if ( lpViewAttrib->bKey )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $L11007

; 10261:          lpKeyViewAttrib[ nKeyCnt++ ] = lpViewAttrib;

	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeyViewAttrib$[ebp+ecx*4], edx
	mov	ax, WORD PTR _nKeyCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nKeyCnt$[ebp], ax
$L11007:

; 10262:    }

	jmp	SHORT $L11005
$L11006:

; 10263: 
; 10264:    // Create an empty lock OI.
; 10265:    if ( fnDeclareView( &vLock.vOI, lpCurrentTask, lpView, "ZPLOCKO", FALSE ) != 0 )

	push	0
	push	OFFSET FLAT:??_C@_07KIPN@ZPLOCKO?$AA@	; `string'
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnDeclareView@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11008

; 10266:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10987
$L11008:

; 10267: 
; 10268:    if ( fnActivateEmptyObjectInstance( lpCurrentTask, vLock.vOI, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11009

; 10269:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L10987
$L11009:

; 10270: 
; 10271:    // Get the lpViewEntity and lpViewEntityCsr for the lock OI.
; 10272:    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, vLock.vOI, "ZeidonLock", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@PIFJ@ZeidonLock?$AA@ ; `string'
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10273: 
; 10274:    if ( bLOD_Lock )

	mov	ecx, DWORD PTR _bLOD_Lock$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L11010

; 10276:       // We are setting a LOD level lock so we set LockName to the name of
; 10277:       // the LOD.
; 10278:       zstrcpy( szLockName, lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 10280:    else

	jmp	SHORT $L11011
$L11010:

; 10282:       // We are setting a lock at the entity level so use the name of the
; 10283:       // entity for the LockName.  In addition, to handle the rare case where
; 10284:       // a LOD and entity name are the same we prefix all entity names with
; 10285:       // a '@' because it's an invalid character for entity names.  This
; 10286:       // insures that the LockName for the entity does not match a LOD name.
; 10287:       lpViewEntity = zGETPTR( lpFirstEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10288:       zsprintf( szLockName, "@%s", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET FLAT:??_C@_03LNBB@?$EA?$CFs?$AA@	; `string'
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L11011:

; 10290: 
; 10291:    // Loop through each of the root entities and create a locking record.
; 10292:    for ( lpEntityInstance = lpFirstEntityInstance;
; 10293:          lpEntityInstance;
; 10294:          lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $L11014
$L11015:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L11014:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L11016

; 10296:       LPENTITYINSTANCE lpLockInstance;
; 10297: 
; 10298:       // Create the concat key string.
; 10299:       fnCreateConcatKey( szKeyString, lpEntityInstance,
; 10300:                          lpKeyViewAttrib, nKeyCnt );

	mov	dx, WORD PTR _nKeyCnt$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpKeyViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szKeyString$[ebp]
	push	edx
	call	_fnCreateConcatKey@16

; 10301: 
; 10302:       if ( fnCreateEntity( vLock.vOI, lpViewEntity, lpViewEntityCsr,
; 10303:                            zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnCreateEntity@20
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11019

; 10305:          goto EndOfFunction;

	jmp	$EndOfFunction$11020
$L11019:

; 10307: 
; 10308:       // fnCreateEntity DOES NOT set the bCreated flag so set it.
; 10309:       lpLockInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLockInstance$11017[ebp], eax

; 10310:       lpLockInstance->u.nInd.bCreated = TRUE;

	mov	eax, DWORD PTR _lpLockInstance$11017[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 2
	mov	edx, DWORD PTR _lpLockInstance$11017[ebp]
	mov	DWORD PTR [edx+6], ecx

; 10311: 
; 10312:       if ( fnSetLockingAttributes( lpCurrentTask,
; 10313:                                    vLock.vOI, lpViewEntity, lpViewEntityCsr,
; 10314:                                    szLockName, szKeyString,
; 10315:                                    TRUE, TRUE, bAllowRead ? "Y" : "N" ) != 0 )

	mov	eax, DWORD PTR _bAllowRead$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L12841
	mov	DWORD PTR -508+[ebp], OFFSET FLAT:??_C@_01PCJP@Y?$AA@ ; `string'
	jmp	SHORT $L12842
$L12841:
	mov	DWORD PTR -508+[ebp], OFFSET FLAT:??_C@_01OAK@N?$AA@ ; `string'
$L12842:
	mov	ecx, DWORD PTR -508+[ebp]
	push	ecx
	push	1
	push	1
	lea	edx, DWORD PTR _szKeyString$[ebp]
	push	edx
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnSetLockingAttributes@36
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L11022

; 10317:          goto EndOfFunction;

	jmp	SHORT $EndOfFunction$11020
$L11022:

; 10319:    } // for ( lpEntityInstance...)

	jmp	$L11015
$L11016:

; 10320: 
; 10321:    // Now commit the lock OI.
; 10322:    if ( fnInitViewArrayBlock( &tViewArrayBlock, 1 ) != 0 )

	push	1
	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11024

; 10323:       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$11020
$L11024:

; 10324: 
; 10325:    if ( fnCommitObjectInstance( &vLock, &vLock.vOI, 1, 0, lpCurrentTask,
; 10326:                                 0, &tViewArrayBlock ) != 0 )

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	1
	lea	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnCommitObjectInstance@28
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11025

; 10328:       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$11020
$L11025:

; 10330: 
; 10331:    lpViewOI->bIsLocked = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 10332: 
; 10333:    // If we get here then everything is OK.
; 10334:    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$11020:

; 10335: 
; 10336: EndOfFunction:
; 10337:    if ( vLock.vOI )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $L11026

; 10338:       fnDropView( vLock.vOI );

	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnDropView@4
$L11026:

; 10339: 
; 10340:    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 10341: 
; 10342:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L10987:

; 10343: 
; 10344: } // fnSetLocksOnTwins

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnSetLocksOnTwins@24 ENDP
_lpCurrentTask$ = 8
_lpView$ = 12
_lpQualView$ = 16
_lControl$ = 20
_lpViewOD$ = -8
_lpViewOI$ = -40
_lpViewCsr$ = -4
_lpEntityInstance$ = -20
_lpTaskDBHandler$ = -32
_pOper$ = -24
_lpPtr$ = -16
_bTransactionStartedHere$ = -28
_nReturnCode$ = -36
_nRC$ = -12
_bReadOnly$11062 = -44
_bAllowRead$11065 = -48
_lpViewEntity$11085 = -52
_bReadOnly$11087 = -56
_bAllowRead$11092 = -60
_fnActivateObjectInstance PROC NEAR

; 10379: {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 10380:    LPVIEWOD          lpViewOD;
; 10381:    LPVIEWOI          lpViewOI;
; 10382:    LPVIEWCSR         lpViewCsr;
; 10383:    LPENTITYINSTANCE  lpEntityInstance;
; 10384:    LPTASKDBHANDLER   lpTaskDBHandler;
; 10385:    zPDBHOPER         pOper;
; 10386:    zPVOID            lpPtr;
; 10387:    zBOOL             bTransactionStartedHere;
; 10388:    zSHORT            nReturnCode;
; 10389:    zSHORT            nRC;
; 10390: 
; 10391:    lpPtr       = 0;

	mov	DWORD PTR _lpPtr$[ebp], 0

; 10392:    nReturnCode = 0;

	mov	WORD PTR _nReturnCode$[ebp], 0

; 10393: 
; 10394:    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 10395:    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 10396:    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 10397:    lpTaskDBHandler = fnGetDBHandlerOper( lpCurrentTask, lpView,
; 10398:                                          (zlpPDBHOPER) &pOper );

	lea	eax, DWORD PTR _pOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnGetDBHandlerOper@12
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax

; 10399:    if ( lpTaskDBHandler == 0 )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	jne	SHORT $L11050

; 10400:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11035
$L11050:

; 10401: 
; 10402:    // Check to see if a transaction has already been started for the database.
; 10403:    // If it has already been started we don't want to do it again but set a
; 10404:    // flag to indicate we don't want to END the transaction later.
; 10405:    //
; 10406:    // We need to do this because fnActivateObjectInstance can be called
; 10407:    // recursively.
; 10408:    if ( lpTaskDBHandler->bTranStarted )

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L11051

; 10410:       bTransactionStartedHere = FALSE;

	mov	BYTE PTR _bTransactionStartedHere$[ebp], 0

; 10411:       lpPtr = lpTaskDBHandler->lpConnection;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR _lpPtr$[ebp], eax

; 10413:    else

	jmp	SHORT $L11052
$L11051:

; 10415:       // Call DBHandler routine to issue start of transaction.
; 10416:       nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 10417:                       DBH_Object | DBH_TranBegin, DBH_LoadOI,
; 10418:                       lpViewOD, 0, lpView, lpQualView, &lpPtr );

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	1
	push	16385					; 00004001H
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 10419:       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $L11055

; 10420:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11035
$L11055:

; 10421: 
; 10422:       // Set flag to indicate that we started the transaction here and will
; 10423:       // need to end the transaction before we exit the operation.
; 10424:       bTransactionStartedHere = TRUE;

	mov	BYTE PTR _bTransactionStartedHere$[ebp], 1

; 10425:       lpTaskDBHandler->bTranStarted = TRUE;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	or	edx, 1
	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [eax+26], edx

; 10426:       lpTaskDBHandler->lpConnection = lpPtr;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR _lpPtr$[ebp]
	mov	DWORD PTR [ecx+18], edx
$L11052:

; 10428: 
; 10429:    // Retrieve the root entity(-ies).
; 10430:    nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 10431:                    DBH_Entity | DBH_Load, (int) lControl, lpViewOD,
; 10432:                    zGETPTR( lpViewOD->hFirstOD_Entity ),
; 10433:                    lpView, lpQualView, &lpPtr );

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	push	32800					; 00008020H
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 10434: 
; 10435:    // If nRC > 0, then the root entity was loaded OK but multiple roots were
; 10436:    // found and lControl = zSINGLE or the multi-root limit was reached.
; 10437:    // This means that not all roots where loaded.
; 10438:    // Set nRC back to 0 (indicate load was OK) and set nReturnCode = 1 (this
; 10439:    // will be returned by the Activate if everything else goes OK).
; 10440:    if ( nRC >= 1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 1
	jl	SHORT $L11060

; 10442:       nReturnCode = nRC;

	mov	ax, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nReturnCode$[ebp], ax

; 10443:       nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$L11060:

; 10445: 
; 10446:    // If we activated some information check to see if we need to set up
; 10447:    // some pessimistic locks.
; 10448:    if ( nRC >= 0 && lpViewOD->nLock >= zLL_PESSIMISTIC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L11067
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+236]
	cmp	eax, 3
	jl	$L11067

; 10450:       zBOOL bReadOnly = (lControl & zSINGLE_FOR_UPDATE) == 0 ||
; 10451:                         lpViewOD->nLock == zLL_PESSIMISTIC;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 67108864				; 04000000H
	test	ecx, ecx
	je	SHORT $L12844
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+236]
	cmp	eax, 3
	je	SHORT $L12844
	mov	DWORD PTR -64+[ebp], 0
	jmp	SHORT $L12845
$L12844:
	mov	DWORD PTR -64+[ebp], 1
$L12845:
	mov	cl, BYTE PTR -64+[ebp]
	mov	BYTE PTR _bReadOnly$11062[ebp], cl

; 10452: 
; 10453:       nRC = fnCheckLocksOnTwins( lpCurrentTask, TRUE, bReadOnly, lpView,
; 10454:                                  zGETPTR( lpViewOI->hRootEntityInstance ),
; 10455:                                  lpViewOD );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	al, BYTE PTR _bReadOnly$11062[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCheckLocksOnTwins@24
	mov	WORD PTR _nRC$[ebp], ax

; 10456: 
; 10457:       // If nRC >= 0 then we might need to set locks on the parent entities.
; 10458:       if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L11067

; 10460:          zBOOL bAllowRead = lpViewOD->nLock == zLL_PESSIMISTIC_WITHREAD;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+236]
	xor	edx, edx
	cmp	ecx, 4
	sete	dl
	mov	BYTE PTR _bAllowRead$11065[ebp], dl

; 10461: 
; 10462:          if ( bReadOnly == FALSE &&
; 10463:               fnSetLocksOnTwins( lpCurrentTask, TRUE, lpView,
; 10464:                                  zGETPTR( lpViewOI->hRootEntityInstance ),
; 10465:                                  lpViewOI, bAllowRead ) != 0 )

	mov	eax, DWORD PTR _bReadOnly$11062[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L11067
	mov	cl, BYTE PTR _bAllowRead$11065[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnSetLocksOnTwins@24
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11067

; 10467:             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H
$L11067:

; 10471: 
; 10472:    // For each of the root entities, call fnLoadChildEntities to load all of
; 10473:    // their children if lower-level entities are to be loaded.
; 10474:    if ( nRC >= 0 && (lControl & zACTIVATE_ROOTONLY) == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$L11068
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	jne	$L11068

; 10476:       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 10477:             lpEntityInstance && nRC >= 0;
; 10478:             lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L11071
$L11072:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L11071:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L11073
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L11073

; 10480:          // Make lpEntityInstance the current instance.
; 10481:          fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 10482: 
; 10483:          nRC = fnLoadChildEntities( lpCurrentTask, lpView, lpEntityInstance,
; 10484:                                     lpQualView, pOper, &lpPtr );

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnLoadChildEntities
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 10485:          if ( nRC == zDB_DEADLOCK || nRC == zMEMORY_LIMIT )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -3					; fffffffdH
	je	SHORT $L11075
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -7					; fffffff9H
	jne	SHORT $L11074
$L11075:

; 10486:             nReturnCode = nRC;

	mov	cx, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nReturnCode$[ebp], cx
$L11074:

; 10487: 
; 10488:          // If nRC is 2 then not all child entities where loaded because the
; 10489:          // Activate Limit constraint was reached.
; 10490:          if ( nRC == 2 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 2
	jne	SHORT $L11076

; 10491:             nReturnCode = 2;

	mov	WORD PTR _nReturnCode$[ebp], 2
$L11076:

; 10492: 
; 10493:       }  // for ( lpEntityInstance )...

	jmp	SHORT $L11072
$L11073:

; 10496:    else

	jmp	SHORT $L11078
$L11068:

; 10497:    if ( lControl == (lControl | zACTIVATE_ROOTONLY) )

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 268435456				; 10000000H
	cmp	DWORD PTR _lControl$[ebp], eax
	jne	SHORT $L11078

; 10498:       lpViewOI->bRootOnly = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 2
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$L11078:

; 10499: 
; 10500:    // If we activated some information check to see if we need to set up
; 10501:    // some pessimistic locks.
; 10502:    if ( nRC >= 0 && lpViewOD->nEntityLock >= zLL_PESSIMISTIC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L11084
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+237]
	cmp	eax, 3
	jl	$L11084

; 10504:       // Loop through all the instances and check to see if
; 10505:       // the entity has locking.
; 10506:       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 10507:             lpEntityInstance;
; 10508:             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L11082
$L11083:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L11082:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L11084

; 10510:          LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$11085[ebp], eax

; 10511:          zBOOL        bReadOnly;
; 10512: 
; 10513:          // If entity has no locking skip it.
; 10514:          if ( lpViewEntity->nLock == 0 )

	mov	ecx, DWORD PTR _lpViewEntity$11085[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+230]
	test	edx, edx
	jne	SHORT $L11088

; 10515:             continue;

	jmp	SHORT $L11083
$L11088:

; 10516: 
; 10517:          // If the instance is not the first twin then skip it.
; 10518:          if ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $L11089

; 10519:             continue;

	jmp	SHORT $L11083
$L11089:

; 10520: 
; 10521:          // We're about to check the locks on the entity instances but if the
; 10522:          // zSINGLE_FOR_UPDATE flag is not set or if the locking level is only
; 10523:          // zLL_PESSIMISTIC then the entity instance is read-only.
; 10524:          bReadOnly = (lControl & zSINGLE_FOR_UPDATE) == 0 ||
; 10525:                      lpViewEntity->nLock == zLL_PESSIMISTIC;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 67108864				; 04000000H
	test	ecx, ecx
	je	SHORT $L12846
	mov	edx, DWORD PTR _lpViewEntity$11085[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+230]
	cmp	eax, 3
	je	SHORT $L12846
	mov	DWORD PTR -68+[ebp], 0
	jmp	SHORT $L12847
$L12846:
	mov	DWORD PTR -68+[ebp], 1
$L12847:
	mov	cl, BYTE PTR -68+[ebp]
	mov	BYTE PTR _bReadOnly$11087[ebp], cl

; 10526: 
; 10527:          // Make sure the entities aren't locked.
; 10528:          if ( fnCheckLocksOnTwins( lpCurrentTask, FALSE, bReadOnly, lpView,
; 10529:                                    lpEntityInstance, lpViewOD ) != 0 )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	dl, BYTE PTR _bReadOnly$11087[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCheckLocksOnTwins@24
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11090

; 10531:             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 10532:             break;

	jmp	SHORT $L11084
$L11090:

; 10534: 
; 10535:          // If entity instances are not read-only then we need to set up locks
; 10536:          // for the entities.
; 10537:          if ( bReadOnly == FALSE )

	mov	edx, DWORD PTR _bReadOnly$11087[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L11093

; 10539:             zBOOL bAllowRead = lpViewEntity->nLock == zLL_PESSIMISTIC_WITHREAD;

	mov	eax, DWORD PTR _lpViewEntity$11085[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+230]
	xor	edx, edx
	cmp	ecx, 4
	sete	dl
	mov	BYTE PTR _bAllowRead$11092[ebp], dl

; 10540: 
; 10541:             if ( fnSetLocksOnTwins( lpCurrentTask, FALSE, lpView,
; 10542:                                     lpEntityInstance, lpViewOI,
; 10543:                                     bAllowRead ) != 0 )

	mov	al, BYTE PTR _bAllowRead$11092[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnSetLocksOnTwins@24
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L11093

; 10545:                nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 10546:                break;

	jmp	SHORT $L11084
$L11093:

; 10549:       } // for...

	jmp	$L11083
$L11084:

; 10551: 
; 10552:    // Check to see if we need to close the transaction.
; 10553:    if ( bTransactionStartedHere )

	mov	eax, DWORD PTR _bTransactionStartedHere$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L11099

; 10555:       // We're about to close the transaction so set flag.
; 10556:       lpTaskDBHandler->bTranStarted = FALSE;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [eax+26], edx

; 10557:       lpTaskDBHandler->lpConnection = 0;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [ecx+18], 0

; 10558: 
; 10559:       if ( nRC >= -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jl	SHORT $L11095

; 10561:          // Call DBHandler routine to commit transaction.
; 10562:          if ( (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 10563:                         DBH_Object | DBH_Commit, DBH_LoadOI,
; 10564:                         lpViewOD, 0, lpView, 0, &lpPtr ) != 0 )

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	1
	push	16386					; 00004002H
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11098

; 10566:             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11035
$L11098:

; 10569:       else

	jmp	SHORT $L11099
$L11095:

; 10571:          // Call DBHandler routine to rollback transaction.
; 10572:          (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 10573:                    DBH_Object | DBH_Rollback, DBH_LoadOI,
; 10574:                    lpViewOD, 0, lpView, 0, &lpPtr );

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	1
	push	16388					; 00004004H
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]

; 10575:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11035
$L11099:

; 10578: 
; 10579:    // At this point if:
; 10580:    //    nRC = 0, nReturnCode = 1 -- 1 root loaded, mult found; children loaded
; 10581:    //    nRC = 0, nReturnCode = 0 -- all roots (possibly only 1) loaded.
; 10582:    //    nRC = -1                 -- No root found matching lpQual.
; 10583:    //    nRC < -1                 -- Error loading entities.
; 10584: 
; 10585:    if ( nRC >= -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jl	$L11109

; 10587:       // Before we exit, reset indicators in object instance to denote
; 10588:       // that entities are not to be created/include at commit time.
; 10589:       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 10590:             lpEntityInstance;
; 10591:             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L11105
$L11106:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L11105:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L11107

; 10593:          lpEntityInstance->u.nInd.bCreated        =
; 10594:             lpEntityInstance->u.nInd.bIncluded    =
; 10595:             lpEntityInstance->u.nInd.bUpdated     =
; 10596:             lpEntityInstance->u.nInd.bDBHCreated  =
; 10597:             lpEntityInstance->u.nInd.bDBHIncluded =
; 10598:             lpEntityInstance->u.nInd.bDBHDeleted  =
; 10599:             lpEntityInstance->u.nInd.bDBHExcluded =
; 10600:             lpEntityInstance->u.nInd.bDBHUpdated  = 0;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -131073				; fffdffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -65537				; fffeffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, -65					; ffffffbfH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, 127					; 0000007fH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, -33					; ffffffdfH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	al, -5					; fffffffbH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	al, -33					; ffffffdfH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	al, -3					; fffffffdH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 10601:       }

	jmp	$L11106
$L11107:

; 10602: 
; 10603:       lpViewOI->bUpdated = lpViewOI->bUpdatedFile = 0;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	al, -33					; ffffffdfH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	al, -17					; ffffffefH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 10604: 
; 10605:       if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $L11108

; 10606:          return( nReturnCode );

	mov	ax, WORD PTR _nReturnCode$[ebp]
	jmp	SHORT $L11035
$L11108:

; 10607:       else
; 10608:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L11035
$L11109:

; 10610: 
; 10611:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L11035:

; 10612: 
; 10613: }  //  fnActivateObjectInstance

	mov	esp, ebp
	pop	ebp
	ret	0
_fnActivateObjectInstance ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@GEOJ@?$CIWARNING?$CJ?5Couldn?8t?5find?5entity?5?$AA@ ; `string'
PUBLIC	??_C@_0BC@FECF@?$CIWARNING?$CJ?5in?5LOD?5?$AA@	; `string'
PUBLIC	??_C@_01PJCK@?4?$AA@				; `string'
PUBLIC	??_C@_0CH@HIC@Error?5from?5UUDECODE_NextLineToBu@ ; `string'
PUBLIC	??_C@_0BK@FNGM@UUDECODE?5length?5invalid?3?5?$AA@ ; `string'
PUBLIC	??_C@_0FA@FOLJ@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Tgt?5View?5E@ ; `string'
PUBLIC	??_C@_0CL@DJNN@ER?5Tokens?5don?8t?5match?5for?5linked@ ; `string'
PUBLIC	??_C@_0BL@IKLP@?$CIoi?$CJ?5Failed?5entity?5linking?$AA@ ; `string'
PUBLIC	??_C@_0BD@FPOB@?$CIoi?$CJ?5Link?5Src?5?$CD?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BG@GFPE@?$CIoi?$CJ?5Source?5Entity?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BD@GIND@?$CIoi?$CJ?5Link?5Tgt?5?$CD?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BG@FHME@?$CIoi?$CJ?5Target?5Entity?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0EA@MMNH@?$CIoi?$CJ?5Entity?5type?5mismatch?5during@ ; `string'
PUBLIC	_UUDECODE_NextLineToBuffer@16
PUBLIC	_fnActivateOI_FromTextStream
PUBLIC	??_C@_07ICJO@CONTROL?$AA@			; `string'
PUBLIC	??_C@_04EECP@ETAG?$AA@				; `string'
PUBLIC	??_C@_04BDIB@EKEY?$AA@				; `string'
PUBLIC	??_C@_05JDHD@OITAG?$AA@				; `string'
PUBLIC	??_C@_07IFBG@OIFLAGS?$AA@			; `string'
EXTRN	_fnSetAttributeFromInteger:NEAR
EXTRN	_fnSetAttributeFromBlob:NEAR
EXTRN	_SysParseLine@12:NEAR
EXTRN	__imp__strtoul:NEAR
EXTRN	_fnSetAttributeFromString:NEAR
;	COMDAT ??_C@_07ICJO@CONTROL?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_07ICJO@CONTROL?$AA@ DB 'CONTROL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EECP@ETAG?$AA@
_DATA	SEGMENT
??_C@_04EECP@ETAG?$AA@ DB 'ETAG', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BDIB@EKEY?$AA@
_DATA	SEGMENT
??_C@_04BDIB@EKEY?$AA@ DB 'EKEY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JDHD@OITAG?$AA@
_DATA	SEGMENT
??_C@_05JDHD@OITAG?$AA@ DB 'OITAG', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07IFBG@OIFLAGS?$AA@
_DATA	SEGMENT
??_C@_07IFBG@OIFLAGS?$AA@ DB 'OIFLAGS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@GEOJ@?$CIWARNING?$CJ?5Couldn?8t?5find?5entity?5?$AA@
_DATA	SEGMENT
??_C@_0CA@GEOJ@?$CIWARNING?$CJ?5Couldn?8t?5find?5entity?5?$AA@ DB '(WARNI'
	DB	'NG) Couldn''t find entity ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@FECF@?$CIWARNING?$CJ?5in?5LOD?5?$AA@
_DATA	SEGMENT
??_C@_0BC@FECF@?$CIWARNING?$CJ?5in?5LOD?5?$AA@ DB '(WARNING) in LOD ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PJCK@?4?$AA@
_DATA	SEGMENT
??_C@_01PJCK@?4?$AA@ DB '.', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CH@HIC@Error?5from?5UUDECODE_NextLineToBu@
_DATA	SEGMENT
??_C@_0CH@HIC@Error?5from?5UUDECODE_NextLineToBu@ DB 'Error from UUDECODE'
	DB	'_NextLineToBuffer: ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@FNGM@UUDECODE?5length?5invalid?3?5?$AA@
_DATA	SEGMENT
??_C@_0BK@FNGM@UUDECODE?5length?5invalid?3?5?$AA@ DB 'UUDECODE length inv'
	DB	'alid: ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FA@FOLJ@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Tgt?5View?5E@
_DATA	SEGMENT
??_C@_0FA@FOLJ@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Tgt?5View?5E@ DB '('
	DB	'oi) Error (OD: %s) - Tgt View Entity: %s Token: %d  View Enti'
	DB	'ty: %s Token = %d', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@DJNN@ER?5Tokens?5don?8t?5match?5for?5linked@
_DATA	SEGMENT
??_C@_0CL@DJNN@ER?5Tokens?5don?8t?5match?5for?5linked@ DB 'ER Tokens don'''
	DB	't match for linked entities!', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@IKLP@?$CIoi?$CJ?5Failed?5entity?5linking?$AA@
_DATA	SEGMENT
??_C@_0BL@IKLP@?$CIoi?$CJ?5Failed?5entity?5linking?$AA@ DB '(oi) Failed e'
	DB	'ntity linking', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@FPOB@?$CIoi?$CJ?5Link?5Src?5?$CD?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BD@FPOB@?$CIoi?$CJ?5Link?5Src?5?$CD?5?$DN?5?$AA@ DB '(oi) Link Src'
	DB	' # = ', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@GFPE@?$CIoi?$CJ?5Source?5Entity?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BG@GFPE@?$CIoi?$CJ?5Source?5Entity?5?$DN?5?$AA@ DB '(oi) Source En'
	DB	'tity = ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GIND@?$CIoi?$CJ?5Link?5Tgt?5?$CD?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BD@GIND@?$CIoi?$CJ?5Link?5Tgt?5?$CD?5?$DN?5?$AA@ DB '(oi) Link Tgt'
	DB	' # = ', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@FHME@?$CIoi?$CJ?5Target?5Entity?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BG@FHME@?$CIoi?$CJ?5Target?5Entity?5?$DN?5?$AA@ DB '(oi) Target En'
	DB	'tity = ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EA@MMNH@?$CIoi?$CJ?5Entity?5type?5mismatch?5during@
_DATA	SEGMENT
??_C@_0EA@MMNH@?$CIoi?$CJ?5Entity?5type?5mismatch?5during@ DB '(oi) Entit'
	DB	'y type mismatch during cursor restoration for entity ', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpWkViewEntity$11290 = -456
_lpAttribFlags$11323 = -464
_AttribFlags$11324 = -460
_pchStart$11326 = -468
_l$11343 = -472
_szAttribFlags$11353 = -484
_j$11354 = -488
_lXVATok$11361 = -492
_sz$11380 = -892
_l$11423 = -896
_lLinkTgt$11434 = -900
_lLinkSrc$11435 = -904
_lpTgtViewEntity$11442 = -908
_nHierNbr$11466 = -912
_l$11467 = -916
_lpFirstViewCsr$11476 = -920
_lpWk$11500 = -924
_lpView$ = 8
_lpfnStreamFunc$ = 12
_lpvData$ = 16
_plControl$ = 20
_lpViewOD$ = -40
_lpViewOI$ = -384
_lpViewEntity$ = -76
_lpViewAttrib$ = -92
_lpViewCsr$ = -8
_lpViewEntityCsr$ = -440
_lpEntityInstance$ = -68
_lpSrcInstance$ = -72
_lpTgtInstance$ = -48
_lpCursorEI$ = -44
_lpTask$ = -84
_pchAttr$ = -64
_pchLine$ = -28
_pRelinkBufferTable$ = -432
_pRelinkBufferPtr$ = -24
_pRelinkBufferEnd$ = -60
_ulLth$ = -376
_ulLthDecoded$ = -436
_uPos$ = -360
_bIgnoreEntityErrors$ = -356
_bIgnoreAttribErrors$ = -56
_bEntityIsCompressed$ = -392
_bOI_IsUpdated$ = -80
_bSkipAttributes$ = -20
_bMsgBox$ = -352
_szWorkString$ = -348
_lIndicators$ = -380
_lPrevIndicators$ = -388
_lEntityCnt$ = -36
_lLineCount$ = -372
_k$ = -368
_nErrorEntityLvl$ = -364
_nErrorEntityCnt$ = -16
_nErrorAttribCnt$ = -4
_nEOF$ = -88
_nLevel$ = -12
_nRC$ = -52
_lInstanceCount$ = -32
_uFlags$11229 = -444
_nHierNbr$11249 = -448
_lpSearchViewEntityCsr$11254 = -452
_fnActivateOI_FromTextStream PROC NEAR

; 10621: {

	push	ebp
	mov	ebp, esp
	sub	esp, 956				; 000003bcH
	push	edi

; 10622:    LPVIEWOD          lpViewOD;
; 10623:    LPVIEWOI          lpViewOI;
; 10624:    LPVIEWENTITY      lpViewEntity;
; 10625:    LPVIEWATTRIB      lpViewAttrib;
; 10626:    LPVIEWCSR         lpViewCsr;
; 10627:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 10628:    LPENTITYINSTANCE  lpEntityInstance;
; 10629:    LPENTITYINSTANCE  lpSrcInstance;
; 10630:    LPENTITYINSTANCE  lpTgtInstance;
; 10631:    LPENTITYINSTANCE  lpCursorEI;    // Used to set cursors.
; 10632:    LPTASK            lpTask;
; 10633:    zPCHAR            pchAttr;
; 10634:    zPCHAR            pchLine;
; 10635:    zPLONG            pRelinkBufferTable[ 10 ] = { 0 };

	mov	DWORD PTR _pRelinkBufferTable$[ebp], 0
	mov	ecx, 9
	xor	eax, eax
	lea	edi, DWORD PTR _pRelinkBufferTable$[ebp+4]
	rep stosd

; 10636:    zPLONG            pRelinkBufferPtr;
; 10637:    zPLONG            pRelinkBufferEnd;
; 10638:    zULONG            ulLth;
; 10639:    zULONG            ulLthDecoded;
; 10640:    zULONG            uPos;
; 10641:    zBOOL             bIgnoreEntityErrors;
; 10642:    zBOOL             bIgnoreAttribErrors;
; 10643:    zBOOL             bEntityIsCompressed;
; 10644:    zBOOL             bOI_IsUpdated = FALSE;

	mov	BYTE PTR _bOI_IsUpdated$[ebp], 0

; 10645:    zBOOL             bSkipAttributes = FALSE;

	mov	BYTE PTR _bSkipAttributes$[ebp], 0

; 10646:    zBOOL             bMsgBox = TRUE;

	mov	BYTE PTR _bMsgBox$[ebp], 1

; 10647:    zCHAR             szWorkString[ 256 ];
; 10648:    zLONG             lIndicators = 0, lPrevIndicators;

	mov	DWORD PTR _lIndicators$[ebp], 0

; 10649:    zLONG             lEntityCnt = 0;

	mov	DWORD PTR _lEntityCnt$[ebp], 0

; 10650:    zLONG             lLineCount = 0;

	mov	DWORD PTR _lLineCount$[ebp], 0

; 10651:    zLONG             k;
; 10652:    zSHORT            nErrorEntityLvl;
; 10653:    zSHORT            nErrorEntityCnt;
; 10654:    zSHORT            nErrorAttribCnt;
; 10655:    zSHORT            nEOF;
; 10656:    zSHORT            nLevel;
; 10657:    zSHORT            nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 10658: 
; 10659:    // The following should only be used for cursor processing.
; 10660:    zLONG             lInstanceCount = 0;

	mov	DWORD PTR _lInstanceCount$[ebp], 0

; 10661: 
; 10662:    bIgnoreEntityErrors = (*plControl & zIGNORE_ENTITY_ERRORS) ? 1 : 0;

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 4096				; 00001000H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	BYTE PTR _bIgnoreEntityErrors$[ebp], cl

; 10663:    bIgnoreAttribErrors = (*plControl & zIGNORE_ATTRIB_ERRORS) ? 1 : 0;

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 8192				; 00002000H
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	BYTE PTR _bIgnoreAttribErrors$[ebp], al

; 10664: 
; 10665:    nErrorEntityLvl = 0;

	mov	WORD PTR _nErrorEntityLvl$[ebp], 0

; 10666:    nErrorEntityCnt = 0;

	mov	WORD PTR _nErrorEntityCnt$[ebp], 0

; 10667:    nErrorAttribCnt = 0;

	mov	WORD PTR _nErrorAttribCnt$[ebp], 0

; 10668: 
; 10669:    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 10670:    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 10671:    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 10672:    lpTask    = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 10673: 
; 10674:    // Initialize buffer pointers to indicate it hasn't been allocated yet.
; 10675:    pRelinkBufferEnd = pRelinkBufferPtr = 0;

	mov	DWORD PTR _pRelinkBufferPtr$[ebp], 0
	mov	eax, DWORD PTR _pRelinkBufferPtr$[ebp]
	mov	DWORD PTR _pRelinkBufferEnd$[ebp], eax

; 10676: 
; 10677:    // Process the stream
; 10678:    lpViewEntityCsr = 0;

	mov	DWORD PTR _lpViewEntityCsr$[ebp], 0

; 10679:    lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0
$L11163:

; 10680:    while ( (nEOF = (*lpfnStreamFunc)( lpView, lpvData,
; 10681:                                       &pchLine, 0, 0 )) == 1 )

	push	0
	push	0
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
	movsx	ecx, WORD PTR _nEOF$[ebp]
	cmp	ecx, 1
	jne	$L11164

; 10683:       lLineCount++;

	mov	edx, DWORD PTR _lLineCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _lLineCount$[ebp], edx

; 10684:       if ( pRelinkBufferPtr == pRelinkBufferEnd )

	mov	eax, DWORD PTR _pRelinkBufferPtr$[ebp]
	cmp	eax, DWORD PTR _pRelinkBufferEnd$[ebp]
	jne	$L11165

; 10686:          k = lEntityCnt / 160000;  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	DWORD PTR _k$[ebp], eax

; 10687: 
; 10688:          // If we've loaded 160000 * 10 entities then bomb.
; 10689:          if ( k > 10 )

	cmp	DWORD PTR _k$[ebp], 10			; 0000000aH
	jle	SHORT $L11166

; 10691:             // if the relink entity pointer is at the end of the
; 10692:             // space allocated, issue an error
; 10693:             //  "KZOEE090 - Maximum number of entities in portable file exceeded "
; 10694:             (*lpfnStreamFunc)( lpView, lpvData, 0, 0, 90 );

	push	90					; 0000005aH
	push	0
	push	0
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]

; 10695:             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 10696:             break;

	jmp	$L11164
$L11166:

; 10698: 
; 10699:          pRelinkBufferTable[ k ] =
; 10700:             (zPLONG) fnAllocDataspace( lpTask->hFirstDataHeader,
; 10701:                                        640000L, TRUE, 0, iRelinkBuffer );  // moved up from 64000 dks/don 2007.01.04

	push	10107					; 0000277bH
	push	0
	push	1
	push	640000					; 0009c400H
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _pRelinkBufferTable$[ebp+ecx*4], eax

; 10702: 
; 10703:          pRelinkBufferTable[ k ] = zGETPTR( pRelinkBufferTable[ k ] );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pRelinkBufferTable$[ebp+edx*4]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _pRelinkBufferTable$[ebp+ecx*4], eax

; 10704: 
; 10705:          pRelinkBufferEnd = pRelinkBufferTable[ k ] + 640000 / 4;  // Space for 160000 entities ... moved up from 16000 dks/don 2007.01.04

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pRelinkBufferTable$[ebp+edx*4]
	add	eax, 640000				; 0009c400H
	mov	DWORD PTR _pRelinkBufferEnd$[ebp], eax

; 10706:          pRelinkBufferPtr = pRelinkBufferTable[ k ];

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pRelinkBufferTable$[ebp+ecx*4]
	mov	DWORD PTR _pRelinkBufferPtr$[ebp], edx
$L11165:

; 10709: 
; 10710:       if ( nErrorEntityLvl )

	movsx	eax, WORD PTR _nErrorEntityLvl$[ebp]
	test	eax, eax
	je	$L11177

; 10712:          if ( pchLine[ 0 ] == 'e' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 101				; 00000065H
	jne	$L11170

; 10714:             SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_SysParseLine@12

; 10715:             if ( *plControl & zCOMPRESSED )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L11171

; 10716:                nLevel = (zSHORT) zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nLevel$[ebp], ax

; 10717:             else

	jmp	SHORT $L11173
$L11171:

; 10718:                nLevel = (zSHORT) zatol( pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nLevel$[ebp], ax
$L11173:

; 10719: 
; 10720:             if ( nLevel > nErrorEntityLvl )

	movsx	ecx, WORD PTR _nLevel$[ebp]
	movsx	edx, WORD PTR _nErrorEntityLvl$[ebp]
	cmp	ecx, edx
	jle	SHORT $L11175

; 10721:                pchLine[ 0 ] = ' ';

	mov	eax, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
$L11175:

; 10722: 
; 10723:             *pRelinkBufferPtr = 0;

	mov	ecx, DWORD PTR _pRelinkBufferPtr$[ebp]
	mov	DWORD PTR [ecx], 0

; 10724:             pRelinkBufferPtr++;

	mov	edx, DWORD PTR _pRelinkBufferPtr$[ebp]
	add	edx, 4
	mov	DWORD PTR _pRelinkBufferPtr$[ebp], edx

; 10725:             lEntityCnt++;

	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _lEntityCnt$[ebp], eax

; 10727:          else

	jmp	SHORT $L11177
$L11170:

; 10728:          if ( pchLine[ 0 ] == 'a' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 97					; 00000061H
	jne	SHORT $L11177

; 10729:             pchLine[ 0 ] = ' ';

	mov	eax, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
$L11177:

; 10731: 
; 10732:       if ( pchLine[ 0 ] == 'm' )  // Meta information

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 109				; 0000006dH
	jne	$L11178

; 10734:          // Meta information is information about the OI (as opposed to the
; 10735:          // info *in* the OI).
; 10736:          SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_SysParseLine@12

; 10737:          switch ( szWorkString[ 0 ] )
; 10738:          {

	mov	al, BYTE PTR _szWorkString$[ebp]
	mov	BYTE PTR -928+[ebp], al
	cmp	BYTE PTR -928+[ebp], 67			; 00000043H
	je	SHORT $L11183
	cmp	BYTE PTR -928+[ebp], 69			; 00000045H
	je	$L11192
	cmp	BYTE PTR -928+[ebp], 79			; 0000004fH
	je	$L11211
	jmp	$L11180
$L11183:

; 10739:             case 'C':
; 10740:                if ( zstrcmp( szWorkString, "CONTROL" ) == 0 )

	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	movsx	edx, BYTE PTR ??_C@_07ICJO@CONTROL?$AA@
	cmp	ecx, edx
	jne	SHORT $L12849
	push	OFFSET FLAT:??_C@_07ICJO@CONTROL?$AA@	; `string'
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -932+[ebp], eax
	jmp	SHORT $L12850
$L12849:
	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	movsx	edx, BYTE PTR ??_C@_07ICJO@CONTROL?$AA@
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -932+[ebp], eax
$L12850:
	cmp	DWORD PTR -932+[ebp], 0
	jne	SHORT $L11190

; 10741:                   lpViewOI->lActivateControl = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+48], eax
$L11190:

; 10742: 
; 10743:                break;

	jmp	$L11180
$L11192:

; 10744: 
; 10745:             case 'E':
; 10746:                if ( zstrcmp( szWorkString, "ETAG" ) == 0 )

	movsx	eax, BYTE PTR _szWorkString$[ebp]
	movsx	ecx, BYTE PTR ??_C@_04EECP@ETAG?$AA@
	cmp	eax, ecx
	jne	SHORT $L12851
	push	OFFSET FLAT:??_C@_04EECP@ETAG?$AA@	; `string'
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -936+[ebp], eax
	jmp	SHORT $L12852
$L12851:
	movsx	eax, BYTE PTR _szWorkString$[ebp]
	movsx	ecx, BYTE PTR ??_C@_04EECP@ETAG?$AA@
	sub	eax, ecx
	xor	edx, edx
	test	eax, eax
	setle	dl
	dec	edx
	and	edx, 2
	add	edx, -1
	mov	DWORD PTR -936+[ebp], edx
$L12852:
	cmp	DWORD PTR -936+[ebp], 0
	jne	SHORT $L11199

; 10747:                   lpEntityInstance->lTag = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+46], eax

; 10748:                else

	jmp	SHORT $L11208
$L11199:

; 10749:                if ( zstrcmp( szWorkString, "EKEY" ) == 0 )

	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR ??_C@_04BDIB@EKEY?$AA@
	cmp	edx, eax
	jne	SHORT $L12853
	push	OFFSET FLAT:??_C@_04BDIB@EKEY?$AA@	; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -940+[ebp], eax
	jmp	SHORT $L12854
$L12853:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR ??_C@_04BDIB@EKEY?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -940+[ebp], ecx
$L12854:
	cmp	DWORD PTR -940+[ebp], 0
	jne	SHORT $L11208

; 10750:                   lpEntityInstance->ulKey = (zULONG) zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+50], eax
$L11208:

; 10751: 
; 10752:                break;

	jmp	$L11180
$L11211:

; 10753: 
; 10754:             case 'O':
; 10755:                if ( zstrcmp( szWorkString, "OITAG" ) == 0 )

	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR ??_C@_05JDHD@OITAG?$AA@
	cmp	edx, eax
	jne	SHORT $L12855
	push	OFFSET FLAT:??_C@_05JDHD@OITAG?$AA@	; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -944+[ebp], eax
	jmp	SHORT $L12856
$L12855:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR ??_C@_05JDHD@OITAG?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -944+[ebp], ecx
$L12856:
	cmp	DWORD PTR -944+[ebp], 0
	jne	SHORT $L11218

; 10756:                   lpViewOI->lTag = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 10757:                else

	jmp	$L11231
$L11218:

; 10758:                if ( zstrcmp( szWorkString, "OIFLAGS" ) == 0 )

	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR ??_C@_07IFBG@OIFLAGS?$AA@
	cmp	edx, eax
	jne	SHORT $L12857
	push	OFFSET FLAT:??_C@_07IFBG@OIFLAGS?$AA@	; `string'
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -948+[ebp], eax
	jmp	SHORT $L12858
$L12857:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR ??_C@_07IFBG@OIFLAGS?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -948+[ebp], ecx
$L12858:
	cmp	DWORD PTR -948+[ebp], 0
	jne	SHORT $L11231

; 10760:                   zULONG uFlags = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _uFlags$11229[ebp], eax

; 10761: 
; 10762:                   // If zOI_ISLOCKED flag is set then the OI has pessimistic
; 10763:                   // locks set.
; 10764:                   if ( uFlags & zOI_ISLOCKED )

	mov	eax, DWORD PTR _uFlags$11229[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L11230

; 10765:                      lpViewOI->bIsLocked = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$L11230:

; 10766: 
; 10767:                   if ( uFlags & zOI_READONLY )

	mov	ecx, DWORD PTR _uFlags$11229[ebp]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L11231

; 10768:                      lpView->bReadOnly = TRUE;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, 64					; 00000040H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax
$L11231:
$L11180:

; 10774:       else

	jmp	$L11505
$L11178:

; 10775:       if ( pchLine[ 0 ] == 'e' )  // Entity type

	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 101				; 00000065H
	jne	$L11233

; 10777:          SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_SysParseLine@12

; 10778:          if ( *plControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L11234

; 10779:             nLevel = (zSHORT) zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nLevel$[ebp], ax

; 10780:          else

	jmp	SHORT $L11236
$L11234:

; 10781:             nLevel = (zSHORT) zatol( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nLevel$[ebp], ax
$L11236:

; 10782: 
; 10783:          if ( *plControl & zINCREMENTAL )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	SHORT $L11244
$L11240:

; 10785:             while ( pchLine[ 0 ] != ',' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	je	SHORT $L11241

; 10786:                pchLine++;

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchLine$[ebp], eax
	jmp	SHORT $L11240
$L11241:

; 10787: 
; 10788:             pchLine++;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLine$[ebp], ecx

; 10789:             lPrevIndicators = lIndicators;

	mov	edx, DWORD PTR _lIndicators$[ebp]
	mov	DWORD PTR _lPrevIndicators$[ebp], edx

; 10790: 
; 10791:             if ( *plControl & zCOMPRESSED )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L11242

; 10792:                lIndicators = (zLONG) zxtob( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lIndicators$[ebp], eax

; 10793:             else

	jmp	SHORT $L11244
$L11242:

; 10794:                lIndicators = (zLONG) zatob( pchLine ); /* HH, 14.10.96 */

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lIndicators$[ebp], eax
$L11244:

; 10799:             zSHORT nHierNbr;
; 10800: 
; 10801:             lpViewEntity    = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10802:             lpViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 10803: 
; 10804:             // If the root cursor is not the first cursor, skip ViewEntities
; 10805:             // until we get to the entity matching the root cursor
; 10806:             if ( lpViewEntityCsr != zGETPTR( lpViewCsr->hFirstOD_EntityCsr ) )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpViewEntityCsr$[ebp], eax
	je	SHORT $L11258

; 10808:                LPVIEWENTITYCSR lpSearchViewEntityCsr;
; 10809: 
; 10810:                lpSearchViewEntityCsr =
; 10811:                                     zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntityCsr$11254[ebp], eax
$L11257:

; 10812: 
; 10813:                while ( lpSearchViewEntityCsr != lpViewEntityCsr )

	mov	eax, DWORD PTR _lpSearchViewEntityCsr$11254[ebp]
	cmp	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	je	SHORT $L11258

; 10815:                   lpViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10816:                   lpSearchViewEntityCsr++;

	mov	eax, DWORD PTR _lpSearchViewEntityCsr$11254[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpSearchViewEntityCsr$11254[ebp], eax

; 10817:                }

	jmp	SHORT $L11257
$L11258:

; 10819: 
; 10820:             if ( *plControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L11260

; 10821:                nHierNbr = (zSHORT) zxtol( szWorkString );

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nHierNbr$11249[ebp], ax
$L11260:

; 10822: 
; 10823:             while ( lpViewEntityCsr )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	$L11264

; 10825:                if ( *plControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L11265

; 10827:                   if ( lpViewEntity->nHierNbr == nHierNbr )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	movsx	edx, WORD PTR _nHierNbr$11249[ebp]
	cmp	ecx, edx
	jne	SHORT $L11266

; 10828:                      break;

	jmp	$L11264
$L11266:

; 10830:                else

	jmp	SHORT $L11274
$L11265:

; 10831:                if ( zstrcmp( lpViewEntity->szName, szWorkString ) == 0 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	cmp	ecx, edx
	jne	SHORT $L12859
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -952+[ebp], eax
	jmp	SHORT $L12860
$L12859:
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, BYTE PTR [edx+14]
	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	sub	eax, ecx
	xor	edx, edx
	test	eax, eax
	setle	dl
	dec	edx
	and	edx, 2
	add	edx, -1
	mov	DWORD PTR -952+[ebp], edx
$L12860:
	cmp	DWORD PTR -952+[ebp], 0
	jne	SHORT $L11274

; 10832:                   break;

	jmp	SHORT $L11264
$L11274:

; 10833: 
; 10834:                lpViewEntity    = zGETPTR( lpViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10835:                lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 10836:             }

	jmp	$L11260
$L11264:

; 10837: 
; 10838:             if ( lpViewEntityCsr == 0 )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	jne	SHORT $L11277

; 10840:                // OK, No cursor was found in the current view, if there are
; 10841:                // outstanding subobjects, do a reset and try again to find
; 10842:                // the entity
; 10843:                if ( lpViewCsr->hFirstViewSubobject )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $L11278

; 10844:                   fnResetViewFromSubobject( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnResetViewFromSubobject
	add	esp, 4

; 10845:                else

	jmp	SHORT $L11279
$L11278:

; 10847:                   lpViewEntity = 0;

	mov	DWORD PTR _lpViewEntity$[ebp], 0

; 10848:                   break;  // Ouch, Entity does not exist, give up

	jmp	$L11248
$L11279:

; 10851:             else

	jmp	$L11288
$L11277:

; 10853:                // We've found a cursor which matches the entity type
; 10854:                // now check to see if a SetViewToSubobject or a reset is
; 10855:                // needed to create the entity at the appropriate level
; 10856:                if ( lpViewEntityCsr->nLevel == nLevel )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	jne	SHORT $L11281

; 10858:                   break;

	jmp	$L11248
$L11281:

; 10860:                else
; 10861:                if ( lpViewEntityCsr->nLevel > nLevel )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	jle	SHORT $L11283

; 10863:                   if ( lpViewCsr->hFirstViewSubobject == 0 )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [eax+30], 0
	jne	SHORT $L11284

; 10864:                      break;

	jmp	SHORT $L11248
$L11284:

; 10865: 
; 10866:                   while ( lpViewEntityCsr->nLevel > nLevel &&
; 10867:                           lpViewCsr->hFirstViewSubobject )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	edx, eax
	jle	SHORT $L11287
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $L11287

; 10869:                      fnResetViewFromSubobject( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnResetViewFromSubobject
	add	esp, 4

; 10870:                   }

	jmp	SHORT $L11284
$L11287:

; 10872:                else

	jmp	SHORT $L11288
$L11283:

; 10874:                   // The view entity csr level is < the entity level.
; 10875:                   // In this case, the current (last) instance must be the
; 10876:                   // parent of the instance we are about to create and
; 10877:                   // it must have recursive behaviour. Otherwise we will
; 10878:                   // drop out and issue a level error
; 10879:                   if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L11292

; 10881:                      LPVIEWENTITY lpWkViewEntity =
; 10882:                                  zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$11290[ebp], eax

; 10883: 
; 10884:                      if ( lpWkViewEntity->bRecursive )

	mov	edx, DWORD PTR _lpWkViewEntity$11290[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	test	eax, eax
	je	SHORT $L11292

; 10885:                         fnSetViewToSubobject( lpView, lpWkViewEntity, 0 );

	push	0
	mov	ecx, DWORD PTR _lpWkViewEntity$11290[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH
$L11292:

; 10887: 
; 10888:                   break;

	jmp	SHORT $L11248
$L11288:

; 10891:          }  // for ( ; ; )...

	jmp	$L11244
$L11248:

; 10892: 
; 10893:          bSkipAttributes = FALSE;

	mov	BYTE PTR _bSkipAttributes$[ebp], 0

; 10894: 
; 10895:          if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $L11293

; 10897:             // Let's at least trace it out.
; 10898:             TraceLineS( "(WARNING) Couldn't find entity ", szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CA@GEOJ@?$CIWARNING?$CJ?5Couldn?8t?5find?5entity?5?$AA@ ; `string'
	call	_TraceLineS@8

; 10899:             TraceLineS( "(WARNING) in LOD ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0BC@FECF@?$CIWARNING?$CJ?5in?5LOD?5?$AA@ ; `string'
	call	_TraceLineS@8

; 10900: 
; 10901:             if ( bIgnoreEntityErrors == FALSE || nLevel == 1 )

	mov	edx, DWORD PTR _bIgnoreEntityErrors$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L11297
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 1
	jne	SHORT $L11296
$L11297:

; 10903:                //  "KZOEE074 - Invalid Entity name on line "
; 10904:                (*lpfnStreamFunc)( lpView, lpvData, (zPPCHAR) szWorkString, 0, 74 );

	push	74					; 0000004aH
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]

; 10905:                nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 10906:                break;

	jmp	$L11164
$L11296:

; 10908: 
; 10909:             nErrorEntityLvl = nLevel;

	mov	cx, WORD PTR _nLevel$[ebp]
	mov	WORD PTR _nErrorEntityLvl$[ebp], cx

; 10910:             nErrorEntityCnt++;

	mov	dx, WORD PTR _nErrorEntityCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nErrorEntityCnt$[ebp], dx

; 10912:          else

	jmp	$L11306
$L11293:

; 10913:          if ( *plControl & zACTIVATE_ROOTONLY && nLevel > 1 )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 268435456				; 10000000H
	test	ecx, ecx
	je	SHORT $L11300
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 1
	jle	SHORT $L11300

; 10915:             // Current entity is not a root and user indicated that she only
; 10916:             // wants roots.  Set flag to indicate we want to skip setting
; 10917:             // attribute values.
; 10918:             bSkipAttributes = TRUE;

	mov	BYTE PTR _bSkipAttributes$[ebp], 1

; 10919:             continue;

	jmp	$L11163
$L11300:

; 10921:          else
; 10922:          if ( lpViewEntityCsr->nLevel != nLevel )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	je	SHORT $L11302

; 10924:             // if the view cursor level does not equal the entity
; 10925:             // level coming in, issue an error
; 10926:             //  "KZOEE075 - Invalid Entity level on line "
; 10927:             (*lpfnStreamFunc)( lpView, lpvData, (zPPCHAR) szWorkString, 0, 75 );

	push	75					; 0000004bH
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]

; 10928:             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 10929:             break;

	jmp	$L11164
$L11302:

; 10933:             if ( nLevel == 1 && lpViewEntityCsr->hEntityInstance &&
; 10934:                  lpViewOI->bMultipleRootLevels == FALSE )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 1
	jne	SHORT $L11305
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $L11305
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L11305

; 10936:                // Doing this stuff means that there are multiple level 1
; 10937:                // roots in the the file, but that the user has requested
; 10938:                // activation of the the instance with zSINGLE rather than
; 10939:                // zMULTIPLE.  We will act like the EOF condition has
; 10940:                // occurred and set return code to indicate that we found
; 10941:                // multiple roots.
; 10942:                nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1

; 10943:                bSkipAttributes = TRUE;

	mov	BYTE PTR _bSkipAttributes$[ebp], 1

; 10944:                continue;

	jmp	$L11163
$L11305:

; 10948:                nRC = fnCreateEntity( lpView, lpViewEntity,
; 10949:                                      lpViewEntityCsr, zPOS_AFTER, 0 );

	push	0
	push	3
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCreateEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 10950:                if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L11308

; 10951:                   break;

	jmp	$L11164
$L11308:

; 10952: 
; 10953:                nErrorEntityLvl = 0;

	mov	WORD PTR _nErrorEntityLvl$[ebp], 0
$L11306:

; 10956: 
; 10957:          // The current entity is compressed if:
; 10958:          // o  The portable file is stored in compressed format.
; 10959:          // o  The max size of all the attributes for the entity is smaller
; 10960:          //    then the buffer we set up to hold all the attribute values.
; 10961:          bEntityIsCompressed = (*plControl & zCOMPRESSED) &&
; 10962:                                (lpViewEntity->ulMaxLth < zENTITY_BUFFER_SIZE);

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L12861
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [ecx+203], 10000		; 00002710H
	jae	SHORT $L12861
	mov	DWORD PTR -956+[ebp], 1
	jmp	SHORT $L12862
$L12861:
	mov	DWORD PTR -956+[ebp], 0
$L12862:
	mov	dl, BYTE PTR -956+[ebp]
	mov	BYTE PTR _bEntityIsCompressed$[ebp], dl

; 10963: 
; 10964:          if ( nErrorEntityLvl == 0 )

	movsx	eax, WORD PTR _nErrorEntityLvl$[ebp]
	test	eax, eax
	jne	$L11309

; 10966:             // if this is not the first instance, set the indicators on
; 10967:             // the previous instance. NOTE this is done after all updates
; 10968:             // so the update flag can be reset!
; 10969:             if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L11316

; 10971:                if ( *plControl & zINCREMENTAL )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 65536				; 00010000H
	test	edx, edx
	je	$L11311

; 10973:                   lpEntityInstance->u.nIndicators = lPrevIndicators;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lPrevIndicators$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 10974:                   lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	ah, -2					; fffffffeH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 10975: 
; 10976:                   // A hack to make sure that a delete/excluded entity is
; 10977:                   // flagged as hidden.  This tries to fix a bug.
; 10978:                   if ( lpEntityInstance->u.nInd.bDeleted  ||
; 10979:                        lpEntityInstance->u.nInd.bExcluded )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $L11313
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L11312
$L11313:

; 10981:                      lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ch, 4
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L11312:

; 10983: 
; 10984:                   if ( lpEntityInstance->u.nInd.bCreated  ||
; 10985:                        lpEntityInstance->u.nInd.bDeleted  ||
; 10986:                        lpEntityInstance->u.nInd.bIncluded ||
; 10987:                        lpEntityInstance->u.nInd.bExcluded ||
; 10988:                        lpEntityInstance->u.nInd.bUpdated )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L11315
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $L11315
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	test	edx, edx
	jne	SHORT $L11315
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L11315
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $L11314
$L11315:

; 10990:                      bOI_IsUpdated = TRUE;

	mov	BYTE PTR _bOI_IsUpdated$[ebp], 1
$L11314:

; 10993:                else

	jmp	SHORT $L11316
$L11311:

; 10994:                   lpEntityInstance->u.nInd.bUpdated = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$L11316:

; 10996: 
; 10997:             // Set lpEntityInstance to instance just created.
; 10998:             lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 10999:             *pRelinkBufferPtr = (zLONG) lpEntityInstance;

	mov	eax, DWORD PTR _pRelinkBufferPtr$[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax], ecx

; 11000:             pRelinkBufferPtr++;

	mov	edx, DWORD PTR _pRelinkBufferPtr$[ebp]
	add	edx, 4
	mov	DWORD PTR _pRelinkBufferPtr$[ebp], edx

; 11001:             lEntityCnt++;

	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _lEntityCnt$[ebp], eax

; 11002:             lpEntityInstance->u.nInd.bCreated = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 2
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 11003:             lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	dh, -2					; fffffffeH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 11005:          else

	jmp	SHORT $L11320
$L11309:

; 11007:             *pRelinkBufferPtr = 0;

	mov	ecx, DWORD PTR _pRelinkBufferPtr$[ebp]
	mov	DWORD PTR [ecx], 0

; 11008:             pRelinkBufferPtr++;

	mov	edx, DWORD PTR _pRelinkBufferPtr$[ebp]
	add	edx, 4
	mov	DWORD PTR _pRelinkBufferPtr$[ebp], edx

; 11009:             lEntityCnt++;

	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _lEntityCnt$[ebp], eax

; 11010: 
; 11011:             // If we're ignoring errors then set the error code back to 0
; 11012:             // so that we can keep processing entities.
; 11013:             if ( bIgnoreEntityErrors )

	mov	ecx, DWORD PTR _bIgnoreEntityErrors$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L11320

; 11014:                nErrorEntityLvl = 0;

	mov	WORD PTR _nErrorEntityLvl$[ebp], 0
$L11320:

; 11017:       else

	jmp	$L11505
$L11233:

; 11018:       if ( pchLine[ 0 ] == 'a' && lpViewEntity )  // Attrib and entity exists

	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 97					; 00000061H
	jne	$L11322
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	$L11322

; 11020:          LPATTRIBFLAGS     lpAttribFlags;
; 11021:          AttribFlagsRecord AttribFlags;
; 11022: 
; 11023:          if ( bEntityIsCompressed && pchLine[ 1 ] == ' ' )

	mov	ecx, DWORD PTR _bEntityIsCompressed$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	$L11325
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 32					; 00000020H
	jne	$L11325

; 11025:             zPCHAR pchStart;
; 11026: 
; 11027:             // The entity is stored in a compressed format.  The line we just
; 11028:             // read contains an 'a' followed by the length of all the attribute
; 11029:             // data in hex.
; 11030:             ulLth = zxtol( pchLine + 2 );

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 2
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ulLth$[ebp], eax

; 11031:             nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, ulLth, 0 );

	push	0
	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax

; 11032:             if ( nEOF != 1 )

	movsx	eax, WORD PTR _nEOF$[ebp]
	cmp	eax, 1
	je	SHORT $L11327

; 11034:                nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11035:                break;

	jmp	$L11164
$L11327:

; 11037: 
; 11038:             pchStart = pchLine;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	mov	DWORD PTR _pchStart$11326[ebp], ecx

; 11039: 
; 11040:             // If bSkipAttributes is TRUE, then we need to skip over these attributes.
; 11041:             if ( bSkipAttributes )

	mov	edx, DWORD PTR _bSkipAttributes$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L11328

; 11042:                continue;

	jmp	$L11163
$L11328:

; 11043: 
; 11044:             // pchLine should now point to a buffer containing all the
; 11045:             // attribute values.  Copy each value to the entity.
; 11046:             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 11047:                   lpViewAttrib;
; 11048:                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L11331
$L11332:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L11331:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$L11333

; 11050:                if ( lpViewAttrib->szDerivedOper[ 0 ] &&
; 11051:                     lpViewAttrib->bPersist == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+213]
	test	edx, edx
	je	SHORT $L11334
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L11334

; 11053:                   continue;

	jmp	SHORT $L11332
$L11334:

; 11055: 
; 11056:                if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $L11335

; 11057:                   continue;

	jmp	SHORT $L11332
$L11335:

; 11058: 
; 11059:                if ( *pchLine == 0 )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L11336

; 11061:                   // Attribute value is null.  Skip over 0.
; 11062:                   pchLine++;

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchLine$[ebp], eax

; 11063: 
; 11064:                   // Make sure that a record (data stick exists).
; 11065:                   if ( (lpViewAttrib->bPersist &&
; 11066:                         lpEntityInstance->hPersistRecord == 0) ||
; 11067:                        (lpViewAttrib->bPersist == FALSE &&
; 11068:                         lpEntityInstance->hNonPersistRecord == 0) )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	test	edx, edx
	je	SHORT $L11339
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+60], 0
	je	SHORT $L11338
$L11339:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	test	edx, edx
	jne	SHORT $L11340
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+64], 0
	jne	SHORT $L11340
$L11338:

; 11070:                      // Set a null value so that the record gets created.
; 11071:                      if ( fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11072:                                                     lpViewAttrib,
; 11073:                                                     "", 0 ) != 0 )

	push	0
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11340

; 11075:                         nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11076:                         break;

	jmp	$L11333
$L11340:

; 11080:                else

	jmp	$L11341
$L11336:

; 11082:                   if ( lpViewAttrib->cType == zTYPE_INTEGER )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $L11342

; 11084:                      zLONG l;
; 11085: 
; 11086:                      l = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _l$11343[ebp], eax

; 11087:                      if ( fnSetAttributeFromInteger( lpView, lpViewEntityCsr,
; 11088:                                                      lpViewAttrib, l ) != 0 )

	mov	edx, DWORD PTR _l$11343[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromInteger
	add	esp, 16					; 00000010H
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11344

; 11090:                         nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11091:                         break;

	jmp	$L11333
$L11344:

; 11094:                   else

	jmp	SHORT $L11346
$L11342:

; 11096:                      if ( fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11097:                                                     lpViewAttrib,
; 11098:                                                     pchLine, 0 ) != 0 )

	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L11346

; 11100:                         nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11101:                         break;

	jmp	SHORT $L11333
$L11346:

; 11104: 
; 11105:                   pchLine += zstrlen( pchLine ) + 1;

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchLine$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchLine$[ebp], edx
$L11341:

; 11107: 
; 11108:                // Now set the attribute flags.
; 11109:                if ( (*plControl & zINCREMENTAL) &&
; 11110:                     (*plControl & zATTRIBFLAGS) )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 65536				; 00010000H
	test	ecx, ecx
	je	SHORT $L11347
	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 33554432				; 02000000H
	test	eax, eax
	je	SHORT $L11347

; 11112:                   lpAttribFlags = fnGetAttribFlagsPtr( lpEntityInstance,
; 11113:                                                        lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$11323[ebp], eax

; 11114:                   lpAttribFlags->u.uFlags = zxtob( pchLine );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpAttribFlags$11323[ebp]
	mov	DWORD PTR [ecx], eax

; 11115: 
; 11116:                   pchLine += zstrlen( pchLine ) + 1;

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchLine$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchLine$[ebp], edx
$L11347:

; 11118:             }

	jmp	$L11332
$L11333:

; 11119: 
; 11120:             if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L11348

; 11121:                break;

	jmp	$L11164
$L11348:

; 11122: 
; 11123:             // Continue with the next line in the file.
; 11124:             continue;

	jmp	$L11163
$L11325:

; 11127: 
; 11128:          // If we get here, then bEntityIsCompressed is FALSE.  But it's still
; 11129:          // possible that the OI is stored in a compressed format--it's just
; 11130:          // that the attributes couldn't be squeezed into one line.  If the OI
; 11131:          // is compressed, then the attribute names are stored as the XVA
; 11132:          // tokens instead of the names.
; 11133: 
; 11134:          // First get the attribute name/number into szWorkString.  The end of
; 11135:          // the name/number is indicated when we find a space or comma.
; 11136:          for ( k = 0, pchLine++;
; 11137:                pchLine[ k ] && pchLine[ k ] != ' ' && pchLine[ k ] != ',';
; 11138:                k++ )

	mov	DWORD PTR _k$[ebp], 0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLine$[ebp], ecx
	jmp	SHORT $L11349
$L11350:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$L11349:
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L11351
	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $L11351
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	je	SHORT $L11351

; 11140:             szWorkString[ k ] = pchLine[ k ];

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR _szWorkString$[ebp+ecx], dl

; 11141:          }

	jmp	SHORT $L11350
$L11351:

; 11142: 
; 11143:          // Terminate szWorkString.
; 11144:          szWorkString[ k ] = 0;

	mov	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 0

; 11145: 
; 11146:          // If the next char in the line is a comma then we also need to
; 11147:          // retrieve the attribute flags.
; 11148:          if ( pchLine[ k ] == ',' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	jne	$L11352

; 11150:             zCHAR  szAttribFlags[ 12 ];
; 11151:             zSHORT j;
; 11152: 
; 11153:             k++;  // Skip over the ','.

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 11154:             j = 0;

	mov	WORD PTR _j$11354[ebp], 0
$L11356:

; 11155:             while ( pchLine[ k ] && pchLine[ k ] != ' ' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L11357
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $L11357

; 11156:                szAttribFlags[ j++ ] = pchLine[ k++ ];

	movsx	edx, WORD PTR _j$11354[ebp]
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szAttribFlags$11353[ebp+edx], cl
	mov	dx, WORD PTR _j$11354[ebp]
	add	dx, 1
	mov	WORD PTR _j$11354[ebp], dx
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $L11356
$L11357:

; 11157: 
; 11158:             szAttribFlags[ j ] = 0;

	movsx	ecx, WORD PTR _j$11354[ebp]
	mov	BYTE PTR _szAttribFlags$11353[ebp+ecx], 0

; 11159: 
; 11160:             AttribFlags.u.uFlags = zxtob( szAttribFlags );

	push	16					; 00000010H
	push	0
	lea	edx, DWORD PTR _szAttribFlags$11353[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _AttribFlags$11324[ebp], eax

; 11162:          else

	jmp	SHORT $L11359
$L11352:

; 11164:             // If flags aren't specified then they are assumed 0 *unless* this
; 11165:             // OI wasn't stored with attrib flags (this means it was stored
; 11166:             // with a pre-10a version).  In this case we have to assume that
; 11167:             // every attribute has been changed.
; 11168:             AttribFlags.u.uFlags = 0; // Turn off all flags.

	mov	DWORD PTR _AttribFlags$11324[ebp], 0

; 11169:             if ( (*plControl & zATTRIBFLAGS ) == 0 )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 33554432				; 02000000H
	test	ecx, ecx
	jne	SHORT $L11359

; 11171:                // No attrib flags--turn on 'changed' bit.
; 11172:                AttribFlags.u.bFlags.bUpdated = TRUE;

	mov	edx, DWORD PTR _AttribFlags$11324[ebp]
	or	edx, 2
	mov	DWORD PTR _AttribFlags$11324[ebp], edx
$L11359:

; 11175: 
; 11176:          if ( *plControl & zCOMPRESSED )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L11360

; 11178:             zLONG lXVATok;
; 11179: 
; 11180:             // Point pchLine to first char of attribute value if there is
; 11181:             // more info after the attribute name.
; 11182:             if ( pchLine[ k ] )

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L11362

; 11183:                pchLine += k + 1;

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pchLine$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	mov	DWORD PTR _pchLine$[ebp], eax
$L11362:

; 11184: 
; 11185:             lXVATok = zxtol( szWorkString );

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lXVATok$11361[ebp], eax

; 11186: 
; 11187:             // Look for the attribute that matches the XVA token.
; 11188:             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 11189:                   lpViewAttrib && lpViewAttrib->lXVAAttTok != lXVATok;
; 11190:                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L11365
$L11366:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L11365:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $L11367
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+181]
	cmp	ecx, DWORD PTR _lXVATok$11361[ebp]
	je	SHORT $L11367

; 11192:                // nothing needs to be done here
; 11193:             }

	jmp	SHORT $L11366
$L11367:

; 11195:          else

	jmp	SHORT $L11376
$L11360:

; 11197:             // Point pchLine to first char of attribute value if there is
; 11198:             // more info after the attribute name.
; 11199: 
; 11200:             // Skip over any blanks that filled out the name.
; 11201:             if ( pchLine[ k ] )

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L11371

; 11203:                if ( k < 9 )

	cmp	DWORD PTR _k$[ebp], 9
	jge	SHORT $L11370

; 11204:                   pchLine += 10;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _pchLine$[ebp], ecx

; 11205:                else

	jmp	SHORT $L11371
$L11370:

; 11206:                   pchLine += k + 1;

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pchLine$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	mov	DWORD PTR _pchLine$[ebp], ecx
$L11371:

; 11208: 
; 11209:             // Look for the attribute that matches the attribute name.
; 11210:             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 11211:                   lpViewAttrib;
; 11212:                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L11374
$L11375:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L11374:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $L11376

; 11214:                if ( zstrcmpi( lpViewAttrib->szName, szWorkString ) == 0 )

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L11377

; 11215:                   break;

	jmp	SHORT $L11376
$L11377:

; 11216:             }

	jmp	SHORT $L11375
$L11376:

; 11218: 
; 11219:          // If entity not found return error.
; 11220:          if ( lpViewAttrib == 0 )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $L11378

; 11222:             if ( bIgnoreAttribErrors == FALSE )

	mov	edx, DWORD PTR _bIgnoreAttribErrors$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L11379

; 11224:                zCHAR sz[ 400 ];
; 11225: 
; 11226:                zstrcpy( sz, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _sz$11380[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 11227:                zstrcat( sz, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	edx, DWORD PTR _sz$11380[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 11228:                zstrcat( sz, szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sz$11380[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 11229: 
; 11230:                //  "KZOEE104 - Invalid Attribute name for Entity"
; 11231:                (*lpfnStreamFunc)( lpView, lpvData, (zPPCHAR) sz, 0, 104 );

	push	104					; 00000068H
	push	0
	lea	edx, DWORD PTR _sz$11380[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
$L11379:

; 11238: 
; 11239:             nErrorAttribCnt++;

	mov	dx, WORD PTR _nErrorAttribCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nErrorAttribCnt$[ebp], dx

; 11241:          else

	jmp	$L11420
$L11378:

; 11242:          if ( lpViewAttrib->cType == zTYPE_BLOB ||
; 11243:               (lpViewAttrib->cType == zTYPE_STRING &&
; 11244:                *pchLine == zSTRING_STORED_AS_BLOB) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	je	SHORT $L11385
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 83					; 00000053H
	jne	$L11384
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 31					; 0000001fH
	jne	$L11384
$L11385:

; 11246:             // If a string is stored with special characters (e.g. '\n') then
; 11247:             // is is stored as a blob.  This is indicated if the first char
; 11248:             // in pchLine is zSTRING_STORED_AS_BLOB.
; 11249:             if ( lpViewAttrib->cType == zTYPE_STRING &&
; 11250:                  *pchLine == zSTRING_STORED_AS_BLOB )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $L11386
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 31					; 0000001fH
	jne	SHORT $L11386

; 11252:                pchLine++;  // Point pchLine past zSTRING_STORED_AS_BLOB.

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLine$[ebp], ecx

; 11253:                ulLth = zatol( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 11254:                if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $L11387

; 11255:                   nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, ulLth, 0 );

	push	0
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
$L11387:

; 11257:             else // must be blob, so need to check for encoding

	jmp	$L11407
$L11386:

; 11259:                ulLthDecoded = 0;

	mov	DWORD PTR _ulLthDecoded$[ebp], 0

; 11260:                if ( *pchLine == zBLOB_STORED_ENCODED )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 85					; 00000055H
	jne	$L11389

; 11262:                   pchLine++;  // point pchLine past zBLOB_STORED_ENCODED

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchLine$[ebp], eax

; 11263:                   ulLth = zatol( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 11264:                   if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	$L11404

; 11266:                      // If are ignoring attributes, just skip the encoded lines.
; 11267:                      if ( bSkipAttributes )

	mov	edx, DWORD PTR _bSkipAttributes$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L11391

; 11269:                         nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
$L11393:

; 11270:                         while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L11394

; 11272:                            if ( *pchLine == 0x60 )  // terminating "`" line

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 96					; 00000060H
	jne	SHORT $L11395

; 11273:                               break;

	jmp	SHORT $L11394
$L11395:

; 11274: 
; 11275:                            nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax

; 11276:                         }

	jmp	SHORT $L11393
$L11394:

; 11278:                      else

	jmp	$L11404
$L11391:

; 11280:                         // Init the blob attribute to have a buffer for decoding.
; 11281:                         if ( fnSetAttributeFromBlob( lpView, lpViewEntityCsr,
; 11282:                                                      lpViewAttrib,
; 11283:                                                      0, ulLth ) != 0 )

	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromBlob
	add	esp, 20					; 00000014H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11397

; 11285:                            nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11286:                            break;

	jmp	$L11164
$L11397:

; 11288: 
; 11289:                         fnGetAddrForAttribute( &pchAttr, lpView, lpViewEntityCsr, 0,
; 11290:                                                lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchAttr$[ebp]
	push	edx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 11291: 
; 11292:                         // Now decode the blob lines until the 'zero length' line is found.
; 11293:                         uPos = 0;

	mov	DWORD PTR _uPos$[ebp], 0

; 11294:                         nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
$L11399:

; 11295:                         while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	SHORT $L11400

; 11297:                            nRC = UUDECODE_NextLineToBuffer( pchLine, pchAttr, ulLth, &uPos );

	lea	ecx, DWORD PTR _uPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchAttr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	_UUDECODE_NextLineToBuffer@16
	mov	WORD PTR _nRC$[ebp], ax

; 11298:                            //TraceLineS( "Decoded Line: ", pchLine);
; 11299:                            if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L11401

; 11301:                               TraceLineI( "Error from UUDECODE_NextLineToBuffer: ", nRC );

	movsx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CH@HIC@Error?5from?5UUDECODE_NextLineToBu@ ; `string'
	call	_TraceLineI@8

; 11302:                               nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11303:                               break;

	jmp	SHORT $L11400
$L11401:

; 11305: 
; 11306:                            if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L11403

; 11307:                               break;

	jmp	SHORT $L11400
$L11403:

; 11308: 
; 11309:                            ulLthDecoded = ulLthDecoded + nRC;

	movsx	edx, WORD PTR _nRC$[ebp]
	mov	eax, DWORD PTR _ulLthDecoded$[ebp]
	add	eax, edx
	mov	DWORD PTR _ulLthDecoded$[ebp], eax

; 11310:                            nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax

; 11311:                         }

	jmp	SHORT $L11399
$L11400:

; 11312: 
; 11313:                         if ( ulLthDecoded != ulLth )

	mov	ecx, DWORD PTR _ulLthDecoded$[ebp]
	cmp	ecx, DWORD PTR _ulLth$[ebp]
	je	SHORT $L11404

; 11315:                            TraceLineI( "UUDECODE length invalid: ", ulLthDecoded );

	mov	edx, DWORD PTR _ulLthDecoded$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BK@FNGM@UUDECODE?5length?5invalid?3?5?$AA@ ; `string'
	call	_TraceLineI@8

; 11316:                            nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11317:                            break;

	jmp	$L11164
$L11404:

; 11322:                else

	jmp	SHORT $L11407
$L11389:

; 11324:                   ulLth = zatol( pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 11325:                   if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $L11407

; 11326:                      nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, ulLth, 0 );

	push	0
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
$L11407:

; 11329: 
; 11330:          // ulLth = zatol( pchLine );
; 11331:             if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	$L11408

; 11333:             // nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, ulLth, 0 );
; 11334:                if ( nEOF != 1 )

	movsx	edx, WORD PTR _nEOF$[ebp]
	cmp	edx, 1
	je	SHORT $L11409

; 11336:                   nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11337:                   break;

	jmp	$L11164
$L11409:

; 11339: 
; 11340:                lLineCount++;

	mov	eax, DWORD PTR _lLineCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _lLineCount$[ebp], eax

; 11341: 
; 11342:                // If bSkipAttributes is TRUE, then we need to skip over these attributes.
; 11343:                if ( bSkipAttributes )

	mov	ecx, DWORD PTR _bSkipAttributes$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L11410

; 11344:                   continue;

	jmp	$L11163
$L11410:

; 11345: 
; 11346:                if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $L11411

; 11348:                   if ( ulLthDecoded > 0 )

	cmp	DWORD PTR _ulLthDecoded$[ebp], 0
	jbe	SHORT $L11412

; 11352:                   else

	jmp	SHORT $L11414
$L11412:

; 11354:                      if ( fnSetAttributeFromBlob( lpView, lpViewEntityCsr,
; 11355:                                                   lpViewAttrib,
; 11356:                                                   pchLine, ulLth ) != 0 )

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromBlob
	add	esp, 20					; 00000014H
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11414

; 11358:                         nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11359:                         break;

	jmp	$L11164
$L11414:

; 11363:                else

	jmp	SHORT $L11416
$L11411:

; 11365:                   // PAS 03-09-2001 - x00 is no longer put at the end of
; 11366:                   //                  a string that was stored as a BLOB
; 11367:                   //                  (with length), so always terminate
; 11368:                   pchLine[ ulLth - 1 ] = 0;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [ecx-1], 0

; 11369:                   if ( fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11370:                                                  lpViewAttrib,
; 11371:                                                  pchLine, 0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11416

; 11373:                      nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11374:                      break;

	jmp	$L11164
$L11416:

; 11378:             else

	jmp	SHORT $L11418
$L11408:

; 11379:                // If bSkipAttributes is TRUE, then we need to skip over these attributes.
; 11380:                if ( bSkipAttributes )

	mov	ecx, DWORD PTR _bSkipAttributes$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L11418

; 11381:                   continue;

	jmp	$L11163
$L11418:

; 11382: 
; 11383:             // Now set the attribute flags.
; 11384:             lpAttribFlags = fnGetAttribFlagsPtr( zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 11385:                                                  lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$11323[ebp], eax

; 11386:             lpAttribFlags->u.uFlags = AttribFlags.u.uFlags;

	mov	edx, DWORD PTR _lpAttribFlags$11323[ebp]
	mov	eax, DWORD PTR _AttribFlags$11324[ebp]
	mov	DWORD PTR [edx], eax

; 11388:          else

	jmp	$L11420
$L11384:

; 11390:             // If bSkipAttributes is TRUE, then we need to skip over these attributes.
; 11391:             if ( bSkipAttributes )

	mov	ecx, DWORD PTR _bSkipAttributes$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L11421

; 11392:                continue;

	jmp	$L11163
$L11421:

; 11393: 
; 11394:             if ( *plControl & zCOMPRESSED &&
; 11395:                  lpViewAttrib->cType == zTYPE_INTEGER )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	$L11422
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 76					; 0000004cH
	jne	$L11422

; 11397:                zLONG  l;
; 11398: 
; 11399:                if ( *pchLine == '*' )

	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $L11424

; 11401:                   // Integer attribute is NULL.
; 11402:                   fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11403:                                             lpViewAttrib, "", 0 );

	push	0
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H

; 11405:                else

	jmp	SHORT $L11428
$L11424:

; 11407:                   if ( *pchLine == '-' )

	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $L11426

; 11408:                      l = zxtol( pchLine + 1 ) * -1;

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	imul	eax, -1
	mov	DWORD PTR _l$11423[ebp], eax

; 11409:                   else

	jmp	SHORT $L11427
$L11426:

; 11410:                      l = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _l$11423[ebp], eax
$L11427:

; 11411: 
; 11412:                   if ( fnSetAttributeFromInteger( lpView, lpViewEntityCsr,
; 11413:                                                   lpViewAttrib, l ) != 0 )

	mov	eax, DWORD PTR _l$11423[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromInteger
	add	esp, 16					; 00000010H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11428

; 11415:                      nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11416:                      break;

	jmp	$L11164
$L11428:

; 11420:             else

	jmp	SHORT $L11430
$L11422:

; 11422:                if ( fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11423:                                               lpViewAttrib, pchLine, 0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11430

; 11425:                   nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 11426:                   break;

	jmp	$L11164
$L11430:

; 11429: 
; 11430:             // Now set the attribute flags.
; 11431:             lpAttribFlags = fnGetAttribFlagsPtr( zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 11432:                                                  lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$11323[ebp], eax

; 11433:             lpAttribFlags->u.uFlags = AttribFlags.u.uFlags;

	mov	ecx, DWORD PTR _lpAttribFlags$11323[ebp]
	mov	edx, DWORD PTR _AttribFlags$11324[ebp]
	mov	DWORD PTR [ecx], edx
$L11420:

; 11435: 
; 11436:          nRC = 0;  // Everything OK so far...

	mov	WORD PTR _nRC$[ebp], 0

; 11439:       else

	jmp	$L11505
$L11322:

; 11440:       if ( pchLine[ 0 ] == 'i' )

	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 105				; 00000069H
	jne	$L11433

; 11442:          zLONG  lLinkTgt;
; 11443:          zLONG  lLinkSrc;
; 11444: 
; 11445:          // If we are reading root only then don't bother with the link cards.
; 11446:          if ( *plControl & zACTIVATE_ROOTONLY )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $L11436

; 11447:             continue;

	jmp	$L11163
$L11436:

; 11448: 
; 11449:          SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_SysParseLine@12

; 11450:          if ( *plControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L11437

; 11452:             lLinkTgt = zxtol( szWorkString );

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lLinkTgt$11434[ebp], eax

; 11453:             lLinkSrc = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lLinkSrc$11435[ebp], eax

; 11455:          else

	jmp	SHORT $L11438
$L11437:

; 11457:             lLinkTgt = zatol( szWorkString );

	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lLinkTgt$11434[ebp], eax

; 11458:             lLinkSrc = zatol( pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lLinkSrc$11435[ebp], eax
$L11438:

; 11460: 
; 11461:          k = lLinkSrc / 160000;  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lLinkSrc$11435[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	DWORD PTR _k$[ebp], eax

; 11462:          lpSrcInstance = (LPENTITYINSTANCE) *(pRelinkBufferTable[ k ] +
; 11463:                                                      lLinkSrc % 160000);  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lLinkSrc$11435[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pRelinkBufferTable$[ebp+eax*4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _lpSrcInstance$[ebp], edx

; 11464:          k = lLinkTgt / 160000;  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lLinkTgt$11434[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	DWORD PTR _k$[ebp], eax

; 11465:          lpTgtInstance = (LPENTITYINSTANCE) *(pRelinkBufferTable[ k ] +
; 11466:                                                      lLinkTgt % 160000);  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lLinkTgt$11434[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pRelinkBufferTable$[ebp+eax*4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _lpTgtInstance$[ebp], edx

; 11467: 
; 11468:          if ( lpTgtInstance && lpSrcInstance )

	cmp	DWORD PTR _lpTgtInstance$[ebp], 0
	je	$L11441
	cmp	DWORD PTR _lpSrcInstance$[ebp], 0
	je	$L11441

; 11470:             LPVIEWENTITY lpTgtViewEntity;
; 11471: 
; 11472:             lpViewEntity    = zGETPTR( lpSrcInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 11473:             lpTgtViewEntity = zGETPTR( lpTgtInstance->hViewEntity );

	mov	edx, DWORD PTR _lpTgtInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewEntity$11442[ebp], eax

; 11474: 
; 11475:             if ( lpTgtViewEntity->lEREntTok != lpViewEntity->lEREntTok )

	mov	ecx, DWORD PTR _lpTgtViewEntity$11442[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	je	SHORT $L11445

; 11477:                TraceLine( "(oi) Error (OD: %s) - Tgt View Entity: %s Token: %d  View Entity: %s Token = %d",
; 11478:                           lpViewOD->szName, lpTgtViewEntity->szName, lpTgtViewEntity->lEREntTok,
; 11479:                           lpViewEntity->szName, lpViewEntity->lEREntTok );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+195]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$11442[ebp]
	mov	edx, DWORD PTR [ecx+195]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntity$11442[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET FLAT:??_C@_0FA@FOLJ@?$CIoi?$CJ?5Error?5?$CIOD?3?5?$CFs?$CJ?5?9?5Tgt?5View?5E@ ; `string'
	call	_TraceLine
	add	esp, 24					; 00000018H

; 11480:                if ( bMsgBox )

	mov	edx, DWORD PTR _bMsgBox$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L11447

; 11482:                   bMsgBox = FALSE;

	mov	BYTE PTR _bMsgBox$[ebp], 0

; 11483:                   SysMessageBox( lpView, szlOE_SystemError,
; 11484:                                  "ER Tokens don't match for linked entities!", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0CL@DJNN@ER?5Tokens?5don?8t?5match?5for?5linked@ ; `string'
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16
$L11447:

; 11487:             else

	jmp	SHORT $L11449
$L11445:

; 11489:                lpTgtInstance->hPersistRecord = lpSrcInstance->hPersistRecord;

	mov	edx, DWORD PTR _lpTgtInstance$[ebp]
	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+60], ecx

; 11490:                if ( lpSrcInstance->hNextLinked )

	mov	edx, DWORD PTR _lpSrcInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $L11450

; 11491:                   lpTgtInstance->hNextLinked = lpSrcInstance->hNextLinked;

	mov	eax, DWORD PTR _lpTgtInstance$[ebp]
	mov	ecx, DWORD PTR _lpSrcInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	mov	DWORD PTR [eax+42], edx

; 11492:                else

	jmp	SHORT $L11451
$L11450:

; 11493:                   lpTgtInstance->hNextLinked = zGETHNDL( lpSrcInstance );

	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTgtInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax
$L11451:

; 11494: 
; 11495:                lpSrcInstance->hNextLinked = zGETHNDL( lpTgtInstance );

	mov	edx, DWORD PTR _lpTgtInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax
$L11449:

; 11498:          else

	jmp	SHORT $L11461
$L11441:

; 11500:             TraceLineS( "(oi) Failed entity linking", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BL@IKLP@?$CIoi?$CJ?5Failed?5entity?5linking?$AA@ ; `string'
	call	_TraceLineS@8

; 11501: 
; 11502:             TraceLineI( "(oi) Link Src # = ", lLinkSrc );

	mov	edx, DWORD PTR _lLinkSrc$11435[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BD@FPOB@?$CIoi?$CJ?5Link?5Src?5?$CD?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8

; 11503:             if ( lpSrcInstance )

	cmp	DWORD PTR _lpSrcInstance$[ebp], 0
	je	SHORT $L11457

; 11505:                lpViewEntity = zGETPTR( lpSrcInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 11506:                TraceLineS( "(oi) Source Entity = ", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET FLAT:??_C@_0BG@GFPE@?$CIoi?$CJ?5Source?5Entity?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8
$L11457:

; 11508: 
; 11509:             TraceLineI( "(oi) Link Tgt # = ", lLinkTgt );

	mov	eax, DWORD PTR _lLinkTgt$11434[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BD@GIND@?$CIoi?$CJ?5Link?5Tgt?5?$CD?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8

; 11510:             if ( lpTgtInstance )

	cmp	DWORD PTR _lpTgtInstance$[ebp], 0
	je	SHORT $L11461

; 11512:                lpViewEntity = zGETPTR( lpTgtInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpTgtInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 11513:                TraceLineS( "(oi) Target Entity = ", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET FLAT:??_C@_0BG@FHME@?$CIoi?$CJ?5Target?5Entity?5?$DN?5?$AA@ ; `string'
	call	_TraceLineS@8
$L11461:

; 11518:       else

	jmp	$L11505
$L11433:

; 11519:       if ( pchLine[ 0 ] == 'c' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 99					; 00000063H
	jne	$L11465

; 11521:          zSHORT nHierNbr;
; 11522:          zLONG  l;
; 11523: 
; 11524:          // First make sure that the last created entity instance has it's
; 11525:          // indicators set.
; 11526:          if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L11468

; 11528:             if ( *plControl & zINCREMENTAL )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 65536				; 00010000H
	test	ecx, ecx
	je	$L11469

; 11530:                lpEntityInstance->u.nIndicators = lIndicators;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lIndicators$[ebp]
	mov	DWORD PTR [edx+6], eax

; 11531:                lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	dh, -2					; fffffffeH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 11532: 
; 11533:                // A hack to make sure that a delete/excluded entity is
; 11534:                // flagged as hidden.  This tries to fix a bug.
; 11535:                if ( lpEntityInstance->u.nInd.bDeleted  ||
; 11536:                     lpEntityInstance->u.nInd.bExcluded )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L11471
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L11470
$L11471:

; 11538:                   lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	ah, 4
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$L11470:

; 11540: 
; 11541:                if ( lpEntityInstance->u.nInd.bCreated  ||
; 11542:                     lpEntityInstance->u.nInd.bDeleted  ||
; 11543:                     lpEntityInstance->u.nInd.bIncluded ||
; 11544:                     lpEntityInstance->u.nInd.bExcluded ||
; 11545:                     lpEntityInstance->u.nInd.bUpdated )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	jne	SHORT $L11473
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L11473
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L11473
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	jne	SHORT $L11473
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 2
	and	edx, 1
	test	edx, edx
	je	SHORT $L11472
$L11473:

; 11547:                   bOI_IsUpdated = TRUE;

	mov	BYTE PTR _bOI_IsUpdated$[ebp], 1
$L11472:

; 11550:             else

	jmp	SHORT $L11474
$L11469:

; 11551:                lpEntityInstance->u.nInd.bUpdated = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$L11474:

; 11552: 
; 11553:             // Set lpEntityInstance to 0 to indicate that the indicators for
; 11554:             // the last entity instance has been set.
; 11555:             lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0
$L11468:

; 11557: 
; 11558:          // Cursor positions are saved in cursor records.  A cursor record
; 11559:          // looks like:
; 11560:          //    cEnt-hier-nbr, absolute-instance-count
; 11561:          // For example, the cursor record for the root might look like:
; 11562:          //    c1, 1
; 11563:          // Numbers are stored in hex format.
; 11564: 
; 11565:          // If lInstanceCount is 0, then we need to set up some stuff.
; 11566:          if ( lInstanceCount == 0 )

	cmp	DWORD PTR _lInstanceCount$[ebp], 0
	jne	$L11475

; 11568:             LPVIEWCSR lpFirstViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewCsr$11476[ebp], eax

; 11569: 
; 11570:             // Indicate that cursor positions have been loaded.
; 11571:             *plControl = *plControl | zSAVE_CURSORS;

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 262144				; 00040000H
	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	DWORD PTR [ecx], eax

; 11572: 
; 11573:             // Initialize all entity cursors to be NULL.
; 11574:             for ( lpViewEntityCsr = zGETPTR( lpFirstViewCsr->hFirstOD_EntityCsr );
; 11575:                   lpViewEntityCsr;
; 11576:                   lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier ) )

	mov	edx, DWORD PTR _lpFirstViewCsr$11476[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
	jmp	SHORT $L11480
$L11481:
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
$L11480:
	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $L11482

; 11578:                lpViewEntityCsr->hEntityInstance = 0;

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [eax+26], 0

; 11579:             }

	jmp	SHORT $L11481
$L11482:

; 11580: 
; 11581:             lpViewEntityCsr = zGETPTR( lpFirstViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpFirstViewCsr$11476[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 11582:             lpCursorEI      = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCursorEI$[ebp], eax

; 11583:             lInstanceCount  = 1;

	mov	DWORD PTR _lInstanceCount$[ebp], 1
$L11475:

; 11585: 
; 11586:          // Get entity hier number and absolute instance position from record.
; 11587:          SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, 1
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_SysParseLine@12

; 11588:          nHierNbr = (zSHORT) zxtol( szWorkString );

	push	16					; 00000010H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nHierNbr$11466[ebp], ax

; 11589:          l = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _l$11467[ebp], eax
$L11487:

; 11590: 
; 11591:          // Entity cursors that are NULL do not have a cursor record.  If the
; 11592:          // hier nbr read from the record is greater than the "current"
; 11593:          // entity cursor, then at least one cursor is NULL.
; 11594:          while ( lpViewEntityCsr->nHierNbr < nHierNbr )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+24]
	movsx	eax, WORD PTR _nHierNbr$11466[ebp]
	cmp	edx, eax
	jge	SHORT $L11488

; 11595:             lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
	jmp	SHORT $L11487
$L11488:

; 11596: 
; 11597:          if ( l == 0 )

	cmp	DWORD PTR _l$11467[ebp], 0
	jne	SHORT $L11490

; 11599:             lpViewEntityCsr->hEntityInstance = UNSET_CSR;

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [eax+26], 1

; 11603:          else

	jmp	SHORT $L11499
$L11490:

; 11605:             // Look for the entity instance that has the absolute position l.
; 11606:             while ( lInstanceCount < l )

	mov	ecx, DWORD PTR _lInstanceCount$[ebp]
	cmp	ecx, DWORD PTR _l$11467[ebp]
	jge	SHORT $L11495

; 11608:                lpCursorEI = zGETPTR( lpCursorEI->hNextHier );

	mov	edx, DWORD PTR _lpCursorEI$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCursorEI$[ebp], eax

; 11609:                lInstanceCount++;

	mov	ecx, DWORD PTR _lInstanceCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lInstanceCount$[ebp], ecx

; 11610:             }

	jmp	SHORT $L11490
$L11495:

; 11611: 
; 11612:             if ( lpViewEntityCsr->hViewEntity == lpCursorEI->hViewEntity )

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpCursorEI$[ebp]
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+2]
	jne	SHORT $L11497

; 11614:                lpViewEntityCsr->hEntityInstance = zGETHNDL( lpCursorEI );

	mov	edx, DWORD PTR _lpCursorEI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 11618:             else

	jmp	SHORT $L11499
$L11497:

; 11620:                LPVIEWENTITY lpWk = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk$11500[ebp], eax

; 11621: 
; 11622:                TraceLineS( "(oi) Entity type mismatch during cursor restoration"
; 11623:                            " for entity ", lpWk->szName );

	mov	ecx, DWORD PTR _lpWk$11500[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET FLAT:??_C@_0EA@MMNH@?$CIoi?$CJ?5Entity?5type?5mismatch?5during@ ; `string'
	call	_TraceLineS@8
$L11499:

; 11626: 
; 11627:          lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 11630:       else

	jmp	SHORT $L11505
$L11465:

; 11631:       if ( zstrncmp( pchLine, "ZEND", 4 ) == 0 )

	push	4
	push	OFFSET FLAT:??_C@_04JJOE@ZEND?$AA@	; `string'
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L11505

; 11633:          // "ZEND" means we got to the end of the current OI so break out
; 11634:          // of loop.
; 11635:          nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 11636:          break;

	jmp	SHORT $L11164
$L11505:

; 11638: 
; 11639:    } // while ( (nEOF = (*lpfnStreamFunc)( ... )) == 1 )

	jmp	$L11163
$L11164:

; 11640: 
; 11641:    for ( lEntityCnt = 0; pRelinkBufferTable[ lEntityCnt ]; lEntityCnt++ )

	mov	DWORD PTR _lEntityCnt$[ebp], 0
	jmp	SHORT $L11506
$L11507:
	mov	edx, DWORD PTR _lEntityCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lEntityCnt$[ebp], edx
$L11506:
	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	cmp	DWORD PTR _pRelinkBufferTable$[ebp+eax*4], 0
	je	SHORT $L11508

; 11642:       fnFreeDataspace( pRelinkBufferTable[ lEntityCnt ] );

	mov	ecx, DWORD PTR _lEntityCnt$[ebp]
	mov	edx, DWORD PTR _pRelinkBufferTable$[ebp+ecx*4]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
	jmp	SHORT $L11507
$L11508:

; 11643: 
; 11644:    if ( nEOF == zCALL_ERROR )

	movsx	eax, WORD PTR _nEOF$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L11509

; 11645:       nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H
$L11509:

; 11646: 
; 11647:    // Mark the final instance indicators after updating all of the attributes.
; 11648:    if ( nRC >= 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L11510

; 11650:       if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L11515

; 11652:          if ( *plControl & zINCREMENTAL )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	SHORT $L11512

; 11654:             lpEntityInstance->u.nIndicators = lIndicators;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR _lIndicators$[ebp]
	mov	DWORD PTR [ecx+6], edx

; 11655:             lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ch, -2					; fffffffeH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 11656: 
; 11657:             if ( lpEntityInstance->u.nInd.bCreated  ||
; 11658:                  lpEntityInstance->u.nInd.bDeleted  ||
; 11659:                  lpEntityInstance->u.nInd.bIncluded ||
; 11660:                  lpEntityInstance->u.nInd.bExcluded ||
; 11661:                  lpEntityInstance->u.nInd.bUpdated )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L11514
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $L11514
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	test	edx, edx
	jne	SHORT $L11514
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L11514
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $L11513
$L11514:

; 11663:                bOI_IsUpdated = TRUE;

	mov	BYTE PTR _bOI_IsUpdated$[ebp], 1
$L11513:

; 11666:          else

	jmp	SHORT $L11515
$L11512:

; 11667:             lpEntityInstance->u.nInd.bUpdated = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$L11515:

; 11669: 
; 11670:       // Check if OI is updated.
; 11671:       lpViewOI->bUpdated     = bOI_IsUpdated;

	mov	ecx, DWORD PTR _bOI_IsUpdated$[ebp]
	and	ecx, 255				; 000000ffH
	and	ecx, 1
	shl	ecx, 4
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	al, -17					; ffffffefH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 11672:       lpViewOI->bUpdatedFile = FALSE;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	al, -33					; ffffffdfH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
$L11510:

; 11674: 
; 11675:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 11676: 
; 11677: } // fnActivateOI_FromTextStream

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnActivateOI_FromTextStream ENDP
_TEXT	ENDS
PUBLIC	??_C@_08NLFK@TZCMULWO?$AA@			; `string'
PUBLIC	??_C@_0CN@HFJB@?$CIoi?$CJ?5Total?5time?5for?5SfActivateOI@ ; `string'
EXTRN	__imp__strncpy:NEAR
;	COMDAT ??_C@_08NLFK@TZCMULWO?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_08NLFK@TZCMULWO?$AA@ DB 'TZCMULWO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CN@HFJB@?$CIoi?$CJ?5Total?5time?5for?5SfActivateOI@
_DATA	SEGMENT
??_C@_0CN@HFJB@?$CIoi?$CJ?5Total?5time?5for?5SfActivateOI@ DB '(oi) Total'
	DB	' time for SfActivateOI_FromStream ', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_lControl$ = 20
_lpfnStreamFunc$ = 24
_lpvData$ = 28
_lpCurrentTask$ = -52
_lpOwningTask$ = -28
_lpViewCsr$ = -4
_lpViewOI$ = -44
_lpViewOD$ = -12
_lpView$ = -20
_vOrigView$ = -36
_vQualView$ = -16
_pchLine$ = -8
_lTickCount$ = -48
_bContainsOptimisticOIs$ = -40
_nEOF$ = -32
_nRC$ = -24
_lTempControl$11585 = -56
_nSaveRC$11586 = -60
_lpRootEntityInstance$11605 = -64
_k$11610 = -72
_nState$11611 = -68
_sz$11620 = -172
_SfActivateOI_FromStream@24 PROC NEAR

; 11750: {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH

; 11751:    LPTASK            lpCurrentTask;
; 11752:    LPTASK            lpOwningTask;
; 11753:    LPVIEWCSR         lpViewCsr;
; 11754:    LPVIEWOI          lpViewOI;
; 11755:    LPVIEWOD          lpViewOD;
; 11756:    zVIEW             lpView;
; 11757:    zVIEW             vOrigView = 0;

	mov	DWORD PTR _vOrigView$[ebp], 0

; 11758:    zVIEW             vQualView = 0;

	mov	DWORD PTR _vQualView$[ebp], 0

; 11759:    zPCHAR            pchLine;
; 11760:    zLONG             lTickCount;
; 11761:    zBOOL             bContainsOptimisticOIs = FALSE;

	mov	BYTE PTR _bContainsOptimisticOIs$[ebp], 0

; 11762:    zSHORT            nEOF;
; 11763:    zSHORT            nRC;
; 11764: 
; 11765:    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L11542

; 11766:       lTickCount = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTickCount$[ebp], eax
$L11542:

; 11767: 
; 11768:    // Init in case of error.
; 11769:    *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0

; 11770: 
; 11771:    // If task not active or disabled, return zCALL_ERROR.
; 11772:    lpCurrentTask = zGETPTR( lpAppQualView->hTask );

	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 11773:    if ( lpCurrentTask == 0 )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L11544

; 11775:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11528
$L11544:

; 11777: 
; 11778:    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 12					; 0000000cH
	test	edx, edx
	je	SHORT $L11545

; 11779:       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 11780:    else

	jmp	SHORT $L11547
$L11545:

; 11781:       lpOwningTask = lpCurrentTask;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], edx
$L11547:

; 11782: 
; 11783:    if ( lControl & zACTIVATE_SYSTEM )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 536870912				; 20000000H
	test	eax, eax
	je	SHORT $L11548

; 11785:       if ( (nRC = fnDeclareView( pvReturnView, lpOwningTask,
; 11786:                                  lpAppQualView, cpcViewOD_Name, 1 )) != 0 )

	push	1
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L11549

; 11788:       // fnOperationReturn( iSfActivateSysOI_FromFile, lpCurrentTask, 0 );
; 11789:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11528
$L11549:

; 11805:    else

	jmp	SHORT $L11551
$L11548:

; 11807:       if ( (nRC = fnDeclareView( pvReturnView, lpOwningTask,
; 11808:                                  lpAppQualView, cpcViewOD_Name, 0 )) != 0 )

	push	0
	mov	eax, DWORD PTR _cpcViewOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L11551

; 11810:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11528
$L11551:

; 11823: 
; 11824:    lpView   = *pvReturnView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpView$[ebp], eax

; 11825:    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 11826: 
; 11827:    nRC = fnActivateEmptyObjectInstance( lpCurrentTask, lpView, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 11828:    if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L11553

; 11829:       goto EndOfFunction;

	jmp	$EndOfFunction$11554
$L11553:

; 11830: 
; 11831:    //======================================================================
; 11832:    // Retrieve the first line from the stream and determine if the stream
; 11833:    // is a binary or ASCII stream.
; 11834:    //======================================================================
; 11835: 
; 11836:    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 11837:    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 11838: 
; 11839:    nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax

; 11840:    if ( nEOF == 0 || nEOF == zCALL_ERROR )

	movsx	edx, WORD PTR _nEOF$[ebp]
	test	edx, edx
	je	SHORT $L11558
	movsx	eax, WORD PTR _nEOF$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L11557
$L11558:

; 11842:       //  "KZOEE072 - Error reading instance file "
; 11843:    // fnIssueCoreError( lpCurrentTask, lpView, 16, 72, 0, szOpenFileName, 0 );
; 11844:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11528
$L11557:

; 11846: 
; 11847: #if 0    // sample header
; 11848: rZeidon    SPARDA01 TZEREMDO 03/01/96   09:03:16 1.0a
; 11849: 
; 11850:       // sample new header
; 11851: z0100-Zeidon    SPARDA01 TZEREMDO 03/01/96   09:03:16 1.0a
; 11852: z1000-Zeidon    ACCOUNT  TZWDLGSO 04/18/07   09:18:42 1.0a2
; 11853: #endif
; 11854: 
; 11855:    // DGC 10/23/96  New header style where binary, incremental, and compressed
; 11856:    // information is stored as bit-flags.
; 11857:    if ( *pchLine == 'z' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jne	$L11559

; 11859:       // New header style.
; 11860:       if ( zstrncmp( pchLine + 6, szlmZeidon, 6 ) != 0 )

	push	6
	mov	eax, DWORD PTR _szlmZeidon
	push	eax
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 6
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L11560

; 11862:          //  "KZOEE073 - Invalid instance file header in "
; 11863:       // fnIssueCoreError( lpCurrentTask, lpView, 16, 73, 0, szOpenFileName, 0 );
; 11864:          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11528
$L11560:

; 11866: 
; 11867:       // Just got the header ... set the release value from the file
; 11868:       // header into the view (object instance) release value. (dks 3/5/96)
; 11869:       if ( zstrlen( pchLine ) > 55 )

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 55					; 00000037H
	jbe	SHORT $L11561

; 11871:          zstrncpy( lpViewOI->szRelease, pchLine + 54, 8 );

	push	8
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 54					; 00000036H
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 11872:          lpViewOI->szRelease[ 8 ] = 0;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	BYTE PTR [edx+64], 0
$L11561:

; 11874: 
; 11875:       if ( pchLine[ 2 ] == '1' )

	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 49					; 00000031H
	jne	SHORT $L11562

; 11876:          lControl |= zINCREMENTAL;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 65536				; 00010000H
	mov	DWORD PTR _lControl$[ebp], edx

; 11877:       else

	jmp	SHORT $L11563
$L11562:

; 11878:          lControl &= ~zINCREMENTAL;

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, -65537				; fffeffffH
	mov	DWORD PTR _lControl$[ebp], eax
$L11563:

; 11879: 
; 11880:       if ( pchLine[ 3 ] == '1' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+3]
	cmp	edx, 49					; 00000031H
	jne	SHORT $L11564

; 11881:          lControl |= zCOMPRESSED;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 131072				; 00020000H
	mov	DWORD PTR _lControl$[ebp], eax

; 11882:       else

	jmp	SHORT $L11565
$L11564:

; 11883:          lControl &= ~zCOMPRESSED;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, -131073				; fffdffffH
	mov	DWORD PTR _lControl$[ebp], ecx
$L11565:

; 11884: 
; 11885:       if ( pchLine[ 4 ] == '1' )

	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, 49					; 00000031H
	jne	SHORT $L11566

; 11886:          bContainsOptimisticOIs = TRUE;

	mov	BYTE PTR _bContainsOptimisticOIs$[ebp], 1
$L11566:

; 11887: 
; 11888:       // Attrib flags have been written if the 5th flag is set or if the OI is
; 11889:       // written in incremental/compressed form.
; 11890:       if ( pchLine[ 5 ] == '1' ||
; 11891:            ((lControl & zCOMPRESSED) && (lControl & zINCREMENTAL)) )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	cmp	edx, 49					; 00000031H
	je	SHORT $L11568
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	SHORT $L11567
	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 65536				; 00010000H
	test	ecx, ecx
	je	SHORT $L11567
$L11568:

; 11893:          lControl |= zATTRIBFLAGS;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 33554432				; 02000000H
	mov	DWORD PTR _lControl$[ebp], edx
$L11567:

; 11895: 
; 11896:       // This used to be the binary flag.  For now it tells us whether the
; 11897:       // ER_Date is stored with the LOD.
; 11898:       if ( pchLine[ 1 ] == '1' && (lControl & zINCREMENTAL) != 0 )

	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 49					; 00000031H
	jne	$L11576
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 65536				; 00010000H
	test	edx, edx
	je	$L11576

; 11900:          // Get the ER date.
; 11901:          (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]

; 11902: 
; 11903:          // Check to see if the ER dates match.  We only worry about this if
; 11904:          // the OI is compressed.  If it's not compressed then we can probably
; 11905:          // handle any differences.
; 11906:          if ( (lControl & zCOMPRESSED) &&
; 11907:               pchLine[ 0 ] && lpViewOD->szER_Date[ 0 ] &&
; 11908:               zstrcmp( lpViewOD->szER_Date, pchLine ) != 0 )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	test	eax, eax
	je	$L11576
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$L11576
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+248]
	test	ecx, ecx
	je	$L11576
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+248]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $L12864
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 248				; 000000f8H
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -176+[ebp], eax
	jmp	SHORT $L12865
$L12864:
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+248]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	xor	ecx, ecx
	test	eax, eax
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -176+[ebp], ecx
$L12865:
	cmp	DWORD PTR -176+[ebp], 0
	je	SHORT $L11576

; 11910:             // "KZOEE088 - Compressed OI is out of sync with LOD/XOD"
; 11911:             fnIssueCoreError( lpCurrentTask, lpView, 16, 88, 0, lpViewOD->szName, 0 );

	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	0
	push	88					; 00000058H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 11912:             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11528
$L11576:

; 11916:    else

	jmp	SHORT $L11581
$L11559:

; 11918:       // Old header style.
; 11919:       if ( zstrncmp( pchLine + 1, szlmZeidon, 6 ) )

	push	6
	mov	edx, DWORD PTR _szlmZeidon
	push	edx
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L11578

; 11921:          //  "KZOEE073 - Invalid instance file header in "
; 11922:       // fnIssueCoreError( lpCurrentTask, lpView, 16, 73, 0, szOpenFileName, 0 );
; 11923:          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11528
$L11578:

; 11925: 
; 11926:       // just got the header ... set the release value from the file
; 11927:       // header into the view (object instance) release value. (dks 3/5/96)
; 11928:       if ( zstrlen( pchLine ) > 50 )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	eax, 50					; 00000032H
	jbe	SHORT $L11579

; 11930:          zstrncpy( lpViewOI->szRelease, pchLine + 49, 8 );

	push	8
	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, 49					; 00000031H
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 11931:          lpViewOI->szRelease[ 8 ] = 0;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	BYTE PTR [ecx+64], 0
$L11579:

; 11933: 
; 11934:       // Set Incremental.
; 11935:       if ( pchLine[ 0 ] == 'r' )

	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 114				; 00000072H
	jne	SHORT $L11580

; 11936:          lControl |= zINCREMENTAL;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 65536				; 00010000H
	mov	DWORD PTR _lControl$[ebp], ecx

; 11937:       else

	jmp	SHORT $L11581
$L11580:

; 11938:          lControl &= ~zINCREMENTAL;

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, -65537				; fffeffffH
	mov	DWORD PTR _lControl$[ebp], edx
$L11581:

; 11940: 
; 11941:    // Set Root only indicator.
; 11942:    if ( lControl & zACTIVATE_ROOTONLY )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 268435456				; 10000000H
	test	eax, eax
	je	SHORT $L11582

; 11943:       lpViewOI->bRootOnly = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 2
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$L11582:

; 11944: 
; 11945:    nRC = fnActivateOI_FromTextStream( lpView, lpfnStreamFunc,
; 11946:                                       lpvData, &lControl );

	lea	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpfnStreamFunc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnActivateOI_FromTextStream
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 11947:    if ( nRC < -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jge	SHORT $L11583

; 11948:       goto EndOfFunction;

	jmp	$EndOfFunction$11554
$L11583:

; 11949: 
; 11950:    // If the stream has optimistic locking information try to activate
; 11951:    // the "original view" and the qualification view.  These should appear
; 11952:    // in the stream after the main view.
; 11953:    if ( bContainsOptimisticOIs )

	mov	eax, DWORD PTR _bContainsOptimisticOIs$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L11584

; 11955:       zLONG  lTempControl;
; 11956:       zSHORT nSaveRC = nRC;

	mov	cx, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nSaveRC$11586[ebp], cx

; 11957: 
; 11958:       // lTempControl is what we use to activate the original OI and the
; 11959:       // qualification OI.  Since no OI is OK, add it to the flag.
; 11960:       lTempControl = lControl | zNOI_OKAY;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	dh, 2
	mov	DWORD PTR _lTempControl$11585[ebp], edx

; 11961: 
; 11962:       if ( lControl & zACTIVATE_SYSTEM )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 536870912				; 20000000H
	test	eax, eax
	je	SHORT $L11587

; 11964:          nRC = fnDeclareView( &vOrigView, lpOwningTask,
; 11965:                               lpAppQualView, cpcViewOD_Name, 1 );

	push	1
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax

; 11967:       else

	jmp	SHORT $L11588
$L11587:

; 11969:          nRC = fnDeclareView( &vOrigView, lpOwningTask,
; 11970:                               lpAppQualView, cpcViewOD_Name, 0 );

	push	0
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vOrigView$[ebp]
	push	edx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
$L11588:

; 11972: 
; 11973:       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $L11589

; 11974:          goto EndOfFunction;

	jmp	$EndOfFunction$11554
$L11589:

; 11975: 
; 11976:       nRC = fnActivateEmptyObjectInstance( lpCurrentTask, vOrigView, lControl );

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vOrigView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 11977: 
; 11978:       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L11590

; 11979:          goto EndOfFunction;

	jmp	$EndOfFunction$11554
$L11590:

; 11980: 
; 11981:       nRC = fnActivateOI_FromTextStream( vOrigView, lpfnStreamFunc,
; 11982:                                          lpvData, &lTempControl );

	lea	edx, DWORD PTR _lTempControl$11585[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpfnStreamFunc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vOrigView$[ebp]
	push	edx
	call	_fnActivateOI_FromTextStream
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 11983: 
; 11984:       if ( nRC < -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jge	SHORT $L11591

; 11985:          goto EndOfFunction;

	jmp	$EndOfFunction$11554
$L11591:

; 11986: 
; 11987:       nRC = fnDeclareView( &vQualView, lpOwningTask,
; 11988:                            lpAppQualView, "KZDBHQUA", 1 );

	push	1
	push	OFFSET FLAT:??_C@_08ILBJ@KZDBHQUA?$AA@	; `string'
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _vQualView$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax

; 11989: 
; 11990:       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L11592

; 11991:          goto EndOfFunction;

	jmp	$EndOfFunction$11554
$L11592:

; 11992: 
; 11993:       nRC = fnActivateEmptyObjectInstance( lpCurrentTask, vQualView, lControl );

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 11994: 
; 11995:       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L11593

; 11996:          goto EndOfFunction;

	jmp	$EndOfFunction$11554
$L11593:

; 11997: 
; 11998:       nRC = fnActivateOI_FromTextStream( vQualView, lpfnStreamFunc,
; 11999:                                          lpvData, &lTempControl );

	lea	eax, DWORD PTR _lTempControl$11585[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpfnStreamFunc$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQualView$[ebp]
	push	eax
	call	_fnActivateOI_FromTextStream
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 12000: 
; 12001:       if ( nRC < -1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jge	SHORT $L11594

; 12002:          goto EndOfFunction;

	jmp	$EndOfFunction$11554
$L11594:

; 12003:       else
; 12004:       if ( nRC == -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jne	SHORT $L11596

; 12006:          // Qual view is empty so we really don't need it.
; 12007:          fnDropView( vQualView );

	mov	eax, DWORD PTR _vQualView$[ebp]
	push	eax
	call	_fnDropView@4

; 12008:          vQualView = 0;

	mov	DWORD PTR _vQualView$[ebp], 0
$L11596:

; 12010: 
; 12011:       nRC = nSaveRC;

	mov	cx, WORD PTR _nSaveRC$11586[ebp]
	mov	WORD PTR _nRC$[ebp], cx

; 12012: 
; 12013:       vOrigView->bOrigView   = TRUE;

	mov	edx, DWORD PTR _vOrigView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, -128				; ffffff80H
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 12014:       vOrigView->bViewLocked = TRUE;

	mov	edx, DWORD PTR _vOrigView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 12015:       vOrigView->hMainOI     = zGETHNDL( lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 12016:       lpViewOI->vOriginalOI  = zGETHNDL( vOrigView );

	mov	edx, DWORD PTR _vOrigView$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 12017: 
; 12018:       vQualView->bQualView   = TRUE;

	mov	edx, DWORD PTR _vQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	ah, 1
	mov	ecx, DWORD PTR _vQualView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 12019:       vQualView->bViewLocked = TRUE;

	mov	edx, DWORD PTR _vQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _vQualView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 12020:       vQualView->hMainOI     = zGETHNDL( lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _vQualView$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 12021:       lpViewOI->vQualOI      = zGETHNDL( vQualView );

	mov	edx, DWORD PTR _vQualView$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+44], eax
$L11584:

; 12023: 
; 12024:    // Reset the view if successful.
; 12025:    if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L11603

; 12027:       if ( (lControl & zSAVE_CURSORS) == 0 )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 262144				; 00040000H
	test	eax, eax
	jne	SHORT $L11602

; 12028:          fnResetView( lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetView
	add	esp, 8
$L11602:

; 12029: 
; 12030:       if ( lControl & zREADONLY )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2048				; 00000800H
	test	edx, edx
	je	SHORT $L11603

; 12031:          lpView->bReadOnly = TRUE;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx
$L11603:

; 12033: 
; 12034:    // Now that we are finished activating, check the root instance
; 12035:    // to determine if multiple roots were loaded.
; 12036:    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $L11607

; 12038:       LPENTITYINSTANCE lpRootEntityInstance =
; 12039:                                  zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$11605[ebp], eax

; 12040: 
; 12041:       if ( lpRootEntityInstance && lpRootEntityInstance->hNextTwin )

	cmp	DWORD PTR _lpRootEntityInstance$11605[ebp], 0
	je	SHORT $L11607
	mov	eax, DWORD PTR _lpRootEntityInstance$11605[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $L11607

; 12043:          nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1
$L11607:

; 12046: 
; 12047: #ifdef __ACTIVATE_CONSTRAINTS__
; 12048:    if ( (lControl & zACTIVATE_NOCONSTRAINTS) == 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 16777216				; 01000000H
	test	ecx, ecx
	jne	$EndOfFunction$11554

; 12050:       if ( lpViewOD->bActivateConstraint && nRC >= -1 )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $EndOfFunction$11554
	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jl	SHORT $EndOfFunction$11554

; 12052:          zSHORT   k;
; 12053:          zSHORT   nState = zOCE_STATE_FILE;

	mov	WORD PTR _nState$11611[ebp], 1

; 12054: 
; 12055:          if ( lControl & zLEVEL_SYSTEM )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 8
	test	edx, edx
	je	SHORT $L11612

; 12056:             nState += zOCE_STATE_SYSTEM;

	mov	ax, WORD PTR _nState$11611[ebp]
	add	ax, 4
	mov	WORD PTR _nState$11611[ebp], ax
$L11612:

; 12057: 
; 12058:          if ( nRC == -2 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -2					; fffffffeH
	jne	SHORT $L11613

; 12059:             nState += zOCE_STATE_NOI;

	mov	dx, WORD PTR _nState$11611[ebp]
	add	dx, 8
	mov	WORD PTR _nState$11611[ebp], dx
$L11613:

; 12060: 
; 12061:          k = fnInvokeOCEOperation( lpView, lpCurrentTask,
; 12062:                                    zOCE_ACTIVATE, nState );

	mov	ax, WORD PTR _nState$11611[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _k$11610[ebp], ax

; 12063:          if ( k )

	movsx	eax, WORD PTR _k$11610[ebp]
	test	eax, eax
	je	SHORT $EndOfFunction$11554

; 12065:             fnDropView( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropView@4

; 12066:             *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0

; 12067:          // fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );
; 12068:             return( k );

	mov	ax, WORD PTR _k$11610[ebp]
	jmp	$L11528
$EndOfFunction$11554:

; 12072: #endif
; 12073: 
; 12074: EndOfFunction:
; 12075: 
; 12076:    // Based on the return code, see if we have to reset the view to the
; 12077:    // prior instance or clean up the prior instance.
; 12078:    // note: rc = indicates multiple level1 roots present
; 12079:    if ( nRC >= -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jl	SHORT $L11615

; 12081:       lpViewOI->bUpdatedFile = FALSE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 12083:    else

	jmp	SHORT $L11618
$L11615:

; 12085:       fnDropView( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropView@4

; 12086:       *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0

; 12087: 
; 12088:       if ( vOrigView )

	cmp	DWORD PTR _vOrigView$[ebp], 0
	je	SHORT $L11617

; 12089:          fnDropView( vOrigView );

	mov	eax, DWORD PTR _vOrigView$[ebp]
	push	eax
	call	_fnDropView@4
$L11617:

; 12090: 
; 12091:       if ( vQualView )

	cmp	DWORD PTR _vQualView$[ebp], 0
	je	SHORT $L11618

; 12092:          fnDropView( vQualView );

	mov	ecx, DWORD PTR _vQualView$[ebp]
	push	ecx
	call	_fnDropView@4
$L11618:

; 12094: 
; 12095:    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	and	eax, 1
	test	eax, eax
	je	$L11627

; 12097:       zCHAR sz[ 100 ];
; 12098: 
; 12099:       if ( zstrcmp( lpViewOD->szName, "TZCMULWO" ) != 0 )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	movsx	eax, BYTE PTR ??_C@_08NLFK@TZCMULWO?$AA@
	cmp	edx, eax
	jne	SHORT $L12866
	push	OFFSET FLAT:??_C@_08NLFK@TZCMULWO?$AA@	; `string'
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -180+[ebp], eax
	jmp	SHORT $L12867
$L12866:
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	movsx	ecx, BYTE PTR ??_C@_08NLFK@TZCMULWO?$AA@
	sub	eax, ecx
	xor	edx, edx
	test	eax, eax
	setle	dl
	dec	edx
	and	edx, 2
	add	edx, -1
	mov	DWORD PTR -180+[ebp], edx
$L12867:
	cmp	DWORD PTR -180+[ebp], 0
	je	SHORT $L11627

; 12101:          zsprintf( sz, "(%s) = %lf seconds", lpViewOD->szName,
; 12102:                    (double) (SysGetTickCount( ) - lTickCount) / zTICKS_PER_SECOND );

	call	_SysGetTickCount@0
	sub	eax, DWORD PTR _lTickCount$[ebp]
	mov	DWORD PTR -188+[ebp], eax
	mov	DWORD PTR -188+[ebp+4], 0
	fild	QWORD PTR -188+[ebp]
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET FLAT:??_C@_0BD@BCKI@?$CI?$CFs?$CJ?5?$DN?5?$CFlf?5seconds?$AA@ ; `string'
	lea	ecx, DWORD PTR _sz$11620[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 12103:          TraceLineS( "(oi) Total time for SfActivateOI_FromStream ", sz );

	lea	edx, DWORD PTR _sz$11620[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CN@HFJB@?$CIoi?$CJ?5Total?5time?5for?5SfActivateOI@ ; `string'
	call	_TraceLineS@8
$L11627:

; 12106: 
; 12107:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L11528:

; 12108: 
; 12109: } // SfActivateOI_FromStream

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_SfActivateOI_FromStream@24 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FO@KBNJ@SfActivateSysOI_FromFile?5now?5REQ@ ; `string'
PUBLIC	??_C@_0FM@LNBI@SfActivateSysOI_FromFile?5now?5REQ@ ; `string'
PUBLIC	??_C@_09BPDN@Zeidon?5OE?$AA@			; `string'
PUBLIC	_SfActivateSysOI_FromFile@20
;	COMDAT ??_C@_0FO@KBNJ@SfActivateSysOI_FromFile?5now?5REQ@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0FO@KBNJ@SfActivateSysOI_FromFile?5now?5REQ@ DB 'SfActivateSysOI_Fr'
	DB	'omFile now REQUIRES a non-zero qualification view for Object '
	DB	'Definition: %s', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FM@LNBI@SfActivateSysOI_FromFile?5now?5REQ@
_DATA	SEGMENT
??_C@_0FM@LNBI@SfActivateSysOI_FromFile?5now?5REQ@ DB 'SfActivateSysOI_Fr'
	DB	'omFile now REQUIRES a non-zero qualification view.  System wi'
	DB	'll now crash', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_09BPDN@Zeidon?5OE?$AA@
_DATA	SEGMENT
??_C@_09BPDN@Zeidon?5OE?$AA@ DB 'Zeidon OE', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_cpcFileName$ = 20
_lControl$ = 24
_lpCurrentTask$ = -8
_nRC$ = -4
_SfActivateSysOI_FromFile@20 PROC NEAR

; 12165: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 12166:    LPTASK      lpCurrentTask;
; 12167:    zSHORT      nRC;
; 12168: 
; 12169:    // init in case of error
; 12170:    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 12171: 
; 12172: #ifdef DEBUG
; 12173:    if ( lpAppQualView == 0 )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	jne	SHORT $L11644

; 12175:       TraceLine( "SfActivateSysOI_FromFile now REQUIRES a non-zero "
; 12176:                    "qualification view for Object Definition: %s", cpcViewOD_Name );

	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0FO@KBNJ@SfActivateSysOI_FromFile?5now?5REQ@ ; `string'
	call	_TraceLine
	add	esp, 8

; 12177:       SysMessageBox( 0, "Zeidon OE", "SfActivateSysOI_FromFile now REQUIRES a "
; 12178:                      "non-zero qualification view.  System will now crash", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0FM@LNBI@SfActivateSysOI_FromFile?5now?5REQ@ ; `string'
	push	OFFSET FLAT:??_C@_09BPDN@Zeidon?5OE?$AA@ ; `string'
	push	0
	call	_SysMessageBox@16
$L11644:

; 12180: #endif
; 12181: 
; 12182:    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 12183:    if ( (lpCurrentTask = fnOperationCall( iSfActivateSysOI_FromFile,
; 12184:                                           lpAppQualView, zVALID_VIEW )) == 0 )

	push	1
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	215					; 000000d7H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L11648

; 12186:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L11641
$L11648:

; 12188: 
; 12189:    nRC = ActivateOI_FromFile( pvReturnView, cpcViewOD_Name, lpAppQualView,
; 12190:                               cpcFileName, lControl | zACTIVATE_SYSTEM );

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 536870912				; 20000000H
	push	eax
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcViewOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_ActivateOI_FromFile@20
	mov	WORD PTR _nRC$[ebp], ax

; 12191: 
; 12192:    fnOperationReturn( iSfActivateSysOI_FromFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	215					; 000000d7H
	call	_fnOperationReturn
	add	esp, 8

; 12193:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L11641:

; 12194: 
; 12195: } // SfActivateSysOI_FromFile

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SfActivateSysOI_FromFile@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FL@BEFB@SfActivateSysEmptyOI?5now?5REQUIRE@ ; `string'
PUBLIC	??_C@_0FI@FKHH@SfActivateSysEmptyOI?5now?5REQUIRE@ ; `string'
;	COMDAT ??_C@_0FL@BEFB@SfActivateSysEmptyOI?5now?5REQUIRE@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0FL@BEFB@SfActivateSysEmptyOI?5now?5REQUIRE@ DB 'SfActivateSysEmpty'
	DB	'OI now REQUIRES a non-zero qualification view for Object Defi'
	DB	'nition: %s.', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FI@FKHH@SfActivateSysEmptyOI?5now?5REQUIRE@
_DATA	SEGMENT
??_C@_0FI@FKHH@SfActivateSysEmptyOI?5now?5REQUIRE@ DB 'SfActivateSysEmpty'
	DB	'OI now REQUIRES a non-zero qualification view.  System will n'
	DB	'ow crash', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvReturnView$ = 8
_cpcViewOD_Name$ = 12
_lpAppQualView$ = 16
_lControl$ = 20
_lpCurrentTask$ = -20
_lpOwningTask$ = -16
_lpViewOD$ = -4
_lpView$ = -8
_nRC$ = -12
_nState$11674 = -24
_SfActivateSysEmptyOI@16 PROC NEAR

; 12239: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 12240:    LPTASK      lpCurrentTask;
; 12241:    LPTASK      lpOwningTask;
; 12242:    LPVIEWOD    lpViewOD;
; 12243:    zVIEW       lpView;
; 12244:    zSHORT      nRC;
; 12245: 
; 12246:    // init in case of error
; 12247:    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 12248: 
; 12249: #ifdef DEBUG
; 12250:    if ( lpAppQualView == 0 )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	jne	SHORT $L11663

; 12252:       TraceLine( "SfActivateSysEmptyOI now REQUIRES a non-zero "
; 12253:                    "qualification view for Object Definition: %s.", cpcViewOD_Name );

	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0FL@BEFB@SfActivateSysEmptyOI?5now?5REQUIRE@ ; `string'
	call	_TraceLine
	add	esp, 8

; 12254:       SysMessageBox( 0, "Zeidon OE", "SfActivateSysEmptyOI now REQUIRES a "
; 12255:                      "non-zero qualification view.  System will now crash", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0FI@FKHH@SfActivateSysEmptyOI?5now?5REQUIRE@ ; `string'
	push	OFFSET FLAT:??_C@_09BPDN@Zeidon?5OE?$AA@ ; `string'
	push	0
	call	_SysMessageBox@16
$L11663:

; 12257: #endif
; 12258: 
; 12259:    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 12260:    if ( (lpCurrentTask = fnOperationCall( iSfActivateSysEmptyOI,
; 12261:                                           lpAppQualView, zVALID_VIEW )) == 0 )

	push	1
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	216					; 000000d8H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L11666

; 12263:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11657
$L11666:

; 12265: 
; 12266:    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L11667

; 12267:       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 12268:    else

	jmp	SHORT $L11669
$L11667:

; 12269:       lpOwningTask = lpCurrentTask;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], eax
$L11669:

; 12270: 
; 12271:    if ( (nRC = fnDeclareView( pvReturnView, lpOwningTask,
; 12272:                               lpAppQualView, cpcViewOD_Name, 1 )) != 0 )

	push	1
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L11670

; 12274:       fnOperationReturn( iSfActivateSysEmptyOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	216					; 000000d8H
	call	_fnOperationReturn
	add	esp, 8

; 12275:       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11657
$L11670:

; 12277: 
; 12278: #if 0
; 12279:    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 12280:    {
; 12281:       zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 12282:                                   zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 12283:       if ( (nRC = SfTransferView( *pvReturnView, lpAppQualView,
; 12284:                                   nScope )) != 0 )
; 12285:       {
; 12286:          fnOperationReturn( iSfActivateSysEmptyOI, lpCurrentTask );
; 12287:          return( nRC );
; 12288:       }
; 12289:    }
; 12290: #endif
; 12291: 
; 12292:    nRC = fnActivateEmptyObjectInstance( lpCurrentTask, *pvReturnView, lControl );

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 12293:    lpView = *pvReturnView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpView$[ebp], eax

; 12294:    if ( lControl & zREADONLY )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 2048				; 00000800H
	test	ecx, ecx
	je	SHORT $L11671

; 12295:       lpView->bReadOnly = TRUE;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	al, 64					; 00000040H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax
$L11671:

; 12296: 
; 12297: #ifdef __ACTIVATE_CONSTRAINTS__
; 12298:    // If object has activate constraint active, check for objections.
; 12299:    // If any drop view and exit...
; 12300:    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 12301:    if ( lpViewOD->bActivateEmptyConstraint && nRC == 0 )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 4
	and	edx, 1
	test	edx, edx
	je	SHORT $L11675
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $L11675

; 12303:       zSHORT nState = zOCE_STATE_SYSTEM;

	mov	WORD PTR _nState$11674[ebp], 4

; 12304: 
; 12305:       nRC = fnInvokeOCEOperation( lpView, lpCurrentTask,
; 12306:                                   zOCE_ACTIVATE_EMPTY, nState );

	mov	cx, WORD PTR _nState$11674[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 12307:       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $L11675

; 12309:          fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDropView@4

; 12310:          *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0
$L11675:

; 12313: #endif
; 12314: 
; 12315:    fnOperationReturn( iSfActivateSysEmptyOI, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	216					; 000000d8H
	call	_fnOperationReturn
	add	esp, 8

; 12316:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L11657:

; 12317: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SfActivateSysEmptyOI@16 ENDP
_pchDateTime$ = 8
_pchDate$ = 12
_pchTime$ = 16
_fnDateTimeFormat PROC NEAR

; 12336: {

	push	ebp
	mov	ebp, esp

; 12337:    zstrncpy( pchDate, pchDateTime + 4, 2 );      // copy month

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pchDate$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12338:    pchDate[ 2 ] = '/';                           // separator

	mov	edx, DWORD PTR _pchDate$[ebp]
	mov	BYTE PTR [edx+2], 47			; 0000002fH

; 12339:    zstrncpy( pchDate + 3, pchDateTime + 6, 2 );  // copy day

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _pchDate$[ebp]
	add	ecx, 3
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12340:    pchDate[ 5 ] = '/';                           // separator

	mov	edx, DWORD PTR _pchDate$[ebp]
	mov	BYTE PTR [edx+5], 47			; 0000002fH

; 12341:    zstrncpy( pchDate + 6, pchDateTime + 2, 2 );  // copy year

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pchDate$[ebp]
	add	ecx, 6
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12342:    pchDate[ 8 ] = 0;                             // null terminator

	mov	edx, DWORD PTR _pchDate$[ebp]
	mov	BYTE PTR [edx+8], 0

; 12343: 
; 12344:    zstrncpy( pchTime, pchDateTime + 8, 2 );      // copy hours

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pchTime$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12345:    pchTime[ 2 ] = ':';                           // separator

	mov	edx, DWORD PTR _pchTime$[ebp]
	mov	BYTE PTR [edx+2], 58			; 0000003aH

; 12346:    zstrncpy( pchTime + 3, pchDateTime + 10, 2 ); // copy minutes

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _pchTime$[ebp]
	add	ecx, 3
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12347:    pchTime[ 5 ] = ':';                           // separator

	mov	edx, DWORD PTR _pchTime$[ebp]
	mov	BYTE PTR [edx+5], 58			; 0000003aH

; 12348:    zstrncpy( pchTime + 6, pchDateTime + 12, 2 ); // copy seconds

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _pchTime$[ebp]
	add	ecx, 6
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12349:    pchDate[ 8 ] = 0;                             // null terminator

	mov	edx, DWORD PTR _pchDate$[ebp]
	mov	BYTE PTR [edx+8], 0

; 12350: }

	pop	ebp
	ret	0
_fnDateTimeFormat ENDP
_TEXT	ENDS
EXTRN	_fnGetVariableFromAttribute:NEAR
EXTRN	_fnCompareDateTimeToDateTime:NEAR
EXTRN	_memcmp:NEAR
EXTRN	_SysCompareDecimalToDecimal@8:NEAR
_TEXT	SEGMENT
_lpCurrentTask$ = 8
_lpView1$ = 12
_lpInstance1$ = 16
_lpViewAttrib1$ = 20
_pchContextName1$ = 24
_lpView2$ = 28
_lpInstance2$ = 32
_lpViewAttrib2$ = 36
_pchContextName2$ = 40
_pchValue1$ = -20
_pchValue2$ = -16
_bNull1$ = -8
_bNull2$ = -4
_chType1$ = -536
_chType2$ = -540
_nRC$ = -12
_AttrVal1$ = -276
_AttrVal2$ = -532
_lpViewEntityCsr$11723 = -548
_ulLth$11724 = -544
_lpViewEntityCsr$11731 = -556
_uLth$11732 = -552
_ulLth1$11768 = -568
_ulLth2$11769 = -564
_uBlobLth$11770 = -560
_fnCompareEIAttrs@36 PROC NEAR

; 12388: {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H

; 12389:    zPCHAR   pchValue1, pchValue2;
; 12390:    zSHORT   bNull1, bNull2;
; 12391:    zCHAR    chType1, chType2;
; 12392:    zSHORT   nRC;
; 12393: 
; 12394:    typedef union _AttrValues
; 12395:    {
; 12396:       zLONG          l;
; 12397:       zCHAR          sz[ 256 ];
; 12398:       zDECIMAL       d;
; 12399:       DateTimeRecord dt;
; 12400:    } AttrValues;
; 12401:    AttrValues AttrVal1, AttrVal2;
; 12402: 
; 12403:    bNull1 = fnAttributeValueNull( 0, lpInstance1, lpViewAttrib1 );

	mov	eax, DWORD PTR _lpViewAttrib1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInstance1$[ebp]
	push	ecx
	push	0
	call	_fnAttributeValueNull
	add	esp, 12					; 0000000cH
	mov	WORD PTR _bNull1$[ebp], ax

; 12404:    bNull2 = fnAttributeValueNull( 0, lpInstance2, lpViewAttrib2 );

	mov	edx, DWORD PTR _lpViewAttrib2$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInstance2$[ebp]
	push	eax
	push	0
	call	_fnAttributeValueNull
	add	esp, 12					; 0000000cH
	mov	WORD PTR _bNull2$[ebp], ax

; 12405: 
; 12406:    if ( bNull1 )

	movsx	ecx, WORD PTR _bNull1$[ebp]
	test	ecx, ecx
	je	SHORT $L11717

; 12408:       if ( bNull2 )

	movsx	edx, WORD PTR _bNull2$[ebp]
	test	edx, edx
	je	SHORT $L11718

; 12409:          return( 0 );

	xor	ax, ax
	jmp	$L11701
$L11718:

; 12410:       else
; 12411:          return( -1 );

	or	ax, -1
	jmp	$L11701
$L11717:

; 12413:    else
; 12414:    if ( bNull2 )

	movsx	eax, WORD PTR _bNull2$[ebp]
	test	eax, eax
	je	SHORT $L11721

; 12416:       // We know that attrib 1 is NOT null so it is > than attrib 2.
; 12417:       return( 1 );

	mov	ax, 1
	jmp	$L11701
$L11721:

; 12419: 
; 12420:    chType1 = lpViewAttrib1->cType;

	mov	ecx, DWORD PTR _lpViewAttrib1$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR _chType1$[ebp], dl

; 12421: 
; 12422:    // Check to see if we have a context.  If we do, use it to get the attr
; 12423:    // value.  If not, get a pointer to the internal value.
; 12424: 
; 12425:    if ( pchContextName1 && chType1 != zTYPE_BLOB && chType1 != zTYPE_DATETIME )

	cmp	DWORD PTR _pchContextName1$[ebp], 0
	je	$L11722
	movsx	eax, BYTE PTR _chType1$[ebp]
	cmp	eax, 66					; 00000042H
	je	SHORT $L11722
	movsx	ecx, BYTE PTR _chType1$[ebp]
	cmp	ecx, 84					; 00000054H
	je	SHORT $L11722

; 12427:       LPVIEWENTITYCSR lpViewEntityCsr;
; 12428:       zULONG          ulLth;
; 12429: 
; 12430:       // Use the context name to get attribute value.
; 12431:       lpViewEntityCsr = fnEstablishViewForInstance( lpView1, 0, lpInstance1 );

	mov	edx, DWORD PTR _lpInstance1$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView1$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$11723[ebp], eax

; 12432: 
; 12433:       // Use default context if pchContextName points to an empty string.
; 12434:       fnGetVariableFromAttribute( (zPVOID) &AttrVal1, &ulLth,
; 12435:                                   chType1, (zULONG) sizeof( AttrVal2 ),
; 12436:                                   lpView1, lpViewEntityCsr,
; 12437:                                   lpViewAttrib1,
; 12438:                                   pchContextName1,
; 12439:                                   lpCurrentTask,
; 12440:                                   (zSHORT) (*pchContextName1 ? 0 : zUSE_DEFAULT_CONTEXT) );

	mov	ecx, DWORD PTR _pchContextName1$[ebp]
	movsx	edx, BYTE PTR [ecx]
	neg	edx
	sbb	edx, edx
	and	edx, -8					; fffffff8H
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchContextName1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib1$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$11723[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView1$[ebp]
	push	ecx
	push	256					; 00000100H
	mov	dl, BYTE PTR _chType1$[ebp]
	push	edx
	lea	eax, DWORD PTR _ulLth$11724[ebp]
	push	eax
	lea	ecx, DWORD PTR _AttrVal1$[ebp]
	push	ecx
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H

; 12441: 
; 12442:       pchValue1 = (zPCHAR) &AttrVal1;

	lea	edx, DWORD PTR _AttrVal1$[ebp]
	mov	DWORD PTR _pchValue1$[ebp], edx

; 12444:    else

	jmp	SHORT $L11729
$L11722:

; 12445:       fnGetAddrForAttribute( &pchValue1, 0, 0, lpInstance1, lpViewAttrib1 );

	mov	eax, DWORD PTR _lpViewAttrib1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInstance1$[ebp]
	push	ecx
	push	0
	push	0
	lea	edx, DWORD PTR _pchValue1$[ebp]
	push	edx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H
$L11729:

; 12446: 
; 12447:    chType2 = lpViewAttrib2->cType;

	mov	eax, DWORD PTR _lpViewAttrib2$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR _chType2$[ebp], cl

; 12448: 
; 12449:    if ( pchContextName2 && chType2 != zTYPE_BLOB && chType2 != zTYPE_DATETIME )

	cmp	DWORD PTR _pchContextName2$[ebp], 0
	je	$L11730
	movsx	edx, BYTE PTR _chType2$[ebp]
	cmp	edx, 66					; 00000042H
	je	SHORT $L11730
	movsx	eax, BYTE PTR _chType2$[ebp]
	cmp	eax, 84					; 00000054H
	je	SHORT $L11730

; 12451:       LPVIEWENTITYCSR lpViewEntityCsr;
; 12452:       zLONG           uLth;
; 12453: 
; 12454:       // Use the context name to get attribute value.
; 12455:       lpViewEntityCsr = fnEstablishViewForInstance( lpView2, 0, lpInstance2 );

	mov	ecx, DWORD PTR _lpInstance2$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView2$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$11731[ebp], eax

; 12456: 
; 12457:       // Use default context if pchContextName points to an empty string.
; 12458:       fnGetVariableFromAttribute( (zPVOID) &AttrVal2, &uLth,
; 12459:                                   chType2, (zULONG) sizeof( AttrVal2 ),
; 12460:                                   lpView2, lpViewEntityCsr,
; 12461:                                   lpViewAttrib2,
; 12462:                                   pchContextName2,
; 12463:                                   lpCurrentTask,
; 12464:                                   (zSHORT) ( *pchContextName2 ? 0 : zUSE_DEFAULT_CONTEXT ) );

	mov	eax, DWORD PTR _pchContextName2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, -8					; fffffff8H
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchContextName2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$11731[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView2$[ebp]
	push	eax
	push	256					; 00000100H
	mov	cl, BYTE PTR _chType2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _uLth$11732[ebp]
	push	edx
	lea	eax, DWORD PTR _AttrVal2$[ebp]
	push	eax
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H

; 12465: 
; 12466:       pchValue2 = (zPCHAR) &AttrVal2;

	lea	ecx, DWORD PTR _AttrVal2$[ebp]
	mov	DWORD PTR _pchValue2$[ebp], ecx

; 12468:    else

	jmp	SHORT $L11737
$L11730:

; 12469:       fnGetAddrForAttribute( &pchValue2, 0, 0, lpInstance2, lpViewAttrib2 );

	mov	edx, DWORD PTR _lpViewAttrib2$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInstance2$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _pchValue2$[ebp]
	push	ecx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H
$L11737:

; 12470: 
; 12471:    switch ( chType1 )
; 12472:    {

	movsx	edx, BYTE PTR _chType1$[ebp]
	mov	DWORD PTR -572+[ebp], edx
	mov	eax, DWORD PTR -572+[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR -572+[ebp], eax
	cmp	DWORD PTR -572+[ebp], 18		; 00000012H
	ja	$L11739
	mov	edx, DWORD PTR -572+[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR $L12876[edx]
	jmp	DWORD PTR $L12877[ecx*4]
$L11742:

; 12473:       case zTYPE_STRING:
; 12474:          if ( lpViewAttrib1->bCaseSens )

	mov	eax, DWORD PTR _lpViewAttrib1$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 6
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L11743

; 12475:             nRC = zstrcmp( pchValue1, pchValue2 );

	mov	edx, DWORD PTR _pchValue1$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchValue2$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $L12872
	mov	eax, DWORD PTR _pchValue2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchValue1$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -576+[ebp], eax
	jmp	SHORT $L12873
$L12872:
	mov	edx, DWORD PTR _pchValue1$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchValue2$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	xor	ecx, ecx
	test	eax, eax
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -576+[ebp], ecx
$L12873:
	mov	dx, WORD PTR -576+[ebp]
	mov	WORD PTR _nRC$[ebp], dx

; 12476:          else

	jmp	SHORT $L11750
$L11743:

; 12477:             nRC = zstrcmpi( pchValue1, pchValue2 );

	mov	eax, DWORD PTR _pchValue2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchValue1$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$L11750:

; 12478: 
; 12479:          if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L11751

; 12480:             nRC = -1;

	mov	WORD PTR _nRC$[ebp], -1

; 12481:          else

	jmp	SHORT $L11753
$L11751:

; 12482:          if ( nRC > 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jle	SHORT $L11753

; 12483:             nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1
$L11753:

; 12484: 
; 12485:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11701
$L11754:

; 12486: 
; 12487:       case zTYPE_INTEGER:
; 12488:          if ( *((zPLONG) pchValue1) == *((zPLONG) pchValue2) )

	mov	ecx, DWORD PTR _pchValue1$[ebp]
	mov	edx, DWORD PTR _pchValue2$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $L11757

; 12489:             nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 12490:          else

	jmp	SHORT $L11758
$L11757:

; 12491:             nRC = (*((zPLONG) pchValue1) < *((zPLONG) pchValue2)) ? -1 : 1;

	mov	ecx, DWORD PTR _pchValue1$[ebp]
	mov	edx, DWORD PTR _pchValue2$[ebp]
	mov	eax, DWORD PTR [ecx]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setge	cl
	dec	ecx
	and	ecx, -2					; fffffffeH
	add	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
$L11758:

; 12492: 
; 12493:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11701
$L11761:

; 12494: 
; 12495:       case zTYPE_DECIMAL:
; 12496:          return( SysCompareDecimalToDecimal( (zPDECIMAL) pchValue1,
; 12497:                                              (zPDECIMAL) pchValue2 ) );

	mov	edx, DWORD PTR _pchValue2$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchValue1$[ebp]
	push	eax
	call	_SysCompareDecimalToDecimal@8
	jmp	$L11701
$L11764:

; 12498: 
; 12499:       case zTYPE_DATETIME:
; 12500:          nRC = fnCompareDateTimeToDateTime( (LPDTINTERNAL) pchValue1,
; 12501:                                             (LPDTINTERNAL) pchValue2 );

	mov	ecx, DWORD PTR _pchValue2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchValue1$[ebp]
	push	edx
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 12502:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11701
$L11767:

; 12506:          zULONG ulLth1, ulLth2, uBlobLth;
; 12507: 
; 12508:          fnGetAttributeLength( &ulLth1, 0, lpInstance1, lpViewAttrib1 );

	mov	eax, DWORD PTR _lpViewAttrib1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInstance1$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _ulLth1$11768[ebp]
	push	edx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 12509:          fnGetAttributeLength( &ulLth2, 0, lpInstance2, lpViewAttrib2 );

	mov	eax, DWORD PTR _lpViewAttrib2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInstance2$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _ulLth2$11769[ebp]
	push	edx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 12510: 
; 12511:          uBlobLth = min( ulLth1, ulLth2 );

	mov	eax, DWORD PTR _ulLth1$11768[ebp]
	cmp	eax, DWORD PTR _ulLth2$11769[ebp]
	jae	SHORT $L12874
	mov	ecx, DWORD PTR _ulLth1$11768[ebp]
	mov	DWORD PTR -580+[ebp], ecx
	jmp	SHORT $L12875
$L12874:
	mov	edx, DWORD PTR _ulLth2$11769[ebp]
	mov	DWORD PTR -580+[ebp], edx
$L12875:
	mov	eax, DWORD PTR -580+[ebp]
	mov	DWORD PTR _uBlobLth$11770[ebp], eax

; 12512: 
; 12513:          nRC = zmemcmp( pchValue1, pchValue2, (int) uBlobLth );

	mov	ecx, DWORD PTR _uBlobLth$11770[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchValue2$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchValue1$[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 12514:          if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L11772

; 12516:             if ( ulLth1 == ulLth2 )

	mov	edx, DWORD PTR _ulLth1$11768[ebp]
	cmp	edx, DWORD PTR _ulLth2$11769[ebp]
	jne	SHORT $L11773

; 12517:                return( 0 );

	xor	ax, ax
	jmp	SHORT $L11701
$L11773:

; 12518:             else
; 12519:                return( ulLth1 < ulLth2 ? -1 : 1 );

	mov	eax, DWORD PTR _ulLth1$11768[ebp]
	cmp	eax, DWORD PTR _ulLth2$11769[ebp]
	sbb	eax, eax
	and	al, -2					; fffffffeH
	add	eax, 1
	jmp	SHORT $L11701
$L11772:

; 12521:          else
; 12522:             return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L11701
$L11739:

; 12526: 
; 12527:    return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
$L11701:

; 12528: }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
$L12877:
	DD	$L11767
	DD	$L11754
	DD	$L11761
	DD	$L11742
	DD	$L11764
	DD	$L11739
$L12876:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_fnCompareEIAttrs@36 ENDP
_TEXT	ENDS
PUBLIC	_fnCmprEntities
_TEXT	SEGMENT
_hViewEntity1$ = 8
_hViewEntity2$ = 12
_lpViewEntity1$ = -4
_lpViewEntity2$ = -8
_fnCmprEntities PROC NEAR

; 12545: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 12546:    LPVIEWENTITY lpViewEntity1 = zGETPTR( hViewEntity1 );

	mov	eax, DWORD PTR _hViewEntity1$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity1$[ebp], eax

; 12547:    LPVIEWENTITY lpViewEntity2 = zGETPTR( hViewEntity2 );

	mov	ecx, DWORD PTR _hViewEntity2$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity2$[ebp], eax

; 12548: 
; 12549: #if 0
; 12550:    TraceLine( "fnSortCmpr Checking Entities: %s : 0x%08x, %s : 0x%08x",
; 12551:               lpViewEntity1->szName, lpViewEntity1->lEREntTok,
; 12552:               lpViewEntity2->szName, lpViewEntity2->lEREntTok );
; 12553: #endif
; 12554: 
; 12555:    // It appears that it is "good enough" for the entity tokens to
; 12556:    // match when doing the compare.  In such a case, for example,
; 12557:    // CtrlCtrl matches Control in TZWDLGSO.   dks 2005.12.26
; 12558:    if ( lpViewEntity1 && lpViewEntity2 &&
; 12559:         lpViewEntity1->lEREntTok == lpViewEntity2->lEREntTok )

	cmp	DWORD PTR _lpViewEntity1$[ebp], 0
	je	SHORT $L11793
	cmp	DWORD PTR _lpViewEntity2$[ebp], 0
	je	SHORT $L11793
	mov	edx, DWORD PTR _lpViewEntity1$[ebp]
	mov	eax, DWORD PTR _lpViewEntity2$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	jne	SHORT $L11793

; 12561:       return( 0 );

	xor	ax, ax
	jmp	SHORT $L11788
$L11793:

; 12563: 
; 12564:    return( 1 );

	mov	ax, 1
$L11788:

; 12565: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCmprEntities ENDP
_TEXT	ENDS
PUBLIC	_fnSortCmpr
_TEXT	SEGMENT
_lpSortData$ = 8
_lpEI1$ = 12
_lpEI2$ = 16
_lpAttrListPtr$ = -16
_lpCompareEI1$ = -8
_lpCompareEI2$ = -4
_nComp$ = -12
_fnSortCmpr PROC NEAR

; 12577: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 12578:    LPVIEWATTRLIST   lpAttrListPtr;
; 12579:    LPENTITYINSTANCE lpCompareEI1;
; 12580:    LPENTITYINSTANCE lpCompareEI2;
; 12581:    zSHORT           nComp;
; 12582: 
; 12583:    // Compare sort keys from major to minor.  When an inequality is
; 12584:    // found, see if an entity swap is needed.
; 12585:    for ( lpAttrListPtr = lpSortData->lpViewAttrList;
; 12586:          lpAttrListPtr->lpViewAttrib;
; 12587:          lpAttrListPtr++ )

	mov	eax, DWORD PTR _lpSortData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpAttrListPtr$[ebp], ecx
	jmp	SHORT $L11806
$L11807:
	mov	edx, DWORD PTR _lpAttrListPtr$[ebp]
	add	edx, 13					; 0000000dH
	mov	DWORD PTR _lpAttrListPtr$[ebp], edx
$L11806:
	mov	eax, DWORD PTR _lpAttrListPtr$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$L11808

; 12589:       // Check to see if the sort key belongs to the same entity that we are
; 12590:       // sorting.  If not we need to retrieve the EI for the sort key.
; 12591:       if ( lpAttrListPtr->lpViewAttrib->hViewEntity != lpEI1->hViewEntity &&
; 12592:            fnCmprEntities( lpAttrListPtr->lpViewAttrib->hViewEntity,
; 12593:                            lpEI1->hViewEntity ) != 0 )

	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	ecx, DWORD PTR [edx+6]
	cmp	ecx, DWORD PTR [eax+2]
	je	$L11809
	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_fnCmprEntities
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	je	$L11809

; 12595:          // Sort key is from a different entity than the swap entity.  This
; 12596:          // could happen if the user is sorting entities using the value of a
; 12597:          // child entity.  We need to retrieve the EI for the child entity.
; 12598:          // Since cursor positions are undefined at this point we will assume
; 12599:          // the first child entity.
; 12600:          lpCompareEI1 = zGETPTR( lpEI1->hNextHier );

	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareEI1$[ebp], eax
$L11812:

; 12601:          while ( lpCompareEI1 )

	cmp	DWORD PTR _lpCompareEI1$[ebp], 0
	je	SHORT $L11813

; 12603:             // Check to see if this is the EI we are looking for.
; 12604:             if ( lpCompareEI1->hViewEntity ==
; 12605:                                   lpAttrListPtr->lpViewAttrib->hViewEntity )

	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpCompareEI1$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR [edx+6]
	jne	SHORT $L11814

; 12607:                break;  // it is the EI we are looking for

	jmp	SHORT $L11813
$L11814:

; 12609: 
; 12610:             // Check the next EI.
; 12611:             lpCompareEI1 = zGETPTR( lpCompareEI1->hNextHier );

	mov	edx, DWORD PTR _lpCompareEI1$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareEI1$[ebp], eax

; 12612: 
; 12613:             if ( lpCompareEI1 == 0 )

	cmp	DWORD PTR _lpCompareEI1$[ebp], 0
	jne	SHORT $L11816

; 12614:                break;

	jmp	SHORT $L11813
$L11816:

; 12615: 
; 12616:             // If the level of the current EI is <= the level of the parent
; 12617:             // EI then we never found a matching child entity ... so break.
; 12618:             if ( lpCompareEI1->nLevel <= lpEI1->nLevel )

	mov	ecx, DWORD PTR _lpCompareEI1$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpEI1$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jg	SHORT $L11817

; 12620:                lpCompareEI1 = 0;

	mov	DWORD PTR _lpCompareEI1$[ebp], 0

; 12621:                break;

	jmp	SHORT $L11813
$L11817:

; 12623:          }

	jmp	SHORT $L11812
$L11813:

; 12624: 
; 12625:          // Do the same thing for the second EI.
; 12626:          lpCompareEI2 = zGETPTR( lpEI2->hNextHier );

	mov	edx, DWORD PTR _lpEI2$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareEI2$[ebp], eax
$L11820:

; 12627:          while ( lpCompareEI2 )

	cmp	DWORD PTR _lpCompareEI2$[ebp], 0
	je	SHORT $L11821

; 12629:             // Check to see if this is the EI we are looking for.
; 12630:             if ( lpCompareEI2->hViewEntity ==
; 12631:                                   lpAttrListPtr->lpViewAttrib->hViewEntity )

	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpCompareEI2$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR [edx+6]
	jne	SHORT $L11822

; 12633:                break;  // it is the EI we are looking for

	jmp	SHORT $L11821
$L11822:

; 12635: 
; 12636:             // Check the next EI.
; 12637:             lpCompareEI2 = zGETPTR( lpCompareEI2->hNextHier );

	mov	edx, DWORD PTR _lpCompareEI2$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareEI2$[ebp], eax

; 12638: 
; 12639:             if ( lpCompareEI2 == 0 )

	cmp	DWORD PTR _lpCompareEI2$[ebp], 0
	jne	SHORT $L11824

; 12640:                break;

	jmp	SHORT $L11821
$L11824:

; 12641: 
; 12642:             // If the level of the current EI is <= the level of the parent
; 12643:             // EI then we never found a matching child entity ... so break.
; 12644:             if ( lpCompareEI2->nLevel <= lpEI2->nLevel )

	mov	ecx, DWORD PTR _lpCompareEI2$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpEI2$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jg	SHORT $L11825

; 12646:                lpCompareEI2 = 0;

	mov	DWORD PTR _lpCompareEI2$[ebp], 0

; 12647:                break;

	jmp	SHORT $L11821
$L11825:

; 12649:          }

	jmp	SHORT $L11820
$L11821:

; 12650: 
; 12651:          // If either of the compare entities are 0 then they don't
; 12652:          // exist so set nComp and break.
; 12653:          if ( lpCompareEI1 == 0 || lpCompareEI2 == 0 )

	cmp	DWORD PTR _lpCompareEI1$[ebp], 0
	je	SHORT $L11827
	cmp	DWORD PTR _lpCompareEI2$[ebp], 0
	jne	SHORT $L11826
$L11827:

; 12655:             // If they are the same then they are both 0 and we'll assume
; 12656:             // that they compare equal.
; 12657:             if ( lpCompareEI1 == lpCompareEI2 )

	mov	edx, DWORD PTR _lpCompareEI1$[ebp]
	cmp	edx, DWORD PTR _lpCompareEI2$[ebp]
	jne	SHORT $L11828

; 12658:                nComp = 0;

	mov	WORD PTR _nComp$[ebp], 0

; 12659:             else

	jmp	SHORT $L11831
$L11828:

; 12660:             if ( lpCompareEI1 ) // EI1 is valid but EI2 is not so we'll assume EI1 > EI2.

	cmp	DWORD PTR _lpCompareEI1$[ebp], 0
	je	SHORT $L11830

; 12661:                nComp = 1;

	mov	WORD PTR _nComp$[ebp], 1

; 12662:             else

	jmp	SHORT $L11831
$L11830:

; 12663:                nComp = -1;

	mov	WORD PTR _nComp$[ebp], -1
$L11831:

; 12664: 
; 12665:             break;

	jmp	SHORT $L11808
$L11826:

; 12668:       else

	jmp	SHORT $L11832
$L11809:

; 12670:          // We are comparing the same entity we are swapping.
; 12671:          lpCompareEI1 = lpEI1;

	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	DWORD PTR _lpCompareEI1$[ebp], eax

; 12672:          lpCompareEI2 = lpEI2;

	mov	ecx, DWORD PTR _lpEI2$[ebp]
	mov	DWORD PTR _lpCompareEI2$[ebp], ecx
$L11832:

; 12674: 
; 12675:       // Now actually perform the compare.
; 12676:       nComp = fnCompareEIAttrs( lpSortData->lpCurrentTask,
; 12677:                                 lpSortData->lpView1, lpCompareEI1,
; 12678:                                 lpAttrListPtr->lpViewAttrib,
; 12679:                                 lpAttrListPtr->pszContextName,
; 12680:                                 lpSortData->lpView2, lpCompareEI2,
; 12681:                                 lpAttrListPtr->lpViewAttrib,
; 12682:                                 lpAttrListPtr->pszContextName );

	mov	edx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	eax, DWORD PTR [edx+9]
	push	eax
	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _lpCompareEI2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _lpAttrListPtr$[ebp]
	mov	ecx, DWORD PTR [eax+9]
	push	ecx
	mov	edx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpCompareEI1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fnCompareEIAttrs@36
	mov	WORD PTR _nComp$[ebp], ax

; 12683: 
; 12684:       // If the compare wasn't equal then we don't need to compare any more
; 12685:       // because we know the EIs are different.
; 12686:       if ( nComp )

	movsx	eax, WORD PTR _nComp$[ebp]
	test	eax, eax
	je	SHORT $L11833

; 12687:          break;

	jmp	SHORT $L11808
$L11833:

; 12688: 
; 12689:    } // for...

	jmp	$L11807
$L11808:

; 12690: 
; 12691:    // If the EIs are different then find out if they need to be swapped.
; 12692:    if ( nComp )

	movsx	ecx, WORD PTR _nComp$[ebp]
	test	ecx, ecx
	je	SHORT $L11836

; 12694:       if ( nComp < 0 && lpAttrListPtr->bOrder )

	movsx	edx, WORD PTR _nComp$[ebp]
	test	edx, edx
	jge	SHORT $L11835
	mov	eax, DWORD PTR _lpAttrListPtr$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+8]
	test	ecx, ecx
	je	SHORT $L11835

; 12695:          return( 1 );

	mov	ax, 1
	jmp	SHORT $L11801
$L11835:

; 12696: 
; 12697:       if ( nComp > 0 && lpAttrListPtr->bOrder == FALSE )

	movsx	edx, WORD PTR _nComp$[ebp]
	test	edx, edx
	jle	SHORT $L11836
	mov	eax, DWORD PTR _lpAttrListPtr$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+8]
	test	ecx, ecx
	jne	SHORT $L11836

; 12698:          return( 1 );

	mov	ax, 1
	jmp	SHORT $L11801
$L11836:

; 12700: 
; 12701:    // If we get here then the EIs are in correct order.
; 12702:    return( 0 );

	xor	ax, ax
$L11801:

; 12703: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSortCmpr ENDP
_TEXT	ENDS
PUBLIC	_Heapify
_TEXT	SEGMENT
_lpSortData$ = 8
_lpEI$ = 12
_ulRecordCnt$ = 16
_k$ = 20
_ulLeft$ = -8
_ulLargest$ = -4
_t$11854 = -12
_Heapify PROC NEAR

; 12722: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 12723: // ASSERT_TRACE( "Heapify error", 0, k <= ulRecordCnt );
; 12724:    zULONG ulLeft = k << 1;

	mov	eax, DWORD PTR _k$[ebp]
	shl	eax, 1
	mov	DWORD PTR _ulLeft$[ebp], eax

; 12725:    zULONG ulLargest;
; 12726: 
; 12727:    if ( ulLeft > ulRecordCnt )

	mov	ecx, DWORD PTR _ulLeft$[ebp]
	cmp	ecx, DWORD PTR _ulRecordCnt$[ebp]
	jbe	SHORT $L11849

; 12729:       return( 0 );

	xor	eax, eax
	jmp	$L11846
$L11849:

; 12731: 
; 12732:    ulLargest = k;

	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _ulLargest$[ebp], edx

; 12733: // if ( CompareRecords( ulLeft, ulLargest ) > 0 )
; 12734:    if ( fnSortCmpr( lpSortData, lpEI[ ulLeft - 1 ], lpEI[ ulLargest - 1 ] ) )

	mov	eax, DWORD PTR _ulLargest$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	push	edx
	mov	eax, DWORD PTR _ulLeft$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	push	edx
	mov	eax, DWORD PTR _lpSortData$[ebp]
	push	eax
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11850

; 12736:       ulLargest = ulLeft;

	mov	edx, DWORD PTR _ulLeft$[ebp]
	mov	DWORD PTR _ulLargest$[ebp], edx
$L11850:

; 12738: 
; 12739:    ulLeft++;   // ulRight (use ulLeft to conserve stack space)

	mov	eax, DWORD PTR _ulLeft$[ebp]
	add	eax, 1
	mov	DWORD PTR _ulLeft$[ebp], eax

; 12740:    if ( ulLeft <= ulRecordCnt )

	mov	ecx, DWORD PTR _ulLeft$[ebp]
	cmp	ecx, DWORD PTR _ulRecordCnt$[ebp]
	ja	SHORT $L11852

; 12742:    // if ( CompareRecords( ulLeft, ulLargest ) > 0 )
; 12743:       if ( fnSortCmpr( lpSortData, lpEI[ ulLeft - 1 ], lpEI[ ulLargest - 1 ] ) )

	mov	edx, DWORD PTR _ulLargest$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4-4]
	push	ecx
	mov	edx, DWORD PTR _ulLeft$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4-4]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	push	edx
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	eax, ax
	test	eax, eax
	je	SHORT $L11852

; 12745:          ulLargest = ulLeft;

	mov	ecx, DWORD PTR _ulLeft$[ebp]
	mov	DWORD PTR _ulLargest$[ebp], ecx
$L11852:

; 12748: 
; 12749:    if ( k != ulLargest )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _ulLargest$[ebp]
	je	SHORT $L11853

; 12751:       SWAP_EI( lpEI[ k - 1 ], lpEI[ ulLargest - 1 ] );

	mov	eax, DWORD PTR _ulLargest$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	DWORD PTR _t$11854[ebp], edx
	mov	eax, DWORD PTR _ulLargest$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [esi+edx*4-4]
	mov	DWORD PTR [ecx+eax*4-4], edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _t$11854[ebp]
	mov	DWORD PTR [ecx+eax*4-4], edx

; 12752:    // zULONG *p1;
; 12753:    // zULONG *p2;
; 12754: 
; 12755:    // // Use uLeft to conserve stack.
; 12756:    // p1 = CSIMP_GETSORTIDX_PTR( k, m_pUseIdx->m_pxIdx );
; 12757:    // p2 = CSIMP_GETSORTIDX_PTR( ulLargest, m_pUseIdx->m_pxIdx );
; 12758:    // ulLeft = *p1;
; 12759:    // *p1 = *p2;
; 12760:    // *p2 = ulLeft;
; 12761:       return( ulLargest );

	mov	eax, DWORD PTR _ulLargest$[ebp]
	jmp	SHORT $L11846
$L11853:

; 12763: 
; 12764:    return( 0 );

	xor	eax, eax
$L11846:

; 12765: }  // end of:  Heapify

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Heapify ENDP
_TEXT	ENDS
PUBLIC	_BuildHeap
_TEXT	SEGMENT
_lpSortData$ = 8
_lpEI$ = 12
_ulRecordCnt$ = 16
_k$ = -8
_ul$ = -4
_BuildHeap PROC NEAR

; 12774: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 12775:    zULONG k;
; 12776:    zULONG ul;
; 12777: 
; 12778: #ifdef DEBUG_ALL
; 12779:    OutputDebugString( "\nShowing heap prior to build heap ...\n" );
; 12780:    ShowHeap( this, m_pUseIdx->m_pxIdx );
; 12781: #endif
; 12782: 
; 12783:    k = ulRecordCnt / 2;

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	shr	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$L11866:

; 12784:    while ( k > 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jbe	SHORT $L11867

; 12786:       ul = Heapify( lpSortData, lpEI, ulRecordCnt, k-- );

	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR -12+[ebp], ecx
	mov	edx, DWORD PTR -12+[ebp]
	push	edx
	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	call	_Heapify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ul$[ebp], eax
$L11869:

; 12787:       while ( ul )

	cmp	DWORD PTR _ul$[ebp], 0
	je	SHORT $L11870

; 12789:          ul = Heapify( lpSortData, lpEI, ulRecordCnt, ul );

	mov	ecx, DWORD PTR _ul$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulRecordCnt$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_Heapify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ul$[ebp], eax

; 12790:       }

	jmp	SHORT $L11869
$L11870:

; 12791:    }

	jmp	SHORT $L11866
$L11867:

; 12792: }  // end of:  BuildHeap

	mov	esp, ebp
	pop	ebp
	ret	0
_BuildHeap ENDP
_TEXT	ENDS
PUBLIC	_fnHeapSort
_TEXT	SEGMENT
_lpSortData$ = 8
_lpEI$ = 12
_ulRecordCnt$ = 16
_ul$ = -4
_fnHeapSort PROC NEAR

; 12801: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 12802: // zULONG ulHoldCnt = ulRecordCnt;
; 12803: // zULONG ulHoldMax = ulMaxRecords;
; 12804: // zULONG *p1;
; 12805:    zULONG ul;
; 12806: 
; 12807:    BuildHeap( lpSortData, lpEI, ulRecordCnt );

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	push	edx
	call	_BuildHeap
	add	esp, 12					; 0000000cH
$L11881:

; 12808: 
; 12809:    while ( ulRecordCnt > 1 )

	cmp	DWORD PTR _ulRecordCnt$[ebp], 1
	jbe	SHORT $L11882

; 12811:       ulRecordCnt--;

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ulRecordCnt$[ebp], eax

; 12812:    // ulMaxRecords--;
; 12813:    //
; 12814:    // p1 = CSIMP_GETSORTIDX_PTR( ulRecordCnt + 1, m_pUseIdx->m_pxIdx );
; 12815:    // ul = *p1;
; 12816:    // *p1 = *(m_pUseIdx->m_pxIdx);
; 12817:    // *(m_pUseIdx->m_pxIdx) = ul;
; 12818: 
; 12819:    // ul = Heapify( 1 );
; 12820:       ul = Heapify( lpSortData, lpEI, ulRecordCnt, 1 );

	push	1
	mov	ecx, DWORD PTR _ulRecordCnt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEI$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSortData$[ebp]
	push	eax
	call	_Heapify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ul$[ebp], eax
$L11884:

; 12821:       while ( ul )

	cmp	DWORD PTR _ul$[ebp], 0
	je	SHORT $L11885

; 12823:       // ul = Heapify( ul );
; 12824:          ul = Heapify( lpSortData, lpEI, ulRecordCnt, ul );

	mov	ecx, DWORD PTR _ul$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulRecordCnt$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_Heapify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ul$[ebp], eax

; 12825:       }

	jmp	SHORT $L11884
$L11885:

; 12826:    }

	jmp	SHORT $L11881
$L11882:

; 12827: 
; 12828: // ulRecordCnt = ulHoldCnt;
; 12829: // ulMaxRecords = ulHoldMax;
; 12830: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnHeapSort ENDP
_TEXT	ENDS
PUBLIC	_fnQuickSort
_TEXT	SEGMENT
_lpSortData$ = 8
_lpEI$ = 12
_ulRecordCnt$ = 16
_k$ = -12
_j$ = -8
_ulLeft$ = -16
_ulRight$ = -4
_t$11901 = -20
_t$11914 = -24
_t$11915 = -28
_fnQuickSort PROC NEAR

; 12839: {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
$L11899:

; 12840:    zULONG k, j, ulLeft, ulRight;
; 12841: 
; 12842:    while ( ulRecordCnt > 1 )

	cmp	DWORD PTR _ulRecordCnt$[ebp], 1
	jbe	$L11900

; 12844:       SWAP_EI( lpEI[ 0 ], lpEI[ ulRecordCnt / 2 ] );

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _t$11901[ebp], edx
	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR _t$11901[ebp]
	mov	DWORD PTR [eax], ecx

; 12845: 
; 12846:       for ( k = 0, j = ulRecordCnt; ; )

	mov	DWORD PTR _k$[ebp], 0
	mov	edx, DWORD PTR _ulRecordCnt$[ebp]
	mov	DWORD PTR _j$[ebp], edx
$L11903:

; 12848:          // Search for an EI that is "less than" lpEI[ 0 ].
; 12849:          do
; 12850:             j--;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax

; 12851:          while ( j > 0 && fnSortCmpr( lpSortData, lpEI[ j ], lpEI[ 0 ] ) );

	cmp	DWORD PTR _j$[ebp], 0
	jbe	SHORT $L11908
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _lpSortData$[ebp]
	push	eax
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L11903
$L11908:

; 12852: 
; 12853:          // Search for an EI that is "less than" lpEI[ 0 ].
; 12854:          do
; 12855:             k++;

	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 12856:          while ( k < j && !fnSortCmpr( lpSortData, lpEI[ k ], lpEI[ 0 ] ) );

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _j$[ebp]
	jae	SHORT $L11912
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _lpSortData$[ebp]
	push	eax
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L11908
$L11912:

; 12857: 
; 12858:          if ( k >= j )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _j$[ebp]
	jb	SHORT $L11913

; 12859:             break;

	jmp	SHORT $L11904
$L11913:

; 12860: 
; 12861:          SWAP_EI( lpEI[ k ], lpEI[ j ] );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _t$11914[ebp], edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _t$11914[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 12862:       }

	jmp	$L11903
$L11904:

; 12863: 
; 12864:       SWAP_EI( lpEI[ j ], lpEI[ 0 ] );

	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _t$11915[ebp], ecx
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR _t$11915[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 12865: 
; 12866:       ulLeft = j;

	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _ulLeft$[ebp], ecx

; 12867:       ulRight = ulRecordCnt - ++j;

	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	sub	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _ulRight$[ebp], eax

; 12868:       if ( ulLeft < ulRight )

	mov	ecx, DWORD PTR _ulLeft$[ebp]
	cmp	ecx, DWORD PTR _ulRight$[ebp]
	jae	SHORT $L11916

; 12870:          fnQuickSort( lpSortData, lpEI, ulLeft );

	mov	edx, DWORD PTR _ulLeft$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_fnQuickSort
	add	esp, 12					; 0000000cH

; 12871: 
; 12872:          lpEI += j;

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _lpEI$[ebp], ecx

; 12873:          ulRecordCnt = ulRight;

	mov	edx, DWORD PTR _ulRight$[ebp]
	mov	DWORD PTR _ulRecordCnt$[ebp], edx

; 12875:       else

	jmp	SHORT $L11917
$L11916:

; 12877:          fnQuickSort( lpSortData, lpEI + j, ulRight );

	mov	eax, DWORD PTR _ulRight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_fnQuickSort
	add	esp, 12					; 0000000cH

; 12878:          ulRecordCnt = ulLeft;

	mov	edx, DWORD PTR _ulLeft$[ebp]
	mov	DWORD PTR _ulRecordCnt$[ebp], edx
$L11917:

; 12880: 
; 12881:    } // while ( ulRecordCnt > 1 )...

	jmp	$L11899
$L11900:

; 12882: 
; 12883: } // fnQuickSort

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnQuickSort ENDP
_TEXT	ENDS
PUBLIC	_fnBubbleSort
_TEXT	SEGMENT
_lpSortData$ = 8
_lpEI$ = 12
_ulRecordCnt$ = 16
_k$ = -8
_j$ = -4
_bSwaps$ = -12
_t$11936 = -16
_fnBubbleSort PROC NEAR

; 12889: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 12890:    zULONG k, j;
; 12891:    zBOOL  bSwaps;
; 12892: 
; 12893:    for ( k = ulRecordCnt - 1; k > 0; k-- )

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $L11929
$L11930:
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$L11929:
	cmp	DWORD PTR _k$[ebp], 0
	jbe	$L11931

; 12895:       bSwaps = FALSE;

	mov	BYTE PTR _bSwaps$[ebp], 0

; 12896: 
; 12897:       for ( j = 0; j < k; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L11932
$L11933:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L11932:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jae	SHORT $L11934

; 12899:          // If EI[ j ] is > EI[ j + 1 ] then swap them.
; 12900:          if ( fnSortCmpr( lpSortData, lpEI[ j ], lpEI[ j + 1 ] ) )

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L11935

; 12902:             bSwaps = TRUE;

	mov	BYTE PTR _bSwaps$[ebp], 1

; 12903:             SWAP_EI( lpEI[ j ], lpEI[ j + 1 ] );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR _t$11936[ebp], edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4+4], edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _t$11936[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
$L11935:

; 12905:       }

	jmp	SHORT $L11933
$L11934:

; 12906: 
; 12907:       // If there were no swaps then everything's in order so get out.
; 12908:       if ( bSwaps == FALSE )

	mov	eax, DWORD PTR _bSwaps$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L11937

; 12909:          break;

	jmp	SHORT $L11931
$L11937:

; 12910:    }

	jmp	$L11930
$L11931:

; 12911: 
; 12912: } // fnBubbleSort

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnBubbleSort ENDP
_TEXT	ENDS
PUBLIC	_fnOrderEntityForView@16
EXTRN	_fnGetAttribOper:NEAR
EXTRN	_fnFindLastEntityUnderParent@8:NEAR
EXTRN	_SysAllocMemory@20:NEAR
EXTRN	_SysFreeMemory@4:NEAR
_TEXT	SEGMENT
_zView$ = 8
_lpEntityInstance$ = 12
_lpViewAttrList$ = 16
_bUseBubbleSort$ = 20
_SortData$ = -60
_lpViewAttrListPtr$ = -8
_lpEI1$ = -72
_lpLastChild$ = -32
_lpLastOldChild$ = -44
_lpEIBuffer$ = -4
_lpFirstEntityInstance$ = -40
_lpLastEntityInstance$ = -28
_ulEntityCnt$ = -68
_ulFront$ = -64
_ulBack$ = -24
_k$ = -36
_hEIBuffer$ = -20
_bDerivedAttribPresent$ = -12
_nRC$ = -16
_lpCurrentTask$ = -76
_lpViewAttrib$11971 = -80
_lpView$11992 = -84
_lpViewEntityCsr$11998 = -88
_hViewEntity$12003 = -96
_lpViewEntity$12004 = -92
_lpSearch$12007 = -100
_lpViewCsr$12022 = -104
_lpViewOI$12024 = -108
_lpPrevHier$12028 = -112
_lpNextHier$12033 = -116
_fnOrderEntityForView@16 PROC NEAR

; 12931: {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H

; 12932:    SortDataRecord    SortData;
; 12933:    LPVIEWATTRLIST    lpViewAttrListPtr;
; 12934:    LPENTITYINSTANCE  lpEI1;
; 12935:    LPENTITYINSTANCE  lpLastChild;
; 12936:    LPENTITYINSTANCE  lpLastOldChild;
; 12937:    LPENTITYINSTANCE  *lpEIBuffer;
; 12938:    LPENTITYINSTANCE  lpFirstEntityInstance;
; 12939:    LPENTITYINSTANCE  lpLastEntityInstance;
; 12940:    zULONG            ulEntityCnt;
; 12941:    zULONG            ulFront, ulBack, k;
; 12942:    zLONG             hEIBuffer;
; 12943:    zBOOL             bDerivedAttribPresent = FALSE;

	mov	BYTE PTR _bDerivedAttribPresent$[ebp], 0

; 12944:    zSHORT            nRC;
; 12945: 
; 12946:    // Only used with derived attributes ...
; 12947:    LPTASK            lpCurrentTask;
; 12948: 
; 12949:    // If instance is null, there is nothing to sort ...
; 12950:    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $L11964

; 12951:       return( 0 );

	xor	ax, ax
	jmp	$L11947
$L11964:

; 12952: 
; 12953:    // Error if trying to sort "unset".
; 12954:    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $L11966

; 12955:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L11947
$L11966:

; 12956: 
; 12957:    lpCurrentTask = zGETPTR( zView->hTask );

	mov	eax, DWORD PTR _zView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 12958: // lpCurrentTask = fnFindTask( 0 );  // dks 2006.04.05  back to 10b
; 12959: 
; 12960:    // Scan through the view attributes for any derived attributes.
; 12961:    for ( lpViewAttrListPtr = lpViewAttrList;
; 12962:          lpViewAttrListPtr->lpViewAttrib;
; 12963:          lpViewAttrListPtr++ )

	mov	edx, DWORD PTR _lpViewAttrList$[ebp]
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], edx
	jmp	SHORT $L11968
$L11969:
	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	add	eax, 13					; 0000000dH
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], eax
$L11968:
	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L11970

; 12965:       LPVIEWATTRIB lpViewAttrib = lpViewAttrListPtr->lpViewAttrib;

	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpViewAttrib$11971[ebp], eax

; 12966: 
; 12967:       if ( lpViewAttrib->szDerivedOper[ 0 ] )

	mov	ecx, DWORD PTR _lpViewAttrib$11971[ebp]
	movsx	edx, BYTE PTR [ecx+213]
	test	edx, edx
	je	SHORT $L11972

; 12969:          bDerivedAttribPresent = TRUE;

	mov	BYTE PTR _bDerivedAttribPresent$[ebp], 1

; 12970:          lpViewAttrListPtr->pfObjectOper =
; 12971:                        fnGetAttribOper( zView, lpViewAttrib, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$11971[ebp]
	push	ecx
	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	call	_fnGetAttribOper
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	DWORD PTR [ecx+4], eax
$L11972:

; 12973:    }

	jmp	SHORT $L11969
$L11970:

; 12974: 
; 12975:    // Count the number of entities after lpEntityInstance.
; 12976:    ulEntityCnt = 1; // account for the current lpEntityInstance

	mov	DWORD PTR _ulEntityCnt$[ebp], 1

; 12977:    for ( lpLastEntityInstance = lpEntityInstance;
; 12978:          lpLastEntityInstance->hNextTwin;
; 12979:          lpLastEntityInstance = zGETPTR( lpLastEntityInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpLastEntityInstance$[ebp], edx
	jmp	SHORT $L11974
$L11975:
	mov	eax, DWORD PTR _lpLastEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastEntityInstance$[ebp], eax
$L11974:
	mov	edx, DWORD PTR _lpLastEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $L11976

; 12981:       ulEntityCnt++;

	mov	eax, DWORD PTR _ulEntityCnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _ulEntityCnt$[ebp], eax

; 12982:    }

	jmp	SHORT $L11975
$L11976:

; 12983: 
; 12984:    // Add the number of entities prior to lpEntityInstance.
; 12985:    for ( lpFirstEntityInstance = lpEntityInstance;
; 12986:          lpFirstEntityInstance->hPrevTwin;
; 12987:          lpFirstEntityInstance = zGETPTR( lpFirstEntityInstance->hPrevTwin ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpFirstEntityInstance$[ebp], ecx
	jmp	SHORT $L11978
$L11979:
	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstEntityInstance$[ebp], eax
$L11978:
	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $L11980

; 12989:       ulEntityCnt++;

	mov	edx, DWORD PTR _ulEntityCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _ulEntityCnt$[ebp], edx

; 12990:    }

	jmp	SHORT $L11979
$L11980:

; 12991: 
; 12992:    // If we only have 1 entity then there's nothing to sort.
; 12993:    if ( ulEntityCnt == 1 )

	cmp	DWORD PTR _ulEntityCnt$[ebp], 1
	jne	SHORT $L11981

; 12994:       return( 0 );

	xor	ax, ax
	jmp	$L11947
$L11981:

; 12995: 
; 12996:    // Now allocate space to hold all the entity instances.
; 12997:    hEIBuffer = SysAllocMemory( (zCOREMEM) &lpEIBuffer,
; 12998:                                sizeof( LPENTITYINSTANCE ) * ulEntityCnt,
; 12999:                                0, zCOREMEM_ALLOC, 0 );

	push	0
	push	32768					; 00008000H
	push	0
	mov	eax, DWORD PTR _ulEntityCnt$[ebp]
	shl	eax, 2
	push	eax
	lea	ecx, DWORD PTR _lpEIBuffer$[ebp]
	push	ecx
	call	_SysAllocMemory@20
	mov	DWORD PTR _hEIBuffer$[ebp], eax

; 13000: 
; 13001:    // Copy the list of entity pointers into the buffer.  We'll put all the
; 13002:    // hidden instances at the end because we don't need/want to sort them.
; 13003:    ulFront = 0;

	mov	DWORD PTR _ulFront$[ebp], 0

; 13004:    ulBack  = ulEntityCnt - 1;

	mov	edx, DWORD PTR _ulEntityCnt$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ulBack$[ebp], edx

; 13005:    for ( lpEI1 = lpFirstEntityInstance;
; 13006:          lpEI1;
; 13007:          lpEI1 = zGETPTR( lpEI1->hNextTwin ) )

	mov	eax, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEI1$[ebp], eax
	jmp	SHORT $L11985
$L11986:
	mov	ecx, DWORD PTR _lpEI1$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI1$[ebp], eax
$L11985:
	cmp	DWORD PTR _lpEI1$[ebp], 0
	je	SHORT $L11987

; 13009:       if ( lpEI1->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L11988

; 13010:          lpEIBuffer[ ulBack-- ] = lpEI1;  // put hidden EI at the end

	mov	edx, DWORD PTR _ulBack$[ebp]
	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR _lpEI1$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR _ulBack$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ulBack$[ebp], edx

; 13011:       else

	jmp	SHORT $L11989
$L11988:

; 13012:          lpEIBuffer[ ulFront++ ] = lpEI1;

	mov	eax, DWORD PTR _ulFront$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _ulFront$[ebp]
	add	eax, 1
	mov	DWORD PTR _ulFront$[ebp], eax
$L11989:

; 13013:    }

	jmp	SHORT $L11986
$L11987:

; 13014: 
; 13015:    // ulFront is a count of all the non-hidden EIs.  If there's only one EI
; 13016:    // then don't bother sorting.
; 13017:    if ( ulFront <= 1 )

	cmp	DWORD PTR _ulFront$[ebp], 1
	ja	SHORT $L11990

; 13019:       SysFreeMemory( hEIBuffer );

	mov	ecx, DWORD PTR _hEIBuffer$[ebp]
	push	ecx
	call	_SysFreeMemory@4

; 13020:       return( 0 );

	xor	ax, ax
	jmp	$L11947
$L11990:

; 13022: 
; 13023:    // If any derived attributes in the order keys, go set them for all of
; 13024:    // the entities now.
; 13025:    if ( bDerivedAttribPresent )

	mov	edx, DWORD PTR _bDerivedAttribPresent$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	$L11991

; 13027:       zVIEW lpView;
; 13028: 
; 13029:       if ( (nRC = fnDeclareView( &lpView, lpCurrentTask, zView, 0, 0 )) != 0 )

	push	0
	push	0
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpView$11992[ebp]
	push	edx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L11993

; 13031:          SysFreeMemory( hEIBuffer );

	mov	ecx, DWORD PTR _hEIBuffer$[ebp]
	push	ecx
	call	_SysFreeMemory@4

; 13032:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11947
$L11993:

; 13034: 
; 13035:       fnSetViewFromView( lpView, zView );

	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$11992[ebp]
	push	eax
	call	_fnSetViewFromView
	add	esp, 8

; 13036:       for ( lpEI1 = lpFirstEntityInstance;
; 13037:             lpEI1;
; 13038:             lpEI1 = zGETPTR( lpEI1->hNextTwin ) )

	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEI1$[ebp], ecx
	jmp	SHORT $L11995
$L11996:
	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI1$[ebp], eax
$L11995:
	cmp	DWORD PTR _lpEI1$[ebp], 0
	je	$L11997

; 13040:          LPVIEWENTITYCSR   lpViewEntityCsr;
; 13041: 
; 13042:          if ( lpEI1->u.nInd.bHidden )

	mov	ecx, DWORD PTR _lpEI1$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	je	SHORT $L11999

; 13043:             continue;

	jmp	SHORT $L11996
$L11999:

; 13044: 
; 13045:          lpViewEntityCsr = fnEstablishViewForInstance( lpView, 0, lpEI1 );

	mov	eax, DWORD PTR _lpEI1$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$11992[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$11998[ebp], eax

; 13046: 
; 13047:          // Set all of the derived attributes (that are used as sort keys)
; 13048:          // for the entity instance.
; 13049:          for ( lpViewAttrListPtr = lpViewAttrList;
; 13050:                lpViewAttrListPtr->lpViewAttrib;
; 13051:                lpViewAttrListPtr++ )

	mov	edx, DWORD PTR _lpViewAttrList$[ebp]
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], edx
	jmp	SHORT $L12000
$L12001:
	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	add	eax, 13					; 0000000dH
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], eax
$L12000:
	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$L12002

; 13053:             LPVIEWENTITY hViewEntity;
; 13054:             LPVIEWENTITY lpViewEntity;
; 13055: 
; 13056:             if ( lpViewAttrListPtr->pfObjectOper == 0 )

	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $L12005

; 13057:                continue;

	jmp	SHORT $L12001
$L12005:

; 13058: 
; 13059:             // If the view entity for the sorting attribute is different
; 13060:             // from the view entity for the EI we're sorting then the attr
; 13061:             // must be from a child entity.  Make sure a child EI exists
; 13062:             // before we call the derived operation.
; 13063:             hViewEntity = lpViewAttrListPtr->lpViewAttrib->hViewEntity;

	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR _hViewEntity$12003[ebp], edx

; 13064:             if ( hViewEntity != lpEI1->hViewEntity )

	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	ecx, DWORD PTR _hViewEntity$12003[ebp]
	cmp	ecx, DWORD PTR [eax+2]
	je	SHORT $L12016

; 13066:                LPENTITYINSTANCE lpSearch;
; 13067: 
; 13068:                for ( lpSearch = zGETPTR( lpEI1->hNextHier );
; 13069:                      lpSearch;
; 13070:                      lpSearch = zGETPTR( lpSearch->hNextHier ) )

	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearch$12007[ebp], eax
	jmp	SHORT $L12010
$L12011:
	mov	ecx, DWORD PTR _lpSearch$12007[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearch$12007[ebp], eax
$L12010:
	cmp	DWORD PTR _lpSearch$12007[ebp], 0
	je	SHORT $L12012

; 13072:                   if ( lpSearch->nLevel <= lpEI1->nLevel )

	mov	eax, DWORD PTR _lpSearch$12007[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpEI1$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	jg	SHORT $L12013

; 13074:                      lpSearch = 0;

	mov	DWORD PTR _lpSearch$12007[ebp], 0

; 13075:                      break;

	jmp	SHORT $L12012
$L12013:

; 13077: 
; 13078:                   if ( lpSearch->hViewEntity == hViewEntity )

	mov	ecx, DWORD PTR _lpSearch$12007[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hViewEntity$12003[ebp]
	jne	SHORT $L12014

; 13079:                      break;

	jmp	SHORT $L12012
$L12014:

; 13080:                }

	jmp	SHORT $L12011
$L12012:

; 13081: 
; 13082:                // If lpSearch is 0 then we didn't find a child EI matching
; 13083:                // hViewEntity so don't call the derived operation.
; 13084:                if ( lpSearch == 0 )

	cmp	DWORD PTR _lpSearch$12007[ebp], 0
	jne	SHORT $L12015

; 13085:                   continue;

	jmp	$L12001
$L12015:

; 13088:                   // Establish cursor position for the child entity. (dks and DonC 2009.12.23)
; 13089:                   fnEstablishViewForInstance( lpView, 0, lpSearch );

	mov	eax, DWORD PTR _lpSearch$12007[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$11992[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
$L12016:

; 13092: 
; 13093:             lpViewEntity = zGETPTR( hViewEntity );

	mov	edx, DWORD PTR _hViewEntity$12003[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$12004[ebp], eax

; 13094: 
; 13095:             nRC = (*lpViewAttrListPtr->pfObjectOper)( lpView, lpViewEntity,
; 13096:                                                       lpViewAttrListPtr->lpViewAttrib,
; 13097:                                                       zDERIVED_GET );

	push	2
	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$12004[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$11992[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	call	DWORD PTR [ecx+4]
	mov	WORD PTR _nRC$[ebp], ax

; 13098:             if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L12018

; 13100:                SysFreeMemory( hEIBuffer );

	mov	eax, DWORD PTR _hEIBuffer$[ebp]
	push	eax
	call	_SysFreeMemory@4

; 13101:                fnDropView( lpView );

	mov	ecx, DWORD PTR _lpView$11992[ebp]
	push	ecx
	call	_fnDropView@4

; 13102:                return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L11947
$L12018:

; 13104:          }

	jmp	$L12001
$L12002:

; 13105: 
; 13106:       } // for each lpEI1...

	jmp	$L11996
$L11997:

; 13107: 
; 13108:       fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$11992[ebp]
	push	edx
	call	_fnDropView@4
$L11991:

; 13111: 
; 13112:    // Set up information for sorting.
; 13113:    SortData.lpViewAttrList = lpViewAttrList;

	mov	eax, DWORD PTR _lpViewAttrList$[ebp]
	mov	DWORD PTR _SortData$[ebp+4], eax

; 13114:    SortData.lpCurrentTask  = lpCurrentTask;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _SortData$[ebp], ecx

; 13115:    CreateViewFromViewForTask( &SortData.lpView1, zView, zView );

	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _SortData$[ebp+8]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 13116:    CreateViewFromViewForTask( &SortData.lpView2, zView, zView );

	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _SortData$[ebp+12]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 13117: 
; 13118:    // Call operation to sort the entity list.  We use ulFront instead of
; 13119:    // ulEntityCnt because we only want to sort the non-hidden EIs.
; 13120:    if ( bUseBubbleSort )

	mov	edx, DWORD PTR _bUseBubbleSort$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L12019

; 13121:       fnBubbleSort( &SortData, lpEIBuffer, ulFront );

	mov	eax, DWORD PTR _ulFront$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _SortData$[ebp]
	push	edx
	call	_fnBubbleSort
	add	esp, 12					; 0000000cH

; 13122:    else

	jmp	SHORT $L12020
$L12019:

; 13123:       fnQuickSort( &SortData, lpEIBuffer, ulFront );

	mov	eax, DWORD PTR _ulFront$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _SortData$[ebp]
	push	edx
	call	_fnQuickSort
	add	esp, 12					; 0000000cH
$L12020:

; 13124:    // fnHeapSort( &SortData, lpEIBuffer, ulFront );  // does not work (yet)!
; 13125: 
; 13126:    fnDropView( SortData.lpView1 );

	mov	eax, DWORD PTR _SortData$[ebp+8]
	push	eax
	call	_fnDropView@4

; 13127:    fnDropView( SortData.lpView2 );

	mov	ecx, DWORD PTR _SortData$[ebp+12]
	push	ecx
	call	_fnDropView@4

; 13128: 
; 13129:    // Subtract 1 from ulEntityCnt so it points to the last EI.  This will
; 13130:    // save us a little time later on.
; 13131:    ulEntityCnt--;

	mov	edx, DWORD PTR _ulEntityCnt$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ulEntityCnt$[ebp], edx

; 13132: 
; 13133:    //---------------------------------------------------------------------
; 13134:    // Re-arrange the EI pointers.
; 13135:    //---------------------------------------------------------------------
; 13136: 
; 13137:    // If we sorted the root instances then set the root entity instance.
; 13138:    if ( lpFirstEntityInstance->nLevel == 1 )

	mov	eax, DWORD PTR _lpFirstEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	ecx, 1
	jne	SHORT $L12021

; 13140:       LPVIEWCSR lpViewCsr = zGETPTR( zView->hViewCsr );

	mov	edx, DWORD PTR _zView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$12022[ebp], eax

; 13141:       LPVIEWOI  lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$12022[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$12024[ebp], eax

; 13142: 
; 13143:       lpViewOI->hRootEntityInstance = zGETHNDL( lpEIBuffer[ 0 ] );

	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewOI$12024[ebp]
	mov	DWORD PTR [edx+26], eax
$L12021:

; 13145: 
; 13146:    // Reset the EI pointer for the entity before the "old" first entity.
; 13147:    if ( lpFirstEntityInstance->hPrevHier )

	mov	eax, DWORD PTR _lpFirstEntityInstance$[ebp]
	cmp	DWORD PTR [eax+18], 0
	je	SHORT $L12027

; 13149:       LPENTITYINSTANCE lpPrevHier = zGETPTR( lpFirstEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevHier$12028[ebp], eax

; 13150: 
; 13151:       // Change lpPrevHier to point to the "new" first entity.
; 13152:       lpPrevHier->hNextHier = zGETHNDL( lpEIBuffer[ 0 ] );

	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpPrevHier$12028[ebp]
	mov	DWORD PTR [edx+14], eax

; 13153: 
; 13154:       lpEIBuffer[ 0 ]->hPrevHier = lpFirstEntityInstance->hPrevHier;

	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR [ecx+18], eax

; 13156:    else

	jmp	SHORT $L12031
$L12027:

; 13157:       lpEIBuffer[ 0 ]->hPrevHier = 0;

	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+18], 0
$L12031:

; 13158: 
; 13159:    // Get the last child of the last old or "unsorted" entity.
; 13160:    lpLastOldChild = fnFindLastEntityUnderParent( lpLastEntityInstance, FALSE );

	push	0
	mov	eax, DWORD PTR _lpLastEntityInstance$[ebp]
	push	eax
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpLastOldChild$[ebp], eax

; 13161: 
; 13162:    // Get the last child for the last "sorted" entity.
; 13163:    lpLastChild = fnFindLastEntityUnderParent( lpEIBuffer[ ulEntityCnt ], FALSE );

	push	0
	mov	ecx, DWORD PTR _ulEntityCnt$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpLastChild$[ebp], eax

; 13164: 
; 13165:    // Reset the EI pointer for the entity after the "old" last entity.
; 13166:    if ( lpLastOldChild->hNextHier )

	mov	ecx, DWORD PTR _lpLastOldChild$[ebp]
	cmp	DWORD PTR [ecx+14], 0
	je	SHORT $L12032

; 13168:       LPENTITYINSTANCE lpNextHier = zGETPTR( lpLastOldChild->hNextHier );

	mov	edx, DWORD PTR _lpLastOldChild$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$12033[ebp], eax

; 13169: 
; 13170:       lpLastChild->hNextHier = lpLastOldChild->hNextHier;

	mov	ecx, DWORD PTR _lpLastChild$[ebp]
	mov	edx, DWORD PTR _lpLastOldChild$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR [ecx+14], eax

; 13171:       lpNextHier->hPrevHier = zGETHNDL( lpLastChild );

	mov	ecx, DWORD PTR _lpLastChild$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpNextHier$12033[ebp]
	mov	DWORD PTR [edx+18], eax

; 13174:    else

	jmp	SHORT $L12036
$L12032:

; 13175:       lpLastChild->hNextHier = 0;

	mov	eax, DWORD PTR _lpLastChild$[ebp]
	mov	DWORD PTR [eax+14], 0
$L12036:

; 13176: 
; 13177:    // Now we'll loop through ALL the EIs and set the
; 13178:    // PrevHier/NextHier/PrevTwin/NextTwin pointers.
; 13179:    for ( k = 0; k <= ulEntityCnt; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L12037
$L12038:
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$L12037:
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _ulEntityCnt$[ebp]
	ja	$L12039

; 13181:       // If 'k' is > 0 then we need to set up Prev pointers.
; 13182:       if ( k > 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jbe	SHORT $L12040

; 13184:          lpEIBuffer[ k ]->hPrevHier = zGETHNDL( lpLastChild );

	mov	eax, DWORD PTR _lpLastChild$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+18], eax

; 13185:          lpEIBuffer[ k ]->hPrevTwin = zGETHNDL( lpEIBuffer[ k - 1 ] );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4-4]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edx+26], eax

; 13187:       else

	jmp	SHORT $L12043
$L12040:

; 13188:          lpEIBuffer[ k ]->hPrevTwin = 0;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+26], 0
$L12043:

; 13189: 
; 13190:       // Find the last child (hierarchically) under the current EI.
; 13191:       lpLastChild = fnFindLastEntityUnderParent( lpEIBuffer[ k ], FALSE );

	push	0
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpLastChild$[ebp], eax

; 13192: 
; 13193:       // If 'k' is < ulEntityCnt then we need to set up Next pointers.
; 13194:       if ( k < ulEntityCnt )

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _ulEntityCnt$[ebp]
	jae	SHORT $L12044

; 13196:          lpEIBuffer[ k ]->hNextTwin = zGETHNDL( lpEIBuffer[ k + 1 ] );

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+22], eax

; 13197:          lpLastChild->hNextHier     = zGETHNDL( lpEIBuffer[ k + 1 ] );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpLastChild$[ebp]
	mov	DWORD PTR [edx+14], eax

; 13199:       else

	jmp	SHORT $L12047
$L12044:

; 13200:          lpEIBuffer[ k ]->hNextTwin = 0;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+22], 0
$L12047:

; 13201:    }

	jmp	$L12038
$L12039:

; 13202: 
; 13203:    SysFreeMemory( hEIBuffer );

	mov	eax, DWORD PTR _hEIBuffer$[ebp]
	push	eax
	call	_SysFreeMemory@4

; 13204: 
; 13205:    return( 0 );

	xor	ax, ax
$L11947:

; 13206: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnOrderEntityForView@16 ENDP
_TEXT	ENDS
PUBLIC	_OrderEntityForView@12
PUBLIC	??_C@_0N@CEOG@?4bubblesort?5?$AA@		; `string'
EXTRN	__imp__toupper:NEAR
EXTRN	_fnSetUpdateIndicator:NEAR
EXTRN	_fnEstablishCursorForView:NEAR
EXTRN	__chkstk:NEAR
;	COMDAT ??_C@_0N@CEOG@?4bubblesort?5?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0N@CEOG@?4bubblesort?5?$AA@ DB '.bubblesort ', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_zView$ = 8
_cpcEntityName$ = 12
_cpcOrderKeys$ = 16
_lpViewEntity$ = -13340
_lpTempViewEntity$ = -13352
_lpViewEntityCsr$ = -17472
_lpEntityInstance$ = -13336
_lpCurrentTask$ = -17468
_lpViewAttrList$ = -13320
_lpViewAttrListPtr$ = -8
_szWorkString$ = -17452
_chOrder$ = -4
_pchWSPtr$ = -17460
_pchWSBuffer$ = -13348
_pchEntityName$ = -17456
_pchAttrName$ = -17464
_pchScan$ = -13328
_bBubbleSort$ = -13356
_bAutoSeq$ = -13324
_lTemp$ = -13344
_nRC$ = -13332
_idx$12119 = -17476
_OrderEntityForView@12 PROC NEAR

; 13237: {

	push	ebp
	mov	ebp, esp
	mov	eax, 17476				; 00004444H
	call	__chkstk
	push	edi

; 13238:    LPVIEWENTITY       lpViewEntity;
; 13239:    LPVIEWENTITY       lpTempViewEntity;
; 13240:    LPVIEWENTITYCSR    lpViewEntityCsr;
; 13241:    LPENTITYINSTANCE   lpEntityInstance;
; 13242:    LPTASK             lpCurrentTask;
; 13243:    ViewAttrListRecord lpViewAttrList[ 1024 ] = {0};

	mov	DWORD PTR _lpViewAttrList$[ebp], 0
	mov	ecx, 3327				; 00000cffH
	xor	eax, eax
	lea	edi, DWORD PTR _lpViewAttrList$[ebp+4]
	rep stosd

; 13244:    LPVIEWATTRLIST     lpViewAttrListPtr = 0;

	mov	DWORD PTR _lpViewAttrListPtr$[ebp], 0

; 13245:    zCHAR              szWorkString[ 4096 ];
; 13246:    zCHAR              chOrder;
; 13247:    zPCHAR             pchWSPtr = 0;

	mov	DWORD PTR _pchWSPtr$[ebp], 0

; 13248:    zPCHAR             pchWSBuffer = 0;

	mov	DWORD PTR _pchWSBuffer$[ebp], 0

; 13249:    zPCHAR             pchEntityName;
; 13250:    zPCHAR             pchAttrName;
; 13251:    zPCHAR             pchScan;
; 13252:    zBOOL              bBubbleSort;
; 13253:    zBOOL              bAutoSeq = FALSE;

	mov	BYTE PTR _bAutoSeq$[ebp], 0

; 13254:    zLONG              lTemp;
; 13255:    zSHORT             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 13256: 
; 13257:    // Validate task and entity ... ensure entity cursor is established.
; 13258: 
; 13259:    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 13260:    if ( (lpCurrentTask = fnOperationCall( iOrderEntityForView,
; 13261:                                           zView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	push	122					; 0000007aH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L12073

; 13263:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12054
$L12073:

; 13265: 
; 13266: // TraceLine( "OrderEntityForView Entity: %s   OrderKeys: %s",
; 13267: //            cpcEntityName, cpcOrderKeys );
; 13268: 
; 13269: // SetEntityCursor( zView, cpcEntityName, 0, zPOS_FIRST, 0, 0, 0, 0, 0, 0 ); does nothing
; 13270: 
; 13271:    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView, cpcEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 13272:    if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $L12074

; 13274:       fnOperationReturn( iOrderEntityForView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	122					; 0000007aH
	call	_fnOperationReturn
	add	esp, 8

; 13275:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12054
$L12074:

; 13277: 
; 13278:    if ( lpViewEntity->bAutoSeq )  // added dks 2006.07.31 because this entity may be the

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 20					; 00000014H
	and	eax, 1
	test	eax, eax
	je	SHORT $L12075

; 13279:       bAutoSeq = TRUE;            // only AutoSeq entity

	mov	BYTE PTR _bAutoSeq$[ebp], 1
$L12075:

; 13280: 
; 13281:    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 13282:    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $L12078

; 13283:       lpEntityInstance = fnEstablishCursorForView( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEstablishCursorForView
	add	esp, 4
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L12078:

; 13284: 
; 13285:    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $L12079

; 13286:       goto EndOfFunction;

	jmp	$EndOfFunction$12080
$L12079:

; 13287: 
; 13288: #if 0
; 13289:    lpTempViewEntity = zGETPTR( lpEntityInstance->hViewEntity );
; 13290:    if ( lpTempViewEntity && lpTempViewEntity != lpViewEntity &&
; 13291:         lpTempViewEntity->bRecursive )
; 13292:    {
; 13293:       LPVIEWENTITY lpTempViewEntityParent = lpTempViewEntity;
; 13294: 
; 13295:       while ( lpTempViewEntityParent->hParent )
; 13296:       {
; 13297:          lpTempViewEntityParent = zGETPTR( lpTempViewEntity->hParent );
; 13298:          if ( lpTempViewEntityParent->lEREntTok == lpTempViewEntity->lEREntTok &&
; 13299:               lpTempViewEntityParent == lpViewEntity )
; 13300:          {
; 13301: #if 0
; 13302:             // Found same entity at another level.
; 13303:             fnResetCursorForViewChildren( lpViewEntityCsr );
; 13304:             lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView,
; 13305:                                               cpcEntityName, 0 );
; 13306:             lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );
; 13307: #endif
; 13308:          // lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView,
; 13309:          //                                   lpTempViewEntity->szName, 0 );
; 13310:             break;
; 13311:          }
; 13312:       }
; 13313:    }
; 13314: #endif
; 13315: 
; 13316:    // Check to see if user wants a bubble sort instead of the (default)
; 13317:    // quicksort.  Note that the only reason to use a bubble sort instead of
; 13318:    // quicksort is to maintain sort order on previously sorted items.
; 13319:    // Quicksort will switch items that compare equal, bubble sort will not.
; 13320:    if ( zstrncmpi( cpcOrderKeys, ".bubblesort ", 12 ) == 0 )

	push	12					; 0000000cH
	push	OFFSET FLAT:??_C@_0N@CEOG@?4bubblesort?5?$AA@ ; `string'
	mov	ecx, DWORD PTR _cpcOrderKeys$[ebp]
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L12081

; 13322:       bBubbleSort = TRUE;

	mov	BYTE PTR _bBubbleSort$[ebp], 1

; 13323:       cpcOrderKeys += 12;

	mov	edx, DWORD PTR _cpcOrderKeys$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _cpcOrderKeys$[ebp], edx

; 13325:    else

	jmp	SHORT $L12083
$L12081:

; 13326:       bBubbleSort = FALSE;

	mov	BYTE PTR _bBubbleSort$[ebp], 0
$L12083:

; 13327: 
; 13328:    lpViewAttrListPtr = lpViewAttrList;

	lea	eax, DWORD PTR _lpViewAttrList$[ebp]
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], eax

; 13329: 
; 13330:    lTemp = zstrlen( cpcOrderKeys );

	mov	ecx, DWORD PTR _cpcOrderKeys$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lTemp$[ebp], eax

; 13331:    if ( lTemp > 4094 )

	cmp	DWORD PTR _lTemp$[ebp], 4094		; 00000ffeH
	jle	SHORT $L12084

; 13333:       pchWSBuffer = (zPCHAR) fnAllocDataspace( lpCurrentTask->hFirstDataHeader,
; 13334:                                                lTemp, 0, 0, iBuffer );

	push	10105					; 00002779H
	push	0
	push	0
	mov	edx, DWORD PTR _lTemp$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pchWSBuffer$[ebp], eax

; 13335:       pchWSBuffer = zGETPTR( pchWSBuffer );

	mov	edx, DWORD PTR _pchWSBuffer$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchWSBuffer$[ebp], eax

; 13336:       pchWSPtr = pchWSBuffer;

	mov	eax, DWORD PTR _pchWSBuffer$[ebp]
	mov	DWORD PTR _pchWSPtr$[ebp], eax

; 13338:    else

	jmp	SHORT $L12087
$L12084:

; 13339:       pchWSPtr = szWorkString;

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	mov	DWORD PTR _pchWSPtr$[ebp], ecx
$L12087:

; 13340: 
; 13341:    zstrcpy( pchWSPtr, cpcOrderKeys );

	mov	edx, DWORD PTR _cpcOrderKeys$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchWSPtr$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 13342: 
; 13343:    // Validate each of the attributes in the sort list.
; 13344:    for ( pchScan = pchWSPtr; *pchScan; )

	mov	ecx, DWORD PTR _pchWSPtr$[ebp]
	mov	DWORD PTR _pchScan$[ebp], ecx
$L12089:
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$L12090
$L12092:

; 13346:       // Initialize current AttrList entry ... done above at instantiation
; 13347:    // lpViewAttrListPtr->bOrder = FALSE; // order ascending by default
; 13348:    // lpViewAttrListPtr->pfObjectOper = 0;
; 13349:    // lpViewAttrListPtr->pszContextName = 0;
; 13350:    // lpViewAttrListPtr->lpViewAttrib = 0;  // this gets set for sure
; 13351: 
; 13352:       while ( *pchScan == ' ' || *pchScan == ',' )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $L12094
	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	jne	SHORT $L12093
$L12094:

; 13353:          pchScan++;

	mov	edx, DWORD PTR _pchScan$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchScan$[ebp], edx
	jmp	SHORT $L12092
$L12093:

; 13354: 
; 13355:       pchAttrName = pchScan;  // save pointer to attr name

	mov	eax, DWORD PTR _pchScan$[ebp]
	mov	DWORD PTR _pchAttrName$[ebp], eax
$L12096:

; 13356:       while ( *pchScan != ' ' && *pchScan != 0 )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $L12097
	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L12097

; 13357:          pchScan++;

	mov	edx, DWORD PTR _pchScan$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchScan$[ebp], edx
	jmp	SHORT $L12096
$L12097:

; 13358: 
; 13359:       if ( *pchScan )     // if space is found,

	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L12098

; 13360:          *pchScan++ = 0;  // null terminate

	mov	edx, DWORD PTR _pchScan$[ebp]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _pchScan$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchScan$[ebp], eax
$L12098:

; 13361: 
; 13362:       if ( *pchAttrName == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L12099

; 13363:          break;

	jmp	$L12090
$L12099:

; 13364: 
; 13365:       // Check to see if the attribute name also has an entity name.  It
; 13366:       // should be seperated from the attr name by a '.'.
; 13367:       pchEntityName = zstrchr( pchAttrName, '.' );

	push	46					; 0000002eH
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchEntityName$[ebp], eax

; 13368:       if ( pchEntityName )

	cmp	DWORD PTR _pchEntityName$[ebp], 0
	je	SHORT $L12101

; 13370:          // We have an entity name.
; 13371:          *pchEntityName = 0;       // change '.' to null

	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	mov	BYTE PTR [ecx], 0

; 13372:          lpTempViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView,
; 13373:                                                pchAttrName, 0 );

	push	0
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpTempViewEntity$[ebp], eax

; 13374:          if ( lpTempViewEntity == 0 )

	cmp	DWORD PTR _lpTempViewEntity$[ebp], 0
	jne	SHORT $L12102

; 13375:             goto EndOfFunction;

	jmp	$EndOfFunction$12080
$L12102:

; 13376: 
; 13377:          // Change attr pointer to point to beginning of attr name.
; 13378:          pchAttrName = pchEntityName + 1;

	mov	edx, DWORD PTR _pchEntityName$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchAttrName$[ebp], edx

; 13380:       else

	jmp	SHORT $L12103
$L12101:

; 13382:          // No entity name specified so use default entity.
; 13383:          lpTempViewEntity = lpViewEntity;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpTempViewEntity$[ebp], eax
$L12103:

; 13385: 
; 13386:    // if ( lpTempViewEntity->bAutoSeq ) // dropped dks/don 2006.07.31 since we
; 13387:    //    bAutoSeq = TRUE;               // believe only sort entity should be considered
; 13388: 
; 13389:       lpViewAttrListPtr->lpViewAttrib =
; 13390:                 fnValidViewAttrib( zView, lpTempViewEntity, pchAttrName, 0 );

	push	0
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTempViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	DWORD PTR [ecx], eax

; 13391:       if ( lpViewAttrListPtr->lpViewAttrib == 0 )

	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L12104

; 13392:          goto EndOfFunction;

	jmp	$EndOfFunction$12080
$L12104:

; 13393: 
; 13394:       while ( *pchScan == ' ' || *pchScan == ',' )

	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $L12108
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $L12107
$L12108:

; 13395:          pchScan++;

	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx
	jmp	SHORT $L12104
$L12107:

; 13396: 
; 13397:       // Is there an order character present?
; 13398:       if ( pchScan && *pchScan )

	cmp	DWORD PTR _pchScan$[ebp], 0
	je	$L12116
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$L12116

; 13400:          chOrder = ztoupper( *pchScan );

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	BYTE PTR _chOrder$[ebp], al

; 13401:          if ( (chOrder == 'A' || chOrder == 'D') &&
; 13402:               (pchScan[ 1 ] == 0 || pchScan[ 1 ] == ' ' || pchScan[ 1 ] == ',') )

	movsx	eax, BYTE PTR _chOrder$[ebp]
	cmp	eax, 65					; 00000041H
	je	SHORT $L12111
	movsx	ecx, BYTE PTR _chOrder$[ebp]
	cmp	ecx, 68					; 00000044H
	jne	SHORT $L12116
$L12111:
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	test	eax, eax
	je	SHORT $L12112
	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 32					; 00000020H
	je	SHORT $L12112
	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 44					; 0000002cH
	jne	SHORT $L12116
$L12112:

; 13404:             if ( chOrder == 'D' )

	movsx	edx, BYTE PTR _chOrder$[ebp]
	cmp	edx, 68					; 00000044H
	jne	SHORT $L12113

; 13405:                lpViewAttrListPtr->bOrder = TRUE; // order descending

	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	BYTE PTR [eax+8], 1
$L12113:

; 13406: 
; 13407:             pchScan++;

	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx
$L12115:

; 13408:             while ( *pchScan == ' ' || *pchScan == ',' )

	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $L12117
	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	jne	SHORT $L12116
$L12117:

; 13409:                pchScan++;

	mov	eax, DWORD PTR _pchScan$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchScan$[ebp], eax
	jmp	SHORT $L12115
$L12116:

; 13412: 
; 13413:       // Check for a Context Name.  It should be surrounded by brackets.
; 13414:       if ( *pchScan == '[' )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 91					; 0000005bH
	jne	$L12128

; 13416:          zSHORT idx = 0;

	mov	WORD PTR _idx$12119[ebp], 0

; 13417: 
; 13418:          pchScan++;   // Skip over bracket.

	mov	eax, DWORD PTR _pchScan$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchScan$[ebp], eax
$L12121:

; 13419:          while ( *pchScan == ' ' )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $L12122

; 13420:             pchScan++;

	mov	eax, DWORD PTR _pchScan$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchScan$[ebp], eax
	jmp	SHORT $L12121
$L12122:

; 13421: 
; 13422:          if ( *pchScan != ']' )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 93					; 0000005dH
	je	SHORT $L12123

; 13423:             lpViewAttrListPtr->pszContextName = pchScan;

	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	ecx, DWORD PTR _pchScan$[ebp]
	mov	DWORD PTR [eax+9], ecx
$L12123:

; 13424: 
; 13425:          while ( *pchScan && *pchScan != ']' )

	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L12126
	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 93					; 0000005dH
	je	SHORT $L12126

; 13427:             // If we find a space we'll convert it into a null-terminator.
; 13428:             // This will cause us to ignore trailing spaces.
; 13429:             if ( *pchScan == ' ' )

	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $L12127

; 13430:                *pchScan = 0;

	mov	edx, DWORD PTR _pchScan$[ebp]
	mov	BYTE PTR [edx], 0
$L12127:

; 13431: 
; 13432:             pchScan++;

	mov	eax, DWORD PTR _pchScan$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchScan$[ebp], eax

; 13433:          }

	jmp	SHORT $L12123
$L12126:

; 13434: 
; 13435:          // If we found a closing bracket (only other possiblity is a 0) then
; 13436:          // change it to a null-terminator and skip to next char.
; 13437:          if ( *pchScan == ']' )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 93					; 0000005dH
	jne	SHORT $L12128

; 13438:             *pchScan++ = 0;

	mov	eax, DWORD PTR _pchScan$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx
$L12128:

; 13440: 
; 13441:       lpViewAttrListPtr++;

	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	add	edx, 13					; 0000000dH
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], edx

; 13442: 
; 13443:    } // for ( pchScan = pchWSPtr; *pchScan; )

	jmp	$L12089
$L12090:

; 13444: 
; 13445:    // Initialize last AttrList entry ... done above at instantiation
; 13446: // lpViewAttrListPtr->lpViewAttrib = 0;
; 13447: 
; 13448:    // Call the actual sort routine.
; 13449:    nRC = fnOrderEntityForView( zView, lpEntityInstance,
; 13450:                                lpViewAttrList, bBubbleSort );

	mov	al, BYTE PTR _bBubbleSort$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewAttrList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	call	_fnOrderEntityForView@16
	mov	WORD PTR _nRC$[ebp], ax

; 13451: 
; 13452:    if ( nRC != zCALL_ERROR && bAutoSeq )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	je	SHORT $EndOfFunction$12080
	mov	edx, DWORD PTR _bAutoSeq$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $EndOfFunction$12080

; 13454:       fnSetUpdateIndicator( 0, lpEntityInstance, 0, TRUE, TRUE, TRUE );

	push	1
	push	1
	push	1
	push	0
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H
$EndOfFunction$12080:

; 13456: 
; 13457: EndOfFunction:
; 13458: 
; 13459:    if ( pchWSBuffer )

	cmp	DWORD PTR _pchWSBuffer$[ebp], 0
	je	SHORT $L12130

; 13460:       fnFreeDataspace( pchWSBuffer );   // free work area

	mov	ecx, DWORD PTR _pchWSBuffer$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4
$L12130:

; 13461: 
; 13462:    fnOperationReturn( iOrderEntityForView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	122					; 0000007aH
	call	_fnOperationReturn
	add	esp, 8

; 13463:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L12054:

; 13464: }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_OrderEntityForView@12 ENDP
_TEXT	ENDS
PUBLIC	_fnGetSortAttrsFromEntity@16
PUBLIC	??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@ ; `string'
PUBLIC	??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@ ; `string'
PUBLIC	??_C@_0BL@NNA@fnOrderOI_ByDefaultAttribs?$AA@	; `string'
;	COMDAT ??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@ DB 'Maximum # of'
	DB	' order attributes used', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@
_DATA	SEGMENT
??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@ DB 'KZOEE013 - Inte'
	DB	'rnal operation call error: ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@NNA@fnOrderOI_ByDefaultAttribs?$AA@
_DATA	SEGMENT
??_C@_0BL@NNA@fnOrderOI_ByDefaultAttribs?$AA@ DB 'fnOrderOI_ByDefaultAttr'
	DB	'ibs', 00H					; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_plAttribCnt$ = 12
_lpAttribList$ = 16
_lpViewEntity$ = 20
_lpViewAttrib$ = -4
_nSeq$12150 = -8
_lpTask$12152 = -12
_fnGetSortAttrsFromEntity@16 PROC NEAR

; 13476: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 13477:    LPVIEWATTRIB lpViewAttrib;
; 13478: 
; 13479:    // Loop through all the view attribs looking for default sorting attribs.
; 13480:    // When one is found, add it to the attrib list.
; 13481:    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 13482:          lpViewAttrib;
; 13483:          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L12144
$L12145:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L12144:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$L12146

; 13485:       if ( lpViewAttrib->bAutoSeq )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	je	SHORT $L12147

; 13487:          *plAttribCnt = 1;

	mov	eax, DWORD PTR _plAttribCnt$[ebp]
	mov	DWORD PTR [eax], 1

; 13488:          lpAttribList[ 0 ].lpViewAttrib = lpViewAttrib;

	mov	ecx, DWORD PTR _lpAttribList$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx], edx

; 13489:          lpAttribList[ 0 ].bOrder = FALSE;

	mov	eax, DWORD PTR _lpAttribList$[ebp]
	mov	BYTE PTR [eax+8], 0

; 13490: 
; 13491:          // Make sure next attrib is 0.
; 13492:          lpAttribList[ 1 ].lpViewAttrib = 0;

	mov	ecx, DWORD PTR _lpAttribList$[ebp]
	mov	DWORD PTR [ecx+13], 0

; 13493: 
; 13494:          return( 1 ); // There is only 1 autoseq attr per entity, so return.

	mov	ax, 1
	jmp	$L12140
$L12147:

; 13496:       else
; 13497:       if ( lpViewAttrib->cSequencing > 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+197]
	test	eax, eax
	jle	$L12158

; 13499:          zSHORT nSeq;
; 13500: 
; 13501:          nSeq = lpViewAttrib->cSequencing;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movzx	dx, BYTE PTR [ecx+197]
	mov	WORD PTR _nSeq$12150[ebp], dx

; 13502:          if ( nSeq >= MAX_SEQ_ATTS )

	movsx	eax, WORD PTR _nSeq$12150[ebp]
	cmp	eax, 20					; 00000014H
	jl	SHORT $L12151

; 13504:             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$12152[ebp], eax

; 13505:             // "KZOEE013 - Internal operation call error"
; 13506:             TraceLineS( "KZOEE013 - Internal operation call error: ",
; 13507:                         "Maximum # of order attributes used" );

	push	OFFSET FLAT:??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@ ; `string'
	push	OFFSET FLAT:??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@ ; `string'
	call	_TraceLineS@8

; 13508:             fnIssueCoreError( lpTask, lpView, 16, 13, 0,
; 13509:                               "Maximum # of order attributes used",
; 13510:                               "fnOrderOI_ByDefaultAttribs" );

	push	OFFSET FLAT:??_C@_0BL@NNA@fnOrderOI_ByDefaultAttribs?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@ ; `string'
	push	0
	push	13					; 0000000dH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$12152[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 13511:             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L12140
$L12151:

; 13513: 
; 13514:          if ( *plAttribCnt < nSeq )

	movsx	edx, WORD PTR _nSeq$12150[ebp]
	mov	eax, DWORD PTR _plAttribCnt$[ebp]
	cmp	DWORD PTR [eax], edx
	jge	SHORT $L12157

; 13515:             *plAttribCnt = nSeq;

	movsx	ecx, WORD PTR _nSeq$12150[ebp]
	mov	edx, DWORD PTR _plAttribCnt$[ebp]
	mov	DWORD PTR [edx], ecx
$L12157:

; 13516: 
; 13517:          lpAttribList[ nSeq - 1 ].lpViewAttrib = lpViewAttrib;

	movsx	eax, WORD PTR _nSeq$12150[ebp]
	sub	eax, 1
	imul	eax, 13					; 0000000dH
	mov	ecx, DWORD PTR _lpAttribList$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 13518:          if ( lpViewAttrib->bSequencingD )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L12158

; 13519:             lpAttribList[ nSeq - 1 ].bOrder = TRUE;

	movsx	edx, WORD PTR _nSeq$12150[ebp]
	sub	edx, 1
	imul	edx, 13					; 0000000dH
	mov	eax, DWORD PTR _lpAttribList$[ebp]
	mov	BYTE PTR [eax+edx+8], 1
$L12158:

; 13521:    } // for ( lpViewAttrib )...

	jmp	$L12145
$L12146:

; 13522: 
; 13523:    return( 0 );

	xor	ax, ax
$L12140:

; 13524: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnGetSortAttrsFromEntity@16 ENDP
_TEXT	ENDS
PUBLIC	_fnOrderOI_ByDefaultAttribs
PUBLIC	??_C@_0BK@NHNF@Out?5of?5space?5for?5entities?$AA@ ; `string'
PUBLIC	??_C@_0CB@LCPB@Maximum?5?$CD?5of?5order?5entities?5used@ ; `string'
;	COMDAT ??_C@_0BK@NHNF@Out?5of?5space?5for?5entities?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BK@NHNF@Out?5of?5space?5for?5entities?$AA@ DB 'Out of space for en'
	DB	'tities', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@LCPB@Maximum?5?$CD?5of?5order?5entities?5used@
_DATA	SEGMENT
??_C@_0CB@LCPB@Maximum?5?$CD?5of?5order?5entities?5used@ DB 'Maximum # of'
	DB	' order entities used', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_EntityList$ = -820
_lpViewCsr$ = -4
_lpViewOI$ = -828
_lpEntityInstance$ = -16
_lpViewEntity$ = -20
_AttribList$ = -1088
_lEntityCnt$ = -8
_k$ = -824
_nRC$ = -12
_lpPrevHier$12183 = -1092
_lAttribCnt$12193 = -1096
_lpTask$12195 = -1100
_lpSrchViewEntity$12202 = -1104
_nChildLevel$12208 = -1108
_fnOrderOI_ByDefaultAttribs PROC NEAR

; 13541: {

	push	ebp
	mov	ebp, esp
	sub	esp, 1108				; 00000454H

; 13542:    struct EntityListStruct
; 13543:    {
; 13544:       LPVIEWENTITY   lpViewEntity;
; 13545:       LPVIEWATTRLIST lpPtr;
; 13546:    } EntityList[ MAX_SEQ_ENTS ];
; 13547: 
; 13548:    LPVIEWCSR          lpViewCsr;
; 13549:    LPVIEWOI           lpViewOI;
; 13550:    LPENTITYINSTANCE   lpEntityInstance;
; 13551:    LPVIEWENTITY       lpViewEntity;
; 13552:    ViewAttrListRecord AttribList[ MAX_SEQ_ATTS ];
; 13553:    zLONG              lEntityCnt;
; 13554:    zLONG              k;
; 13555:    zSHORT             nRC;
; 13556: 
; 13557:    // Fill EntityList with zeros.
; 13558:    zmemset( (zPVOID) EntityList, 0,
; 13559:             sizeof( struct EntityListStruct ) * MAX_SEQ_ENTS );

	push	800					; 00000320H
	push	0
	lea	eax, DWORD PTR _EntityList$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 13560:    lEntityCnt = 0;

	mov	DWORD PTR _lEntityCnt$[ebp], 0

; 13561: 
; 13562:    lpViewCsr        = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 13563:    lpViewOI         = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 13564: 
; 13565:    // For each of the entity instances, sort all groups of twin entities if
; 13566:    // the entity instance is the first twin.
; 13567:    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );
; 13568:          lpEntityInstance;
; 13569:          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L12180
$L12181:
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L12180:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$L12182

; 13571:       LPENTITYINSTANCE lpPrevHier;
; 13572: 
; 13573:       // Sort the group of entity instances if:
; 13574:       //    o  The entity instance is supposed to be sorted AND
; 13575:       //    o  The entity instance is the first twin (prev twin == 0) AND
; 13576:       //    o  There are more than 1 twins (next twin != 0).
; 13577: 
; 13578:       // If EI has a prev twin then it's not the first twin so don't bother
; 13579:       // sorting.
; 13580:       if ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $L12184

; 13581:          continue;

	jmp	SHORT $L12181
$L12184:

; 13582: 
; 13583:       // If next twin is NULL then there is only one EI so there's nothing to
; 13584:       // sort.
; 13585:       if ( lpEntityInstance->hNextTwin == 0 )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	jne	SHORT $L12185

; 13586:          continue;

	jmp	SHORT $L12181
$L12185:

; 13587: 
; 13588:       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 13589: 
; 13590:       // If this entity doesn't have sorting attributes then skip it.
; 13591:       if ( lpViewEntity->bAutoSeq == FALSE && lpViewEntity->bAttrOrder == FALSE )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 20					; 00000014H
	and	edx, 1
	test	edx, edx
	jne	SHORT $L12187
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 18					; 00000012H
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L12187

; 13592:          continue;

	jmp	SHORT $L12181
$L12187:

; 13593: 
; 13594:       // If we get here then we're going to sort the twins.  Save the prev
; 13595:       // hier EI of the current EI.  Once we are done sorting the EIs we can
; 13596:       // quickly find the first twin by using the prev hier ptr.
; 13597:       lpPrevHier = zGETPTR( lpEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevHier$12183[ebp], eax

; 13598: 
; 13599:       // First check to see if this lpViewEntity has been sorted already.
; 13600:       // If it has, then we already have the list of default sort attribs.
; 13601:       k = 0;

	mov	DWORD PTR _k$[ebp], 0
$L12190:

; 13602:       while ( EntityList[ k ].lpViewEntity != lpViewEntity && k < lEntityCnt )

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _EntityList$[ebp+ecx*8]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $L12191
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _lEntityCnt$[ebp]
	jge	SHORT $L12191

; 13603:          k++;

	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
	jmp	SHORT $L12190
$L12191:

; 13604: 
; 13605:       // If k == lEntityCnt, then lpViewEntity has not been sorted yet.
; 13606:       // Go through each of the lpViewAttribs for the lpViewEntity and
; 13607:       // find all default sort attributes.
; 13608:       if ( k == lEntityCnt )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _lEntityCnt$[ebp]
	jne	$L12192

; 13610:          zLONG  lAttribCnt;
; 13611: 
; 13612:          // If k >= MAX_SEQ_ENTS, then we have run out of space for entities.
; 13613:          if ( k >= MAX_SEQ_ENTS )

	cmp	DWORD PTR _k$[ebp], 100			; 00000064H
	jl	SHORT $L12194

; 13615:             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$12195[ebp], eax

; 13616:             // "KZOEE013 - Internal operation call error"
; 13617:             TraceLineS( "KZOEE013 - Internal operation call error: ",
; 13618:                         "Out of space for entities" );

	push	OFFSET FLAT:??_C@_0BK@NHNF@Out?5of?5space?5for?5entities?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@ ; `string'
	call	_TraceLineS@8

; 13619:             fnIssueCoreError( lpTask, lpView, 16, 13, 0,
; 13620:                               "Maximum # of order entities used",
; 13621:                               "fnOrderOI_ByDefaultAttribs" );

	push	OFFSET FLAT:??_C@_0BL@NNA@fnOrderOI_ByDefaultAttribs?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CB@LCPB@Maximum?5?$CD?5of?5order?5entities?5used@ ; `string'
	push	0
	push	13					; 0000000dH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$12195[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 13622:             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12161
$L12194:

; 13624: 
; 13625:          // Zero out attribute list.
; 13626:          lAttribCnt = 0;

	mov	DWORD PTR _lAttribCnt$12193[ebp], 0

; 13627:          zmemset( (zPVOID) AttribList, 0,
; 13628:                   sizeof( ViewAttrListRecord ) * MAX_SEQ_ATTS );

	push	260					; 00000104H
	push	0
	lea	ecx, DWORD PTR _AttribList$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 13629: 
; 13630:          // Find all the sorting attributes and add them to AttribList.
; 13631:          nRC = fnGetSortAttrsFromEntity( lpView, &lAttribCnt, AttribList,
; 13632:                                          lpViewEntity );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _AttribList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lAttribCnt$12193[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnGetSortAttrsFromEntity@16
	mov	WORD PTR _nRC$[ebp], ax

; 13633: 
; 13634:          // If nRC != 0 then sorting is done by using autosequencing fields
; 13635:          // and there can be only one autoseq field per entity.  Otherwise
; 13636:          // check to see if the entity is sorted using child attributes and
; 13637:          // if so then add them to AttribList.
; 13638:          if ( nRC == 0 && lpViewEntity->bAttrOrderChild )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$L12206
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 19					; 00000013H
	and	edx, 1
	test	edx, edx
	je	$L12206

; 13640:             LPVIEWENTITY lpSrchViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$12202[ebp], eax
$L12205:

; 13641: 
; 13642:             while ( lpSrchViewEntity &&
; 13643:                     lpSrchViewEntity->nLevel > lpViewEntity->nLevel )

	cmp	DWORD PTR _lpSrchViewEntity$12202[ebp], 0
	je	$L12206
	mov	edx, DWORD PTR _lpSrchViewEntity$12202[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jle	$L12206

; 13645:                // We can only sort using children that have a max cardinality
; 13646:                // of 1.  If it's greater than 1 then we can ignore it and all
; 13647:                // it's children.
; 13648:                if ( lpSrchViewEntity->uCardMax > 1 )

	mov	eax, DWORD PTR _lpSrchViewEntity$12202[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+221]
	cmp	ecx, 1
	jle	SHORT $L12207

; 13650:                   zSHORT nChildLevel;
; 13651: 
; 13652:                   // Entity doesn't have a twin so use next hier pointers to
; 13653:                   // skip the children.
; 13654:                   nChildLevel = lpSrchViewEntity->nLevel;

	mov	edx, DWORD PTR _lpSrchViewEntity$12202[ebp]
	mov	ax, WORD PTR [edx+215]
	mov	WORD PTR _nChildLevel$12208[ebp], ax

; 13655:                   for ( lpSrchViewEntity = zGETPTR( lpSrchViewEntity->hNextHier );
; 13656:                         lpSrchViewEntity;
; 13657:                         lpSrchViewEntity = zGETPTR( lpSrchViewEntity->hNextHier ) )

	mov	ecx, DWORD PTR _lpSrchViewEntity$12202[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$12202[ebp], eax
	jmp	SHORT $L12211
$L12212:
	mov	eax, DWORD PTR _lpSrchViewEntity$12202[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$12202[ebp], eax
$L12211:
	cmp	DWORD PTR _lpSrchViewEntity$12202[ebp], 0
	je	SHORT $L12213

; 13659:                      if ( lpSrchViewEntity->nLevel > nChildLevel )

	mov	edx, DWORD PTR _lpSrchViewEntity$12202[ebp]
	movsx	eax, WORD PTR [edx+215]
	movsx	ecx, WORD PTR _nChildLevel$12208[ebp]
	cmp	eax, ecx
	jle	SHORT $L12214

; 13660:                         break;

	jmp	SHORT $L12213
$L12214:

; 13661:                   }

	jmp	SHORT $L12212
$L12213:

; 13662: 
; 13663:                   continue;

	jmp	$L12205
$L12207:

; 13665: 
; 13666:                // If we get here then the max card is 1.
; 13667:                fnGetSortAttrsFromEntity( lpView, &lAttribCnt, AttribList,
; 13668:                                          lpSrchViewEntity );

	mov	edx, DWORD PTR _lpSrchViewEntity$12202[ebp]
	push	edx
	lea	eax, DWORD PTR _AttribList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lAttribCnt$12193[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnGetSortAttrsFromEntity@16

; 13669: 
; 13670:                lpSrchViewEntity = zGETPTR( lpSrchViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpSrchViewEntity$12202[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$12202[ebp], eax

; 13671: 
; 13672:             } // while...

	jmp	$L12205
$L12206:

; 13675: 
; 13676:          // Allocate space to hold the attribute list.  We use
; 13677:          // "lAttribCnt + 1" to allocate space for the NULL attribute.
; 13678:          EntityList[ k ].lpPtr = (LPVIEWATTRLIST)
; 13679:                    fnAllocDataspace( ((LPTASK) zGETPTR (lpView->hTask))->hFirstDataHeader,
; 13680:                                      (sizeof( ViewAttrListRecord ) * (zULONG)
; 13681:                                         (lAttribCnt + 1)), 0, 0, iBuffer );

	push	10105					; 00002779H
	push	0
	push	0
	mov	edx, DWORD PTR _lAttribCnt$12193[ebp]
	add	edx, 1
	imul	edx, 13					; 0000000dH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR [eax+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _EntityList$[ebp+ecx*8+4], eax

; 13682:          if ( EntityList[ k ].lpPtr == 0 )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	DWORD PTR _EntityList$[ebp+edx*8+4], 0
	jne	SHORT $L12221

; 13683:             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12161
$L12221:

; 13684: 
; 13685:          EntityList[ k ].lpPtr = zGETPTR( EntityList[ k ].lpPtr );

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _EntityList$[ebp+eax*8+4]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _EntityList$[ebp+edx*8+4], eax

; 13686: 
; 13687:          // Copy attribute list + NULL attribute to entity list.
; 13688:          zmemcpy( (zPVOID) EntityList[ k ].lpPtr, (zPVOID) AttribList,
; 13689:                   sizeof( ViewAttrListRecord ) * (lAttribCnt + 1) );

	mov	eax, DWORD PTR _lAttribCnt$12193[ebp]
	add	eax, 1
	imul	eax, 13					; 0000000dH
	push	eax
	lea	ecx, DWORD PTR _AttribList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _EntityList$[ebp+edx*8+4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 13690:          EntityList[ k ].lpViewEntity = lpViewEntity;

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _EntityList$[ebp+ecx*8], edx

; 13691: 
; 13692:          lEntityCnt++;

	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _lEntityCnt$[ebp], eax
$L12192:

; 13695: 
; 13696:       nRC = fnOrderEntityForView( lpView, lpEntityInstance,
; 13697:                                   EntityList[ k ].lpPtr, FALSE );

	push	0
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _EntityList$[ebp+ecx*8+4]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnOrderEntityForView@16
	mov	WORD PTR _nRC$[ebp], ax

; 13698:       if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $L12226

; 13700:          for ( k = 0; k < lEntityCnt; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L12227
$L12228:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$L12227:
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _lEntityCnt$[ebp]
	jge	SHORT $L12229

; 13701:             fnFreeDataspace( EntityList[ k ].lpPtr );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _EntityList$[ebp+edx*8+4]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
	jmp	SHORT $L12228
$L12229:

; 13702: 
; 13703:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L12161
$L12226:

; 13705: 
; 13706:       // Set lpEntityInstance to be the first twin in its particular group.
; 13707:       if ( lpPrevHier )

	cmp	DWORD PTR _lpPrevHier$12183[ebp], 0
	je	SHORT $L12230

; 13708:          lpEntityInstance = zGETPTR( lpPrevHier->hNextHier );

	mov	ecx, DWORD PTR _lpPrevHier$12183[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 13709:       else

	jmp	SHORT $L12232
$L12230:

; 13710:          lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L12232:

; 13711: 
; 13712:    } // for ( lpEntityInstance )...

	jmp	$L12181
$L12182:

; 13713: 
; 13714:    for ( k = 0; k < lEntityCnt; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L12234
$L12235:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$L12234:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _lEntityCnt$[ebp]
	jge	SHORT $L12236

; 13715:       fnFreeDataspace( EntityList[ k ].lpPtr );

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _EntityList$[ebp+ecx*8+4]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
	jmp	SHORT $L12235
$L12236:

; 13716: 
; 13717:    return( 0 );

	xor	ax, ax
$L12161:

; 13718: 
; 13719: } // fnOrderOI_ByDefaultAttribs

	mov	esp, ebp
	pop	ebp
	ret	0
_fnOrderOI_ByDefaultAttribs ENDP
_TEXT	ENDS
PUBLIC	_OrderOI_ByDefaultAttribs@4
_TEXT	SEGMENT
_lpView$ = 8
_lpCurrentTask$ = -12
_lpViewOD$ = -4
_nRC$ = -8
_OrderOI_ByDefaultAttribs@4 PROC NEAR

; 13740: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 13741:    LPTASK            lpCurrentTask;
; 13742:    LPVIEWOD          lpViewOD;
; 13743:    zSHORT            nRC;
; 13744: 
; 13745:    // validate some stuff
; 13746: 
; 13747:    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 13748:    if ( (lpCurrentTask = fnOperationCall( iOrderOI_ByDefaultAttribs,
; 13749:                                            lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	125					; 0000007dH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L12243

; 13751:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L12239
$L12243:

; 13753: 
; 13754:    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 13755:    if ( lpViewOD->bAutoSeq == FALSE )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L12245

; 13756:       nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1

; 13757:    else

	jmp	SHORT $L12246
$L12245:

; 13758:       nRC = fnOrderOI_ByDefaultAttribs( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnOrderOI_ByDefaultAttribs
	add	esp, 4
	mov	WORD PTR _nRC$[ebp], ax
$L12246:

; 13759: 
; 13760:    fnOperationReturn( iOrderOI_ByDefaultAttribs, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	125					; 0000007dH
	call	_fnOperationReturn
	add	esp, 8

; 13761:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L12239:

; 13762: 
; 13763: } // OrderOI_ByDefaultAttribs

	mov	esp, ebp
	pop	ebp
	ret	4
_OrderOI_ByDefaultAttribs@4 ENDP
_TEXT	ENDS
PUBLIC	_fnOrderEntitiesByDefaultAttribs
PUBLIC	??_C@_0BG@KEBP@Sequencing?5error?5?$DO?540?$AA@	; `string'
PUBLIC	??_C@_0CA@OIFL@fnOrderEntitiesByDefaultAttribs?$AA@ ; `string'
;	COMDAT ??_C@_0BG@KEBP@Sequencing?5error?5?$DO?540?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BG@KEBP@Sequencing?5error?5?$DO?540?$AA@ DB 'Sequencing error > 40'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@OIFL@fnOrderEntitiesByDefaultAttribs?$AA@
_DATA	SEGMENT
??_C@_0CA@OIFL@fnOrderEntitiesByDefaultAttribs?$AA@ DB 'fnOrderEntitiesBy'
	DB	'DefaultAttribs', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_lpEntityInstance$ = 12
_AttribList$ = -540
_lpViewEntity$ = -12
_lpTopViewEntity$ = -16
_lpViewAttrib$ = -20
_lAttribCnt$ = -4
_nRC$ = -8
_nSeq$12277 = -544
_lpTask$12280 = -548
_fnOrderEntitiesByDefaultAttribs PROC NEAR

; 13781: {

	push	ebp
	mov	ebp, esp
	sub	esp, 548				; 00000224H
$L12259:

; 13782:    ViewAttrListRecord AttribList[ 40 ]; // Max 40 attribs for sorting.
; 13783:    LPVIEWENTITY       lpViewEntity;
; 13784:    LPVIEWENTITY       lpTopViewEntity;
; 13785:    LPVIEWATTRIB       lpViewAttrib;
; 13786:    zLONG              lAttribCnt;
; 13787:    zSHORT             nRC;
; 13788: 
; 13789:    // Find first twin of lpEntityInstance.
; 13790:    while ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $L12260

; 13791:       lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $L12259
$L12260:

; 13792: 
; 13793:    lpTopViewEntity = lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpTopViewEntity$[ebp], edx

; 13794: 
; 13795:    // Sort the group of entity instances if:
; 13796:    //   - The entity instance is supposed to be sorted AND
; 13797:    //   - There are more than 1 twins (next twin != 0).
; 13798:    if ( lpViewEntity->bAttrOrder == FALSE && lpViewEntity->bAutoSeq == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 18					; 00000012H
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L12263
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 20					; 00000014H
	and	eax, 1
	test	eax, eax
	jne	SHORT $L12263

; 13799:       return( 0 ); // No sorting for entity.

	xor	ax, ax
	jmp	$L12251
$L12263:

; 13800: 
; 13801:    if ( lpEntityInstance->hNextTwin == 0 )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	jne	SHORT $L12264

; 13802:       return( 0 ); // Nothing to sort.

	xor	ax, ax
	jmp	$L12251
$L12264:

; 13803: 
; 13804:    zmemset( (zPVOID) AttribList, 0, sizeof( ViewAttrListRecord ) * 40 );

	push	520					; 00000208H
	push	0
	lea	edx, DWORD PTR _AttribList$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 13805:    lAttribCnt = 0;

	mov	DWORD PTR _lAttribCnt$[ebp], 0

; 13806: 
; 13807:    // Loop through all the attributes for the current entity and possibly
; 13808:    // loop through the attrs for child entities.
; 13809:    for ( ;
; 13810:          lpViewEntity->nLevel > lpTopViewEntity->nLevel ||
; 13811:             lpViewEntity == lpTopViewEntity;
; 13812:          lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	jmp	SHORT $L12268
$L12269:
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$L12268:
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpTopViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jg	SHORT $L12271
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	eax, DWORD PTR _lpTopViewEntity$[ebp]
	jne	$L12270
$L12271:

; 13814:       for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 13815:             lpViewAttrib;
; 13816:             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $L12274
$L12275:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$L12274:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$L12276

; 13818:          zSHORT nSeq;
; 13819: 
; 13820:          // Forget about it if no sequencing value.
; 13821:          if ( lpViewAttrib->cSequencing == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+197]
	test	eax, eax
	jne	SHORT $L12278

; 13822:             continue;

	jmp	SHORT $L12275
$L12278:

; 13823: 
; 13824:          nSeq = lpViewAttrib->cSequencing;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movzx	dx, BYTE PTR [ecx+197]
	mov	WORD PTR _nSeq$12277[ebp], dx

; 13825:          if ( nSeq > 40 )

	movsx	eax, WORD PTR _nSeq$12277[ebp]
	cmp	eax, 40					; 00000028H
	jle	SHORT $L12279

; 13827:             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$12280[ebp], eax

; 13828:             // "KZOEE013 - Internal operation call error"
; 13829:             TraceLineS( "KZOEE013 - Internal operation call error: ",
; 13830:                         "Sequencing error > 40" );

	push	OFFSET FLAT:??_C@_0BG@KEBP@Sequencing?5error?5?$DO?540?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@ ; `string'
	call	_TraceLineS@8

; 13831:             fnIssueCoreError( lpTask, lpView, 16, 13, 0,
; 13832:                               "Maximum # of order attributes used",
; 13833:                               "fnOrderEntitiesByDefaultAttribs" );

	push	OFFSET FLAT:??_C@_0CA@OIFL@fnOrderEntitiesByDefaultAttribs?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CD@FCAC@Maximum?5?$CD?5of?5order?5attributes?5us@ ; `string'
	push	0
	push	13					; 0000000dH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$12280[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 13834:             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12251
$L12279:

; 13836: 
; 13837:          if ( lAttribCnt < nSeq )

	movsx	edx, WORD PTR _nSeq$12277[ebp]
	cmp	DWORD PTR _lAttribCnt$[ebp], edx
	jge	SHORT $L12284

; 13838:             lAttribCnt = nSeq;

	movsx	eax, WORD PTR _nSeq$12277[ebp]
	mov	DWORD PTR _lAttribCnt$[ebp], eax
$L12284:

; 13839: 
; 13840:          AttribList[ nSeq - 1 ].lpViewAttrib = lpViewAttrib;

	movsx	ecx, WORD PTR _nSeq$12277[ebp]
	sub	ecx, 1
	imul	ecx, 13					; 0000000dH
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _AttribList$[ebp+ecx], edx

; 13841:          if ( lpViewAttrib->bSequencingD )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L12285

; 13842:             AttribList[ nSeq - 1 ].bOrder = TRUE;

	movsx	edx, WORD PTR _nSeq$12277[ebp]
	sub	edx, 1
	imul	edx, 13					; 0000000dH
	mov	BYTE PTR _AttribList$[ebp+edx+8], 1
$L12285:

; 13843: 
; 13844:       } // for ( lpViewAttrib )...

	jmp	$L12275
$L12276:

; 13845: 
; 13846:       // If the top level entity isn't ordered by child entity attributes then
; 13847:       // we can break this loop.
; 13848:       if ( lpTopViewEntity->bAttrOrderChild == FALSE )

	mov	eax, DWORD PTR _lpTopViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 19					; 00000013H
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L12286

; 13849:          break;

	jmp	SHORT $L12270
$L12286:

; 13850: 
; 13851:    } // for ( lpViewEntity )...

	jmp	$L12269
$L12270:

; 13852: 
; 13853:    if ( lAttribCnt > 0 )

	cmp	DWORD PTR _lAttribCnt$[ebp], 0
	jle	SHORT $L12288

; 13855:       nRC = fnOrderEntityForView( lpView, lpEntityInstance, AttribList, FALSE );

	push	0
	lea	edx, DWORD PTR _AttribList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnOrderEntityForView@16
	mov	WORD PTR _nRC$[ebp], ax

; 13856:       if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $L12288

; 13857:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L12251
$L12288:

; 13859: 
; 13860:    return( 0 );

	xor	ax, ax
$L12251:

; 13861: 
; 13862: } // fnOrderEntitiesByDefaultAttribs

	mov	esp, ebp
	pop	ebp
	ret	0
_fnOrderEntitiesByDefaultAttribs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@BDHH@Ordering?5attributes?5?9?9?5resetting@ ; `string'
PUBLIC	??_C@_0BF@KJKO@Unset?5or?5Null?5Cursor?$AA@	; `string'
PUBLIC	??_C@_0O@GNIP@OrderEntities?$AA@		; `string'
PUBLIC	??_C@_0CO@OBEN@Ordering?5attributes?5?9?9?5Entity?5cu@ ; `string'
PUBLIC	_OrderEntitiesByDefaultAttribs@8
;	COMDAT ??_C@_0DA@BDHH@Ordering?5attributes?5?9?9?5resetting@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0DA@BDHH@Ordering?5attributes?5?9?9?5resetting@ DB 'Ordering attrib'
	DB	'utes -- resetting entity cursor.', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@KJKO@Unset?5or?5Null?5Cursor?$AA@
_DATA	SEGMENT
??_C@_0BF@KJKO@Unset?5or?5Null?5Cursor?$AA@ DB 'Unset or Null Cursor', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@GNIP@OrderEntities?$AA@
_DATA	SEGMENT
??_C@_0O@GNIP@OrderEntities?$AA@ DB 'OrderEntities', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CO@OBEN@Ordering?5attributes?5?9?9?5Entity?5cu@
_DATA	SEGMENT
??_C@_0CO@OBEN@Ordering?5attributes?5?9?9?5Entity?5cu@ DB 'Ordering attri'
	DB	'butes -- Entity cursor is null!', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_pchEntityName$ = 12
_lpCurrentTask$ = -20
_lpViewEntityCsr$ = -16
_lpEntityInstance$ = -8
_lpViewEntity$ = -12
_nRC$ = -4
_OrderEntitiesByDefaultAttribs@8 PROC NEAR

; 13880: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 13881:    LPTASK            lpCurrentTask;
; 13882:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 13883:    LPENTITYINSTANCE  lpEntityInstance;
; 13884:    LPVIEWENTITY      lpViewEntity;
; 13885:    zSHORT            nRC;
; 13886: 
; 13887:    // validate some stuff
; 13888: 
; 13889:    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 13890:    if ( (lpCurrentTask = fnOperationCall( iOrderEntitiesByDefaultAttribs,
; 13891:                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	124					; 0000007cH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $L12299

; 13893:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12293
$L12299:

; 13895: 
; 13896:    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView, pchEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 13897:    if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $L12300

; 13899:       fnOperationReturn( iOrderEntitiesByDefaultAttribs, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	124					; 0000007cH
	call	_fnOperationReturn
	add	esp, 8

; 13900:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12293
$L12300:

; 13902: 
; 13903:    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 13904:    if ( (zLONG) lpEntityInstance == 1 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	$L12303

; 13906:       TraceLineS( "Ordering attributes -- resetting entity cursor.", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0DA@BDHH@Ordering?5attributes?5?9?9?5resetting@ ; `string'
	call	_TraceLineS@8

; 13907:       fnEstablishCursorForView( lpViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEstablishCursorForView
	add	esp, 4

; 13908:       lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView, pchEntityName, 0 );

	push	0
	mov	edx, DWORD PTR _pchEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 13909:       if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $L12305

; 13911:          fnOperationReturn( iOrderEntitiesByDefaultAttribs, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	124					; 0000007cH
	call	_fnOperationReturn
	add	esp, 8

; 13912:          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12293
$L12305:

; 13914: 
; 13915:       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 13916:       if ( lpEntityInstance == UNSET_CSR || lpEntityInstance == NULL_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	je	SHORT $L12309
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $L12308
$L12309:

; 13918:          // "KZOEE013 - Internal operation call error"
; 13919:          TraceLineS( "KZOEE013 - Internal operation call error: ",
; 13920:                      "Unset or Null Cursor" );

	push	OFFSET FLAT:??_C@_0BF@KJKO@Unset?5or?5Null?5Cursor?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CL@FGMF@KZOEE013?5?9?5Internal?5operation?5ca@ ; `string'
	call	_TraceLineS@8

; 13921:          fnIssueCoreError( lpCurrentTask, lpView, 8, 13, 0, "OrderEntities", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0O@GNIP@OrderEntities?$AA@ ; `string'
	push	0
	push	13					; 0000000dH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 13922:          nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 13924:       else

	jmp	SHORT $L12312
$L12308:

; 13925:          nRC = fnOrderEntitiesByDefaultAttribs( lpView, lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnOrderEntitiesByDefaultAttribs
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$L12312:

; 13927:    else

	jmp	SHORT $L12315
$L12303:

; 13928:    if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L12314

; 13929:       nRC = fnOrderEntitiesByDefaultAttribs( lpView, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnOrderEntitiesByDefaultAttribs
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 13930:    else

	jmp	SHORT $L12315
$L12314:

; 13932:       TraceLineS( "Ordering attributes -- Entity cursor is null!", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CO@OBEN@Ordering?5attributes?5?9?9?5Entity?5cu@ ; `string'
	call	_TraceLineS@8

; 13933:       nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$L12315:

; 13935: 
; 13936:    fnOperationReturn( iOrderEntitiesByDefaultAttribs, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	124					; 0000007cH
	call	_fnOperationReturn
	add	esp, 8

; 13937:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L12293:

; 13938: 
; 13939: } // OrderEntitiesByDefaultAttribs

	mov	esp, ebp
	pop	ebp
	ret	8
_OrderEntitiesByDefaultAttribs@8 ENDP
_TEXT	ENDS
PUBLIC	_fnGetObjCnstrntOper
_TEXT	SEGMENT
_lpView$ = 8
_lpCurrentTask$ = 12
_hCurrentTask$ = -28
_lpViewOD$ = -16
_hLibrary$ = -12
_lpTaskOperation$ = -24
_hTaskOperation$ = -8
_pchOperLibName$ = -20
_lProcessID$ = -4
_bMutexLocked$12342 = -32
_lpLastTaskOperation$12350 = -36
_fnGetObjCnstrntOper PROC NEAR

; 13952: {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 13953:    LPTASK      hCurrentTask = zGETHNDL( lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hCurrentTask$[ebp], eax

; 13954:    LPVIEWOD    lpViewOD;
; 13955:    LPLIBRARY   hLibrary;
; 13956:    LPTASKOPER  lpTaskOperation;
; 13957:    zPVOID      hTaskOperation;
; 13958:    zPCHAR      pchOperLibName;
; 13959:    zLONG       lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 13960: 
; 13961:    // No Object Constraint operation pointer, return 0 ==> not found.
; 13962:    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 13963:    if ( lpViewOD->szOCEOpername[ 0 ] == 0 )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+175]
	test	ecx, ecx
	jne	SHORT $L12331

; 13964:       return( 0 );

	xor	eax, eax
	jmp	$L12321
$L12331:

; 13965: 
; 13966:    for ( lpTaskOperation = zGETPTR( lpViewOD->hFirstTaskOperation );
; 13967:          lpTaskOperation;
; 13968:          lpTaskOperation = zGETPTR( lpTaskOperation->hNextTaskOperationForOEA ) )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+216]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax
	jmp	SHORT $L12334
$L12335:
	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax
$L12334:
	cmp	DWORD PTR _lpTaskOperation$[ebp], 0
	je	SHORT $L12336

; 13970:       if ( lpTaskOperation->hTask == hCurrentTask &&
; 13971:            lpTaskOperation->lProcessID == lProcessID )

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	cmp	ecx, DWORD PTR _hCurrentTask$[ebp]
	jne	SHORT $L12337
	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [edx+34]
	cmp	eax, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $L12337

; 13973:          return( (zPOCEOPER) lpTaskOperation->pfnTaskOper );

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [ecx+30]
	jmp	$L12321
$L12337:

; 13975:    }

	jmp	SHORT $L12335
$L12336:

; 13976: 
; 13977:    // No task object oper exists yet, create one if possible.
; 13978:    pchOperLibName = lpViewOD->szOperLibname;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 142				; 0000008eH
	mov	DWORD PTR _pchOperLibName$[ebp], edx

; 13979:    if ( pchOperLibName == 0 || pchOperLibName[ 0 ] == 0 )

	cmp	DWORD PTR _pchOperLibName$[ebp], 0
	je	SHORT $L12340
	mov	eax, DWORD PTR _pchOperLibName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L12339
$L12340:

; 13980:       return( 0 );

	xor	eax, eax
	jmp	$L12321
$L12339:

; 13981: 
; 13982:    hLibrary = SysLoadLibrary( lpView, pchOperLibName );

	mov	edx, DWORD PTR _pchOperLibName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 13983: 
; 13984:    if ( hLibrary )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	$L12341

; 13986:       zBOOL bMutexLocked;
; 13987: 
; 13988:       hTaskOperation = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,
; 13989:                                          sizeof( TaskOperationRecord ), 1, 0,
; 13990:                                          iTaskOperation );

	push	10034					; 00002732H
	push	0
	push	1
	push	38					; 00000026H
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskOperation$[ebp], eax

; 13991:       if ( hTaskOperation == 0 )

	cmp	DWORD PTR _hTaskOperation$[ebp], 0
	jne	SHORT $L12344

; 13992:          return( 0 );

	xor	eax, eax
	jmp	$L12321
$L12344:

; 13993: 
; 13994:       lpTaskOperation              = zGETPTR( hTaskOperation );

	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax

; 13995:       lpTaskOperation->hViewOD     = lpView->hViewOD;

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR [ecx+18], eax

; 13996:       lpTaskOperation->hTask       = hCurrentTask;

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _hCurrentTask$[ebp]
	mov	DWORD PTR [ecx+14], edx

; 13997:       lpTaskOperation->lProcessID  = lProcessID;

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [eax+34], ecx

; 13998: 
; 13999:       // Set pointers for TaskOperation chain off of Task structure
; 14000:       // Note: this is a single linked list
; 14001:       if ( hCurrentTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _hCurrentTask$[ebp]
	cmp	eax, DWORD PTR [edx+106]
	jne	SHORT $L12346

; 14003:          bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$12342[ebp], 1

; 14004:          zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 14006:       else

	jmp	SHORT $L12347
$L12346:

; 14007:          bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$12342[ebp], 0
$L12347:

; 14008: 
; 14009:       lpTaskOperation->hNextTaskOperationForTask =
; 14010:                                           lpCurrentTask->hFirstTaskOperation;

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+130]
	mov	DWORD PTR [ecx+2], eax

; 14011:       lpCurrentTask->hFirstTaskOperation = hTaskOperation;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [ecx+130], edx

; 14012: 
; 14013:       if ( bMutexLocked )

	mov	eax, DWORD PTR _bMutexLocked$12342[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L12348

; 14014:          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$L12348:

; 14015: 
; 14016:       lpTaskOperation->pfnTaskOper = SysGetProc( hLibrary,
; 14017:                                                  lpViewOD->szOCEOpername );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 175				; 000000afH
	push	ecx
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 14018: 
; 14019:       // Set pointers for TaskOperation chain off of ViewOD structure
; 14020:       // Note: this is a double linked list
; 14021:       if ( lpViewOD->hLastTaskOperation )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	cmp	DWORD PTR [edx+220], 0
	je	SHORT $L12349

; 14023:          LPTASKOPER lpLastTaskOperation =
; 14024:                                      zGETPTR( lpViewOD->hLastTaskOperation );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastTaskOperation$12350[ebp], eax

; 14025: 
; 14026:          lpLastTaskOperation->hNextTaskOperationForOEA = hTaskOperation;

	mov	edx, DWORD PTR _lpLastTaskOperation$12350[ebp]
	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [edx+6], eax

; 14027:          lpTaskOperation->hPrevTaskOperationForOEA =
; 14028:                                                 lpViewOD->hLastTaskOperation;

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+220]
	mov	DWORD PTR [ecx+10], eax

; 14029:          lpViewOD->hLastTaskOperation = hTaskOperation;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [ecx+220], edx

; 14031:       else

	jmp	SHORT $L12352
$L12349:

; 14033:          lpViewOD->hFirstTaskOperation = hTaskOperation;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 14034:          lpViewOD->hLastTaskOperation  = hTaskOperation;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [edx+220], eax
$L12352:

; 14037:    else

	jmp	SHORT $L12353
$L12341:

; 14038:       return( 0 );

	xor	eax, eax
	jmp	SHORT $L12321
$L12353:

; 14039: 
; 14040:    return( (zPOCEOPER) lpTaskOperation->pfnTaskOper );

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [ecx+30]
$L12321:

; 14041: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetObjCnstrntOper ENDP
_lpView$ = 8
_lpCurrentTask$ = 12
_nEvent$ = 16
_nState$ = 20
_pfn$ = -4
_fnInvokeOCEOperation PROC NEAR

; 14063: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 14064:    zPOCEOPER   pfn;
; 14065: 
; 14066:    pfn = fnGetObjCnstrntOper( lpView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnGetObjCnstrntOper
	add	esp, 8
	mov	DWORD PTR _pfn$[ebp], eax

; 14067:    if ( pfn )

	cmp	DWORD PTR _pfn$[ebp], 0
	je	SHORT $L12365

; 14068:       return( (zSHORT) (*pfn)( lpView, nEvent, nState ) );

	mov	dx, WORD PTR _nState$[ebp]
	push	edx
	mov	ax, WORD PTR _nEvent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _pfn$[ebp]
	jmp	SHORT $L12363
$L12365:

; 14069: 
; 14070:    return( 0 );

	xor	ax, ax
$L12363:

; 14071: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInvokeOCEOperation ENDP
_TEXT	ENDS
PUBLIC	_fnQualError@8
PUBLIC	??_C@_0BF@DGOD@Error?5occurs?5after?3?5?$AA@	; `string'
PUBLIC	??_C@_0CM@MJO@Error?5parsing?5command?4?5?5See?5trac@ ; `string'
;	COMDAT ??_C@_0BF@DGOD@Error?5occurs?5after?3?5?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_0BF@DGOD@Error?5occurs?5after?3?5?$AA@ DB 'Error occurs after: ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@MJO@Error?5parsing?5command?4?5?5See?5trac@
_DATA	SEGMENT
??_C@_0CM@MJO@Error?5parsing?5command?4?5?5See?5trac@ DB 'Error parsing c'
	DB	'ommand.  See trace for more.', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchCommand$ = 8
_fnQualError@8 PROC NEAR

; 14075: {

	push	ebp
	mov	ebp, esp

; 14076:    TraceLineS( "Error occurs after: ", pchCommand );

	mov	eax, DWORD PTR _pchCommand$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@DGOD@Error?5occurs?5after?3?5?$AA@ ; `string'
	call	_TraceLineS@8

; 14077:    SysMessageBox( 0, szlOE_SystemError,
; 14078:                   "Error parsing command.  See trace for more.", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0CM@MJO@Error?5parsing?5command?4?5?5See?5trac@ ; `string'
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 14079: }

	pop	ebp
	ret	8
_fnQualError@8 ENDP
_TEXT	ENDS
PUBLIC	_CreateQualFromCommand
PUBLIC	??_C@_09MHIP@ACTIVATE?5?$AA@			; `string'
PUBLIC	??_C@_06ICCC@WHERE?5?$AA@			; `string'
EXTRN	__imp___pctype:DWORD
EXTRN	__imp___isctype:NEAR
EXTRN	__imp____mb_cur_max:DWORD
;	COMDAT ??_C@_09MHIP@ACTIVATE?5?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_09MHIP@ACTIVATE?5?$AA@ DB 'ACTIVATE ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06ICCC@WHERE?5?$AA@
_DATA	SEGMENT
??_C@_06ICCC@WHERE?5?$AA@ DB 'WHERE ', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchOD_Name$ = 12
_vSubtask$ = 16
_pchCommand$ = 20
_lControl$ = 24
_vaList$ = -60
_lpViewOD$ = -44
_vQual$ = -56
_pch$ = -40
_szActivateView$ = -36
_nExpecting$ = -52
_nRC$ = -48
_k$12411 = -68
_lpViewEntity$12412 = -64
_CreateQualFromCommand PROC NEAR

; 14106: {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 14107:    va_list     vaList;
; 14108:    LPVIEWOD    lpViewOD;
; 14109:    zVIEW       vQual = 0;

	mov	DWORD PTR _vQual$[ebp], 0

; 14110:    zPCHAR      pch;
; 14111:    zCHAR       szActivateView[ zZEIDON_NAME_LTH + 1 ];
; 14112:    zSHORT      nExpecting = ACTIVATE;

	mov	WORD PTR _nExpecting$[ebp], 1

; 14113:    zSHORT      nRC = zCALL_ERROR;  // We'll assume an error.

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 14114: 
; 14115:    va_start( vaList, lControl );

	lea	eax, DWORD PTR _lControl$[ebp+4]
	mov	DWORD PTR _vaList$[ebp], eax

; 14116: 
; 14117:    lpViewOD = ActivateViewObject( vSubtask, pchOD_Name, FALSE );

	push	0
	mov	ecx, DWORD PTR _pchOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_ActivateViewObject@12
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 14118:    if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $L12397

; 14119:       goto EndOfFunction;

	jmp	$EndOfFunction$12398
$L12397:

; 14120: 
; 14121:    // Create an empty qualification.
; 14122:    if ( SfActivateSysEmptyOI( &vQual, "KZDBHQUA", vSubtask, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08ILBJ@KZDBHQUA?$AA@	; `string'
	lea	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L12399

; 14123:       goto EndOfFunction;

	jmp	$EndOfFunction$12398
$L12399:

; 14124: 
; 14125:    pch = pchCommand;

	mov	eax, DWORD PTR _pchCommand$[ebp]
	mov	DWORD PTR _pch$[ebp], eax
$L12401:

; 14126:    while ( *pch )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$L12402

; 14128:       // skip blanks.
; 14129:       if ( zisspace( *pch ) )

	mov	eax, DWORD PTR __imp____mb_cur_max
	cmp	DWORD PTR [eax], 1
	jle	SHORT $L12897
	push	8
	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp___isctype
	add	esp, 8
	mov	DWORD PTR -72+[ebp], eax
	jmp	SHORT $L12898
$L12897:
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR __imp___pctype
	mov	eax, DWORD PTR [edx]
	xor	edx, edx
	mov	dx, WORD PTR [eax+ecx*2]
	and	edx, 8
	mov	DWORD PTR -72+[ebp], edx
$L12898:
	cmp	DWORD PTR -72+[ebp], 0
	je	SHORT $L12403

; 14131:          pch++;

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$[ebp], eax

; 14132:          continue;

	jmp	SHORT $L12401
$L12403:

; 14134: 
; 14135:       switch ( ztoupper( *pch ) )
; 14136:       {

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	DWORD PTR -76+[ebp], eax
	cmp	DWORD PTR -76+[ebp], 65			; 00000041H
	je	SHORT $L12408
	cmp	DWORD PTR -76+[ebp], 87			; 00000057H
	je	$L12421
	jmp	$L12405
$L12408:

; 14137:          case 'A':
; 14138:             if ( zstrncmpi( pch, "ACTIVATE ", 9 ) == 0 )

	push	9
	push	OFFSET FLAT:??_C@_09MHIP@ACTIVATE?5?$AA@ ; `string'
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$L12409

; 14140:                zSHORT       k;
; 14141:                LPVIEWENTITY lpViewEntity;
; 14142: 
; 14143:                if ( nExpecting != ACTIVATE )

	movsx	ecx, WORD PTR _nExpecting$[ebp]
	cmp	ecx, 1
	je	SHORT $L12413

; 14145:                   fnQualError( pch, 0 );

	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_fnQualError@8

; 14146:                   goto EndOfFunction;

	jmp	$EndOfFunction$12398
$L12413:

; 14148: 
; 14149:                // Skip over activate text.
; 14150:                pch += 9;

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 9
	mov	DWORD PTR _pch$[ebp], eax

; 14151: 
; 14152:                // Get activate view name.
; 14153:                for ( k = 0; !zisspace( *pch ) && *pch != 0 ; pch++, k++ )

	mov	WORD PTR _k$12411[ebp], 0
	jmp	SHORT $L12414
$L12415:
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
	mov	dx, WORD PTR _k$12411[ebp]
	add	dx, 1
	mov	WORD PTR _k$12411[ebp], dx
$L12414:
	mov	eax, DWORD PTR __imp____mb_cur_max
	cmp	DWORD PTR [eax], 1
	jle	SHORT $L12899
	push	8
	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp___isctype
	add	esp, 8
	mov	DWORD PTR -80+[ebp], eax
	jmp	SHORT $L12900
$L12899:
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR __imp___pctype
	mov	eax, DWORD PTR [edx]
	xor	edx, edx
	mov	dx, WORD PTR [eax+ecx*2]
	and	edx, 8
	mov	DWORD PTR -80+[ebp], edx
$L12900:
	cmp	DWORD PTR -80+[ebp], 0
	jne	SHORT $L12416
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L12416

; 14155:                   if ( k > zZEIDON_NAME_LTH )

	movsx	edx, WORD PTR _k$12411[ebp]
	cmp	edx, 32					; 00000020H
	jle	SHORT $L12417

; 14157:                      fnQualError( pch, 0 );

	push	0
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_fnQualError@8

; 14158:                      goto EndOfFunction;

	jmp	$EndOfFunction$12398
$L12417:

; 14160: 
; 14161:                   szActivateView[ k ] = *pch;

	movsx	ecx, WORD PTR _k$12411[ebp]
	mov	edx, DWORD PTR _pch$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _szActivateView$[ebp+ecx], al

; 14162:                }

	jmp	$L12415
$L12416:

; 14163: 
; 14164:                lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$12412[ebp], eax

; 14165:                CreateEntity( vQual, "EntitySpec", zPOS_NEXT );

	push	3
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_CreateEntity@12

; 14166:                SetAttributeFromString( vQual, "EntitySpec", "EntityName",
; 14167:                                        lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$12412[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 14168: 
; 14169:                nExpecting = WHERE;

	mov	WORD PTR _nExpecting$[ebp], 2

; 14171:             else

	jmp	SHORT $L12420
$L12409:

; 14173:                fnQualError( pch, 0 );

	push	0
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_fnQualError@8

; 14174:                goto EndOfFunction;

	jmp	SHORT $EndOfFunction$12398
$L12420:

; 14176: 
; 14177:             break;

	jmp	SHORT $L12405
$L12421:

; 14178: 
; 14179:          case 'W':
; 14180:             if ( zstrncmpi( pch, "WHERE ", 6 ) == 0 )

	push	6
	push	OFFSET FLAT:??_C@_06ICCC@WHERE?5?$AA@	; `string'
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L12422

; 14182:                if ( nExpecting != WHERE )

	movsx	edx, WORD PTR _nExpecting$[ebp]
	cmp	edx, 2
	je	SHORT $L12424

; 14184:                   fnQualError( pch, 0 );

	push	0
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_fnQualError@8

; 14185:                   goto EndOfFunction;

	jmp	SHORT $EndOfFunction$12398
$L12424:

; 14187: 
; 14188:                // Skip over where text.
; 14189:                pch += 6;

	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 6
	mov	DWORD PTR _pch$[ebp], ecx

; 14190: 
; 14191:                nExpecting = QUAL;

	mov	WORD PTR _nExpecting$[ebp], 3

; 14193:             else

	jmp	SHORT $L12425
$L12422:

; 14195:                fnQualError( pch, 0 );

	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_fnQualError@8

; 14196:                goto EndOfFunction;

	jmp	SHORT $EndOfFunction$12398
$L12425:
$L12405:

; 14202: 
; 14203:    } // while ( *pch )...

	jmp	$L12401
$L12402:

; 14204: 
; 14205:    // If we get here then everything's good.
; 14206:    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$12398:

; 14207: 
; 14208: EndOfFunction:
; 14209:    va_end( vaList );

	mov	DWORD PTR _vaList$[ebp], 0

; 14210: 
; 14211:    // We need to clean up a little more if we have an error.
; 14212:    if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L12428

; 14214:       if ( vQual )

	cmp	DWORD PTR _vQual$[ebp], 0
	je	SHORT $L12428

; 14215:          DropObjectInstance( vQual );

	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_DropObjectInstance@4
$L12428:

; 14217: 
; 14218:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 14219: }

	mov	esp, ebp
	pop	ebp
	ret	0
_CreateQualFromCommand ENDP
_pchLineOut$ = 8
_pchBuffer$ = 12
_ulBufferLth$ = 16
_pulBufferPos$ = 20
_k$ = -16
_nChars$ = -20
_c$ = -4
_pchIn$ = -12
_pchOut$ = -8
_UUENCODE_NextEncodedLine@16 PROC NEAR

; 14259: {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 14260: 
; 14261: // The encode macro masks the lower 6 bits and adds 32 (a space), but
; 14262: // it translates a binary zero to a "`" rather than leaving it a space.
; 14263: // This is the generally accepted current technique (although not in the standard).
; 14264: #define ENC(c) ((c) ? ((c) & 0x3F) + 0x20: 0x60)
; 14265: 
; 14266:    zSHORT k, nChars;
; 14267:    zCHAR  c;
; 14268:    register zPCHAR pchIn;
; 14269:    register zPCHAR pchOut;
; 14270: 
; 14271:    pchOut = pchLineOut;

	mov	eax, DWORD PTR _pchLineOut$[ebp]
	mov	DWORD PTR _pchOut$[ebp], eax

; 14272:    nChars = (zSHORT) (ulBufferLth - *pulBufferPos);

	mov	ecx, DWORD PTR _pulBufferPos$[ebp]
	mov	edx, DWORD PTR _ulBufferLth$[ebp]
	sub	edx, DWORD PTR [ecx]
	mov	WORD PTR _nChars$[ebp], dx

; 14273:    if ( nChars <= 0 )

	movsx	eax, WORD PTR _nChars$[ebp]
	test	eax, eax
	jg	SHORT $L12444

; 14275:       // Buffer encoding complete
; 14276:       *pchOut++ = '`';

	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx], 96			; 00000060H
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14277:       *pchOut = 0;

	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax], 0

; 14278:       return( 0 );

	xor	ax, ax
	jmp	$L12437
$L12444:

; 14280: 
; 14281:    if ( nChars > 45 )

	movsx	ecx, WORD PTR _nChars$[ebp]
	cmp	ecx, 45					; 0000002dH
	jle	SHORT $L12445

; 14282:       nChars = 45;

	mov	WORD PTR _nChars$[ebp], 45		; 0000002dH
$L12445:

; 14283: 
; 14284:    // store the length as the first byte encoded
; 14285:    *pchOut++ = ENC( nChars );

	movsx	edx, WORD PTR _nChars$[ebp]
	test	edx, edx
	je	SHORT $L12902
	movsx	eax, WORD PTR _nChars$[ebp]
	and	eax, 63					; 0000003fH
	add	eax, 32					; 00000020H
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L12903
$L12902:
	mov	DWORD PTR -24+[ebp], 96			; 00000060H
$L12903:
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	dl, BYTE PTR -24+[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax

; 14286:    pchIn = pchBuffer + *pulBufferPos;

	mov	ecx, DWORD PTR _pulBufferPos$[ebp]
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pchIn$[ebp], edx

; 14287:    for ( k = nChars; k > 0; k -= 3, pchIn += 3 )

	mov	ax, WORD PTR _nChars$[ebp]
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $L12446
$L12447:
	mov	cx, WORD PTR _k$[ebp]
	sub	cx, 3
	mov	WORD PTR _k$[ebp], cx
	mov	edx, DWORD PTR _pchIn$[ebp]
	add	edx, 3
	mov	DWORD PTR _pchIn$[ebp], edx
$L12446:
	movsx	eax, WORD PTR _k$[ebp]
	test	eax, eax
	jle	$L12448

; 14289:       c = *pchIn >> 2;

	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sar	edx, 2
	mov	BYTE PTR _c$[ebp], dl

; 14290:       *pchOut++ = ENC( c );

	movsx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	je	SHORT $L12904
	movsx	ecx, BYTE PTR _c$[ebp]
	and	ecx, 63					; 0000003fH
	add	ecx, 32					; 00000020H
	mov	DWORD PTR -28+[ebp], ecx
	jmp	SHORT $L12905
$L12904:
	mov	DWORD PTR -28+[ebp], 96			; 00000060H
$L12905:
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	al, BYTE PTR -28+[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14291: 
; 14292:       if ( k == 1 )

	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 1
	jne	SHORT $L12449

; 14294:          // only one byte valid - use 0 for next 2 input bytes
; 14295:          c = (*pchIn << 4) & 0x30;

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	shl	ecx, 4
	and	ecx, 48					; 00000030H
	mov	BYTE PTR _c$[ebp], cl

; 14296:          *pchOut++ = ENC( c );

	movsx	edx, BYTE PTR _c$[ebp]
	test	edx, edx
	je	SHORT $L12906
	movsx	eax, BYTE PTR _c$[ebp]
	and	eax, 63					; 0000003fH
	add	eax, 32					; 00000020H
	mov	DWORD PTR -32+[ebp], eax
	jmp	SHORT $L12907
$L12906:
	mov	DWORD PTR -32+[ebp], 96			; 00000060H
$L12907:
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	dl, BYTE PTR -32+[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax

; 14297:          *pchOut++ = ENC( 0 );

	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx], 96			; 00000060H
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14298:          *pchOut++ = ENC( 0 );

	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax], 96			; 00000060H
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14300:       else

	jmp	$L12452
$L12449:

; 14301:       if ( k == 2 )

	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 2
	jne	$L12451

; 14303:          // only 2 bytes valid - use 0 for last input byte
; 14304:          c = ((*pchIn << 4) & 0x30) | ((pchIn[ 1 ] >> 4) & 0x0F);

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	shl	ecx, 4
	and	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	sar	eax, 4
	and	eax, 15					; 0000000fH
	or	ecx, eax
	mov	BYTE PTR _c$[ebp], cl

; 14305:          *pchOut++ = ENC( c );

	movsx	ecx, BYTE PTR _c$[ebp]
	test	ecx, ecx
	je	SHORT $L12908
	movsx	edx, BYTE PTR _c$[ebp]
	and	edx, 63					; 0000003fH
	add	edx, 32					; 00000020H
	mov	DWORD PTR -36+[ebp], edx
	jmp	SHORT $L12909
$L12908:
	mov	DWORD PTR -36+[ebp], 96			; 00000060H
$L12909:
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	cl, BYTE PTR -36+[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14306:          c = (pchIn[ 1 ] << 2) & 0x3C;

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	shl	ecx, 2
	and	ecx, 60					; 0000003cH
	mov	BYTE PTR _c$[ebp], cl

; 14307:          *pchOut++ = ENC( c );

	movsx	edx, BYTE PTR _c$[ebp]
	test	edx, edx
	je	SHORT $L12910
	movsx	eax, BYTE PTR _c$[ebp]
	and	eax, 63					; 0000003fH
	add	eax, 32					; 00000020H
	mov	DWORD PTR -40+[ebp], eax
	jmp	SHORT $L12911
$L12910:
	mov	DWORD PTR -40+[ebp], 96			; 00000060H
$L12911:
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	dl, BYTE PTR -40+[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax

; 14308:          *pchOut++ = ENC( 0 );

	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx], 96			; 00000060H
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14310:       else

	jmp	$L12452
$L12451:

; 14312:          // all 3 bytes valid - use all 3 input bytes for the 4 output bytes
; 14313:          c = ((*pchIn << 4) & 0x30) | ((pchIn[ 1 ] >> 4) & 0x0F);

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	shl	ecx, 4
	and	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	sar	eax, 4
	and	eax, 15					; 0000000fH
	or	ecx, eax
	mov	BYTE PTR _c$[ebp], cl

; 14314:          *pchOut++ = ENC( c );

	movsx	ecx, BYTE PTR _c$[ebp]
	test	ecx, ecx
	je	SHORT $L12912
	movsx	edx, BYTE PTR _c$[ebp]
	and	edx, 63					; 0000003fH
	add	edx, 32					; 00000020H
	mov	DWORD PTR -44+[ebp], edx
	jmp	SHORT $L12913
$L12912:
	mov	DWORD PTR -44+[ebp], 96			; 00000060H
$L12913:
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	cl, BYTE PTR -44+[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14315:          c = ((pchIn[ 1 ] << 2) & 0x3C) | ((pchIn[ 2 ] >> 6) & 0x03);

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	shl	ecx, 2
	and	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	sar	eax, 6
	and	eax, 3
	or	ecx, eax
	mov	BYTE PTR _c$[ebp], cl

; 14316:          *pchOut++ = ENC( c );

	movsx	ecx, BYTE PTR _c$[ebp]
	test	ecx, ecx
	je	SHORT $L12914
	movsx	edx, BYTE PTR _c$[ebp]
	and	edx, 63					; 0000003fH
	add	edx, 32					; 00000020H
	mov	DWORD PTR -48+[ebp], edx
	jmp	SHORT $L12915
$L12914:
	mov	DWORD PTR -48+[ebp], 96			; 00000060H
$L12915:
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	cl, BYTE PTR -48+[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14317:          c = pchIn[ 2 ] & 0x3F;

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	and	ecx, 63					; 0000003fH
	mov	BYTE PTR _c$[ebp], cl

; 14318:          *pchOut++ = ENC( c );

	movsx	edx, BYTE PTR _c$[ebp]
	test	edx, edx
	je	SHORT $L12916
	movsx	eax, BYTE PTR _c$[ebp]
	and	eax, 63					; 0000003fH
	add	eax, 32					; 00000020H
	mov	DWORD PTR -52+[ebp], eax
	jmp	SHORT $L12917
$L12916:
	mov	DWORD PTR -52+[ebp], 96			; 00000060H
$L12917:
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	dl, BYTE PTR -52+[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax
$L12452:

; 14320:    }

	jmp	$L12447
$L12448:

; 14321: 
; 14322:    *pulBufferPos = *pulBufferPos + nChars;

	movsx	ecx, WORD PTR _nChars$[ebp]
	mov	edx, DWORD PTR _pulBufferPos$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _pulBufferPos$[ebp]
	mov	DWORD PTR [ecx], eax

; 14323:    *pchOut = 0;

	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], 0

; 14324: 
; 14325:    return( 1 );

	mov	ax, 1
$L12437:

; 14326: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_UUENCODE_NextEncodedLine@16 ENDP
_pchEncodedLine$ = 8
_pchBuffer$ = 12
_ulBufferLth$ = 16
_pulBufferPos$ = 20
_k$ = -12
_nChars$ = -16
_nAvail$ = -20
_pchIn$ = -8
_pchOut$ = -4
_UUDECODE_NextLineToBuffer@16 PROC NEAR

; 14377: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 14378: 
; 14379: // The decode macro subtracts 32 (a space) and masks the lower 6 bits
; 14380: #define DEC(c)  (((c) - 0x20) & 0x3F)
; 14381: 
; 14382:    zSHORT k, nChars, nAvail;
; 14383:    register zPCHAR pchIn;
; 14384:    register zPCHAR pchOut;
; 14385: 
; 14386:    nAvail = (zSHORT) (ulBufferLth - *pulBufferPos);

	mov	eax, DWORD PTR _pulBufferPos$[ebp]
	mov	ecx, DWORD PTR _ulBufferLth$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	WORD PTR _nAvail$[ebp], cx

; 14387:    pchIn = pchEncodedLine;

	mov	edx, DWORD PTR _pchEncodedLine$[ebp]
	mov	DWORD PTR _pchIn$[ebp], edx

; 14388:    nChars = DEC( *pchIn );

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	mov	WORD PTR _nChars$[ebp], cx

; 14389:    if ( nChars == 0 )

	movsx	edx, WORD PTR _nChars$[ebp]
	test	edx, edx
	jne	SHORT $L12468

; 14390:       return( 0 );

	xor	ax, ax
	jmp	$L12461
$L12468:

; 14391: 
; 14392:    if ( nChars > nAvail || nChars > 45 )

	movsx	eax, WORD PTR _nChars$[ebp]
	movsx	ecx, WORD PTR _nAvail$[ebp]
	cmp	eax, ecx
	jg	SHORT $L12470
	movsx	edx, WORD PTR _nChars$[ebp]
	cmp	edx, 45					; 0000002dH
	jle	SHORT $L12469
$L12470:

; 14394:       // no room left in buffer or invalid line length.
; 14395:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12461
$L12469:

; 14397: 
; 14398:    // check line length is correct
; 14399:    //    this can be eliminated if it is too much overhead
; 14400:    if ( (zUSHORT) zstrlen( pchEncodedLine ) != (zUSHORT) (((((nChars - 1) / 3) + 1) * 4) + 1))

	mov	eax, DWORD PTR _pchEncodedLine$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, eax
	and	ecx, 65535				; 0000ffffH
	movsx	eax, WORD PTR _nChars$[ebp]
	sub	eax, 1
	cdq
	mov	esi, 3
	idiv	esi
	lea	edx, DWORD PTR [eax*4+5]
	and	edx, 65535				; 0000ffffH
	cmp	ecx, edx
	je	SHORT $L12473

; 14402:       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L12461
$L12473:

; 14404: 
; 14405:    // fill the buffer (4 bytes go to 3)
; 14406:    pchOut = pchBuffer + *pulBufferPos;

	mov	eax, DWORD PTR _pulBufferPos$[ebp]
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14407:    for ( pchIn++, k = nChars; k > 0; pchIn += 4, k -= 3 )

	mov	edx, DWORD PTR _pchIn$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchIn$[ebp], edx
	mov	ax, WORD PTR _nChars$[ebp]
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $L12474
$L12475:
	mov	ecx, DWORD PTR _pchIn$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchIn$[ebp], ecx
	mov	dx, WORD PTR _k$[ebp]
	sub	dx, 3
	mov	WORD PTR _k$[ebp], dx
$L12474:
	movsx	eax, WORD PTR _k$[ebp]
	test	eax, eax
	jle	$L12476

; 14409:       if ( k >= 3 )

	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 3
	jl	$L12477

; 14411:          *pchOut++ = DEC (*pchIn) << 2 | DEC (pchIn[ 1 ]) >> 4;

	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	eax, 32					; 00000020H
	and	eax, 63					; 0000003fH
	shl	eax, 2
	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	sub	edx, 32					; 00000020H
	and	edx, 63					; 0000003fH
	sar	edx, 4
	or	eax, edx
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14412:          *pchOut++ = DEC (pchIn[ 1 ]) << 4 | DEC (pchIn[ 2 ]) >> 2;

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	shl	ecx, 4
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	sub	eax, 32					; 00000020H
	and	eax, 63					; 0000003fH
	sar	eax, 2
	or	ecx, eax
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax

; 14413:          *pchOut++ = DEC (pchIn[ 2 ]) << 6 | DEC (pchIn[ 3 ]);

	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	sub	edx, 32					; 00000020H
	and	edx, 63					; 0000003fH
	shl	edx, 6
	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+3]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	or	edx, ecx
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14415:       else

	jmp	SHORT $L12480
$L12477:

; 14417:          if ( k >= 1 )

	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 1
	jl	SHORT $L12479

; 14419:             *pchOut++ = DEC (*pchIn) << 2 | DEC (pchIn[ 1 ]) >> 4;

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	shl	ecx, 2
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	sub	eax, 32					; 00000020H
	and	eax, 63					; 0000003fH
	sar	eax, 4
	or	ecx, eax
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax
$L12479:

; 14421: 
; 14422:          if ( k >= 2 )

	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 2
	jl	SHORT $L12480

; 14424:             *pchOut++ = DEC (pchIn[ 1 ]) << 4 | DEC (pchIn[ 2 ]) >> 2;

	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	sub	eax, 32					; 00000020H
	and	eax, 63					; 0000003fH
	shl	eax, 4
	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	sub	edx, 32					; 00000020H
	and	edx, 63					; 0000003fH
	sar	edx, 2
	or	eax, edx
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx
$L12480:

; 14427:    }

	jmp	$L12475
$L12476:

; 14428: 
; 14429:    *pulBufferPos = *pulBufferPos + nChars;

	movsx	eax, WORD PTR _nChars$[ebp]
	mov	ecx, DWORD PTR _pulBufferPos$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _pulBufferPos$[ebp]
	mov	DWORD PTR [eax], edx

; 14430: 
; 14431:    return( nChars );

	mov	ax, WORD PTR _nChars$[ebp]
$L12461:

; 14432: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_UUDECODE_NextLineToBuffer@16 ENDP
_TEXT	ENDS
EXTRN	_SysMalloc@4:NEAR
_TEXT	SEGMENT
_pViewArrayBlock$ = 8
_nViewCount$ = 12
_pv$ = -8
_nViewCount1$ = -4
_fnInitViewArrayBlock PROC NEAR

; 14447: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 14448:    zPVOID *pv;
; 14449:    zLONG nViewCount1 = nViewCount + 1; // we need a trailing NULL pointer

	mov	eax, DWORD PTR _nViewCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _nViewCount1$[ebp], eax

; 14450: 
; 14451:    zmemset( pViewArrayBlock, 0, sizeof(VIEWARRAYBLOCK) );

	push	64					; 00000040H
	push	0
	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 14452: 
; 14453:    if ( nViewCount > 1 )

	cmp	DWORD PTR _nViewCount$[ebp], 1
	jle	SHORT $L12489

; 14455:       // allocate 5 PVOID arrays of size nViewCount + 1
; 14456:       pv = SysMalloc( 5 * nViewCount1 * sizeof( zPVOID ) );

	mov	edx, DWORD PTR _nViewCount1$[ebp]
	imul	edx, 5
	shl	edx, 2
	push	edx
	call	_SysMalloc@4
	mov	DWORD PTR _pv$[ebp], eax

; 14457:       if ( pv == 0 )

	cmp	DWORD PTR _pv$[ebp], 0
	jne	SHORT $L12491

; 14458:          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L12485
$L12491:

; 14460:    else

	jmp	SHORT $L12492
$L12489:

; 14462:       // Usually there is only 1 view in the cluster ... in which case we
; 14463:       // we do NOT malloc for performance reasons.
; 14464:       pv = pViewArrayBlock->pvDyn;

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR _pv$[ebp], eax
$L12492:

; 14466: 
; 14467:    pViewArrayBlock->lCount = nViewCount1;

	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	edx, DWORD PTR _nViewCount1$[ebp]
	mov	DWORD PTR [ecx], edx

; 14468:    pViewArrayBlock->pvArray = (zVIEW *) pv;

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 14469:    pViewArrayBlock->pViewOI_Array = (LPVIEWOI *)(pv + nViewCount1);

	mov	edx, DWORD PTR _nViewCount1$[ebp]
	mov	eax, DWORD PTR _pv$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 14470:    pViewArrayBlock->pViewOD_Array = (LPVIEWOD *)(pv + 2 * nViewCount1);

	mov	eax, DWORD PTR _nViewCount1$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _pv$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	mov	DWORD PTR [eax+12], edx

; 14471:    pViewArrayBlock->pbGenkeyNeededArray = (zBOOL *)(pv + 3 * nViewCount1);

	mov	ecx, DWORD PTR _nViewCount1$[ebp]
	imul	ecx, 3
	mov	edx, DWORD PTR _pv$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 14472:    pViewArrayBlock->pbFK_NeededArray    = (zBOOL *)(pv + 4 * nViewCount1);

	mov	edx, DWORD PTR _nViewCount1$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _pv$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 14473: 
; 14474:    return( 0 );

	xor	ax, ax
$L12485:

; 14475: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInitViewArrayBlock ENDP
_TEXT	ENDS
EXTRN	_SysFree@4:NEAR
_TEXT	SEGMENT
_pViewArrayBlock$ = 8
_fnFreeViewArrayBlock PROC NEAR

; 14489: {

	push	ebp
	mov	ebp, esp

; 14490:    if ( pViewArrayBlock->pvArray && pViewArrayBlock->lCount > 2 )

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L12501
	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	cmp	DWORD PTR [ecx], 2
	jle	SHORT $L12501

; 14491:       SysFree( pViewArrayBlock->pvArray );

	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_SysFree@4
$L12501:

; 14492: 
; 14493:    zmemset( pViewArrayBlock, 0, sizeof( VIEWARRAYBLOCK ) );

	push	64					; 00000040H
	push	0
	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 14494: }

	pop	ebp
	ret	0
_fnFreeViewArrayBlock ENDP
_TEXT	ENDS
PUBLIC	??_C@_06KGGE@?$CKroot?$CK?$AA@			; `string'
PUBLIC	??_C@_07CHNO@KeyList?$AA@			; `string'
PUBLIC	??_C@_0N@GDFL@IntegerValue?$AA@			; `string'
PUBLIC	_GenerateQualFromEntityList@20
EXTRN	_fnValidateCursorParameters:NEAR
;	COMDAT ??_C@_06KGGE@?$CKroot?$CK?$AA@
; File c:\10c\A\oe\KZOEOIAA.C
_DATA	SEGMENT
??_C@_06KGGE@?$CKroot?$CK?$AA@ DB '*root*', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CHNO@KeyList?$AA@
_DATA	SEGMENT
??_C@_07CHNO@KeyList?$AA@ DB 'KeyList', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@GDFL@IntegerValue?$AA@
_DATA	SEGMENT
??_C@_0N@GDFL@IntegerValue?$AA@ DB 'IntegerValue', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvQual$ = 8
_vEntityList$ = 12
_pchEntityName$ = 16
_pchScoping$ = 20
_lpCurrentTask$ = -32
_lpViewEntity$ = -12
_lpScopingViewEntity$ = -20
_lpViewEntityCsr$ = -28
_lpScopingViewEntityCsr$ = -8
_lpKey$ = -24
_vQual$ = -16
_nRC$ = -4
_GenerateQualFromEntityList@20 PROC NEAR

; 14518: {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 14519:    LPTASK            lpCurrentTask;
; 14520:    LPVIEWENTITY      lpViewEntity;
; 14521:    LPVIEWENTITY      lpScopingViewEntity;
; 14522:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 14523:    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 14524:    LPVIEWATTRIB      lpKey;
; 14525:    zVIEW             vQual;
; 14526:    zSHORT            nRC;
; 14527: 
; 14528:    // Validate parameters
; 14529:    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 14530:                                            &lpViewEntity,
; 14531:                                            &lpScopingViewEntity,
; 14532:                                            &lpViewEntityCsr,
; 14533:                                            &lpScopingViewEntityCsr,
; 14534:                                            iGenerateQualFromEntityList,
; 14535:                                            vEntityList,
; 14536:                                            pchEntityName,
; 14537:                                            pchScoping )) != 0 )

	mov	eax, DWORD PTR _pchScoping$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vEntityList$[ebp]
	push	edx
	push	65					; 00000041H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $L12522

; 14539:       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$L12513
$L12522:

; 14541: 
; 14542:    // Find the key attribute.
; 14543:    for ( lpKey = zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 14544:          lpKey->bKey == FALSE;
; 14545:          lpKey = zGETPTR( lpKey->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpKey$[ebp], eax
	jmp	SHORT $L12525
$L12526:
	mov	edx, DWORD PTR _lpKey$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpKey$[ebp], eax
$L12525:
	mov	ecx, DWORD PTR _lpKey$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	test	edx, edx
	jne	SHORT $L12527

; 14547:       // nothing needs to be done here
; 14548:    }

	jmp	SHORT $L12526
$L12527:

; 14549: 
; 14550:    SfActivateSysEmptyOI( &vQual, "KZDBHQUA", vEntityList, zMULTIPLE );

	push	256					; 00000100H
	mov	eax, DWORD PTR _vEntityList$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08ILBJ@KZDBHQUA?$AA@	; `string'
	lea	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16

; 14551:    CreateEntity( vQual, "EntitySpec", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_CreateEntity@12

; 14552:    SetAttributeFromString( vQual, "EntitySpec", "EntityName", "*root*" );

	push	OFFSET FLAT:??_C@_06KGGE@?$CKroot?$CK?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@EIGE@EntitySpec?$AA@ ; `string'
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 14553: 
; 14554:    CreateEntity( vQual, "QualAttrib", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_CreateEntity@12

; 14555:    SetAttributeFromString( vQual, "QualAttrib", "EntityName", "*root*" );

	push	OFFSET FLAT:??_C@_06KGGE@?$CKroot?$CK?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@LOJF@EntityName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 14556:    SetAttributeFromString( vQual, "QualAttrib", "AttributeName", lpKey->szName );

	mov	eax, DWORD PTR _lpKey$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET FLAT:??_C@_0O@JICG@AttributeName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 14557:    SetAttributeFromString( vQual, "QualAttrib", "Oper", "=" );

	push	OFFSET FLAT:??_C@_01KPOD@?$DN?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04FKDH@Oper?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@DIOI@QualAttrib?$AA@ ; `string'
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 14558: 
; 14559:    // Loop through the entities and copy the key values to the qual OI.
; 14560:    for ( nRC = fnSetEntityCursor( vEntityList, lpViewEntity, lpViewEntityCsr,
; 14561:                                   0, (zLONG) zPOS_FIRST,
; 14562:                                   0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 14563:                                   lpCurrentTask );
; 14564:          nRC >= zCURSOR_SET;
; 14565:          nRC = fnSetEntityCursor( vEntityList, lpViewEntity, lpViewEntityCsr,
; 14566:                                   0, (zLONG) zPOS_NEXT,
; 14567:                                   0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 14568:                                   lpCurrentTask ) )

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	1
	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vEntityList$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L12535
$L12536:
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	3
	push	0
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vEntityList$[ebp]
	push	eax
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax
$L12535:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $L12537

; 14570:       CreateEntity( vQual, "KeyList", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_07CHNO@KeyList?$AA@	; `string'
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_CreateEntity@12

; 14571:       SetAttributeFromAttribute( vQual, "KeyList", "IntegerValue",
; 14572:                                  vEntityList, pchEntityName, lpKey->szName );

	mov	eax, DWORD PTR _lpKey$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vEntityList$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0N@GDFL@IntegerValue?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_07CHNO@KeyList?$AA@	; `string'
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_SetAttributeFromAttribute@24

; 14573:    }

	jmp	SHORT $L12536
$L12537:

; 14574: 
; 14575:    // Reset the cursor back to the first entity.
; 14576:    nRC = fnSetEntityCursor( vEntityList, lpViewEntity, lpViewEntityCsr,
; 14577:                             0, (zLONG) zPOS_FIRST,
; 14578:                             0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 14579:                             lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	push	0
	push	0
	push	0
	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vEntityList$[ebp]
	push	edx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 14580: 
; 14581:    *pvQual = vQual;

	mov	eax, DWORD PTR _pvQual$[ebp]
	mov	ecx, DWORD PTR _vQual$[ebp]
	mov	DWORD PTR [eax], ecx

; 14582: 
; 14583:    fnOperationReturn( iGenerateQualFromEntityList, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	65					; 00000041H
	call	_fnOperationReturn
	add	esp, 8

; 14584:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L12513:

; 14585: }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_GenerateQualFromEntityList@20 ENDP
_TEXT	ENDS
END
