	TITLE	c:\10c\w\oe\ZWINSOCK.CPP
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_08PLFD@WSAEINTR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PJGE@WSAEBADF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HMKF@WSAEACCES?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GNPN@WSAEFAULT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09COKE@WSAEINVAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09IMGE@WSAEMFILE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@HEMP@WSAEWOULDBLOCK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@DGNH@WSAEINPROGRESS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@FDKM@WSAEALREADY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@PLNC@WSAENOTSOCK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@LDNB@WSAEDESTADDRREQ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@EFDP@WSAEMSGSIZE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@MMIF@WSAEPROTOTYPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@CMMD@WSAENOPROTOOPT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@NNFA@WSAEPROTONOSUPPORT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@BHGL@WSAESOCKTNOSUPPORT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@CKGP@WSAEOPNOTSUPP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@NEAC@WSAEPFNOSUPPORT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JGHB@WSAEAFNOSUPPORT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@HEEI@WSAEADDRINUSE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CAPK@WSAEADDRNOTAVAIL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@OCME@WSAENETDOWN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@BMAL@WSAENETUNREACH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@KFEB@WSAENETRESET?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@DAMK@WSAECONNABORTED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@LFGK@WSAECONNRESET?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@HPDK@WSAENOBUFS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GMEH@WSAEISCONN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@FHGM@WSAENOTCONN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@IIJE@WSAESHUTDOWN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JKLP@WSAETOOMANYREFS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@IOAI@WSAETIMEDOUT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@KHJO@WSAECONNREFUSED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08KIHD@WSAELOOP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CAFH@WSAENAMETOOLONG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CHFC@WSAEHOSTDOWN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GDKP@WSAEHOSTUNREACH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@BKLD@WSAENOTEMPTY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@JCAC@WSAEPROCLIM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09EMMP@WSAEUSERS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09EDGJ@WSAEDQUOT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09MAPE@WSAESTALE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@ELPL@WSAEREMOTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@BMGD@WSASYSNOTREADY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@PKID@WSAVERNOTSUPPORTED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@HCBF@WSANOTINITIALISED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@BOGL@?$CIzwinsock?$CJ?5WinSock?5error?5Func?5?$DN?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@BAAC@?$CIzwinsock?$CJ?5Unknown?5WinSock?5error@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@CEPC@?$CIzwinsock?$CJ?5zNetSend?5?9?9?5uLth?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@ENDI@?$CIzwinsock?$CJ?5Total?5bytes?5received?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CF@GOKI@?$CIzwinsock?$CJ?5Sending?5buffer?5of?5len@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@BHID@?$CIzwinsock?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@EAKH@?$CIzwinsock?$CJ?5send?5?9?9?5Error?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PJAD@send?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@PJII@?$CIzwinsock?$CJ?5Bytes?5sent?5for?5send?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CO@LLBN@?$CIzwinsock?$CJ?5Sending?5incoming?5buff@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@ILFB@?$CIzwinsock?$CJ?5Adding?5bytes?5to?5send?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@JAKC@?$CIzwinsock?$CJ?5zNetReceive?5?9?9?5uLth?5?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@PABN@?$CIzwinsock?$CJ?5Flushing?5send?5buffer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@MHKI@?$CIzwinsock?$CJ?5Total?5bytes?5sent?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@CFAO@?$CIzwinsock?$CJ?5Trying?5to?5consolidate@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@EBL@?$CIzwinsock?$CJ?5Allocating?5bigger?5buf@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@MNOP@Out?5of?5memory?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NJFL@recv?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DB@EPNP@?$CIzwinsock?$CJ?5Error?5trying?5to?5exten@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@CDMN@?$CIzwinsock?$CJ?5Bytes?5read?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@LKJJ@?$CIzwinsock?$CJ?5Tracing?5buffer?5?4?4?4?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DB@HDJN@?$CIzwinsock?$CJ?5Buffer?5still?5doens?8t?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PDEL@ApplPort?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IGEO@?$FLzWinSock?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06KDPK@socket?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@HGG@socket?$CI?$CJ?5failed?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LOFA@ioctlsocket?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@LEIK@ioctlsocket?$CI?$CJ?5failed?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@BHE@?$CFs?5took?5?$CFlf?5seconds?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@JKFE@?$CIzWinSock?$CJ?5WARNING?5gethostbyname@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@BLIP@gethostbyname?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0HH@CDEA@Couldn?8t?5resolve?5network?5address@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@ELKH@?$CIzWinSock?$CJ?5WARNING?5connect?$CI?$CJ?5for@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07DHIJ@connect?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0IE@JLHI@Connection?5to?5server?5?8?$CFs?8?5failed@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GPBK@zWinSock?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@POCG@?$CIzwinsock?$CJ?5Connection?5to?5server?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@BGOH@closesocket?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@BIOA@SyncServerAccess?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@ODND@WINSOCK_WORKAROUND?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LFCK@?2?2Zeidon?5System?2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@JPKP@?$CIzwinsock?$CJ?5A?5message?5has?5been?5re@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DNJN@ListenPort?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04FBJP@bind?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@PGKE@bind?$CI?$CJ?5failed?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IODP@listen?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@IPOC@listen?$CI?$CJ?5failed?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@KLFH@?$CIzWinSock?$CJ?5Waiting?5for?5client?5co@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@DDGE@fnListenThreadProc?5trying?5to?5clo@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JGM@accept?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@JNNA@accept?$CIsock?$CJ?5failed?5for?5listen?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@GKON@?$CIzwinsock?$CJ?5Stopping?5listen?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@LIOO@?$CIzwinsock?$CJ?5No?5Listen?5socket?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@ENIM@?$CIzwinsock?$CJ?5Error?5shutting?5down?5l@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DH@IIDH@NetStopListen?5wait?5for?5socket?5to@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@BAFL@?$CIzwinsock?$CJ?5Listen?5stopped?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@OIJA@?$CIzwinsock?$CJ?5Getting?5local?5host?5ad@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@PJMM@getpeername?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@GJMF@getpeername?$CI?$CJ?5failed?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@IOIG@gethostbyaddr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@BEDG@gethostbyaddr?$CI?$CJ?5failed?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@GPA@?$CIzwinsock?$CJ?5Local?5host?5address?5?$DN?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@JNBC@Error?5loading?5starting?5WinSock?3?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@KNMK@?$CIzwinsock?$CJ?5WinSock?5Version?5?5?5?5?5?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@GEAN@?$CIzwinsock?$CJ?5WinSock?5HighVersion?5?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@KOGD@?$CIzwinsock?$CJ?5WinSock?5Description?5?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@OHKN@?$CIzwinsock?$CJ?5System?5status?5?5?5?5?5?5?5?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@BDKG@?$CIzwinsock?$CJ?5Max?5sockets?5?5?5?5?5?5?5?5?5?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@NMMM@?$CIzwinsock?$CJ?5Max?5UPD?5datagram?5?5?5?5?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@PEIO@Out?5of?5memory?5starting?5network?5?8@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@EMAI@?$CIzwinsock?$CJ?5Shutting?5down?5network@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08LFLP@KZFXFERO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NHNM@APP_NAME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LKKI@APPLICATION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FCJM@ApplicationName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GHPH@APP_ADOBIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FDHG@?$CK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OJFH@File?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NJLM@FileName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@DKAG@?$CFd?$CF02d?$CF02d?$CF02d?$CF02d?$CF02d?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07LNLK@ModDate?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08INFO@FileSize?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HLLH@ZEIDON?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IIHF@ZEIDON?4APP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IHGG@KZAPPLOO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@EELN@Error?3?5Couldn?8t?5find?5application@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@KHCK@Application?5Update?5Error?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@GEOD@MaxTotalFileSize?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@PKND@Performing?5Application?5Update?5fo@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@DMEC@_ExecutableSourceList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PCJP@Y?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MIME@Updated?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EGOH@Data?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@BKKK@ReturnValue?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GMMJ@Operation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@FJNC@SourceServer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@ECNA@Performing?5application?5update?5fo@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03BPPE@NpV?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@OJBC@CompareFiles?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CO@HHPG@?$DN?$DN?$DN?$DN?$DN?5Files?5that?5being?5downloade@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IOMJ@FileName?3?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?szlErrorTitle@@3PADA				; szlErrorTitle
PUBLIC	?g_hListenThread@@3KA				; g_hListenThread
PUBLIC	?g_dwListenThreadID@@3IA			; g_dwListenThreadID
PUBLIC	?g_bListenThreadStarted@@3EA			; g_bListenThreadStarted
PUBLIC	?g_bClosingListenSocket@@3EA			; g_bClosingListenSocket
PUBLIC	_g_nApplPort
PUBLIC	_g_nListenPort
_BSS	SEGMENT
?g_hListenThread@@3KA DD 01H DUP (?)			; g_hListenThread
?g_dwListenThreadID@@3IA DD 01H DUP (?)			; g_dwListenThreadID
?g_bListenThreadStarted@@3EA DB 01H DUP (?)		; g_bListenThreadStarted
	ALIGN	4

?g_bClosingListenSocket@@3EA DB 01H DUP (?)		; g_bClosingListenSocket
	ALIGN	4

_?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA DD 01H DUP (?)
_?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA DD 01H DUP (?)
_?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?szlErrorTitle@@3PADA DB 'zWinSock Error', 00H		; szlErrorTitle
	ORG $+1
_g_nApplPort DW	0ffffH
_g_nListenPort DW 0ffffH
_DATA	ENDS
PUBLIC	?fnShowError@@YAXPAD@Z				; fnShowError
PUBLIC	??_C@_08PLFD@WSAEINTR?$AA@			; `string'
PUBLIC	??_C@_08PJGE@WSAEBADF?$AA@			; `string'
PUBLIC	??_C@_09HMKF@WSAEACCES?$AA@			; `string'
PUBLIC	??_C@_09GNPN@WSAEFAULT?$AA@			; `string'
PUBLIC	??_C@_09COKE@WSAEINVAL?$AA@			; `string'
PUBLIC	??_C@_09IMGE@WSAEMFILE?$AA@			; `string'
PUBLIC	??_C@_0P@HEMP@WSAEWOULDBLOCK?$AA@		; `string'
PUBLIC	??_C@_0P@DGNH@WSAEINPROGRESS?$AA@		; `string'
PUBLIC	??_C@_0M@FDKM@WSAEALREADY?$AA@			; `string'
PUBLIC	??_C@_0M@PLNC@WSAENOTSOCK?$AA@			; `string'
PUBLIC	??_C@_0BA@LDNB@WSAEDESTADDRREQ?$AA@		; `string'
PUBLIC	??_C@_0M@EFDP@WSAEMSGSIZE?$AA@			; `string'
PUBLIC	??_C@_0O@MMIF@WSAEPROTOTYPE?$AA@		; `string'
PUBLIC	??_C@_0P@CMMD@WSAENOPROTOOPT?$AA@		; `string'
PUBLIC	??_C@_0BD@NNFA@WSAEPROTONOSUPPORT?$AA@		; `string'
PUBLIC	??_C@_0BD@BHGL@WSAESOCKTNOSUPPORT?$AA@		; `string'
PUBLIC	??_C@_0O@CKGP@WSAEOPNOTSUPP?$AA@		; `string'
PUBLIC	??_C@_0BA@NEAC@WSAEPFNOSUPPORT?$AA@		; `string'
PUBLIC	??_C@_0BA@JGHB@WSAEAFNOSUPPORT?$AA@		; `string'
PUBLIC	??_C@_0O@HEEI@WSAEADDRINUSE?$AA@		; `string'
PUBLIC	??_C@_0BB@CAPK@WSAEADDRNOTAVAIL?$AA@		; `string'
PUBLIC	??_C@_0M@OCME@WSAENETDOWN?$AA@			; `string'
PUBLIC	??_C@_0P@BMAL@WSAENETUNREACH?$AA@		; `string'
PUBLIC	??_C@_0N@KFEB@WSAENETRESET?$AA@			; `string'
PUBLIC	??_C@_0BA@DAMK@WSAECONNABORTED?$AA@		; `string'
PUBLIC	??_C@_0O@LFGK@WSAECONNRESET?$AA@		; `string'
PUBLIC	??_C@_0L@HPDK@WSAENOBUFS?$AA@			; `string'
PUBLIC	??_C@_0L@GMEH@WSAEISCONN?$AA@			; `string'
PUBLIC	??_C@_0M@FHGM@WSAENOTCONN?$AA@			; `string'
PUBLIC	??_C@_0N@IIJE@WSAESHUTDOWN?$AA@			; `string'
PUBLIC	??_C@_0BA@JKLP@WSAETOOMANYREFS?$AA@		; `string'
PUBLIC	??_C@_0N@IOAI@WSAETIMEDOUT?$AA@			; `string'
PUBLIC	??_C@_0BA@KHJO@WSAECONNREFUSED?$AA@		; `string'
PUBLIC	??_C@_08KIHD@WSAELOOP?$AA@			; `string'
PUBLIC	??_C@_0BA@CAFH@WSAENAMETOOLONG?$AA@		; `string'
PUBLIC	??_C@_0N@CHFC@WSAEHOSTDOWN?$AA@			; `string'
PUBLIC	??_C@_0BA@GDKP@WSAEHOSTUNREACH?$AA@		; `string'
PUBLIC	??_C@_0N@BKLD@WSAENOTEMPTY?$AA@			; `string'
PUBLIC	??_C@_0M@JCAC@WSAEPROCLIM?$AA@			; `string'
PUBLIC	??_C@_09EMMP@WSAEUSERS?$AA@			; `string'
PUBLIC	??_C@_09EDGJ@WSAEDQUOT?$AA@			; `string'
PUBLIC	??_C@_09MAPE@WSAESTALE?$AA@			; `string'
PUBLIC	??_C@_0L@ELPL@WSAEREMOTE?$AA@			; `string'
PUBLIC	??_C@_0P@BMGD@WSASYSNOTREADY?$AA@		; `string'
PUBLIC	??_C@_0BD@PKID@WSAVERNOTSUPPORTED?$AA@		; `string'
PUBLIC	??_C@_0BC@HCBF@WSANOTINITIALISED?$AA@		; `string'
PUBLIC	??_C@_0CL@BOGL@?$CIzwinsock?$CJ?5WinSock?5error?5Func?5?$DN?5@ ; `string'
PUBLIC	??_C@_0DA@BAAC@?$CIzwinsock?$CJ?5Unknown?5WinSock?5error@ ; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
EXTRN	_TraceLineS@8:NEAR
EXTRN	__imp__wsprintfA:NEAR
EXTRN	_WSAGetLastError@0:NEAR
;	COMDAT ??_C@_00A@?$AA@
; File c:\10c\w\oe\ZWINSOCK.CPP
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??_C@_08PLFD@WSAEINTR?$AA@
_DATA	SEGMENT
??_C@_08PLFD@WSAEINTR?$AA@ DB 'WSAEINTR', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08PJGE@WSAEBADF?$AA@
_DATA	SEGMENT
??_C@_08PJGE@WSAEBADF?$AA@ DB 'WSAEBADF', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09HMKF@WSAEACCES?$AA@
_DATA	SEGMENT
??_C@_09HMKF@WSAEACCES?$AA@ DB 'WSAEACCES', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GNPN@WSAEFAULT?$AA@
_DATA	SEGMENT
??_C@_09GNPN@WSAEFAULT?$AA@ DB 'WSAEFAULT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09COKE@WSAEINVAL?$AA@
_DATA	SEGMENT
??_C@_09COKE@WSAEINVAL?$AA@ DB 'WSAEINVAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09IMGE@WSAEMFILE?$AA@
_DATA	SEGMENT
??_C@_09IMGE@WSAEMFILE?$AA@ DB 'WSAEMFILE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@HEMP@WSAEWOULDBLOCK?$AA@
_DATA	SEGMENT
??_C@_0P@HEMP@WSAEWOULDBLOCK?$AA@ DB 'WSAEWOULDBLOCK', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@DGNH@WSAEINPROGRESS?$AA@
_DATA	SEGMENT
??_C@_0P@DGNH@WSAEINPROGRESS?$AA@ DB 'WSAEINPROGRESS', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@FDKM@WSAEALREADY?$AA@
_DATA	SEGMENT
??_C@_0M@FDKM@WSAEALREADY?$AA@ DB 'WSAEALREADY', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@PLNC@WSAENOTSOCK?$AA@
_DATA	SEGMENT
??_C@_0M@PLNC@WSAENOTSOCK?$AA@ DB 'WSAENOTSOCK', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@LDNB@WSAEDESTADDRREQ?$AA@
_DATA	SEGMENT
??_C@_0BA@LDNB@WSAEDESTADDRREQ?$AA@ DB 'WSAEDESTADDRREQ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@EFDP@WSAEMSGSIZE?$AA@
_DATA	SEGMENT
??_C@_0M@EFDP@WSAEMSGSIZE?$AA@ DB 'WSAEMSGSIZE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@MMIF@WSAEPROTOTYPE?$AA@
_DATA	SEGMENT
??_C@_0O@MMIF@WSAEPROTOTYPE?$AA@ DB 'WSAEPROTOTYPE', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@CMMD@WSAENOPROTOOPT?$AA@
_DATA	SEGMENT
??_C@_0P@CMMD@WSAENOPROTOOPT?$AA@ DB 'WSAENOPROTOOPT', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@NNFA@WSAEPROTONOSUPPORT?$AA@
_DATA	SEGMENT
??_C@_0BD@NNFA@WSAEPROTONOSUPPORT?$AA@ DB 'WSAEPROTONOSUPPORT', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@BHGL@WSAESOCKTNOSUPPORT?$AA@
_DATA	SEGMENT
??_C@_0BD@BHGL@WSAESOCKTNOSUPPORT?$AA@ DB 'WSAESOCKTNOSUPPORT', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@CKGP@WSAEOPNOTSUPP?$AA@
_DATA	SEGMENT
??_C@_0O@CKGP@WSAEOPNOTSUPP?$AA@ DB 'WSAEOPNOTSUPP', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@NEAC@WSAEPFNOSUPPORT?$AA@
_DATA	SEGMENT
??_C@_0BA@NEAC@WSAEPFNOSUPPORT?$AA@ DB 'WSAEPFNOSUPPORT', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JGHB@WSAEAFNOSUPPORT?$AA@
_DATA	SEGMENT
??_C@_0BA@JGHB@WSAEAFNOSUPPORT?$AA@ DB 'WSAEAFNOSUPPORT', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@HEEI@WSAEADDRINUSE?$AA@
_DATA	SEGMENT
??_C@_0O@HEEI@WSAEADDRINUSE?$AA@ DB 'WSAEADDRINUSE', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CAPK@WSAEADDRNOTAVAIL?$AA@
_DATA	SEGMENT
??_C@_0BB@CAPK@WSAEADDRNOTAVAIL?$AA@ DB 'WSAEADDRNOTAVAIL', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@OCME@WSAENETDOWN?$AA@
_DATA	SEGMENT
??_C@_0M@OCME@WSAENETDOWN?$AA@ DB 'WSAENETDOWN', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@BMAL@WSAENETUNREACH?$AA@
_DATA	SEGMENT
??_C@_0P@BMAL@WSAENETUNREACH?$AA@ DB 'WSAENETUNREACH', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@KFEB@WSAENETRESET?$AA@
_DATA	SEGMENT
??_C@_0N@KFEB@WSAENETRESET?$AA@ DB 'WSAENETRESET', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@DAMK@WSAECONNABORTED?$AA@
_DATA	SEGMENT
??_C@_0BA@DAMK@WSAECONNABORTED?$AA@ DB 'WSAECONNABORTED', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@LFGK@WSAECONNRESET?$AA@
_DATA	SEGMENT
??_C@_0O@LFGK@WSAECONNRESET?$AA@ DB 'WSAECONNRESET', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@HPDK@WSAENOBUFS?$AA@
_DATA	SEGMENT
??_C@_0L@HPDK@WSAENOBUFS?$AA@ DB 'WSAENOBUFS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GMEH@WSAEISCONN?$AA@
_DATA	SEGMENT
??_C@_0L@GMEH@WSAEISCONN?$AA@ DB 'WSAEISCONN', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@FHGM@WSAENOTCONN?$AA@
_DATA	SEGMENT
??_C@_0M@FHGM@WSAENOTCONN?$AA@ DB 'WSAENOTCONN', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@IIJE@WSAESHUTDOWN?$AA@
_DATA	SEGMENT
??_C@_0N@IIJE@WSAESHUTDOWN?$AA@ DB 'WSAESHUTDOWN', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JKLP@WSAETOOMANYREFS?$AA@
_DATA	SEGMENT
??_C@_0BA@JKLP@WSAETOOMANYREFS?$AA@ DB 'WSAETOOMANYREFS', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@IOAI@WSAETIMEDOUT?$AA@
_DATA	SEGMENT
??_C@_0N@IOAI@WSAETIMEDOUT?$AA@ DB 'WSAETIMEDOUT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@KHJO@WSAECONNREFUSED?$AA@
_DATA	SEGMENT
??_C@_0BA@KHJO@WSAECONNREFUSED?$AA@ DB 'WSAECONNREFUSED', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08KIHD@WSAELOOP?$AA@
_DATA	SEGMENT
??_C@_08KIHD@WSAELOOP?$AA@ DB 'WSAELOOP', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CAFH@WSAENAMETOOLONG?$AA@
_DATA	SEGMENT
??_C@_0BA@CAFH@WSAENAMETOOLONG?$AA@ DB 'WSAENAMETOOLONG', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@CHFC@WSAEHOSTDOWN?$AA@
_DATA	SEGMENT
??_C@_0N@CHFC@WSAEHOSTDOWN?$AA@ DB 'WSAEHOSTDOWN', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GDKP@WSAEHOSTUNREACH?$AA@
_DATA	SEGMENT
??_C@_0BA@GDKP@WSAEHOSTUNREACH?$AA@ DB 'WSAEHOSTUNREACH', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@BKLD@WSAENOTEMPTY?$AA@
_DATA	SEGMENT
??_C@_0N@BKLD@WSAENOTEMPTY?$AA@ DB 'WSAENOTEMPTY', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@JCAC@WSAEPROCLIM?$AA@
_DATA	SEGMENT
??_C@_0M@JCAC@WSAEPROCLIM?$AA@ DB 'WSAEPROCLIM', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09EMMP@WSAEUSERS?$AA@
_DATA	SEGMENT
??_C@_09EMMP@WSAEUSERS?$AA@ DB 'WSAEUSERS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09EDGJ@WSAEDQUOT?$AA@
_DATA	SEGMENT
??_C@_09EDGJ@WSAEDQUOT?$AA@ DB 'WSAEDQUOT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09MAPE@WSAESTALE?$AA@
_DATA	SEGMENT
??_C@_09MAPE@WSAESTALE?$AA@ DB 'WSAESTALE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@ELPL@WSAEREMOTE?$AA@
_DATA	SEGMENT
??_C@_0L@ELPL@WSAEREMOTE?$AA@ DB 'WSAEREMOTE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@BMGD@WSASYSNOTREADY?$AA@
_DATA	SEGMENT
??_C@_0P@BMGD@WSASYSNOTREADY?$AA@ DB 'WSASYSNOTREADY', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@PKID@WSAVERNOTSUPPORTED?$AA@
_DATA	SEGMENT
??_C@_0BD@PKID@WSAVERNOTSUPPORTED?$AA@ DB 'WSAVERNOTSUPPORTED', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@HCBF@WSANOTINITIALISED?$AA@
_DATA	SEGMENT
??_C@_0BC@HCBF@WSANOTINITIALISED?$AA@ DB 'WSANOTINITIALISED', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@BOGL@?$CIzwinsock?$CJ?5WinSock?5error?5Func?5?$DN?5@
_DATA	SEGMENT
??_C@_0CL@BOGL@?$CIzwinsock?$CJ?5WinSock?5error?5Func?5?$DN?5@ DB '(zwins'
	DB	'ock) WinSock error Func = %s   %s %d', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DA@BAAC@?$CIzwinsock?$CJ?5Unknown?5WinSock?5error@
_DATA	SEGMENT
??_C@_0DA@BAAC@?$CIzwinsock?$CJ?5Unknown?5WinSock?5error@ DB '(zwinsock) '
	DB	'Unknown WinSock error Func = %s   %d', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchFuncName$ = 8
_szMsg$ = -404
_nErr$ = -4
_k$ = -408
_gErrMsgs$ = -784
?fnShowError@@YAXPAD@Z PROC NEAR			; fnShowError

; 196  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 784				; 00000310H

; 197  :    char   szMsg[ 400 ];
; 198  :    int    nErr = WSAGetLastError( );

	call	_WSAGetLastError@0
	mov	DWORD PTR _nErr$[ebp], eax

; 199  :    int    k;
; 200  : 
; 201  :    struct ErrorMessageStruct gErrMsgs[] =
; 202  :    {
; 203  :       WSAEINTR,              "WSAEINTR",

	mov	DWORD PTR _gErrMsgs$[ebp], 10004	; 00002714H
	mov	DWORD PTR _gErrMsgs$[ebp+4], OFFSET FLAT:??_C@_08PLFD@WSAEINTR?$AA@ ; `string'

; 204  :       WSAEBADF,              "WSAEBADF",

	mov	DWORD PTR _gErrMsgs$[ebp+8], 10009	; 00002719H
	mov	DWORD PTR _gErrMsgs$[ebp+12], OFFSET FLAT:??_C@_08PJGE@WSAEBADF?$AA@ ; `string'

; 205  :       WSAEACCES,             "WSAEACCES",

	mov	DWORD PTR _gErrMsgs$[ebp+16], 10013	; 0000271dH
	mov	DWORD PTR _gErrMsgs$[ebp+20], OFFSET FLAT:??_C@_09HMKF@WSAEACCES?$AA@ ; `string'

; 206  :       WSAEFAULT,             "WSAEFAULT",

	mov	DWORD PTR _gErrMsgs$[ebp+24], 10014	; 0000271eH
	mov	DWORD PTR _gErrMsgs$[ebp+28], OFFSET FLAT:??_C@_09GNPN@WSAEFAULT?$AA@ ; `string'

; 207  :       WSAEINVAL,             "WSAEINVAL",

	mov	DWORD PTR _gErrMsgs$[ebp+32], 10022	; 00002726H
	mov	DWORD PTR _gErrMsgs$[ebp+36], OFFSET FLAT:??_C@_09COKE@WSAEINVAL?$AA@ ; `string'

; 208  :       WSAEMFILE,             "WSAEMFILE",

	mov	DWORD PTR _gErrMsgs$[ebp+40], 10024	; 00002728H
	mov	DWORD PTR _gErrMsgs$[ebp+44], OFFSET FLAT:??_C@_09IMGE@WSAEMFILE?$AA@ ; `string'

; 209  :       WSAEWOULDBLOCK,        "WSAEWOULDBLOCK",

	mov	DWORD PTR _gErrMsgs$[ebp+48], 10035	; 00002733H
	mov	DWORD PTR _gErrMsgs$[ebp+52], OFFSET FLAT:??_C@_0P@HEMP@WSAEWOULDBLOCK?$AA@ ; `string'

; 210  :       WSAEINPROGRESS,        "WSAEINPROGRESS",

	mov	DWORD PTR _gErrMsgs$[ebp+56], 10036	; 00002734H
	mov	DWORD PTR _gErrMsgs$[ebp+60], OFFSET FLAT:??_C@_0P@DGNH@WSAEINPROGRESS?$AA@ ; `string'

; 211  :       WSAEALREADY,           "WSAEALREADY",

	mov	DWORD PTR _gErrMsgs$[ebp+64], 10037	; 00002735H
	mov	DWORD PTR _gErrMsgs$[ebp+68], OFFSET FLAT:??_C@_0M@FDKM@WSAEALREADY?$AA@ ; `string'

; 212  :       WSAENOTSOCK,           "WSAENOTSOCK",

	mov	DWORD PTR _gErrMsgs$[ebp+72], 10038	; 00002736H
	mov	DWORD PTR _gErrMsgs$[ebp+76], OFFSET FLAT:??_C@_0M@PLNC@WSAENOTSOCK?$AA@ ; `string'

; 213  :       WSAEDESTADDRREQ,       "WSAEDESTADDRREQ",

	mov	DWORD PTR _gErrMsgs$[ebp+80], 10039	; 00002737H
	mov	DWORD PTR _gErrMsgs$[ebp+84], OFFSET FLAT:??_C@_0BA@LDNB@WSAEDESTADDRREQ?$AA@ ; `string'

; 214  :       WSAEMSGSIZE,           "WSAEMSGSIZE",

	mov	DWORD PTR _gErrMsgs$[ebp+88], 10040	; 00002738H
	mov	DWORD PTR _gErrMsgs$[ebp+92], OFFSET FLAT:??_C@_0M@EFDP@WSAEMSGSIZE?$AA@ ; `string'

; 215  :       WSAEPROTOTYPE,         "WSAEPROTOTYPE",

	mov	DWORD PTR _gErrMsgs$[ebp+96], 10041	; 00002739H
	mov	DWORD PTR _gErrMsgs$[ebp+100], OFFSET FLAT:??_C@_0O@MMIF@WSAEPROTOTYPE?$AA@ ; `string'

; 216  :       WSAENOPROTOOPT,        "WSAENOPROTOOPT",

	mov	DWORD PTR _gErrMsgs$[ebp+104], 10042	; 0000273aH
	mov	DWORD PTR _gErrMsgs$[ebp+108], OFFSET FLAT:??_C@_0P@CMMD@WSAENOPROTOOPT?$AA@ ; `string'

; 217  :       WSAEPROTONOSUPPORT,    "WSAEPROTONOSUPPORT",

	mov	DWORD PTR _gErrMsgs$[ebp+112], 10043	; 0000273bH
	mov	DWORD PTR _gErrMsgs$[ebp+116], OFFSET FLAT:??_C@_0BD@NNFA@WSAEPROTONOSUPPORT?$AA@ ; `string'

; 218  :       WSAESOCKTNOSUPPORT,    "WSAESOCKTNOSUPPORT",

	mov	DWORD PTR _gErrMsgs$[ebp+120], 10044	; 0000273cH
	mov	DWORD PTR _gErrMsgs$[ebp+124], OFFSET FLAT:??_C@_0BD@BHGL@WSAESOCKTNOSUPPORT?$AA@ ; `string'

; 219  :       WSAEOPNOTSUPP,         "WSAEOPNOTSUPP",

	mov	DWORD PTR _gErrMsgs$[ebp+128], 10045	; 0000273dH
	mov	DWORD PTR _gErrMsgs$[ebp+132], OFFSET FLAT:??_C@_0O@CKGP@WSAEOPNOTSUPP?$AA@ ; `string'

; 220  :       WSAEPFNOSUPPORT,       "WSAEPFNOSUPPORT",

	mov	DWORD PTR _gErrMsgs$[ebp+136], 10046	; 0000273eH
	mov	DWORD PTR _gErrMsgs$[ebp+140], OFFSET FLAT:??_C@_0BA@NEAC@WSAEPFNOSUPPORT?$AA@ ; `string'

; 221  :       WSAEAFNOSUPPORT,       "WSAEAFNOSUPPORT",

	mov	DWORD PTR _gErrMsgs$[ebp+144], 10047	; 0000273fH
	mov	DWORD PTR _gErrMsgs$[ebp+148], OFFSET FLAT:??_C@_0BA@JGHB@WSAEAFNOSUPPORT?$AA@ ; `string'

; 222  :       WSAEADDRINUSE,         "WSAEADDRINUSE",

	mov	DWORD PTR _gErrMsgs$[ebp+152], 10048	; 00002740H
	mov	DWORD PTR _gErrMsgs$[ebp+156], OFFSET FLAT:??_C@_0O@HEEI@WSAEADDRINUSE?$AA@ ; `string'

; 223  :       WSAEADDRNOTAVAIL,      "WSAEADDRNOTAVAIL",

	mov	DWORD PTR _gErrMsgs$[ebp+160], 10049	; 00002741H
	mov	DWORD PTR _gErrMsgs$[ebp+164], OFFSET FLAT:??_C@_0BB@CAPK@WSAEADDRNOTAVAIL?$AA@ ; `string'

; 224  :       WSAENETDOWN,           "WSAENETDOWN",

	mov	DWORD PTR _gErrMsgs$[ebp+168], 10050	; 00002742H
	mov	DWORD PTR _gErrMsgs$[ebp+172], OFFSET FLAT:??_C@_0M@OCME@WSAENETDOWN?$AA@ ; `string'

; 225  :       WSAENETUNREACH,        "WSAENETUNREACH",

	mov	DWORD PTR _gErrMsgs$[ebp+176], 10051	; 00002743H
	mov	DWORD PTR _gErrMsgs$[ebp+180], OFFSET FLAT:??_C@_0P@BMAL@WSAENETUNREACH?$AA@ ; `string'

; 226  :       WSAENETRESET,          "WSAENETRESET",

	mov	DWORD PTR _gErrMsgs$[ebp+184], 10052	; 00002744H
	mov	DWORD PTR _gErrMsgs$[ebp+188], OFFSET FLAT:??_C@_0N@KFEB@WSAENETRESET?$AA@ ; `string'

; 227  :       WSAECONNABORTED,       "WSAECONNABORTED",

	mov	DWORD PTR _gErrMsgs$[ebp+192], 10053	; 00002745H
	mov	DWORD PTR _gErrMsgs$[ebp+196], OFFSET FLAT:??_C@_0BA@DAMK@WSAECONNABORTED?$AA@ ; `string'

; 228  :       WSAECONNRESET,         "WSAECONNRESET",

	mov	DWORD PTR _gErrMsgs$[ebp+200], 10054	; 00002746H
	mov	DWORD PTR _gErrMsgs$[ebp+204], OFFSET FLAT:??_C@_0O@LFGK@WSAECONNRESET?$AA@ ; `string'

; 229  :       WSAENOBUFS,            "WSAENOBUFS",

	mov	DWORD PTR _gErrMsgs$[ebp+208], 10055	; 00002747H
	mov	DWORD PTR _gErrMsgs$[ebp+212], OFFSET FLAT:??_C@_0L@HPDK@WSAENOBUFS?$AA@ ; `string'

; 230  :       WSAEISCONN,            "WSAEISCONN",

	mov	DWORD PTR _gErrMsgs$[ebp+216], 10056	; 00002748H
	mov	DWORD PTR _gErrMsgs$[ebp+220], OFFSET FLAT:??_C@_0L@GMEH@WSAEISCONN?$AA@ ; `string'

; 231  :       WSAENOTCONN,           "WSAENOTCONN",

	mov	DWORD PTR _gErrMsgs$[ebp+224], 10057	; 00002749H
	mov	DWORD PTR _gErrMsgs$[ebp+228], OFFSET FLAT:??_C@_0M@FHGM@WSAENOTCONN?$AA@ ; `string'

; 232  :       WSAESHUTDOWN,          "WSAESHUTDOWN",

	mov	DWORD PTR _gErrMsgs$[ebp+232], 10058	; 0000274aH
	mov	DWORD PTR _gErrMsgs$[ebp+236], OFFSET FLAT:??_C@_0N@IIJE@WSAESHUTDOWN?$AA@ ; `string'

; 233  :       WSAETOOMANYREFS,       "WSAETOOMANYREFS",

	mov	DWORD PTR _gErrMsgs$[ebp+240], 10059	; 0000274bH
	mov	DWORD PTR _gErrMsgs$[ebp+244], OFFSET FLAT:??_C@_0BA@JKLP@WSAETOOMANYREFS?$AA@ ; `string'

; 234  :       WSAETIMEDOUT,          "WSAETIMEDOUT",

	mov	DWORD PTR _gErrMsgs$[ebp+248], 10060	; 0000274cH
	mov	DWORD PTR _gErrMsgs$[ebp+252], OFFSET FLAT:??_C@_0N@IOAI@WSAETIMEDOUT?$AA@ ; `string'

; 235  :       WSAECONNREFUSED,       "WSAECONNREFUSED",

	mov	DWORD PTR _gErrMsgs$[ebp+256], 10061	; 0000274dH
	mov	DWORD PTR _gErrMsgs$[ebp+260], OFFSET FLAT:??_C@_0BA@KHJO@WSAECONNREFUSED?$AA@ ; `string'

; 236  :       WSAELOOP,              "WSAELOOP",

	mov	DWORD PTR _gErrMsgs$[ebp+264], 10062	; 0000274eH
	mov	DWORD PTR _gErrMsgs$[ebp+268], OFFSET FLAT:??_C@_08KIHD@WSAELOOP?$AA@ ; `string'

; 237  :       WSAENAMETOOLONG,       "WSAENAMETOOLONG",

	mov	DWORD PTR _gErrMsgs$[ebp+272], 10063	; 0000274fH
	mov	DWORD PTR _gErrMsgs$[ebp+276], OFFSET FLAT:??_C@_0BA@CAFH@WSAENAMETOOLONG?$AA@ ; `string'

; 238  :       WSAEHOSTDOWN,          "WSAEHOSTDOWN",

	mov	DWORD PTR _gErrMsgs$[ebp+280], 10064	; 00002750H
	mov	DWORD PTR _gErrMsgs$[ebp+284], OFFSET FLAT:??_C@_0N@CHFC@WSAEHOSTDOWN?$AA@ ; `string'

; 239  :       WSAEHOSTUNREACH,       "WSAEHOSTUNREACH",

	mov	DWORD PTR _gErrMsgs$[ebp+288], 10065	; 00002751H
	mov	DWORD PTR _gErrMsgs$[ebp+292], OFFSET FLAT:??_C@_0BA@GDKP@WSAEHOSTUNREACH?$AA@ ; `string'

; 240  :       WSAENOTEMPTY,          "WSAENOTEMPTY",

	mov	DWORD PTR _gErrMsgs$[ebp+296], 10066	; 00002752H
	mov	DWORD PTR _gErrMsgs$[ebp+300], OFFSET FLAT:??_C@_0N@BKLD@WSAENOTEMPTY?$AA@ ; `string'

; 241  :       WSAEPROCLIM,           "WSAEPROCLIM",

	mov	DWORD PTR _gErrMsgs$[ebp+304], 10067	; 00002753H
	mov	DWORD PTR _gErrMsgs$[ebp+308], OFFSET FLAT:??_C@_0M@JCAC@WSAEPROCLIM?$AA@ ; `string'

; 242  :       WSAEUSERS,             "WSAEUSERS",

	mov	DWORD PTR _gErrMsgs$[ebp+312], 10068	; 00002754H
	mov	DWORD PTR _gErrMsgs$[ebp+316], OFFSET FLAT:??_C@_09EMMP@WSAEUSERS?$AA@ ; `string'

; 243  :       WSAEDQUOT,             "WSAEDQUOT",

	mov	DWORD PTR _gErrMsgs$[ebp+320], 10069	; 00002755H
	mov	DWORD PTR _gErrMsgs$[ebp+324], OFFSET FLAT:??_C@_09EDGJ@WSAEDQUOT?$AA@ ; `string'

; 244  :       WSAESTALE,             "WSAESTALE",

	mov	DWORD PTR _gErrMsgs$[ebp+328], 10070	; 00002756H
	mov	DWORD PTR _gErrMsgs$[ebp+332], OFFSET FLAT:??_C@_09MAPE@WSAESTALE?$AA@ ; `string'

; 245  :       WSAEREMOTE,            "WSAEREMOTE",

	mov	DWORD PTR _gErrMsgs$[ebp+336], 10071	; 00002757H
	mov	DWORD PTR _gErrMsgs$[ebp+340], OFFSET FLAT:??_C@_0L@ELPL@WSAEREMOTE?$AA@ ; `string'

; 246  :       WSASYSNOTREADY,        "WSASYSNOTREADY",

	mov	DWORD PTR _gErrMsgs$[ebp+344], 10091	; 0000276bH
	mov	DWORD PTR _gErrMsgs$[ebp+348], OFFSET FLAT:??_C@_0P@BMGD@WSASYSNOTREADY?$AA@ ; `string'

; 247  :       WSAVERNOTSUPPORTED,    "WSAVERNOTSUPPORTED",

	mov	DWORD PTR _gErrMsgs$[ebp+352], 10092	; 0000276cH
	mov	DWORD PTR _gErrMsgs$[ebp+356], OFFSET FLAT:??_C@_0BD@PKID@WSAVERNOTSUPPORTED?$AA@ ; `string'

; 248  :       WSANOTINITIALISED,     "WSANOTINITIALISED",

	mov	DWORD PTR _gErrMsgs$[ebp+360], 10093	; 0000276dH
	mov	DWORD PTR _gErrMsgs$[ebp+364], OFFSET FLAT:??_C@_0BC@HCBF@WSANOTINITIALISED?$AA@ ; `string'

; 249  :       0,                     0 };

	mov	DWORD PTR _gErrMsgs$[ebp+368], 0
	mov	DWORD PTR _gErrMsgs$[ebp+372], 0

; 250  : 
; 251  :    for ( k = 0; gErrMsgs[ k ].pchErrorMessage; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $L60625
$L60626:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$L60625:
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	DWORD PTR _gErrMsgs$[ebp+ecx*8+4], 0
	je	SHORT $L60627

; 253  :       if ( gErrMsgs[ k ].nErrorNbr == nErr )

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _gErrMsgs$[ebp+edx*8]
	cmp	eax, DWORD PTR _nErr$[ebp]
	jne	SHORT $L60628

; 254  :          break;

	jmp	SHORT $L60627
$L60628:

; 255  :    }

	jmp	SHORT $L60626
$L60627:

; 256  : 
; 257  :    if ( gErrMsgs[ k ].pchErrorMessage )

	mov	ecx, DWORD PTR _k$[ebp]
	cmp	DWORD PTR _gErrMsgs$[ebp+ecx*8+4], 0
	je	SHORT $L60629

; 259  :       wsprintf( szMsg, "(zwinsock) WinSock error Func = %s   %s %d",
; 260  :                 pchFuncName, gErrMsgs[ k ].pchErrorMessage, nErr );

	mov	edx, DWORD PTR _nErr$[ebp]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _gErrMsgs$[ebp+eax*8+4]
	push	ecx
	mov	edx, DWORD PTR _pchFuncName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CL@BOGL@?$CIzwinsock?$CJ?5WinSock?5error?5Func?5?$DN?5@ ; `string'
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 20					; 00000014H

; 262  :    else

	jmp	SHORT $L60631
$L60629:

; 264  :       wsprintf( szMsg, "(zwinsock) Unknown WinSock error Func = %s   %d",
; 265  :                 pchFuncName, nErr );

	mov	ecx, DWORD PTR _nErr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchFuncName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0DA@BAAC@?$CIzwinsock?$CJ?5Unknown?5WinSock?5error@ ; `string'
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H
$L60631:

; 267  : 
; 268  :    TraceLineS( szMsg, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_TraceLineS@8

; 269  : 
; 270  : } // fnShowError

	mov	esp, ebp
	pop	ebp
	ret	0
?fnShowError@@YAXPAD@Z ENDP				; fnShowError
_TEXT	ENDS
PUBLIC	_zNetSend@20
PUBLIC	??_C@_0BP@CEPC@?$CIzwinsock?$CJ?5zNetSend?5?9?9?5uLth?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0CD@ENDI@?$CIzwinsock?$CJ?5Total?5bytes?5received?5@ ; `string'
PUBLIC	??_C@_0CF@GOKI@?$CIzwinsock?$CJ?5Sending?5buffer?5of?5len@ ; `string'
PUBLIC	??_C@_0L@BHID@?$CIzwinsock?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BK@EAKH@?$CIzwinsock?$CJ?5send?5?9?9?5Error?$CB?$AA@ ; `string'
PUBLIC	??_C@_04PJAD@send?$AA@				; `string'
PUBLIC	??_C@_0CA@PJII@?$CIzwinsock?$CJ?5Bytes?5sent?5for?5send?5?$AA@ ; `string'
PUBLIC	??_C@_0CO@LLBN@?$CIzwinsock?$CJ?5Sending?5incoming?5buff@ ; `string'
PUBLIC	??_C@_0CH@ILFB@?$CIzwinsock?$CJ?5Adding?5bytes?5to?5send?5@ ; `string'
EXTRN	_TraceLineI@8:NEAR
EXTRN	_TraceBuffer@12:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_send@16:NEAR
;	COMDAT ??_C@_0BP@CEPC@?$CIzwinsock?$CJ?5zNetSend?5?9?9?5uLth?5?$DN?5?$AA@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_0BP@CEPC@?$CIzwinsock?$CJ?5zNetSend?5?9?9?5uLth?5?$DN?5?$AA@ DB '(z'
	DB	'winsock) zNetSend -- uLth = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@ENDI@?$CIzwinsock?$CJ?5Total?5bytes?5received?5@
_DATA	SEGMENT
??_C@_0CD@ENDI@?$CIzwinsock?$CJ?5Total?5bytes?5received?5@ DB '(zwinsock)'
	DB	' Total bytes received = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CF@GOKI@?$CIzwinsock?$CJ?5Sending?5buffer?5of?5len@
_DATA	SEGMENT
??_C@_0CF@GOKI@?$CIzwinsock?$CJ?5Sending?5buffer?5of?5len@ DB '(zwinsock)'
	DB	' Sending buffer of length ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@BHID@?$CIzwinsock?$CJ?$AA@
_DATA	SEGMENT
??_C@_0L@BHID@?$CIzwinsock?$CJ?$AA@ DB '(zwinsock)', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@EAKH@?$CIzwinsock?$CJ?5send?5?9?9?5Error?$CB?$AA@
_DATA	SEGMENT
??_C@_0BK@EAKH@?$CIzwinsock?$CJ?5send?5?9?9?5Error?$CB?$AA@ DB '(zwinsock'
	DB	') send -- Error!', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PJAD@send?$AA@
_DATA	SEGMENT
??_C@_04PJAD@send?$AA@ DB 'send', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@PJII@?$CIzwinsock?$CJ?5Bytes?5sent?5for?5send?5?$AA@
_DATA	SEGMENT
??_C@_0CA@PJII@?$CIzwinsock?$CJ?5Bytes?5sent?5for?5send?5?$AA@ DB '(zwins'
	DB	'ock) Bytes sent for send ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CO@LLBN@?$CIzwinsock?$CJ?5Sending?5incoming?5buff@
_DATA	SEGMENT
??_C@_0CO@LLBN@?$CIzwinsock?$CJ?5Sending?5incoming?5buff@ DB '(zwinsock) '
	DB	'Sending incoming buffer of length ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CH@ILFB@?$CIzwinsock?$CJ?5Adding?5bytes?5to?5send?5@
_DATA	SEGMENT
??_C@_0CH@ILFB@?$CIzwinsock?$CJ?5Adding?5bytes?5to?5send?5@ DB '(zwinsock'
	DB	') Adding bytes to send buffer', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_ppHandle$ = 8
_ppvConnPtr$ = 12
_pchBuffer$ = 16
_uLth$ = 20
_lpSockets$ = -8
_lpConn$ = -16
_iBytesToSend$ = -12
_iBytesSent$ = -4
_zNetSend@20 PROC NEAR

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 309  :    LPSOCKETS      lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 310  :    LPCONNECTION   lpConn = (LPCONNECTION) *ppvConnPtr;

	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpConn$[ebp], eax

; 311  :    int            iBytesToSend;
; 312  :    int            iBytesSent;
; 313  : 
; 314  :    if ( lpConn->nTraceLevel > 1 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	cmp	edx, 1
	jle	SHORT $L60647

; 315  :       TraceLineI( "(zwinsock) zNetSend -- uLth = ", uLth );

	mov	eax, DWORD PTR _uLth$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BP@CEPC@?$CIzwinsock?$CJ?5zNetSend?5?9?9?5uLth?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8
$L60647:

; 316  : 
; 317  :    // If the last command was a receive (as opposed to a send) then we need
; 318  :    // to reset the buffer for sending.
; 319  :    if ( lpConn->bLastReceive )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+42]
	test	edx, edx
	je	SHORT $L60649

; 321  :       if ( lpConn->nTraceLevel > 0 && lpConn->ulTotalBytes > 0 )

	mov	eax, DWORD PTR _lpConn$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	test	ecx, ecx
	jle	SHORT $L60650
	mov	edx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jbe	SHORT $L60650

; 322  :          TraceLineI( "(zwinsock) Total bytes received = ", lpConn->ulTotalBytes );

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET FLAT:??_C@_0CD@ENDI@?$CIzwinsock?$CJ?5Total?5bytes?5received?5@ ; `string'
	call	_TraceLineI@8
$L60650:

; 323  : 
; 324  :       lpConn->bLastReceive = FALSE;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	BYTE PTR [edx+42], 0

; 325  :       lpConn->pchNextByte  = lpConn->pchBuffer;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 326  :       lpConn->ulUnusedLth  = 0;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+16], 0

; 327  :       lpConn->ulTotalBytes = 0;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+24], 0
$L60649:

; 332  :         (lpConn->ulUnusedLth + uLth > lpConn->ulBufferLth) )

	cmp	DWORD PTR _pchBuffer$[ebp], 0
	jne	SHORT $L60654
	mov	edx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [edx+16], 0
	ja	SHORT $L60653
$L60654:
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _uLth$[ebp]
	mov	edx, DWORD PTR _lpConn$[ebp]
	cmp	ecx, DWORD PTR [edx+20]
	jbe	$L60652
$L60653:

; 334  :       if ( lpConn->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpConn$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	cmp	ecx, 1
	jle	SHORT $L60655

; 336  :          TraceLineI( "(zwinsock) Sending buffer of length ",
; 337  :                      lpConn->ulUnusedLth );

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET FLAT:??_C@_0CF@GOKI@?$CIzwinsock?$CJ?5Sending?5buffer?5of?5len@ ; `string'
	call	_TraceLineI@8

; 338  :          TraceBuffer( "(zwinsock)",  lpConn->pchBuffer, lpConn->ulUnusedLth );

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET FLAT:??_C@_0L@BHID@?$CIzwinsock?$CJ?$AA@ ; `string'
	call	_TraceBuffer@12
$L60655:

; 340  : 
; 341  :       iBytesToSend = (int) lpConn->ulUnusedLth;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _iBytesToSend$[ebp], eax
$L60659:

; 345  :          iBytesSent = send( lpConn->sock, lpConn->pchBuffer, iBytesToSend, 0 );

	push	0
	mov	ecx, DWORD PTR _iBytesToSend$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_send@16
	mov	DWORD PTR _iBytesSent$[ebp], eax

; 346  :          if ( iBytesSent == SOCKET_ERROR )

	cmp	DWORD PTR _iBytesSent$[ebp], -1
	jne	SHORT $L60662

; 348  :             TraceLineS( "(zwinsock) send -- Error!", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BK@EAKH@?$CIzwinsock?$CJ?5send?5?9?9?5Error?$CB?$AA@ ; `string'
	call	_TraceLineS@8

; 349  :             SHOWERROR( "send" );

	push	OFFSET FLAT:??_C@_04PJAD@send?$AA@	; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 350  :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L60640
$L60662:

; 352  : 
; 353  :          if ( lpConn->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpConn$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	cmp	ecx, 1
	jle	SHORT $L60665

; 354  :             TraceLineI( "(zwinsock) Bytes sent for send ", iBytesSent );

	mov	edx, DWORD PTR _iBytesSent$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CA@PJII@?$CIzwinsock?$CJ?5Bytes?5sent?5for?5send?5?$AA@ ; `string'
	call	_TraceLineI@8
$L60665:

; 355  : 
; 356  :          iBytesToSend -= iBytesSent;

	mov	eax, DWORD PTR _iBytesToSend$[ebp]
	sub	eax, DWORD PTR _iBytesSent$[ebp]
	mov	DWORD PTR _iBytesToSend$[ebp], eax

; 357  : 
; 358  :       } while ( iBytesToSend > 0 );

	cmp	DWORD PTR _iBytesToSend$[ebp], 0
	jg	SHORT $L60659

; 359  : 
; 360  :       lpConn->ulTotalBytes += lpConn->ulUnusedLth;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _lpConn$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 361  :       lpConn->ulUnusedLth = 0;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx+16], 0
$L60652:

; 363  : 
; 364  :    // If the incoming buffer is 0 then we only needed to flush the buffer.
; 365  :    if ( pchBuffer == 0 )

	cmp	DWORD PTR _pchBuffer$[ebp], 0
	jne	SHORT $L60667

; 366  :       return( 0 );

	xor	ax, ax
	jmp	$L60640
$L60667:

; 367  : 
; 368  :    // If the incoming buffer length is greater than the send buffer we'll just
; 369  :    // send the incoming buffer now.
; 370  :    if ( uLth > lpConn->ulBufferLth )

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR _uLth$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jbe	$L60668

; 372  :       if ( lpConn->nTraceLevel > 1 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	movsx	eax, WORD PTR [edx+40]
	cmp	eax, 1
	jle	SHORT $L60669

; 374  :          TraceLineI( "(zwinsock) Sending incoming buffer of length ", uLth );

	mov	ecx, DWORD PTR _uLth$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CO@LLBN@?$CIzwinsock?$CJ?5Sending?5incoming?5buff@ ; `string'
	call	_TraceLineI@8

; 375  :          TraceBuffer( "(zwinsock)",  pchBuffer, uLth );

	mov	edx, DWORD PTR _uLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@BHID@?$CIzwinsock?$CJ?$AA@ ; `string'
	call	_TraceBuffer@12
$L60669:

; 377  : 
; 378  :       iBytesToSend = (int) uLth;

	mov	ecx, DWORD PTR _uLth$[ebp]
	mov	DWORD PTR _iBytesToSend$[ebp], ecx
$L60672:

; 382  :          iBytesSent = send( lpConn->sock, pchBuffer, iBytesToSend, 0 );

	push	0
	mov	edx, DWORD PTR _iBytesToSend$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_send@16
	mov	DWORD PTR _iBytesSent$[ebp], eax

; 383  :          if ( iBytesSent == SOCKET_ERROR )

	cmp	DWORD PTR _iBytesSent$[ebp], -1
	jne	SHORT $L60675

; 385  :             TraceLineS( "(zwinsock) send -- Error!", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BK@EAKH@?$CIzwinsock?$CJ?5send?5?9?9?5Error?$CB?$AA@ ; `string'
	call	_TraceLineS@8

; 386  :             SHOWERROR( "send" );

	push	OFFSET FLAT:??_C@_04PJAD@send?$AA@	; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 387  :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L60640
$L60675:

; 389  : 
; 390  :          if ( lpConn->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpConn$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	cmp	ecx, 1
	jle	SHORT $L60676

; 391  :             TraceLineI( "(zwinsock) Bytes sent for send ", iBytesSent );

	mov	edx, DWORD PTR _iBytesSent$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CA@PJII@?$CIzwinsock?$CJ?5Bytes?5sent?5for?5send?5?$AA@ ; `string'
	call	_TraceLineI@8
$L60676:

; 392  : 
; 393  :          iBytesToSend -= iBytesSent;

	mov	eax, DWORD PTR _iBytesToSend$[ebp]
	sub	eax, DWORD PTR _iBytesSent$[ebp]
	mov	DWORD PTR _iBytesToSend$[ebp], eax

; 394  : 
; 395  :       } while ( iBytesToSend > 0 );

	cmp	DWORD PTR _iBytesToSend$[ebp], 0
	jg	SHORT $L60672

; 396  : 
; 397  :       lpConn->ulTotalBytes += uLth;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, DWORD PTR _uLth$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+24], edx

; 398  : 
; 399  :       return( 0 );

	xor	ax, ax
	jmp	SHORT $L60640
$L60668:

; 401  : 
; 402  :    // Add the buffer data to the send buffer.
; 403  :    if ( lpConn->nTraceLevel > 1 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	cmp	edx, 1
	jle	SHORT $L60677

; 404  :       TraceLineS( "(zwinsock) Adding bytes to send buffer", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CH@ILFB@?$CIzwinsock?$CJ?5Adding?5bytes?5to?5send?5@ ; `string'
	call	_TraceLineS@8
$L60677:

; 407  :             (unsigned int) uLth );

	mov	eax, DWORD PTR _uLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	add	eax, DWORD PTR [ecx+16]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 408  :    lpConn->ulUnusedLth += uLth;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _uLth$[ebp]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 409  : 
; 410  :    return( 0 );

	xor	ax, ax
$L60640:

; 411  : 
; 412  : } // zNetSend

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_zNetSend@20 ENDP
_TEXT	ENDS
PUBLIC	_zNetReceive@20
PUBLIC	??_C@_0CC@JAKC@?$CIzwinsock?$CJ?5zNetReceive?5?9?9?5uLth?5?$DN@ ; `string'
PUBLIC	??_C@_0CA@PABN@?$CIzwinsock?$CJ?5Flushing?5send?5buffer?$AA@ ; `string'
PUBLIC	??_C@_0BP@MHKI@?$CIzwinsock?$CJ?5Total?5bytes?5sent?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0DA@CFAO@?$CIzwinsock?$CJ?5Trying?5to?5consolidate@ ; `string'
PUBLIC	??_C@_0CE@EBL@?$CIzwinsock?$CJ?5Allocating?5bigger?5buf@ ; `string'
PUBLIC	??_C@_0O@MNOP@Out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_04NJFL@recv?$AA@				; `string'
PUBLIC	??_C@_0DB@EPNP@?$CIzwinsock?$CJ?5Error?5trying?5to?5exten@ ; `string'
PUBLIC	??_C@_0BJ@CDMN@?$CIzwinsock?$CJ?5Bytes?5read?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BP@LKJJ@?$CIzwinsock?$CJ?5Tracing?5buffer?5?4?4?4?5?$AA@ ; `string'
PUBLIC	??_C@_0DB@HDJN@?$CIzwinsock?$CJ?5Buffer?5still?5doens?8t?5@ ; `string'
EXTRN	__imp__free:NEAR
EXTRN	__imp__malloc:NEAR
EXTRN	_SysMessageBox@16:NEAR
EXTRN	_recv@16:NEAR
;	COMDAT ??_C@_0CC@JAKC@?$CIzwinsock?$CJ?5zNetReceive?5?9?9?5uLth?5?$DN@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_0CC@JAKC@?$CIzwinsock?$CJ?5zNetReceive?5?9?9?5uLth?5?$DN@ DB '(zwin'
	DB	'sock) zNetReceive -- uLth = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@PABN@?$CIzwinsock?$CJ?5Flushing?5send?5buffer?$AA@
_DATA	SEGMENT
??_C@_0CA@PABN@?$CIzwinsock?$CJ?5Flushing?5send?5buffer?$AA@ DB '(zwinsoc'
	DB	'k) Flushing send buffer', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@MHKI@?$CIzwinsock?$CJ?5Total?5bytes?5sent?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BP@MHKI@?$CIzwinsock?$CJ?5Total?5bytes?5sent?5?$DN?5?$AA@ DB '(zwi'
	DB	'nsock) Total bytes sent = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DA@CFAO@?$CIzwinsock?$CJ?5Trying?5to?5consolidate@
_DATA	SEGMENT
??_C@_0DA@CFAO@?$CIzwinsock?$CJ?5Trying?5to?5consolidate@ DB '(zwinsock) '
	DB	'Trying to consolidate receive buffer', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CE@EBL@?$CIzwinsock?$CJ?5Allocating?5bigger?5buf@
_DATA	SEGMENT
??_C@_0CE@EBL@?$CIzwinsock?$CJ?5Allocating?5bigger?5buf@ DB '(zwinsock) A'
	DB	'llocating bigger buffer', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@MNOP@Out?5of?5memory?$AA@
_DATA	SEGMENT
??_C@_0O@MNOP@Out?5of?5memory?$AA@ DB 'Out of memory', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NJFL@recv?$AA@
_DATA	SEGMENT
??_C@_04NJFL@recv?$AA@ DB 'recv', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DB@EPNP@?$CIzwinsock?$CJ?5Error?5trying?5to?5exten@
_DATA	SEGMENT
??_C@_0DB@EPNP@?$CIzwinsock?$CJ?5Error?5trying?5to?5exten@ DB '(zwinsock)'
	DB	' Error trying to extend buffer.  RC = ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@CDMN@?$CIzwinsock?$CJ?5Bytes?5read?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BJ@CDMN@?$CIzwinsock?$CJ?5Bytes?5read?5?$DN?5?$AA@ DB '(zwinsock) '
	DB	'Bytes read = ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@LKJJ@?$CIzwinsock?$CJ?5Tracing?5buffer?5?4?4?4?5?$AA@
_DATA	SEGMENT
??_C@_0BP@LKJJ@?$CIzwinsock?$CJ?5Tracing?5buffer?5?4?4?4?5?$AA@ DB '(zwin'
	DB	'sock) Tracing buffer ... ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DB@HDJN@?$CIzwinsock?$CJ?5Buffer?5still?5doens?8t?5@
_DATA	SEGMENT
??_C@_0DB@HDJN@?$CIzwinsock?$CJ?5Buffer?5still?5doens?8t?5@ DB '(zwinsock'
	DB	') Buffer still doens''t have enough data', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_ppHandle$ = 8
_ppvConnPtr$ = 12
_ppchReturnBuffer$ = 16
_uLth$ = 20
_lpSockets$ = -8
_lpConn$ = -16
_ulUsed$ = -12
_uMaxRead$ = -4
_hNewBuff$60704 = -20
_pchNewBuff$60705 = -24
_iBytes$60722 = -28
_zNetReceive@20 PROC NEAR

; 454  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 455  :    LPSOCKETS      lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 456  :    LPCONNECTION   lpConn = (LPCONNECTION) *ppvConnPtr;

	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpConn$[ebp], eax

; 457  :    zULONG         ulUsed;
; 458  :    unsigned       uMaxRead;
; 459  : 
; 460  :    if ( lpConn->nTraceLevel > 1 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	cmp	edx, 1
	jle	SHORT $L60693

; 461  :       TraceLineI( "(zwinsock) zNetReceive -- uLth = ", uLth );

	mov	eax, DWORD PTR _uLth$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CC@JAKC@?$CIzwinsock?$CJ?5zNetReceive?5?9?9?5uLth?5?$DN@ ; `string'
	call	_TraceLineI@8
$L60693:

; 462  : 
; 463  :    // Check the flag to see if the last send/receive command was a send.  If
; 464  :    // the last command was a send, then the send buffer might need to be
; 465  :    // flushed.
; 466  :    if ( lpConn->bLastReceive == FALSE )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+42]
	test	edx, edx
	jne	SHORT $L60699

; 468  :       if ( lpConn->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpConn$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	cmp	ecx, 1
	jle	SHORT $L60696

; 469  :          TraceLineS( "(zwinsock) Flushing send buffer", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CA@PABN@?$CIzwinsock?$CJ?5Flushing?5send?5buffer?$AA@ ; `string'
	call	_TraceLineS@8
$L60696:

; 470  : 
; 471  :       if ( zNetSend( ppHandle, ppvConnPtr, 0, 0, 0 ) != 0 )

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppHandle$[ebp]
	push	eax
	call	_zNetSend@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L60698

; 472  :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L60686
$L60698:

; 473  : 
; 474  :       lpConn->bLastReceive = TRUE;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	BYTE PTR [edx+42], 1

; 475  :       lpConn->ulTotalBytes = 0;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+24], 0

; 476  : 
; 477  :       if ( lpConn->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	test	edx, edx
	jle	SHORT $L60699

; 478  :          TraceLineI( "(zwinsock) Total bytes sent = ", lpConn->ulTotalBytes );

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET FLAT:??_C@_0BP@MHKI@?$CIzwinsock?$CJ?5Total?5bytes?5sent?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8
$L60699:

; 480  : 
; 481  :    // Check to see if we have enough "unused" bytes in the read buffer.
; 482  :    // "Unused" bytes are bytes that have been received from the network but
; 483  :    // haven't been sent back to core.
; 484  :    if ( lpConn->ulUnusedLth >= uLth )

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _uLth$[ebp]
	jb	SHORT $L60701

; 486  :       // We have enough "unused" bytes in the buffer to handle the request.
; 487  :       // Set pointers and return.
; 488  :       *ppchReturnBuffer = lpConn->pchNextByte;

	mov	ecx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 489  :       lpConn->pchNextByte += uLth;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _uLth$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+8], edx

; 490  :       lpConn->ulUnusedLth -= uLth;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR _uLth$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+16], edx

; 491  : 
; 492  :       return( 0 );

	xor	ax, ax
	jmp	$L60686
$L60701:

; 494  : 
; 495  :    ulUsed = (zULONG) (lpConn->pchNextByte - lpConn->pchBuffer);

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _ulUsed$[ebp], eax

; 496  : 
; 497  :    // Check to see if there is enough space left in the buffer to hold the
; 498  :    // data needed.
; 499  :    if ( ulUsed + lpConn->ulUnusedLth + uLth > lpConn->ulBufferLth )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR _ulUsed$[ebp]
	add	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _uLth$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	cmp	edx, DWORD PTR [eax+20]
	jbe	$L60703

; 501  :       zLONG  hNewBuff;
; 502  :       zPCHAR pchNewBuff = 0;

	mov	DWORD PTR _pchNewBuff$60705[ebp], 0

; 503  : 
; 504  :       // If we get here then there is not enough space at the end of the
; 505  :       // buffer to hold the requested data.  This means we have to "move up"
; 506  :       // the "unused" bytes to the beginning of the read buffer.  It's also
; 507  :       // possible that the requested bytes is more than the buffer can hold.
; 508  :       // In this case we'll allocate a new, bigger buffer before we move the
; 509  :       // data around.
; 510  : 
; 511  :       if ( lpConn->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	test	edx, edx
	jle	SHORT $L60706

; 512  :          TraceLineS( "(zwinsock) Trying to consolidate receive buffer", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0DA@CFAO@?$CIzwinsock?$CJ?5Trying?5to?5consolidate@ ; `string'
	call	_TraceLineS@8
$L60706:

; 513  : 
; 514  :       // Check to see if the buffer is big enough to hold the necessary data.
; 515  :       if ( lpConn->ulBufferLth < uLth )

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _uLth$[ebp]
	jae	$L60708

; 517  :          if ( lpConn->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	movsx	eax, WORD PTR [edx+40]
	test	eax, eax
	jle	SHORT $L60709

; 518  :             TraceLineS( "(zwinsock) Allocating bigger buffer", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CE@EBL@?$CIzwinsock?$CJ?5Allocating?5bigger?5buf@ ; `string'
	call	_TraceLineS@8
$L60709:

; 519  : 
; 520  :          // We need to allocate a bigger buffer.
; 521  :          hNewBuff = (zLONG) malloc( uLth + 1000 );

	mov	ecx, DWORD PTR _uLth$[ebp]
	add	ecx, 1000				; 000003e8H
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _hNewBuff$60704[ebp], eax

; 522  :          pchNewBuff = (zPCHAR) hNewBuff;

	mov	edx, DWORD PTR _hNewBuff$60704[ebp]
	mov	DWORD PTR _pchNewBuff$60705[ebp], edx

; 523  :          if ( pchNewBuff == 0 )

	cmp	DWORD PTR _pchNewBuff$60705[ebp], 0
	jne	SHORT $L60713

; 525  :             SysMessageBox( 0, szlErrorTitle, "Out of memory", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0O@MNOP@Out?5of?5memory?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 526  :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L60686
$L60713:

; 531  :                   (unsigned int) lpConn->ulUnusedLth );

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _pchNewBuff$60705[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 532  : 
; 533  :          // Free the old buffer.
; 534  :          free( (zPVOID) lpConn->hBufferMem );

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 535  : 
; 536  :          // Set up connection info with new buffer.
; 537  :          lpConn->ulBufferLth = uLth + 1000;

	mov	ecx, DWORD PTR _uLth$[ebp]
	add	ecx, 1000				; 000003e8H
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 538  :          lpConn->hBufferMem  = hNewBuff;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR _hNewBuff$60704[ebp]
	mov	DWORD PTR [eax+32], ecx

; 539  :          lpConn->pchBuffer   = pchNewBuff;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR _pchNewBuff$60705[ebp]
	mov	DWORD PTR [edx+4], eax

; 541  :       else

	jmp	SHORT $L60717
$L60708:

; 543  :          // Copy the unused data to the beginning of the buffer.  This should
; 544  :          // free up room at the end of the buffer to retrieve data off the network.
; 545  :          zmemcpy( lpConn->pchBuffer, lpConn->pchNextByte,
; 546  :                   (unsigned int) lpConn->ulUnusedLth );

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$L60717:

; 548  : 
; 549  :       lpConn->pchNextByte = lpConn->pchBuffer;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax

; 550  :       ulUsed = 0;

	mov	DWORD PTR _ulUsed$[ebp], 0
$L60703:

; 552  : 
; 553  :    // Determine how much space is left at the end of the buffer.  This is
; 554  :    // the max number of bytes we can get without overflowing the buffer.
; 555  :    uMaxRead = lpConn->ulBufferLth - (ulUsed + lpConn->ulUnusedLth);

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR _ulUsed$[ebp]
	add	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, edx
	mov	DWORD PTR _uMaxRead$[ebp], ecx
$L60720:

; 556  : 
; 557  :    // Keep reading from the network until we have all the data we need.
; 558  :    while ( uLth > lpConn->ulUnusedLth )

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR _uLth$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	$L60721

; 560  :       int iBytes;
; 561  : 
; 562  :       // Now retrieve data from the network, appending it to the end of the
; 563  :       // data in the buffer.
; 564  :       iBytes = recv( lpConn->sock, &lpConn->pchNextByte[ lpConn->ulUnusedLth ],
; 565  :                      uMaxRead, 0 );

	push	0
	mov	ecx, DWORD PTR _uMaxRead$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	add	eax, DWORD PTR [ecx+16]
	push	eax
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_recv@16
	mov	DWORD PTR _iBytes$60722[ebp], eax

; 566  :       if ( iBytes == SOCKET_ERROR || iBytes == 0 )

	cmp	DWORD PTR _iBytes$60722[ebp], -1
	je	SHORT $L60724
	cmp	DWORD PTR _iBytes$60722[ebp], 0
	jne	SHORT $L60723
$L60724:

; 568  :          SHOWERROR( "recv" );

	push	OFFSET FLAT:??_C@_04NJFL@recv?$AA@	; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 569  :          TraceLineI( "(zwinsock) Error trying to extend buffer.  RC = ", iBytes );

	mov	ecx, DWORD PTR _iBytes$60722[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DB@EPNP@?$CIzwinsock?$CJ?5Error?5trying?5to?5exten@ ; `string'
	call	_TraceLineI@8

; 570  :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L60686
$L60723:

; 572  : 
; 573  :       if ( lpConn->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	movsx	eax, WORD PTR [edx+40]
	test	eax, eax
	jle	SHORT $L60729

; 575  :          TraceLineI( "(zwinsock) Bytes read = ", iBytes );

	mov	ecx, DWORD PTR _iBytes$60722[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BJ@CDMN@?$CIzwinsock?$CJ?5Bytes?5read?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8

; 576  : 
; 577  :          if ( lpConn->nTraceLevel > 1 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	movsx	eax, WORD PTR [edx+40]
	cmp	eax, 1
	jle	SHORT $L60729

; 579  :             TraceLineI( "(zwinsock) Tracing buffer ... ", iBytes );

	mov	ecx, DWORD PTR _iBytes$60722[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BP@LKJJ@?$CIzwinsock?$CJ?5Tracing?5buffer?5?4?4?4?5?$AA@ ; `string'
	call	_TraceLineI@8

; 580  :             TraceBuffer( "(zwinsock)",
; 581  :                          &lpConn->pchNextByte[ lpConn->ulUnusedLth ],
; 582  :                          (zUSHORT) iBytes );

	mov	edx, DWORD PTR _iBytes$60722[ebp]
	and	edx, 65535				; 0000ffffH
	push	edx
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _lpConn$[ebp]
	add	ecx, DWORD PTR [edx+16]
	push	ecx
	push	OFFSET FLAT:??_C@_0L@BHID@?$CIzwinsock?$CJ?$AA@ ; `string'
	call	_TraceBuffer@12
$L60729:

; 585  : 
; 586  :       lpConn->ulUnusedLth  += iBytes;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _iBytes$60722[ebp]
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 587  :       lpConn->ulTotalBytes += iBytes;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _iBytes$60722[ebp]
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 588  :       uMaxRead             -= iBytes;

	mov	eax, DWORD PTR _uMaxRead$[ebp]
	sub	eax, DWORD PTR _iBytes$60722[ebp]
	mov	DWORD PTR _uMaxRead$[ebp], eax

; 589  : 
; 590  :       if ( lpConn->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	test	edx, edx
	jle	SHORT $L60733

; 592  :          if ( uLth > lpConn->ulUnusedLth )

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR _uLth$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jbe	SHORT $L60733

; 593  :             TraceLineS( "(zwinsock) Buffer still doens't have enough data", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0DB@HDJN@?$CIzwinsock?$CJ?5Buffer?5still?5doens?8t?5@ ; `string'
	call	_TraceLineS@8
$L60733:

; 595  : 
; 596  :    } // while...

	jmp	$L60720
$L60721:

; 597  : 
; 598  :    *ppchReturnBuffer = lpConn->pchNextByte;

	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 599  :    lpConn->pchNextByte += uLth;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _uLth$[ebp]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 600  :    lpConn->ulUnusedLth -= uLth;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR _uLth$[ebp]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 601  : 
; 602  :    return( 0 );

	xor	ax, ax
$L60686:

; 603  : 
; 604  : } // zNetReceive

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_zNetReceive@20 ENDP
_TEXT	ENDS
PUBLIC	_zNetOpenConnection@16
PUBLIC	??_C@_08PDEL@ApplPort?$AA@			; `string'
PUBLIC	??_C@_0L@IGEO@?$FLzWinSock?$FN?$AA@		; `string'
PUBLIC	??_C@_06KDPK@socket?$AA@			; `string'
PUBLIC	??_C@_0BA@HGG@socket?$CI?$CJ?5failed?$AA@	; `string'
PUBLIC	??_C@_0M@LOFA@ioctlsocket?$AA@			; `string'
PUBLIC	??_C@_0BF@LEIK@ioctlsocket?$CI?$CJ?5failed?$AA@	; `string'
PUBLIC	??_C@_0BF@BHE@?$CFs?5took?5?$CFlf?5seconds?4?$AA@ ; `string'
PUBLIC	??_C@_0CI@JKFE@?$CIzWinSock?$CJ?5WARNING?5gethostbyname@ ; `string'
PUBLIC	??_C@_0O@BLIP@gethostbyname?$AA@		; `string'
PUBLIC	??_C@_0HH@CDEA@Couldn?8t?5resolve?5network?5address@ ; `string'
PUBLIC	??_C@_0CC@ELKH@?$CIzWinSock?$CJ?5WARNING?5connect?$CI?$CJ?5for@ ; `string'
PUBLIC	??_C@_07DHIJ@connect?$AA@			; `string'
PUBLIC	??_C@_0IE@JLHI@Connection?5to?5server?5?8?$CFs?8?5failed@ ; `string'
PUBLIC	??_C@_08GPBK@zWinSock?$AA@			; `string'
PUBLIC	??_C@_0CG@POCG@?$CIzwinsock?$CJ?5Connection?5to?5server?5@ ; `string'
PUBLIC	__real@8@4008fa00000000000000
EXTRN	_NetGetTraceLevel@8:NEAR
EXTRN	__imp__atol:NEAR
EXTRN	__imp__calloc:NEAR
EXTRN	__imp__sprintf:NEAR
EXTRN	_SysGetTickCount@0:NEAR
EXTRN	_SysReadZeidonIni@16:NEAR
EXTRN	_closesocket@4:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_connect@12:NEAR
EXTRN	_ioctlsocket@12:NEAR
EXTRN	_strlen:NEAR
EXTRN	_htons@4:NEAR
EXTRN	__imp__strchr:NEAR
EXTRN	_socket@12:NEAR
EXTRN	_gethostbyname@4:NEAR
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_08PDEL@ApplPort?$AA@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_08PDEL@ApplPort?$AA@ DB 'ApplPort', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@IGEO@?$FLzWinSock?$FN?$AA@
_DATA	SEGMENT
??_C@_0L@IGEO@?$FLzWinSock?$FN?$AA@ DB '[zWinSock]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_06KDPK@socket?$AA@
_DATA	SEGMENT
??_C@_06KDPK@socket?$AA@ DB 'socket', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@HGG@socket?$CI?$CJ?5failed?$AA@
_DATA	SEGMENT
??_C@_0BA@HGG@socket?$CI?$CJ?5failed?$AA@ DB 'socket() failed', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@LOFA@ioctlsocket?$AA@
_DATA	SEGMENT
??_C@_0M@LOFA@ioctlsocket?$AA@ DB 'ioctlsocket', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@LEIK@ioctlsocket?$CI?$CJ?5failed?$AA@
_DATA	SEGMENT
??_C@_0BF@LEIK@ioctlsocket?$CI?$CJ?5failed?$AA@ DB 'ioctlsocket() failed', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@BHE@?$CFs?5took?5?$CFlf?5seconds?4?$AA@
_DATA	SEGMENT
??_C@_0BF@BHE@?$CFs?5took?5?$CFlf?5seconds?4?$AA@ DB '%s took %lf seconds'
	DB	'.', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@JKFE@?$CIzWinSock?$CJ?5WARNING?5gethostbyname@
_DATA	SEGMENT
??_C@_0CI@JKFE@?$CIzWinSock?$CJ?5WARNING?5gethostbyname@ DB '(zWinSock) W'
	DB	'ARNING gethostbyname() for ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@BLIP@gethostbyname?$AA@
_DATA	SEGMENT
??_C@_0O@BLIP@gethostbyname?$AA@ DB 'gethostbyname', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0HH@CDEA@Couldn?8t?5resolve?5network?5address@
_DATA	SEGMENT
??_C@_0HH@CDEA@Couldn?8t?5resolve?5network?5address@ DB 'Couldn''t resolv'
	DB	'e network address ''%s''.  Make sure the server address is co'
	DB	'rrect and that the Zeidon Server is running.', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@ELKH@?$CIzWinSock?$CJ?5WARNING?5connect?$CI?$CJ?5for@
_DATA	SEGMENT
??_C@_0CC@ELKH@?$CIzWinSock?$CJ?5WARNING?5connect?$CI?$CJ?5for@ DB '(zWin'
	DB	'Sock) WARNING connect() for ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07DHIJ@connect?$AA@
_DATA	SEGMENT
??_C@_07DHIJ@connect?$AA@ DB 'connect', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0IE@JLHI@Connection?5to?5server?5?8?$CFs?8?5failed@
_DATA	SEGMENT
??_C@_0IE@JLHI@Connection?5to?5server?5?8?$CFs?8?5failed@ DB 'Connection '
	DB	'to server ''%s'' failed.  Make sure the server address is cor'
	DB	'rect and that the server is running the Zeidon Object Engine.'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GPBK@zWinSock?$AA@
_DATA	SEGMENT
??_C@_08GPBK@zWinSock?$AA@ DB 'zWinSock', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@POCG@?$CIzwinsock?$CJ?5Connection?5to?5server?5@
_DATA	SEGMENT
??_C@_0CG@POCG@?$CIzwinsock?$CJ?5Connection?5to?5server?5@ DB '(zwinsock)'
	DB	' Connection to server made!', 00H		; `string'
_DATA	ENDS
;	COMDAT __real@8@4008fa00000000000000
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
_TEXT	SEGMENT
_ppHandle$ = 8
_ppvConnPtr$ = 12
_pchAddress$ = 16
_lpView$ = 20
_lpSockets$ = -276
_lpConn$ = -288
_sock$ = -296
_DestSocket$ = -284
_pHost$ = -12
_szServerAddress$ = -272
_pch$ = -8
_hMem$ = -4
_lBlockOff$ = -280
_nPort$ = -292
_nRC$ = -16
_szPort$60766 = -316
_szMsg$60789 = -816
_lStart$60790 = -820
_lEnd$60791 = -824
_sz$60793 = -1024
_szMsg$60806 = -1524
_lStart$60807 = -1528
_lEnd$60808 = -1532
_sz$60812 = -1732
_zNetOpenConnection@16 PROC NEAR

; 644  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1740				; 000006ccH

; 645  :    LPSOCKETS      lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 646  :    LPCONNECTION   lpConn;
; 647  :    SOCKET         sock = INVALID_SOCKET;

	mov	DWORD PTR _sock$[ebp], -1

; 648  :    SOCKADDR_IN    *DestSocket;
; 649  :    PHOSTENT       pHost;
; 650  :    zCHAR          szServerAddress[ 256 ];
; 651  :    zPCHAR         pch;
; 652  :    zLONG          hMem;
; 653  :    u_long         lBlockOff = 0;

	mov	DWORD PTR _lBlockOff$[ebp], 0

; 654  :    u_short        nPort;
; 655  :    zSHORT         nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 656  : 
; 657  :    // Set up a buffer to receive network traffic.
; 658  :    hMem = (zLONG) calloc( 1, sizeof( ConnectionRecord ) );

	push	43					; 0000002bH
	push	1
	call	DWORD PTR __imp__calloc
	add	esp, 8
	mov	DWORD PTR _hMem$[ebp], eax

; 659  :    lpConn = (LPCONNECTION) hMem;

	mov	edx, DWORD PTR _hMem$[ebp]
	mov	DWORD PTR _lpConn$[ebp], edx

; 660  :    if ( lpConn == 0 )

	cmp	DWORD PTR _lpConn$[ebp], 0
	jne	SHORT $L60758

; 662  :       SysMessageBox( 0, szlErrorTitle, "Out of memory", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0O@MNOP@Out?5of?5memory?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 663  :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L60741
$L60758:

; 665  : 
; 666  :    // Since we may manipulate the server address let's copy it to a temp var.
; 667  :    zstrcpy( szServerAddress, pchAddress );

	mov	eax, DWORD PTR _pchAddress$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szServerAddress$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 668  : 
; 669  :    // Check to see if the port number is part of the address.  If it is, then
; 670  :    // copy it to szPort.
; 671  :    pch = zstrchr( szServerAddress, ':' );

	push	58					; 0000003aH
	lea	edx, DWORD PTR _szServerAddress$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pch$[ebp], eax

; 672  :    if ( pch )

	cmp	DWORD PTR _pch$[ebp], 0
	je	SHORT $L60760

; 674  :       // Change ':' to null-term.
; 675  :       *pch++ = 0;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx

; 676  : 
; 677  :       // Convert port number.
; 678  :       nPort = (u_short) zatol( pch );

	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nPort$[ebp], ax

; 680  :    else

	jmp	SHORT $L60765
$L60760:

; 681  :    if ( g_nApplPort != (u_short) -1 )

	xor	eax, eax
	mov	ax, WORD PTR _g_nApplPort
	cmp	eax, 65535				; 0000ffffH
	je	SHORT $L60764

; 683  :       nPort = g_nApplPort;

	mov	cx, WORD PTR _g_nApplPort
	mov	WORD PTR _nPort$[ebp], cx

; 685  :    else

	jmp	SHORT $L60765
$L60764:

; 687  :       zCHAR szPort[ 20 ];
; 688  : 
; 689  :       // The port value wasn't specified so get the default port from the Ini file.
; 690  :       SysReadZeidonIni( -1, "[zWinSock]", "ApplPort", szPort );

	lea	edx, DWORD PTR _szPort$60766[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08PDEL@ApplPort?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@IGEO@?$FLzWinSock?$FN?$AA@ ; `string'
	push	-1
	call	_SysReadZeidonIni@16

; 691  :       nPort = (u_short) zatol( szPort );

	lea	eax, DWORD PTR _szPort$60766[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nPort$[ebp], ax

; 692  :       g_nApplPort = nPort;

	mov	cx, WORD PTR _nPort$[ebp]
	mov	WORD PTR _g_nApplPort, cx
$L60765:

; 694  : 
; 695  :    lpConn->hMemHandle = hMem;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR _hMem$[ebp]
	mov	DWORD PTR [edx+28], eax

; 696  : 
; 697  :    // Set up a buffer to receive network traffic.
; 698  :    lpConn->hBufferMem = (zLONG) malloc( BUFFER_LTH );

	push	32000					; 00007d00H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 699  :    lpConn->pchBuffer  = (zPCHAR) lpConn->hBufferMem;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+4], ecx

; 700  :    if ( lpConn->pchBuffer == 0 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $L60772

; 702  :       SysMessageBox( 0, szlErrorTitle, "Out of memory", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0O@MNOP@Out?5of?5memory?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 703  :       goto EndOfFunction;

	jmp	$L60774
$L60772:

; 705  : 
; 706  :    lpConn->ulBufferLth = BUFFER_LTH;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+20], 32000		; 00007d00H

; 707  : 
; 708  :    sock = socket( AF_INET, SOCK_STREAM, 0 );

	push	0
	push	1
	push	2
	call	_socket@12
	mov	DWORD PTR _sock$[ebp], eax

; 709  :    if ( sock == INVALID_SOCKET )

	cmp	DWORD PTR _sock$[ebp], -1
	jne	SHORT $L60776

; 711  :       SHOWERROR( "socket" );

	push	OFFSET FLAT:??_C@_06KDPK@socket?$AA@	; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 712  :       SysMessageBox( 0, szlErrorTitle, "socket() failed", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0BA@HGG@socket?$CI?$CJ?5failed?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 713  :       goto EndOfFunction;

	jmp	$L60779
$L60776:

; 715  : 
; 716  : #ifdef __WIN32__
; 717  :    if ( ioctlsocket( sock, FIONBIO, &lBlockOff ) == SOCKET_ERROR )

	lea	ecx, DWORD PTR _lBlockOff$[ebp]
	push	ecx
	push	-2147195266				; 8004667eH
	mov	edx, DWORD PTR _sock$[ebp]
	push	edx
	call	_ioctlsocket@12
	cmp	eax, -1
	jne	SHORT $L60782

; 719  :       SHOWERROR( "ioctlsocket" );

	push	OFFSET FLAT:??_C@_0M@LOFA@ioctlsocket?$AA@ ; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 720  :       SysMessageBox( 0, szlErrorTitle, "ioctlsocket() failed", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0BF@LEIK@ioctlsocket?$CI?$CJ?5failed?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 721  :       goto EndOfFunction;

	jmp	$L60785
$L60782:

; 723  : #endif
; 724  : 
; 725  :    while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	$L60788

; 727  :       zCHAR szMsg[ 500 ];
; 728  :       zLONG lStart, lEnd;
; 729  : 
; 730  :       lStart = SysGetTickCount();

	call	_SysGetTickCount@0
	mov	DWORD PTR _lStart$60790[ebp], eax

; 731  :       pHost = gethostbyname( szServerAddress );

	lea	ecx, DWORD PTR _szServerAddress$[ebp]
	push	ecx
	call	_gethostbyname@4
	mov	DWORD PTR _pHost$[ebp], eax

; 732  :       lEnd = SysGetTickCount();

	call	_SysGetTickCount@0
	mov	DWORD PTR _lEnd$60791[ebp], eax

; 733  : 
; 734  :       // Trace an error if over 5 seconds.
; 735  :       if ( lEnd - lStart > 5 * zTICKS_PER_SECOND )

	mov	edx, DWORD PTR _lEnd$60791[ebp]
	sub	edx, DWORD PTR _lStart$60790[ebp]
	cmp	edx, 5000				; 00001388H
	jle	SHORT $L60792

; 737  :          char sz[ 200 ];
; 738  : 
; 739  :          zsprintf( sz, "%s took %lf seconds.", szServerAddress,
; 740  :                    (double) ( lEnd - lStart ) / zTICKS_PER_SECOND );

	mov	eax, DWORD PTR _lEnd$60791[ebp]
	sub	eax, DWORD PTR _lStart$60790[ebp]
	mov	DWORD PTR -1736+[ebp], eax
	fild	DWORD PTR -1736+[ebp]
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	ecx, DWORD PTR _szServerAddress$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BF@BHE@?$CFs?5took?5?$CFlf?5seconds?4?$AA@ ; `string'
	lea	edx, DWORD PTR _sz$60793[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 741  :          TraceLineS( "(zWinSock) WARNING gethostbyname() for ", sz );

	lea	eax, DWORD PTR _sz$60793[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CI@JKFE@?$CIzWinSock?$CJ?5WARNING?5gethostbyname@ ; `string'
	call	_TraceLineS@8
$L60792:

; 743  : 
; 744  :       if ( pHost )

	cmp	DWORD PTR _pHost$[ebp], 0
	je	SHORT $L60797

; 745  :          break;  // Got the info, so break.

	jmp	SHORT $L60788
$L60797:

; 746  : 
; 747  :       SHOWERROR( "gethostbyname" );

	push	OFFSET FLAT:??_C@_0O@BLIP@gethostbyname?$AA@ ; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 748  :       zsprintf( szMsg, "Couldn't resolve network address '%s'.  Make sure the server "
; 749  :                 "address is correct and that the Zeidon Server is running.",
; 750  :                 szServerAddress );

	lea	ecx, DWORD PTR _szServerAddress$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0HH@CDEA@Couldn?8t?5resolve?5network?5address@ ; `string'
	lea	edx, DWORD PTR _szMsg$60789[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 751  : 
; 752  : #ifdef __UNIX__
; 753  :       nRC = -1;
; 754  :       goto EndOfFunction;
; 755  : #else
; 756  :       if ( SysMessageBox( lpView, szlErrorTitle, szMsg, MB_RETRYCANCEL ) == IDCANCEL )

	push	5
	lea	eax, DWORD PTR _szMsg$60789[ebp]
	push	eax
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16
	cmp	eax, 2
	jne	SHORT $L60800

; 758  :          nRC = -1;

	mov	WORD PTR _nRC$[ebp], -1

; 759  :          goto EndOfFunction;

	jmp	$L60801
$L60800:

; 761  : #endif
; 762  :    }

	jmp	$L60782
$L60788:

; 763  : 
; 764  :    // Create the destination socket so we can call 'connect'.  Since the
; 765  :    // destination socket structure has a variable length we'll temporarily
; 766  :    // use our buffer that we created.
; 767  :    DestSocket = (SOCKADDR_IN *) &lpConn->pchBuffer[ BUFFER_LTH / 2 ];

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 16000				; 00003e80H
	mov	DWORD PTR _DestSocket$[ebp], eax

; 768  :    zmemcpy( &(DestSocket->sin_addr), pHost->h_addr, pHost->h_length );

	mov	ecx, DWORD PTR _pHost$[ebp]
	movsx	edx, WORD PTR [ecx+10]
	push	edx
	mov	eax, DWORD PTR _pHost$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _DestSocket$[ebp]
	add	eax, 4
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 769  :    DestSocket->sin_port   = htons( nPort );

	mov	cx, WORD PTR _nPort$[ebp]
	push	ecx
	call	_htons@4
	mov	edx, DWORD PTR _DestSocket$[ebp]
	mov	WORD PTR [edx+2], ax

; 770  :    DestSocket->sin_family = AF_INET;

	mov	eax, DWORD PTR _DestSocket$[ebp]
	mov	WORD PTR [eax], 2
$L60804:

; 771  : 
; 772  :    // Try to connect to the server.  We'll keep trying until:
; 773  :    //  1) We get through.
; 774  :    //  2) User says to quit trying.
; 775  :    while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	$L60805

; 777  :       zCHAR szMsg[ 500 ];
; 778  :       zLONG lStart, lEnd;
; 779  : 
; 780  :       lStart = SysGetTickCount();

	call	_SysGetTickCount@0
	mov	DWORD PTR _lStart$60807[ebp], eax

; 781  :       if ( connect( sock, (PSOCKADDR) DestSocket, sizeof( *DestSocket ) ) == 0 )

	push	16					; 00000010H
	mov	edx, DWORD PTR _DestSocket$[ebp]
	push	edx
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	call	_connect@12
	test	eax, eax
	jne	SHORT $L60810

; 783  :          lEnd = SysGetTickCount();

	call	_SysGetTickCount@0
	mov	DWORD PTR _lEnd$60808[ebp], eax

; 784  : 
; 785  :          // Trace an error if over 5 seconds.
; 786  :          if ( lEnd - lStart > 5 * zTICKS_PER_SECOND )

	mov	ecx, DWORD PTR _lEnd$60808[ebp]
	sub	ecx, DWORD PTR _lStart$60807[ebp]
	cmp	ecx, 5000				; 00001388H
	jle	SHORT $L60811

; 788  :             char sz[ 200 ];
; 789  : 
; 790  :             zsprintf( sz, "%s took %lf seconds.", szServerAddress,
; 791  :                       (double) ( lEnd - lStart ) / zTICKS_PER_SECOND );

	mov	edx, DWORD PTR _lEnd$60808[ebp]
	sub	edx, DWORD PTR _lStart$60807[ebp]
	mov	DWORD PTR -1740+[ebp], edx
	fild	DWORD PTR -1740+[ebp]
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	eax, DWORD PTR _szServerAddress$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@BHE@?$CFs?5took?5?$CFlf?5seconds?4?$AA@ ; `string'
	lea	ecx, DWORD PTR _sz$60812[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 792  :             TraceLineS( "(zWinSock) WARNING connect() for ", sz );

	lea	edx, DWORD PTR _sz$60812[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CC@ELKH@?$CIzWinSock?$CJ?5WARNING?5connect?$CI?$CJ?5for@ ; `string'
	call	_TraceLineS@8
$L60811:

; 794  : 
; 795  :          break;  // Got a good connection, break loop.

	jmp	SHORT $L60805
$L60810:

; 797  : 
; 798  :       SHOWERROR( "connect" );

	push	OFFSET FLAT:??_C@_07DHIJ@connect?$AA@	; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 799  : 
; 800  :       zsprintf( szMsg, "Connection to server '%s' failed.  Make sure the server "
; 801  :                 "address is correct and that the server is running the Zeidon "
; 802  :                 "Object Engine.", pchAddress );

	mov	eax, DWORD PTR _pchAddress$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0IE@JLHI@Connection?5to?5server?5?8?$CFs?8?5failed@ ; `string'
	lea	ecx, DWORD PTR _szMsg$60806[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 803  : 
; 804  : #ifdef __UNIX__
; 805  :       nRC = -1;
; 806  :       goto EndOfFunction;
; 807  : #else
; 808  :       if ( SysMessageBox( lpView, szlErrorTitle, szMsg, MB_RETRYCANCEL ) == IDCANCEL )

	push	5
	lea	edx, DWORD PTR _szMsg$60806[ebp]
	push	edx
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16
	cmp	eax, 2
	jne	SHORT $L60817

; 810  :          nRC = -1;

	mov	WORD PTR _nRC$[ebp], -1

; 811  :          goto EndOfFunction;

	jmp	$L60818
$L60817:

; 813  : #endif
; 814  :    }

	jmp	$L60804
$L60805:

; 815  : 
; 816  :    // Everything is OK, so set nRC.
; 817  :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 818  : 
; 819  :    // Init connection info.
; 820  :    lpConn->sock         = sock;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR _sock$[ebp]
	mov	DWORD PTR [ecx], edx

; 821  :    lpConn->pchNextByte  = lpConn->pchBuffer;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 822  :    lpConn->ulUnusedLth  = 0;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+16], 0

; 823  :    lpConn->nTraceLevel  = NetGetTraceLevel( lpView, "zWinSock" );

	push	OFFSET FLAT:??_C@_08GPBK@zWinSock?$AA@	; `string'
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_NetGetTraceLevel@8
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	WORD PTR [edx+40], ax

; 824  :    lpConn->bLastReceive = FALSE;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	BYTE PTR [eax+42], 0

; 825  : 
; 826  :    if ( lpConn->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	test	edx, edx
	jle	SHORT $L60820

; 827  :       TraceLineS( "(zwinsock) Connection to server made!", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CG@POCG@?$CIzwinsock?$CJ?5Connection?5to?5server?5@ ; `string'
	call	_TraceLineS@8
$L60820:

; 828  : 
; 829  :    // Set up a buffer to hold the peer name.
; 830  :    lpConn->hPeerNameMem = (zLONG) malloc( zstrlen( szServerAddress ) + 1 );

	lea	eax, DWORD PTR _szServerAddress$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 831  :    lpConn->pchPeerName = (zPCHAR) lpConn->hPeerNameMem;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+12], ecx

; 832  :    if ( lpConn->pchPeerName == 0 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $L60824

; 834  :       SysMessageBox( 0, szlErrorTitle, "Out of memory", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0O@MNOP@Out?5of?5memory?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 835  :       nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 836  :       goto EndOfFunction;

	jmp	$L60825
$L60824:

; 838  : 
; 839  :    zstrcpy( lpConn->pchPeerName, szServerAddress );

	lea	eax, DWORD PTR _szServerAddress$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_strcpy
	add	esp, 8
$EndOfFunction$60773:

; 840  : 
; 841  : EndOfFunction:
; 842  :    if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	$L60826

; 844  :       // We're ending with an error, so clean up.
; 845  :       if ( lpConn->hBufferMem )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $L60827

; 846  :          free( (zPVOID) lpConn->hBufferMem );

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$L60827:

; 847  : 
; 848  :       if ( lpConn->hPeerNameMem )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $L60829

; 849  :          free( (zPVOID) lpConn->hPeerNameMem );

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$L60829:

; 850  : 
; 851  :       if ( lpConn->hMemHandle )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $L60831

; 852  :          free( (zPVOID) lpConn->hMemHandle );

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$L60831:

; 853  : 
; 854  :       if ( sock != INVALID_SOCKET )

	cmp	DWORD PTR _sock$[ebp], -1
	je	SHORT $L60834

; 855  :          closesocket( sock );

	mov	ecx, DWORD PTR _sock$[ebp]
	push	ecx
	call	_closesocket@4
$L60834:

; 856  : 
; 857  :       lpConn->hBufferMem   = 0;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx+32], 0

; 858  :       lpConn->hPeerNameMem = 0;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+36], 0

; 859  :       lpConn->hMemHandle   = 0;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 861  :    else

	jmp	SHORT $L60835
$L60826:

; 862  :       *ppvConnPtr = lpConn;

	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx], eax
$L60835:

; 863  : 
; 864  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $L60741
$L60825:

; 865  : 
; 866  : } // zNetOpenConnection

	jmp	$EndOfFunction$60773
$L60818:
	jmp	$EndOfFunction$60773
$L60801:
	jmp	$EndOfFunction$60773
$L60785:
	jmp	$EndOfFunction$60773
$L60779:
	jmp	$EndOfFunction$60773
$L60774:
	jmp	$EndOfFunction$60773
$L60741:
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_zNetOpenConnection@16 ENDP
_TEXT	ENDS
PUBLIC	_zNetCloseConnection@8
PUBLIC	??_C@_0M@BGOH@closesocket?$AA@			; `string'
;	COMDAT ??_C@_0M@BGOH@closesocket?$AA@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_0M@BGOH@closesocket?$AA@ DB 'closesocket', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_ppHandle$ = 8
_ppvConnPtr$ = 12
_lpSockets$ = -4
_lpConn$ = -8
_zNetCloseConnection@8 PROC NEAR

; 889  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 890  :    LPSOCKETS      lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 891  :    LPCONNECTION   lpConn = (LPCONNECTION) *ppvConnPtr;

	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpConn$[ebp], eax

; 892  : 
; 893  :    // Check the flag to see if the last send/receive command was a send.  If
; 894  :    // the last command was a send, then the send buffer might need to be
; 895  :    // flushed.
; 896  :    if ( lpConn )

	cmp	DWORD PTR _lpConn$[ebp], 0
	je	$L60844

; 898  :       if ( lpConn->bLastReceive == FALSE )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+42]
	test	edx, edx
	jne	SHORT $L60845

; 900  :          zNetSend( ppHandle, ppvConnPtr, 0, 0, 0 );

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _ppvConnPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppHandle$[ebp]
	push	ecx
	call	_zNetSend@20

; 901  : 
; 902  :          if ( lpConn->nTraceLevel > 0 && lpConn->ulTotalBytes > 0 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	movsx	eax, WORD PTR [edx+40]
	test	eax, eax
	jle	SHORT $L60846
	mov	ecx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jbe	SHORT $L60846

; 903  :             TraceLineI( "(zwinsock) Total bytes sent = ", lpConn->ulTotalBytes );

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	OFFSET FLAT:??_C@_0BP@MHKI@?$CIzwinsock?$CJ?5Total?5bytes?5sent?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8
$L60846:

; 905  :       else

	jmp	SHORT $L60848
$L60845:

; 907  :          if ( lpConn->nTraceLevel > 0 && lpConn->ulTotalBytes > 0 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	test	edx, edx
	jle	SHORT $L60848
	mov	eax, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jbe	SHORT $L60848

; 908  :             TraceLineI( "(zwinsock) Total bytes received = ", lpConn->ulTotalBytes );

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET FLAT:??_C@_0CD@ENDI@?$CIzwinsock?$CJ?5Total?5bytes?5received?5@ ; `string'
	call	_TraceLineI@8
$L60848:

; 910  : 
; 911  :       if ( closesocket( lpConn->sock ) == SOCKET_ERROR )

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_closesocket@4
	cmp	eax, -1
	jne	SHORT $L60849

; 912  :          SHOWERROR( "closesocket" );

	push	OFFSET FLAT:??_C@_0M@BGOH@closesocket?$AA@ ; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4
$L60849:

; 913  : 
; 914  :       free( (zPVOID) lpConn->hBufferMem );

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 915  :       free( (zPVOID) lpConn->hPeerNameMem );

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4

; 916  :       free( (zPVOID) lpConn->hMemHandle );

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4

; 917  : 
; 918  :       *ppvConnPtr = 0;

	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	mov	DWORD PTR [edx], 0
$L60844:

; 920  : 
; 921  :    return( 0 );

	xor	ax, ax

; 922  : 
; 923  : } // zNetCloseConnection

	mov	esp, ebp
	pop	ebp
	ret	8
_zNetCloseConnection@8 ENDP
_TEXT	ENDS
PUBLIC	_fnProcessConnectionThreadProc@4
PUBLIC	??_C@_0BB@BIOA@SyncServerAccess?$AA@		; `string'
PUBLIC	??_C@_0BD@ODND@WINSOCK_WORKAROUND?$AA@		; `string'
PUBLIC	??_C@_0BB@LFCK@?2?2Zeidon?5System?2?$AA@	; `string'
PUBLIC	??_C@_0CN@JPKP@?$CIzwinsock?$CJ?5A?5message?5has?5been?5re@ ; `string'
EXTRN	__imp__CreateMutexA@12:NEAR
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__imp__ReleaseMutex@4:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	_NetProcessMessage@12:NEAR
EXTRN	__imp__atoi:NEAR
EXTRN	_RegisterZeidonApplication@28:NEAR
EXTRN	_UnregisterZeidonApplication@4:NEAR
EXTRN	_SysGetPointerFromHandle@4:NEAR
;	COMDAT ??_C@_0BB@BIOA@SyncServerAccess?$AA@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_0BB@BIOA@SyncServerAccess?$AA@ DB 'SyncServerAccess', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@ODND@WINSOCK_WORKAROUND?$AA@
_DATA	SEGMENT
??_C@_0BD@ODND@WINSOCK_WORKAROUND?$AA@ DB 'WINSOCK_WORKAROUND', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LFCK@?2?2Zeidon?5System?2?$AA@
_DATA	SEGMENT
??_C@_0BB@LFCK@?2?2Zeidon?5System?2?$AA@ DB '\\Zeidon System\', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CN@JPKP@?$CIzwinsock?$CJ?5A?5message?5has?5been?5re@
_DATA	SEGMENT
??_C@_0CN@JPKP@?$CIzwinsock?$CJ?5A?5message?5has?5been?5re@ DB '(zwinsock'
	DB	') A message has been received from ', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_p$ = 8
_pSockTask$ = -4
_lpTask$ = -64
_sock$ = -76
_vSubtask$ = -68
_lBlockOff$ = -56
_pv$ = -72
_cr$ = -52
_nRC$ = -8
_pp$ = -60
_szBuf$60898 = -156
$T61378 = -160
_fnProcessConnectionThreadProc@4 PROC NEAR

; 944  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	edi

; 945  :    LPSOCKTASK         pSockTask = (LPSOCKTASK) p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _pSockTask$[ebp], eax

; 946  : // LPTASK             lpTask = (LPTASK) zGETPTR( pSockTask->hTask );
; 947  :    LPTASK             lpTask = (LPTASK) SysGetPointerFromHandle( pSockTask->hTask );

	mov	ecx, DWORD PTR _pSockTask$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$[ebp], eax

; 948  :    SOCKET             sock = pSockTask->sock;

	mov	eax, DWORD PTR _pSockTask$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _sock$[ebp], ecx

; 949  :    zVIEW              vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 950  :    long               lBlockOff = FALSE;

	mov	DWORD PTR _lBlockOff$[ebp], 0

; 951  :    zPVOID             pv;
; 952  :    ConnectionRecord   cr = { 0 };

	mov	DWORD PTR _cr$[ebp], 0
	mov	ecx, 9
	xor	eax, eax
	lea	edi, DWORD PTR _cr$[ebp+4]
	rep stosd
	stosw
	stosb

; 953  :    zSHORT             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 954  :    zPVOID pp = 0;  // debug code

	mov	DWORD PTR _pp$[ebp], 0

; 955  : 
; 956  :    delete( pSockTask );

	mov	edx, DWORD PTR _pSockTask$[ebp]
	mov	DWORD PTR $T61378[ebp], edx
	mov	eax, DWORD PTR $T61378[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 957  : 
; 958  : #ifdef __WIN32__
; 959  :    static HANDLE      hMutexObject = 0;
; 960  :    static int         DoSync = 0;
; 961  :    // Valid values for DoSync:  0 = zeidon.ini not read yet
; 962  :    //                          -1 = dont use sync mechanisms
; 963  :    //                           1 = use sync Mechanism (Mutex)
; 964  : 
; 965  :    if ( DoSync == 0 )

	cmp	DWORD PTR _?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA, 0
	jne	SHORT $L60900

; 967  :       char szBuf[ 80 ];
; 968  : 
; 969  :       SysReadZeidonIni( -1, "[zWinSock]", "SyncServerAccess", szBuf );

	lea	ecx, DWORD PTR _szBuf$60898[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BB@BIOA@SyncServerAccess?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@IGEO@?$FLzWinSock?$FN?$AA@ ; `string'
	push	-1
	call	_SysReadZeidonIni@16

; 970  :       DoSync = atoi( szBuf );

	lea	edx, DWORD PTR _szBuf$60898[ebp]
	push	edx
	call	DWORD PTR __imp__atoi
	add	esp, 4
	mov	DWORD PTR _?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA, eax

; 971  :       if ( DoSync == 0 )

	cmp	DWORD PTR _?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA, 0
	jne	SHORT $L60900

; 972  :          DoSync = -1;   // atoi returns 0 if string was empty

	mov	DWORD PTR _?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA, -1
$L60900:

; 974  : 
; 975  :    if ( DoSync > 0 )

	cmp	DWORD PTR _?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA, 0
	jle	SHORT $L60901

; 977  :       if ( hMutexObject == 0 )

	cmp	DWORD PTR _?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA, 0
	jne	SHORT $L60902

; 978  :          hMutexObject = CreateMutex( 0, FALSE, "WINSOCK_WORKAROUND" );

	push	OFFSET FLAT:??_C@_0BD@ODND@WINSOCK_WORKAROUND?$AA@ ; `string'
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	DWORD PTR _?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA, eax
$L60902:

; 979  : 
; 980  :       if ( hMutexObject == 0 )

	cmp	DWORD PTR _?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA, 0
	jne	SHORT $L60904

; 981  :          goto EndOfFunction;

	jmp	$L60906
$L60904:

; 982  : 
; 983  :       WaitForSingleObject( hMutexObject, INFINITE );

	push	-1
	mov	eax, DWORD PTR _?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$L60901:

; 990  :                                    "\\\\Zeidon System\\", 0, 0 ) != 0 )

	push	0
	push	0
	push	OFFSET FLAT:??_C@_0BB@LFCK@?2?2Zeidon?5System?2?$AA@ ; `string'
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_RegisterZeidonApplication@28
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L60907

; 991  :       goto EndOfFunction;

	jmp	$L60909
$L60907:

; 992  : 
; 993  :    // Debug code - do a quick test to make sure that vSubtask is a valid
; 994  :    // pointer.
; 995  :    pp = (zPVOID) vSubtask->hTask;

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _pp$[ebp], ecx

; 996  : 
; 997  :    // Set up a buffer to receive network traffic.
; 998  :    cr.hBufferMem = (zLONG) malloc( BUFFER_LTH );

	push	32000					; 00007d00H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _cr$[ebp+32], eax

; 999  :    cr.pchBuffer = (zPCHAR) cr.hBufferMem;

	mov	edx, DWORD PTR _cr$[ebp+32]
	mov	DWORD PTR _cr$[ebp+4], edx

; 1000 :    if ( cr.pchBuffer == 0 )

	cmp	DWORD PTR _cr$[ebp+4], 0
	jne	SHORT $L60913

; 1002 :       SysMessageBox( 0, szlErrorTitle, "Out of memory", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0O@MNOP@Out?5of?5memory?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1003 :       goto EndOfFunction;

	jmp	$L60914
$L60913:

; 1005 : 
; 1006 :    // Init connection info.
; 1007 :    cr.sock        = sock;

	mov	eax, DWORD PTR _sock$[ebp]
	mov	DWORD PTR _cr$[ebp], eax

; 1008 :    cr.ulBufferLth = BUFFER_LTH;

	mov	DWORD PTR _cr$[ebp+20], 32000		; 00007d00H

; 1009 :    cr.pchNextByte = cr.pchBuffer;

	mov	ecx, DWORD PTR _cr$[ebp+4]
	mov	DWORD PTR _cr$[ebp+8], ecx

; 1010 :    cr.ulUnusedLth = 0;

	mov	DWORD PTR _cr$[ebp+16], 0

; 1011 :    cr.nTraceLevel = NetGetTraceLevel( vSubtask, "zWinSock" );

	push	OFFSET FLAT:??_C@_08GPBK@zWinSock?$AA@	; `string'
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_NetGetTraceLevel@8
	mov	WORD PTR _cr$[ebp+40], ax

; 1012 : 
; 1013 :    if ( cr.nTraceLevel > 0 )

	movsx	eax, WORD PTR _cr$[ebp+40]
	test	eax, eax
	jle	SHORT $L60915

; 1015 :                   cr.pchPeerName );

	mov	ecx, DWORD PTR _cr$[ebp+12]
	push	ecx
	push	OFFSET FLAT:??_C@_0CN@JPKP@?$CIzwinsock?$CJ?5A?5message?5has?5been?5re@ ; `string'
	call	_TraceLineS@8
$L60915:

; 1016 : 
; 1017 :    pv = &cr;

	lea	edx, DWORD PTR _cr$[ebp]
	mov	DWORD PTR _pv$[ebp], edx

; 1018 : 
; 1019 :    // If the trace level is > 0 then we'll call Core without a try block so
; 1020 :    // that we can catch crashes in the debugger.
; 1021 :    // In the production environment, TraceLevel should be set to zero so
; 1022 :    // that the errors will be handled and processing will continue.
; 1023 : #if 1
; 1024 :    nRC = NetProcessMessage( vSubtask, "zWinSock", &pv );

	lea	eax, DWORD PTR _pv$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08GPBK@zWinSock?$AA@	; `string'
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_NetProcessMessage@12
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$60905:

; 1025 : #else
; 1026 :    if ( cr.nTraceLevel > 0 )
; 1027 :       nRC = NetProcessMessage( vSubtask, "zWinSock", &pv );
; 1028 :    else
; 1029 :    {
; 1030 :       try
; 1031 :       {
; 1032 :          nRC = NetProcessMessage( vSubtask, "zWinSock", &pv );
; 1033 :       }
; 1034 :       catch ( ... )
; 1035 :       {
; 1036 :          zCHAR szMsg[ 200 ];
; 1037 :          zCHAR szDateTime[ 50 ];
; 1038 :          zCHAR szSysDateTime[ 30 ];
; 1039 : 
; 1040 :          SysGetDateTime( szSysDateTime );
; 1041 :          UfFormatDateTime( szDateTime, szSysDateTime, "YYYY-MM-DD HH:MI:SS" );
; 1042 :          zsprintf( szMsg, "(%s) Client %s created an exception in NetProcessMessage",
; 1043 :                    szDateTime, cr.pchPeerName );
; 1044 :          TraceLineS( "EXCEPTION >>>>>>>>>>>>>>>>>>>>>>>> zWinsock: ", szMsg );
; 1045 :       // SysMessageBox( 0, "Exception in zWinsock", szMsg, -1 );
; 1046 :       }
; 1047 :    }
; 1048 : #endif
; 1049 : 
; 1050 : EndOfFunction:
; 1051 : 
; 1052 :    // Close the connection
; 1053 :    zNetCloseConnection( (zPPVOID) &pv, (zPPVOID) &pv );

	lea	edx, DWORD PTR _pv$[ebp]
	push	edx
	lea	eax, DWORD PTR _pv$[ebp]
	push	eax
	call	_zNetCloseConnection@8

; 1054 : 
; 1055 :    if ( vSubtask )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $L60919

; 1056 :       UnregisterZeidonApplication( vSubtask );

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_UnregisterZeidonApplication@4
$L60919:

; 1057 : 
; 1058 :    #ifdef __WIN32__
; 1059 :       if ( DoSync > 0 )

	cmp	DWORD PTR _?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA, 0
	jle	SHORT $L60920

; 1060 :          ReleaseMutex( hMutexObject );

	mov	edx, DWORD PTR _?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA
	push	edx
	call	DWORD PTR __imp__ReleaseMutex@4
$L60920:

; 1061 :    #endif
; 1062 : 
; 1063 :    return( 0 );

	xor	eax, eax
	jmp	SHORT $L60880
$L60914:

; 1064 : 
; 1065 : } // fnProcessConnectionThreadProc

	jmp	SHORT $EndOfFunction$60905
$L60909:
	jmp	SHORT $EndOfFunction$60905
$L60906:
	jmp	SHORT $EndOfFunction$60905
$L60880:
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	4
_fnProcessConnectionThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	_fnListenThreadProc@4
PUBLIC	??_C@_0L@DNJN@ListenPort?$AA@			; `string'
PUBLIC	??_C@_04FBJP@bind?$AA@				; `string'
PUBLIC	??_C@_0O@PGKE@bind?$CI?$CJ?5failed?$AA@		; `string'
PUBLIC	??_C@_06IODP@listen?$AA@			; `string'
PUBLIC	??_C@_0BA@IPOC@listen?$CI?$CJ?5failed?$AA@	; `string'
PUBLIC	??_C@_0CN@KLFH@?$CIzWinSock?$CJ?5Waiting?5for?5client?5co@ ; `string'
PUBLIC	??_C@_0DA@DDGE@fnListenThreadProc?5trying?5to?5clo@ ; `string'
PUBLIC	??_C@_06JGM@accept?$AA@				; `string'
PUBLIC	??_C@_0BP@JNNA@accept?$CIsock?$CJ?5failed?5for?5listen?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	__imp__CloseHandle@4:NEAR
EXTRN	__imp___beginthreadex:NEAR
EXTRN	_accept@12:NEAR
EXTRN	_bind@12:NEAR
EXTRN	_listen@8:NEAR
;	COMDAT ??_C@_0L@DNJN@ListenPort?$AA@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_0L@DNJN@ListenPort?$AA@ DB 'ListenPort', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04FBJP@bind?$AA@
_DATA	SEGMENT
??_C@_04FBJP@bind?$AA@ DB 'bind', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@PGKE@bind?$CI?$CJ?5failed?$AA@
_DATA	SEGMENT
??_C@_0O@PGKE@bind?$CI?$CJ?5failed?$AA@ DB 'bind() failed', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IODP@listen?$AA@
_DATA	SEGMENT
??_C@_06IODP@listen?$AA@ DB 'listen', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@IPOC@listen?$CI?$CJ?5failed?$AA@
_DATA	SEGMENT
??_C@_0BA@IPOC@listen?$CI?$CJ?5failed?$AA@ DB 'listen() failed', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CN@KLFH@?$CIzWinSock?$CJ?5Waiting?5for?5client?5co@
_DATA	SEGMENT
??_C@_0CN@KLFH@?$CIzWinSock?$CJ?5Waiting?5for?5client?5co@ DB '(zWinSock)'
	DB	' Waiting for client connections...', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DA@DDGE@fnListenThreadProc?5trying?5to?5clo@
_DATA	SEGMENT
??_C@_0DA@DDGE@fnListenThreadProc?5trying?5to?5clo@ DB 'fnListenThreadPro'
	DB	'c trying to close ListenSocket', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JGM@accept?$AA@
_DATA	SEGMENT
??_C@_06JGM@accept?$AA@ DB 'accept', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@JNNA@accept?$CIsock?$CJ?5failed?5for?5listen?$AA@
_DATA	SEGMENT
??_C@_0BP@JNNA@accept?$CIsock?$CJ?5failed?5for?5listen?$AA@ DB 'accept(so'
	DB	'ck) failed for listen', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_p$ = 8
_nTraceLevel$ = -12
_szPort$ = -64
_lpListenInfo$ = -8
_vSubtask$ = -44
_hTask$ = -24
_listenSocket$ = -20
_saServer$ = -40
_nRet$ = -16
_pSockTask$ = -4
_hConnThread$60965 = -72
_dwThreadID$60966 = -68
$T61380 = -76
$T61381 = -80
$T61382 = -84
$T61383 = -88
_fnListenThreadProc@4 PROC NEAR

; 1073 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 1074 :    zSHORT       nTraceLevel = 1; // NetGetTraceLevel( lpView, "zWinSock" );

	mov	WORD PTR _nTraceLevel$[ebp], 1

; 1075 :    char         szPort[ 20 ];
; 1076 :    LPLISTENINFO lpListenInfo = (LPLISTENINFO) p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _lpListenInfo$[ebp], eax

; 1077 :    zVIEW        vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 1078 : // SOCKET       NewSocket;
; 1079 :    LPTASK       hTask = lpListenInfo->hTask;

	mov	ecx, DWORD PTR _lpListenInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _hTask$[ebp], edx

; 1080 : 
; 1081 : #ifdef __UNIX__
; 1082 : 
; 1083 :    if ( RegisterZeidonApplication( &vSubtask, 0, 0, 0,
; 1084 :                                    "\\\\Zeidon System\\", 0, 0 ) != 0 )
; 1085 :    {
; 1086 :       TraceLineS( "ERROR Registering app ERROR", "" );
; 1087 :       return( 0 );
; 1088 :    }
; 1089 : 
; 1090 :    TraceLineI( "New thread task id = ", SysGetTaskID( ) );
; 1091 : 
; 1092 : #endif
; 1093 : 
; 1094 :    // We'll assume that we return an error until proven otherwise.
; 1095 :    lpListenInfo->nRC = zCALL_ERROR;

	mov	eax, DWORD PTR _lpListenInfo$[ebp]
	mov	WORD PTR [eax+8], -16			; fffffff0H

; 1096 : 
; 1097 :    // Get port number.
; 1098 :    if ( g_nListenPort == -1 )

	movsx	ecx, WORD PTR _g_nListenPort
	cmp	ecx, -1
	jne	SHORT $L60931

; 1100 :       SysReadZeidonIni( -1, "[zWinSock]", "ListenPort", szPort );

	lea	edx, DWORD PTR _szPort$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0L@DNJN@ListenPort?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@IGEO@?$FLzWinSock?$FN?$AA@ ; `string'
	push	-1
	call	_SysReadZeidonIni@16

; 1101 :       g_nListenPort = (short) zatol( szPort );

	lea	eax, DWORD PTR _szPort$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _g_nListenPort, ax
$L60931:

; 1108 : 
; 1109 :    listenSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );

	push	6
	push	1
	push	2
	call	_socket@12
	mov	DWORD PTR _listenSocket$[ebp], eax

; 1110 :    if ( listenSocket == INVALID_SOCKET )

	cmp	DWORD PTR _listenSocket$[ebp], -1
	jne	SHORT $L60936

; 1112 :       SHOWERROR( "socket" );

	push	OFFSET FLAT:??_C@_06KDPK@socket?$AA@	; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1113 :       SysMessageBox( 0, szlErrorTitle, "socket() failed", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0BA@HGG@socket?$CI?$CJ?5failed?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1114 : 
; 1115 :       g_bListenThreadStarted = TRUE;

	mov	BYTE PTR ?g_bListenThreadStarted@@3EA, 1 ; g_bListenThreadStarted

; 1116 :       return( 0 );

	xor	eax, eax
	jmp	$L60924
$L60936:

; 1123 : 
; 1124 :    saServer.sin_family = AF_INET;

	mov	WORD PTR _saServer$[ebp], 2

; 1125 :    saServer.sin_addr.s_addr = INADDR_ANY;  // Let WinSock supply address

	mov	DWORD PTR _saServer$[ebp+4], 0

; 1126 :    saServer.sin_port = htons( (short) g_nListenPort );

	mov	cx, WORD PTR _g_nListenPort
	push	ecx
	call	_htons@4
	mov	WORD PTR _saServer$[ebp+2], ax

; 1127 : 
; 1128 :    //
; 1129 :    // bind the name to the socket
; 1130 :    //
; 1131 :    int nRet;
; 1132 : 
; 1133 :    nRet = bind( listenSocket, (PSOCKADDR) &saServer, sizeof( struct sockaddr ) );

	push	16					; 00000010H
	lea	edx, DWORD PTR _saServer$[ebp]
	push	edx
	mov	eax, DWORD PTR _listenSocket$[ebp]
	push	eax
	call	_bind@12
	mov	DWORD PTR _nRet$[ebp], eax

; 1134 :    if ( nRet == SOCKET_ERROR )

	cmp	DWORD PTR _nRet$[ebp], -1
	jne	SHORT $L60943

; 1136 :       SHOWERROR( "bind" );

	push	OFFSET FLAT:??_C@_04FBJP@bind?$AA@	; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1137 :       SysMessageBox( 0, szlErrorTitle, "bind() failed", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0O@PGKE@bind?$CI?$CJ?5failed?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1138 :       g_bListenThreadStarted = TRUE;

	mov	BYTE PTR ?g_bListenThreadStarted@@3EA, 1 ; g_bListenThreadStarted

; 1139 :       closesocket( listenSocket );

	mov	ecx, DWORD PTR _listenSocket$[ebp]
	push	ecx
	call	_closesocket@4

; 1140 :       return( 0 );

	xor	eax, eax
	jmp	$L60924
$L60943:

; 1142 : 
; 1143 :    nRet = listen( listenSocket, MAX_PENDING_CONNECTS );

	push	16					; 00000010H
	mov	edx, DWORD PTR _listenSocket$[ebp]
	push	edx
	call	_listen@8
	mov	DWORD PTR _nRet$[ebp], eax

; 1144 :    if ( nRet == SOCKET_ERROR )

	cmp	DWORD PTR _nRet$[ebp], -1
	jne	SHORT $L60946

; 1146 :       SHOWERROR( "listen" );

	push	OFFSET FLAT:??_C@_06IODP@listen?$AA@	; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1147 :       SysMessageBox( 0, szlErrorTitle, "listen() failed", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0BA@IPOC@listen?$CI?$CJ?5failed?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1148 :       g_bListenThreadStarted = TRUE;

	mov	BYTE PTR ?g_bListenThreadStarted@@3EA, 1 ; g_bListenThreadStarted

; 1149 :       closesocket( listenSocket );

	mov	eax, DWORD PTR _listenSocket$[ebp]
	push	eax
	call	_closesocket@4

; 1150 :       return( 0 );

	xor	eax, eax
	jmp	$L60924
$L60946:

; 1152 : 
; 1153 :    // Listen started OK so set return.
; 1154 :    lpListenInfo->nRC = 0;

	mov	ecx, DWORD PTR _lpListenInfo$[ebp]
	mov	WORD PTR [ecx+8], 0

; 1155 :    lpListenInfo->lpSockets->sockListen = listenSocket;

	mov	edx, DWORD PTR _lpListenInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _listenSocket$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 1156 : 
; 1157 :    // At this point everything's good so let's start waiting for connections.
; 1158 :    // Setting this flag allow the parent thread to continue.
; 1159 :    g_bListenThreadStarted = TRUE;

	mov	BYTE PTR ?g_bListenThreadStarted@@3EA, 1 ; g_bListenThreadStarted

; 1160 : 
; 1161 :    TraceLineS( "(zWinSock) Waiting for client connections...", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CN@KLFH@?$CIzWinSock?$CJ?5Waiting?5for?5client?5co@ ; `string'
	call	_TraceLineS@8
$L60952:

; 1162 : 
; 1163 :    zSOCKTASK    *pSockTask;
; 1164 : 
; 1165 :    // Loop until we the listen socket is closed.
; 1166 :    while ( TRUE )

	mov	edx, 1
	test	edx, edx
	je	$L60953

; 1168 :       if ( g_bClosingListenSocket )

	xor	eax, eax
	mov	al, BYTE PTR ?g_bClosingListenSocket@@3EA ; g_bClosingListenSocket
	test	eax, eax
	je	SHORT $L60954

; 1169 :          TraceLineS( "fnListenThreadProc trying to close ListenSocket", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0DA@DDGE@fnListenThreadProc?5trying?5to?5clo@ ; `string'
	call	_TraceLineS@8
$L60954:

; 1170 : 
; 1171 : #ifdef __UNIX__x
; 1172 :       fd_set         ready;
; 1173 :       struct timeval sTimeVal;
; 1174 : 
; 1175 :       // Call select() to see if there are any connections waiting.
; 1176 :       FD_ZERO( &ready );
; 1177 :       FD_SET( listenSocket, &ready );
; 1178 : 
; 1179 :       if ( select( listenSocket + 1, &ready, 0, 0, 0 ) < 0 )
; 1180 :       {
; 1181 :          SHOWERROR( "select" );
; 1182 :          break;
; 1183 :       }
; 1184 : 
; 1185 :       // If socket doesn't have any connections waiting, then continue loop.
; 1186 :       if ( !FD_ISSET( listenSocket, &ready ) )
; 1187 :          continue;
; 1188 : #endif
; 1189 : 
; 1190 :       // On a successful connection, fnProcessConnectionThreadProc is
; 1191 :       // responsible for deleting pSockTask!
; 1192 :       pSockTask = new zSOCKTASK;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T61380[ebp], eax
	mov	ecx, DWORD PTR $T61380[ebp]
	mov	DWORD PTR _pSockTask$[ebp], ecx

; 1193 :       pSockTask->hTask = hTask;

	mov	edx, DWORD PTR _pSockTask$[ebp]
	mov	eax, DWORD PTR _hTask$[ebp]
	mov	DWORD PTR [edx], eax

; 1194 :       pSockTask->sock = accept( listenSocket, 0, 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _listenSocket$[ebp]
	push	ecx
	call	_accept@12
	mov	edx, DWORD PTR _pSockTask$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1195 :       if ( pSockTask->sock == INVALID_SOCKET )

	mov	eax, DWORD PTR _pSockTask$[ebp]
	cmp	DWORD PTR [eax+4], -1
	jne	SHORT $L60959

; 1197 :          // It's possible we received the error because the socket was closed
; 1198 :          // by another thread.  In this case we'll ignore the error and just
; 1199 :          // return.
; 1200 :          if ( g_bClosingListenSocket )

	xor	ecx, ecx
	mov	cl, BYTE PTR ?g_bClosingListenSocket@@3EA ; g_bClosingListenSocket
	test	ecx, ecx
	je	SHORT $L60960

; 1202 :             // Turn the flag back off so we can re-use it.  This also tells
; 1203 :             // the closing thread that we're done.
; 1204 :             g_bClosingListenSocket = FALSE;

	mov	BYTE PTR ?g_bClosingListenSocket@@3EA, 0 ; g_bClosingListenSocket

; 1205 :             delete( pSockTask );

	mov	edx, DWORD PTR _pSockTask$[ebp]
	mov	DWORD PTR $T61381[ebp], edx
	mov	eax, DWORD PTR $T61381[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1206 :             return( 0 );

	xor	eax, eax
	jmp	$L60924
$L60960:

; 1208 : 
; 1209 :          SHOWERROR( "accept" );

	push	OFFSET FLAT:??_C@_06JGM@accept?$AA@	; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1210 :          SysMessageBox( 0, szlErrorTitle, "accept(sock) failed for listen", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0BP@JNNA@accept?$CIsock?$CJ?5failed?5for?5listen?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1211 :          closesocket( listenSocket );

	mov	ecx, DWORD PTR _listenSocket$[ebp]
	push	ecx
	call	_closesocket@4

; 1212 :          delete( pSockTask );

	mov	edx, DWORD PTR _pSockTask$[ebp]
	mov	DWORD PTR $T61382[ebp], edx
	mov	eax, DWORD PTR $T61382[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1213 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $L60924
$L60959:

; 1232 :       UINT   dwThreadID;
; 1233 : 
; 1234 :       hConnThread = (HANDLE) _beginthreadex( 0, 0,  // security, stacksize,
; 1235 :                                              fnProcessConnectionThreadProc, // start address
; 1236 :                                              (zPVOID) pSockTask, 0,  // arglist, initial state
; 1237 :                                              &dwThreadID );  // thread identifier

	lea	ecx, DWORD PTR _dwThreadID$60966[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _pSockTask$[ebp]
	push	edx
	push	OFFSET FLAT:_fnProcessConnectionThreadProc@4
	push	0
	push	0
	call	DWORD PTR __imp___beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR _hConnThread$60965[ebp], eax

; 1238 :       if ( hConnThread )

	cmp	DWORD PTR _hConnThread$60965[ebp], 0
	je	SHORT $L60969

; 1239 :          CloseHandle( (HANDLE) hConnThread );

	mov	eax, DWORD PTR _hConnThread$60965[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 1240 :       else

	jmp	SHORT $L60971
$L60969:

; 1241 :          delete( pSockTask );

	mov	ecx, DWORD PTR _pSockTask$[ebp]
	mov	DWORD PTR $T61383[ebp], ecx
	mov	edx, DWORD PTR $T61383[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L60971:

; 1242 : #endif
; 1243 : 
; 1244 :    } // while ( TRUE )...

	jmp	$L60952
$L60953:

; 1245 : 
; 1246 :    if ( vSubtask )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $L60973

; 1247 :       UnregisterZeidonApplication( vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_UnregisterZeidonApplication@4
$L60973:

; 1248 : 
; 1249 :    return( 0 );

	xor	eax, eax
$L60924:

; 1250 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnListenThreadProc@4 ENDP
_TEXT	ENDS
PUBLIC	_zNetListen@12
EXTRN	__imp__Sleep@4:NEAR
_TEXT	SEGMENT
_ppHandle$ = 8
_lpView$ = 16
_lpSockets$ = -4
_LisnInfo$ = -16
_zNetListen@12 PROC NEAR

; 1273 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1274 :    LPSOCKETS         lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 1275 : // struct ListenInfo LisnInfo = { 0 };
; 1276 :    struct ListenInfo LisnInfo;
; 1277 : 
; 1278 :    // Set up info we need to pass to new thread.
; 1279 :    LisnInfo.hTask = lpView->hTask;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _LisnInfo$[ebp], eax

; 1280 :    LisnInfo.lpSockets = lpSockets;

	mov	ecx, DWORD PTR _lpSockets$[ebp]
	mov	DWORD PTR _LisnInfo$[ebp+4], ecx

; 1281 :    LisnInfo.nRC = 0;

	mov	WORD PTR _LisnInfo$[ebp+8], 0

; 1282 :    g_bListenThreadStarted = FALSE;

	mov	BYTE PTR ?g_bListenThreadStarted@@3EA, 0 ; g_bListenThreadStarted

; 1283 : 
; 1284 : #ifdef __UNIX__
; 1285 : 
; 1286 :    zSHORT      nTraceLevel = NetGetTraceLevel( lpView, "zwinsock" );
; 1287 :    pthread_t   NewThread;
; 1288 : 
; 1289 :    if ( nTraceLevel > 1 )
; 1290 :    {
; 1291 :       TraceLineS( "(zwinsock) Starting listen", "" );
; 1292 :    }
; 1293 : 
; 1294 :    // Create a thread to perform the listen.  This keeps the current
; 1295 :    // thread from being blocked.
; 1296 :    if ( pthread_create( &NewThread, 0, fnListenThreadProc, &LisnInfo ) != 0 )
; 1297 :    {
; 1298 :       TraceLineS( "Error starting Listen thread", "" );
; 1299 :       return( zCALL_ERROR );
; 1300 :    }
; 1301 : 
; 1302 :    TraceLineI( "Thread created = ", NewThread );
; 1303 : 
; 1304 :    lpSockets->tidListen = NewThread;
; 1305 : 
; 1306 : #else
; 1307 : 
; 1308 :    // Start up a thread to create the socket and wait for connections.
; 1309 :    g_hListenThread = _beginthreadex( 0, 0,  // security, stacksize
; 1310 :                                      fnListenThreadProc,
; 1311 :                                      (zPVOID) &LisnInfo, 0, // arglist, initflag
; 1312 :                                      &g_dwListenThreadID );

	push	OFFSET FLAT:?g_dwListenThreadID@@3IA	; g_dwListenThreadID
	push	0
	lea	edx, DWORD PTR _LisnInfo$[ebp]
	push	edx
	push	OFFSET FLAT:_fnListenThreadProc@4
	push	0
	push	0
	call	DWORD PTR __imp___beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR ?g_hListenThread@@3KA, eax	; g_hListenThread

; 1313 :    if ( g_hListenThread )

	cmp	DWORD PTR ?g_hListenThread@@3KA, 0	; g_hListenThread
	je	SHORT $L60983

; 1314 :       CloseHandle( (HANDLE) g_hListenThread );

	mov	eax, DWORD PTR ?g_hListenThread@@3KA	; g_hListenThread
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$L60983:

; 1315 : 
; 1316 : #endif
; 1317 : 
; 1318 :    // Now wait until the thread has finished its initialization.
; 1319 :    while ( g_bListenThreadStarted == FALSE )

	xor	ecx, ecx
	mov	cl, BYTE PTR ?g_bListenThreadStarted@@3EA ; g_bListenThreadStarted
	test	ecx, ecx
	jne	SHORT $L60987

; 1320 :       Sleep( 10 );

	push	10					; 0000000aH
	call	DWORD PTR __imp__Sleep@4
	jmp	SHORT $L60983
$L60987:

; 1321 : 
; 1322 :    return( LisnInfo.nRC );

	mov	ax, WORD PTR _LisnInfo$[ebp+8]

; 1323 : 
; 1324 : } // zNetListen

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_zNetListen@12 ENDP
_TEXT	ENDS
PUBLIC	_zNetStopListen@8
PUBLIC	??_C@_0BL@GKON@?$CIzwinsock?$CJ?5Stopping?5listen?$AA@ ; `string'
PUBLIC	??_C@_0BN@LIOO@?$CIzwinsock?$CJ?5No?5Listen?5socket?$CB?$AA@ ; `string'
PUBLIC	??_C@_0CN@ENIM@?$CIzwinsock?$CJ?5Error?5shutting?5down?5l@ ; `string'
PUBLIC	??_C@_0DH@IIDH@NetStopListen?5wait?5for?5socket?5to@ ; `string'
PUBLIC	??_C@_0BK@BAFL@?$CIzwinsock?$CJ?5Listen?5stopped?$AA@ ; `string'
;	COMDAT ??_C@_0BL@GKON@?$CIzwinsock?$CJ?5Stopping?5listen?$AA@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_0BL@GKON@?$CIzwinsock?$CJ?5Stopping?5listen?$AA@ DB '(zwinsock) Sto'
	DB	'pping listen', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@LIOO@?$CIzwinsock?$CJ?5No?5Listen?5socket?$CB?$AA@
_DATA	SEGMENT
??_C@_0BN@LIOO@?$CIzwinsock?$CJ?5No?5Listen?5socket?$CB?$AA@ DB '(zwinsoc'
	DB	'k) No Listen socket!', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CN@ENIM@?$CIzwinsock?$CJ?5Error?5shutting?5down?5l@
_DATA	SEGMENT
??_C@_0CN@ENIM@?$CIzwinsock?$CJ?5Error?5shutting?5down?5l@ DB '(zwinsock)'
	DB	' Error shutting down listen socket', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DH@IIDH@NetStopListen?5wait?5for?5socket?5to@
_DATA	SEGMENT
??_C@_0DH@IIDH@NetStopListen?5wait?5for?5socket?5to@ DB 'NetStopListen wa'
	DB	'it for socket to finish ... TERMINATED', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@BAFL@?$CIzwinsock?$CJ?5Listen?5stopped?$AA@
_DATA	SEGMENT
??_C@_0BK@BAFL@?$CIzwinsock?$CJ?5Listen?5stopped?$AA@ DB '(zwinsock) List'
	DB	'en stopped', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_ppHandle$ = 12
_lpSockets$ = -4
_nTraceLevel$ = -8
_lSleepCnt$ = -12
_zNetStopListen@8 PROC NEAR

; 1344 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1345 :    LPSOCKETS   lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 1346 :    zSHORT      nTraceLevel = NetGetTraceLevel( lpView, "zWinSock" );

	push	OFFSET FLAT:??_C@_08GPBK@zWinSock?$AA@	; `string'
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_NetGetTraceLevel@8
	mov	WORD PTR _nTraceLevel$[ebp], ax

; 1347 :    zLONG       lSleepCnt;
; 1348 : 
; 1349 :    if ( nTraceLevel > 1 )

	movsx	eax, WORD PTR _nTraceLevel$[ebp]
	cmp	eax, 1
	jle	SHORT $L60996

; 1350 :       TraceLineS( "(zwinsock) Stopping listen", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BL@GKON@?$CIzwinsock?$CJ?5Stopping?5listen?$AA@ ; `string'
	call	_TraceLineS@8
$L60996:

; 1351 : 
; 1352 :    if ( lpSockets->sockListen == INVALID_SOCKET )

	mov	ecx, DWORD PTR _lpSockets$[ebp]
	cmp	DWORD PTR [ecx+64], -1
	jne	SHORT $L60999

; 1354 :       TraceLineS( "(zwinsock) No Listen socket!", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BN@LIOO@?$CIzwinsock?$CJ?5No?5Listen?5socket?$CB?$AA@ ; `string'
	call	_TraceLineS@8

; 1355 :       return( 0 ); // return 0 because nothing was done.

	xor	ax, ax
	jmp	$L60991
$L60999:

; 1357 : 
; 1358 : #ifdef __UNIX__
; 1359 : 
; 1360 :    closesocket( lpSockets->sockListen );
; 1361 : 
; 1362 : #else
; 1363 : 
; 1364 :    // Set a flag indicating that we're closing the socket.  This allows the
; 1365 :    // thread handling the accept() call to ignore the error code returned
; 1366 :    // from accept( ).
; 1367 :    g_bClosingListenSocket = TRUE;

	mov	BYTE PTR ?g_bClosingListenSocket@@3EA, 1 ; g_bClosingListenSocket

; 1368 : 
; 1369 :    if ( closesocket( lpSockets->sockListen ) == SOCKET_ERROR )

	mov	edx, DWORD PTR _lpSockets$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	_closesocket@4
	cmp	eax, -1
	jne	SHORT $L61001

; 1371 :       TraceLineS( "(zwinsock) Error shutting down listen socket", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CN@ENIM@?$CIzwinsock?$CJ?5Error?5shutting?5down?5l@ ; `string'
	call	_TraceLineS@8

; 1372 :       SHOWERROR( "closesocket" );

	push	OFFSET FLAT:??_C@_0M@BGOH@closesocket?$AA@ ; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1373 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L60991
$L61001:

; 1375 : 
; 1376 :    // Now we'll wait until the thread handling the socket is finished.
; 1377 :    lSleepCnt = 0;

	mov	DWORD PTR _lSleepCnt$[ebp], 0
$L61004:

; 1378 :    while ( g_bClosingListenSocket )

	xor	ecx, ecx
	mov	cl, BYTE PTR ?g_bClosingListenSocket@@3EA ; g_bClosingListenSocket
	test	ecx, ecx
	je	SHORT $L61005

; 1380 :       lSleepCnt++;

	mov	edx, DWORD PTR _lSleepCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lSleepCnt$[ebp], edx

; 1381 :       if ( lSleepCnt > 10000 )

	cmp	DWORD PTR _lSleepCnt$[ebp], 10000	; 00002710H
	jle	SHORT $L61006

; 1383 :          SysMessageBox( 0, szlErrorTitle,
; 1384 :                         "NetStopListen wait for socket to finish ... TERMINATED", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0DH@IIDH@NetStopListen?5wait?5for?5socket?5to@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1385 :          g_bClosingListenSocket = FALSE;

	mov	BYTE PTR ?g_bClosingListenSocket@@3EA, 0 ; g_bClosingListenSocket
$L61006:

; 1387 : 
; 1388 :       Sleep( 100 );

	push	100					; 00000064H
	call	DWORD PTR __imp__Sleep@4

; 1389 :    }

	jmp	SHORT $L61004
$L61005:

; 1390 : #endif
; 1391 : 
; 1392 :    lpSockets->sockListen = INVALID_SOCKET;

	mov	eax, DWORD PTR _lpSockets$[ebp]
	mov	DWORD PTR [eax+64], -1

; 1393 : 
; 1394 :    if ( nTraceLevel > 1 )

	movsx	ecx, WORD PTR _nTraceLevel$[ebp]
	cmp	ecx, 1
	jle	SHORT $L61009

; 1395 :       TraceLineS( "(zwinsock) Listen stopped", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BK@BAFL@?$CIzwinsock?$CJ?5Listen?5stopped?$AA@ ; `string'
	call	_TraceLineS@8
$L61009:

; 1396 : 
; 1397 :    return( 0 );

	xor	ax, ax
$L60991:

; 1398 : 
; 1399 : } // zStopListen

	mov	esp, ebp
	pop	ebp
	ret	8
_zNetStopListen@8 ENDP
_TEXT	ENDS
PUBLIC	_zNetGetHostAddress@20
PUBLIC	??_C@_0CH@OIJA@?$CIzwinsock?$CJ?5Getting?5local?5host?5ad@ ; `string'
PUBLIC	??_C@_0M@PJMM@getpeername?$AA@			; `string'
PUBLIC	??_C@_0BF@GJMF@getpeername?$CI?$CJ?5failed?$AA@	; `string'
PUBLIC	??_C@_0O@IOIG@gethostbyaddr?$AA@		; `string'
PUBLIC	??_C@_0BH@BEDG@gethostbyaddr?$CI?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0CB@GPA@?$CIzwinsock?$CJ?5Local?5host?5address?5?$DN?5@ ; `string'
EXTRN	_getpeername@12:NEAR
EXTRN	_gethostbyaddr@12:NEAR
EXTRN	_gethostname@8:NEAR
;	COMDAT ??_C@_0CH@OIJA@?$CIzwinsock?$CJ?5Getting?5local?5host?5ad@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_0CH@OIJA@?$CIzwinsock?$CJ?5Getting?5local?5host?5ad@ DB '(zwinsock)'
	DB	' Getting local host address.', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@PJMM@getpeername?$AA@
_DATA	SEGMENT
??_C@_0M@PJMM@getpeername?$AA@ DB 'getpeername', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@GJMF@getpeername?$CI?$CJ?5failed?$AA@
_DATA	SEGMENT
??_C@_0BF@GJMF@getpeername?$CI?$CJ?5failed?$AA@ DB 'getpeername() failed', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@IOIG@gethostbyaddr?$AA@
_DATA	SEGMENT
??_C@_0O@IOIG@gethostbyaddr?$AA@ DB 'gethostbyaddr', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@BEDG@gethostbyaddr?$CI?$CJ?5failed?$AA@
_DATA	SEGMENT
??_C@_0BH@BEDG@gethostbyaddr?$CI?$CJ?5failed?$AA@ DB 'gethostbyaddr() fai'
	DB	'led', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@GPA@?$CIzwinsock?$CJ?5Local?5host?5address?5?$DN?5@
_DATA	SEGMENT
??_C@_0CB@GPA@?$CIzwinsock?$CJ?5Local?5host?5address?5?$DN?5@ DB '(zwinso'
	DB	'ck) Local host address = ', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_ppHandle$ = 12
_ppvConnPtr$ = 16
_cHost$ = 20
_pchHostAddress$ = 24
_lpSockets$ = -4
_nTraceLevel$ = -8
_lpConn$61024 = -12
_iLen$61027 = -20
_pHost$61028 = -16
_stRmtAddr$61029 = -36
_zNetGetHostAddress@20 PROC NEAR

; 1432 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1433 :    LPSOCKETS    lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 1434 :    zSHORT       nTraceLevel = NetGetTraceLevel( lpView, "zWinSock" );

	push	OFFSET FLAT:??_C@_08GPBK@zWinSock?$AA@	; `string'
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_NetGetTraceLevel@8
	mov	WORD PTR _nTraceLevel$[ebp], ax

; 1435 : 
; 1436 :    if ( nTraceLevel > 1 )

	movsx	eax, WORD PTR _nTraceLevel$[ebp]
	cmp	eax, 1
	jle	SHORT $L61021

; 1437 :       TraceLineS( "(zwinsock) Getting local host address.", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CH@OIJA@?$CIzwinsock?$CJ?5Getting?5local?5host?5ad@ ; `string'
	call	_TraceLineS@8
$L61021:

; 1438 : 
; 1439 :    if ( ppvConnPtr && cHost == 'R' )

	cmp	DWORD PTR _ppvConnPtr$[ebp], 0
	je	$L61023
	movsx	ecx, BYTE PTR _cHost$[ebp]
	cmp	ecx, 82					; 00000052H
	jne	$L61023

; 1441 :       LPCONNECTION lpConn = (LPCONNECTION) *ppvConnPtr;

	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpConn$61024[ebp], eax

; 1442 : 
; 1443 :       // Check to see if we've already retrieved the name of the client.
; 1444 :       if ( lpConn->pchPeerName == 0 )

	mov	ecx, DWORD PTR _lpConn$61024[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	$L61026

; 1446 :          socklen_t          iLen;
; 1447 :          PHOSTENT           pHost;
; 1448 :          struct sockaddr_in stRmtAddr;
; 1449 : 
; 1450 :          // Get the host address of the client.
; 1451 :          iLen = sizeof( struct sockaddr );

	mov	DWORD PTR _iLen$61027[ebp], 16		; 00000010H

; 1453 :                            &iLen ) == SOCKET_ERROR )

	lea	edx, DWORD PTR _iLen$61027[ebp]
	push	edx
	lea	eax, DWORD PTR _stRmtAddr$61029[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConn$61024[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_getpeername@12
	cmp	eax, -1
	jne	SHORT $L61032

; 1455 :             SHOWERROR( "getpeername" );

	push	OFFSET FLAT:??_C@_0M@PJMM@getpeername?$AA@ ; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1456 :             SysMessageBox( 0, szlErrorTitle, "getpeername() failed", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0BF@GJMF@getpeername?$CI?$CJ?5failed?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1457 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L61017
$L61032:

; 1461 :                                 4, AF_INET );

	push	2
	push	4
	lea	eax, DWORD PTR _stRmtAddr$61029[ebp+4]
	push	eax
	call	_gethostbyaddr@12
	mov	DWORD PTR _pHost$61028[ebp], eax

; 1462 :          if ( pHost == 0 )

	cmp	DWORD PTR _pHost$61028[ebp], 0
	jne	SHORT $L61036

; 1464 :             SHOWERROR( "gethostbyaddr" );

	push	OFFSET FLAT:??_C@_0O@IOIG@gethostbyaddr?$AA@ ; `string'
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1465 :             SysMessageBox( 0, szlErrorTitle, "gethostbyaddr() failed", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0BH@BEDG@gethostbyaddr?$CI?$CJ?5failed?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1466 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L61017
$L61036:

; 1468 : 
; 1469 :          // Set up peer name.
; 1470 :          lpConn->hPeerNameMem = (zLONG) malloc( zstrlen( pHost->h_name ) + 1 );

	mov	ecx, DWORD PTR _pHost$61028[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _lpConn$61024[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1471 :          lpConn->pchPeerName = (zPCHAR) lpConn->hPeerNameMem;

	mov	edx, DWORD PTR _lpConn$61024[ebp]
	mov	eax, DWORD PTR _lpConn$61024[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+12], ecx

; 1472 :          if ( lpConn->pchPeerName == 0 )

	mov	edx, DWORD PTR _lpConn$61024[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $L61041

; 1474 :             SysMessageBox( 0, szlErrorTitle, "Out of memory", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0O@MNOP@Out?5of?5memory?$AA@ ; `string'
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1475 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L61017
$L61041:

; 1477 : 
; 1478 :          zstrcpy( lpConn->pchPeerName, pHost->h_name );

	mov	eax, DWORD PTR _pHost$61028[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lpConn$61024[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_strcpy
	add	esp, 8
$L61026:

; 1480 : 
; 1481 :       zstrcpy( pchHostAddress, lpConn->pchPeerName );

	mov	ecx, DWORD PTR _lpConn$61024[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pchHostAddress$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1483 :    else

	jmp	SHORT $L61042
$L61023:

; 1485 :       gethostname( pchHostAddress, 300 );

	push	300					; 0000012cH
	mov	ecx, DWORD PTR _pchHostAddress$[ebp]
	push	ecx
	call	_gethostname@8
$L61042:

; 1490 : 
; 1491 :    if ( nTraceLevel > 1 )

	movsx	edx, WORD PTR _nTraceLevel$[ebp]
	cmp	edx, 1
	jle	SHORT $L61043

; 1492 :       TraceLineS( "(zwinsock) Local host address = ", pchHostAddress );

	mov	eax, DWORD PTR _pchHostAddress$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CB@GPA@?$CIzwinsock?$CJ?5Local?5host?5address?5?$DN?5@ ; `string'
	call	_TraceLineS@8
$L61043:

; 1493 : 
; 1494 :    return( 0 );

	xor	ax, ax
$L61017:

; 1495 : 
; 1496 : } // zStopListen

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_zNetGetHostAddress@20 ENDP
_TEXT	ENDS
PUBLIC	_zNetStart@8
PUBLIC	??_C@_0CD@JNBC@Error?5loading?5starting?5WinSock?3?5@ ; `string'
PUBLIC	??_C@_0CC@KNMK@?$CIzwinsock?$CJ?5WinSock?5Version?5?5?5?5?5?$DN@ ; `string'
PUBLIC	??_C@_0CC@GEAN@?$CIzwinsock?$CJ?5WinSock?5HighVersion?5?$DN@ ; `string'
PUBLIC	??_C@_0CC@KOGD@?$CIzwinsock?$CJ?5WinSock?5Description?5?$DN@ ; `string'
PUBLIC	??_C@_0CC@OHKN@?$CIzwinsock?$CJ?5System?5status?5?5?5?5?5?5?5?$DN@ ; `string'
PUBLIC	??_C@_0CC@BDKG@?$CIzwinsock?$CJ?5Max?5sockets?5?5?5?5?5?5?5?5?5?$DN@ ; `string'
PUBLIC	??_C@_0CC@NMMM@?$CIzwinsock?$CJ?5Max?5UPD?5datagram?5?5?5?5?$DN@ ; `string'
PUBLIC	??_C@_0CE@PEIO@Out?5of?5memory?5starting?5network?5?8@ ; `string'
EXTRN	_TraceLineX@8:NEAR
EXTRN	_WSAStartup@8:NEAR
EXTRN	_WSACleanup@0:NEAR
;	COMDAT ??_C@_0CD@JNBC@Error?5loading?5starting?5WinSock?3?5@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_0CD@JNBC@Error?5loading?5starting?5WinSock?3?5@ DB 'Error loading s'
	DB	'tarting WinSock: %d', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@KNMK@?$CIzwinsock?$CJ?5WinSock?5Version?5?5?5?5?5?$DN@
_DATA	SEGMENT
??_C@_0CC@KNMK@?$CIzwinsock?$CJ?5WinSock?5Version?5?5?5?5?5?$DN@ DB '(zwi'
	DB	'nsock) WinSock Version     = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@GEAN@?$CIzwinsock?$CJ?5WinSock?5HighVersion?5?$DN@
_DATA	SEGMENT
??_C@_0CC@GEAN@?$CIzwinsock?$CJ?5WinSock?5HighVersion?5?$DN@ DB '(zwinsoc'
	DB	'k) WinSock HighVersion = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@KOGD@?$CIzwinsock?$CJ?5WinSock?5Description?5?$DN@
_DATA	SEGMENT
??_C@_0CC@KOGD@?$CIzwinsock?$CJ?5WinSock?5Description?5?$DN@ DB '(zwinsoc'
	DB	'k) WinSock Description = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@OHKN@?$CIzwinsock?$CJ?5System?5status?5?5?5?5?5?5?5?$DN@
_DATA	SEGMENT
??_C@_0CC@OHKN@?$CIzwinsock?$CJ?5System?5status?5?5?5?5?5?5?5?$DN@ DB '(z'
	DB	'winsock) System status       = ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@BDKG@?$CIzwinsock?$CJ?5Max?5sockets?5?5?5?5?5?5?5?5?5?$DN@
_DATA	SEGMENT
??_C@_0CC@BDKG@?$CIzwinsock?$CJ?5Max?5sockets?5?5?5?5?5?5?5?5?5?$DN@ DB '('
	DB	'zwinsock) Max sockets         = ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@NMMM@?$CIzwinsock?$CJ?5Max?5UPD?5datagram?5?5?5?5?$DN@
_DATA	SEGMENT
??_C@_0CC@NMMM@?$CIzwinsock?$CJ?5Max?5UPD?5datagram?5?5?5?5?$DN@ DB '(zwi'
	DB	'nsock) Max UPD datagram    = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CE@PEIO@Out?5of?5memory?5starting?5network?5?8@
_DATA	SEGMENT
??_C@_0CE@PEIO@Out?5of?5memory?5starting?5network?5?8@ DB 'Out of memory '
	DB	'starting network ''%s''', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchNetworkName$ = 8
_ppHandle$ = 12
_hMemHandle$ = -4
_lpSockets$ = -408
_dummy1$ = -420
_WSAData$ = -404
_dummy2$ = -436
_status$ = -424
_szTemp$61056 = -516
_szTemp$61068 = -596
_zNetStart@8 PROC NEAR

; 1521 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 596				; 00000254H

; 1522 :    zLONG     hMemHandle;
; 1523 :    LPSOCKETS lpSockets;
; 1524 : 
; 1525 : #ifdef __WIN32__
; 1526 : 
; 1527 :    char      dummy1[ 10 ]; // BoundsChecker reported an error that said
; 1528 :    WSADATA   WSAData;      // WSAStartup() was writing past WSAData.  Dummy
; 1529 :    char      dummy2[ 10 ]; // vars are to protect stack.
; 1530 :    int       status;
; 1531 : 
; 1532 :    // Following is to stop compiler warnings:
; 1533 :    *dummy1 = *dummy2 = 0;

	mov	BYTE PTR _dummy2$[ebp], 0
	mov	al, BYTE PTR _dummy2$[ebp]
	mov	BYTE PTR _dummy1$[ebp], al

; 1534 : 
; 1535 :    *ppHandle = 0;

	mov	ecx, DWORD PTR _ppHandle$[ebp]
	mov	DWORD PTR [ecx], 0

; 1536 : 
; 1537 :    if ( (status = WSAStartup( 0x0101, &WSAData )) != 0 )

	lea	edx, DWORD PTR _WSAData$[ebp]
	push	edx
	push	257					; 00000101H
	call	_WSAStartup@8
	mov	DWORD PTR _status$[ebp], eax
	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $L61055

; 1539 :       char szTemp[ 80 ];
; 1540 : 
; 1541 :       sprintf( szTemp, "Error loading starting WinSock: %d", status );

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CD@JNBC@Error?5loading?5starting?5WinSock?3?5@ ; `string'
	lea	ecx, DWORD PTR _szTemp$61056[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 1542 :       SysMessageBox( 0, szlErrorTitle, szTemp, -1 );

	push	-1
	lea	edx, DWORD PTR _szTemp$61056[ebp]
	push	edx
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1543 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L61048
$L61055:

; 1545 : 
; 1546 : // TraceLineX( "(zwinsock) Task ID             = ", (zLONG) SysGetTaskID( ) );
; 1547 :    TraceLineX( "(zwinsock) WinSock Version     = ", WSAData.wVersion );

	mov	eax, DWORD PTR _WSAData$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	push	OFFSET FLAT:??_C@_0CC@KNMK@?$CIzwinsock?$CJ?5WinSock?5Version?5?5?5?5?5?$DN@ ; `string'
	call	_TraceLineX@8

; 1548 :    TraceLineX( "(zwinsock) WinSock HighVersion = ", WSAData.wHighVersion );

	mov	ecx, DWORD PTR _WSAData$[ebp+2]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	push	OFFSET FLAT:??_C@_0CC@GEAN@?$CIzwinsock?$CJ?5WinSock?5HighVersion?5?$DN@ ; `string'
	call	_TraceLineX@8

; 1549 :    TraceLineS( "(zwinsock) WinSock Description = ", WSAData.szDescription );

	lea	edx, DWORD PTR _WSAData$[ebp+4]
	push	edx
	push	OFFSET FLAT:??_C@_0CC@KOGD@?$CIzwinsock?$CJ?5WinSock?5Description?5?$DN@ ; `string'
	call	_TraceLineS@8

; 1550 :    TraceLineS( "(zwinsock) System status       = ", WSAData.szSystemStatus );

	lea	eax, DWORD PTR _WSAData$[ebp+261]
	push	eax
	push	OFFSET FLAT:??_C@_0CC@OHKN@?$CIzwinsock?$CJ?5System?5status?5?5?5?5?5?5?5?$DN@ ; `string'
	call	_TraceLineS@8

; 1551 :    TraceLineI( "(zwinsock) Max sockets         = ", WSAData.iMaxSockets );

	mov	ecx, DWORD PTR _WSAData$[ebp+390]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	push	OFFSET FLAT:??_C@_0CC@BDKG@?$CIzwinsock?$CJ?5Max?5sockets?5?5?5?5?5?5?5?5?5?$DN@ ; `string'
	call	_TraceLineI@8

; 1552 :    TraceLineI( "(zwinsock) Max UPD datagram    = ", WSAData.iMaxUdpDg );

	mov	edx, DWORD PTR _WSAData$[ebp+392]
	and	edx, 65535				; 0000ffffH
	push	edx
	push	OFFSET FLAT:??_C@_0CC@NMMM@?$CIzwinsock?$CJ?5Max?5UPD?5datagram?5?5?5?5?$DN@ ; `string'
	call	_TraceLineI@8

; 1553 : 
; 1554 : #endif // __WIN32__
; 1555 : 
; 1556 :    hMemHandle = (zLONG) malloc( sizeof( SocketsRecord ) );

	push	72					; 00000048H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _hMemHandle$[ebp], eax

; 1557 :    *ppHandle = (zPCHAR) hMemHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR _hMemHandle$[ebp]
	mov	DWORD PTR [eax], ecx

; 1558 :    if ( *ppHandle == 0 )

	mov	edx, DWORD PTR _ppHandle$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L61067

; 1560 :       char szTemp[ 80 ];
; 1561 : 
; 1562 : #ifdef __WIN32__
; 1563 :       WSACleanup();

	call	_WSACleanup@0

; 1564 :       wsprintf( szTemp, "Out of memory starting network '%s'", pchNetworkName );

	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CE@PEIO@Out?5of?5memory?5starting?5network?5?8@ ; `string'
	lea	ecx, DWORD PTR _szTemp$61068[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 1565 :       SysMessageBox( 0, szlErrorTitle, szTemp, -1 );

	push	-1
	lea	edx, DWORD PTR _szTemp$61068[ebp]
	push	edx
	push	OFFSET FLAT:?szlErrorTitle@@3PADA	; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1566 : #endif
; 1567 : 
; 1568 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L61048
$L61067:

; 1570 : 
; 1571 :    lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 1572 :    zstrcpy( lpSockets->szNetworkName, pchNetworkName );

	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSockets$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1573 :    lpSockets->hMemHandle = hMemHandle;

	mov	ecx, DWORD PTR _lpSockets$[ebp]
	mov	edx, DWORD PTR _hMemHandle$[ebp]
	mov	DWORD PTR [ecx+60], edx

; 1574 :    lpSockets->sockListen = INVALID_SOCKET;

	mov	eax, DWORD PTR _lpSockets$[ebp]
	mov	DWORD PTR [eax+64], -1

; 1575 : 
; 1576 :    return( 0 );

	xor	ax, ax
$L61048:

; 1577 : 
; 1578 : } // zNetStart

	mov	esp, ebp
	pop	ebp
	ret	8
_zNetStart@8 ENDP
_TEXT	ENDS
PUBLIC	_zNetClose@8
PUBLIC	??_C@_0CK@EMAI@?$CIzwinsock?$CJ?5Shutting?5down?5network@ ; `string'
;	COMDAT ??_C@_0CK@EMAI@?$CIzwinsock?$CJ?5Shutting?5down?5network@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_0CK@EMAI@?$CIzwinsock?$CJ?5Shutting?5down?5network@ DB '(zwinsock) '
	DB	'Shutting down network zWinSock', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_ppHandle$ = 12
_lpSockets$ = -4
_zNetClose@8 PROC NEAR

; 1598 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1599 :    LPSOCKETS lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 1600 : 
; 1601 :    if ( NetGetTraceLevel( lpView, "zWinSock" ) > 0 )

	push	OFFSET FLAT:??_C@_08GPBK@zWinSock?$AA@	; `string'
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_NetGetTraceLevel@8
	movsx	eax, ax
	test	eax, eax
	jle	SHORT $L61078

; 1602 :       TraceLineS( "(zwinsock) Shutting down network zWinSock", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CK@EMAI@?$CIzwinsock?$CJ?5Shutting?5down?5network@ ; `string'
	call	_TraceLineS@8
$L61078:

; 1603 : 
; 1604 :    if ( lpSockets->sockListen != INVALID_SOCKET )

	mov	ecx, DWORD PTR _lpSockets$[ebp]
	cmp	DWORD PTR [ecx+64], -1
	je	SHORT $L61081

; 1605 :       zNetStopListen( lpView, ppHandle );

	mov	edx, DWORD PTR _ppHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_zNetStopListen@8
$L61081:

; 1606 : 
; 1607 : #if !defined(  __UNIX__ )
; 1608 :    WSACleanup();

	call	_WSACleanup@0

; 1609 : #endif
; 1610 : 
; 1611 :    // After the following call, lpSockets is no longer valid.
; 1612 :    free( (zPVOID) lpSockets->hMemHandle );

	mov	ecx, DWORD PTR _lpSockets$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4

; 1613 : 
; 1614 :    *ppHandle = 0;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	DWORD PTR [eax], 0

; 1615 : 
; 1616 :    return( 0 );

	xor	ax, ax

; 1617 : 
; 1618 : } // zNetClose

	mov	esp, ebp
	pop	ebp
	ret	8
_zNetClose@8 ENDP
_TEXT	ENDS
PUBLIC	_GetDirectoryList@8
PUBLIC	??_C@_08LFLP@KZFXFERO?$AA@			; `string'
PUBLIC	??_C@_08NHNM@APP_NAME?$AA@			; `string'
PUBLIC	??_C@_0M@LKKI@APPLICATION?$AA@			; `string'
PUBLIC	??_C@_0BA@FCJM@ApplicationName?$AA@		; `string'
PUBLIC	??_C@_0L@GHPH@APP_ADOBIN?$AA@			; `string'
PUBLIC	??_C@_01FDHG@?$CK?$AA@				; `string'
PUBLIC	??_C@_04OJFH@File?$AA@				; `string'
PUBLIC	??_C@_08NJLM@FileName?$AA@			; `string'
PUBLIC	??_C@_0BJ@DKAG@?$CFd?$CF02d?$CF02d?$CF02d?$CF02d?$CF02d?$CFd?$AA@ ; `string'
PUBLIC	??_C@_07LNLK@ModDate?$AA@			; `string'
PUBLIC	??_C@_08INFO@FileSize?$AA@			; `string'
EXTRN	_OrderEntityForView@12:NEAR
EXTRN	__imp__FindClose@4:NEAR
EXTRN	_CreateEntity@12:NEAR
EXTRN	__imp__FileTimeToSystemTime@8:NEAR
EXTRN	_SysAppendcDirSep@4:NEAR
EXTRN	__imp__FindFirstFileA@8:NEAR
EXTRN	__imp__FindNextFileA@8:NEAR
EXTRN	_GetStringFromAttribute@16:NEAR
EXTRN	_SetAttributeFromString@16:NEAR
EXTRN	_SetAttributeFromInteger@16:NEAR
EXTRN	_SetAttributeFromAttribute@24:NEAR
EXTRN	_strcat:NEAR
EXTRN	_SfActivateSysEmptyOI@16:NEAR
;	COMDAT ??_C@_08LFLP@KZFXFERO?$AA@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_08LFLP@KZFXFERO?$AA@ DB 'KZFXFERO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08NHNM@APP_NAME?$AA@
_DATA	SEGMENT
??_C@_08NHNM@APP_NAME?$AA@ DB 'APP_NAME', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@LKKI@APPLICATION?$AA@
_DATA	SEGMENT
??_C@_0M@LKKI@APPLICATION?$AA@ DB 'APPLICATION', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FCJM@ApplicationName?$AA@
_DATA	SEGMENT
??_C@_0BA@FCJM@ApplicationName?$AA@ DB 'ApplicationName', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GHPH@APP_ADOBIN?$AA@
_DATA	SEGMENT
??_C@_0L@GHPH@APP_ADOBIN?$AA@ DB 'APP_ADOBIN', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FDHG@?$CK?$AA@
_DATA	SEGMENT
??_C@_01FDHG@?$CK?$AA@ DB '*', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OJFH@File?$AA@
_DATA	SEGMENT
??_C@_04OJFH@File?$AA@ DB 'File', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08NJLM@FileName?$AA@
_DATA	SEGMENT
??_C@_08NJLM@FileName?$AA@ DB 'FileName', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@DKAG@?$CFd?$CF02d?$CF02d?$CF02d?$CF02d?$CF02d?$CFd?$AA@
_DATA	SEGMENT
??_C@_0BJ@DKAG@?$CFd?$CF02d?$CF02d?$CF02d?$CF02d?$CF02d?$CFd?$AA@ DB '%d%'
	DB	'02d%02d%02d%02d%02d%d', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07LNLK@ModDate?$AA@
_DATA	SEGMENT
??_C@_07LNLK@ModDate?$AA@ DB 'ModDate', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08INFO@FileSize?$AA@
_DATA	SEGMENT
??_C@_08INFO@FileSize?$AA@ DB 'FileSize', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvList$ = 8
_vAppList$ = 12
_FileData$ = -584
_hFind$ = -264
_vList$ = -588
_szFileName$ = -260
_szTimestamp$61105 = -640
_lpTime$61106 = -656
_GetDirectoryList@8 PROC NEAR

; 1679 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 656				; 00000290H

; 1680 :    WIN32_FIND_DATA FileData;
; 1681 :    HANDLE          hFind;
; 1682 :    zVIEW           vList;
; 1683 :    zCHAR           szFileName[ zMAX_FILENAME_LTH + 1 ];
; 1684 : 
; 1685 :    if ( *pvList == 0 )

	mov	eax, DWORD PTR _pvList$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L61091

; 1687 :       SfActivateSysEmptyOI( pvList, "KZFXFERO", 0, zMULTIPLE | zLEVEL_SYSTEM );

	push	264					; 00000108H
	push	0
	push	OFFSET FLAT:??_C@_08LFLP@KZFXFERO?$AA@	; `string'
	mov	ecx, DWORD PTR _pvList$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16

; 1688 :       CreateEntity( *pvList, "KZFXFERO", zPOS_FIRST );

	push	1
	push	OFFSET FLAT:??_C@_08LFLP@KZFXFERO?$AA@	; `string'
	mov	edx, DWORD PTR _pvList$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_CreateEntity@12

; 1689 :       SetAttributeFromAttribute( *pvList, "KZFXFERO", "ApplicationName",
; 1690 :                                  vAppList, "APPLICATION", "APP_NAME" );

	push	OFFSET FLAT:??_C@_08NHNM@APP_NAME?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@LKKI@APPLICATION?$AA@ ; `string'
	mov	ecx, DWORD PTR _vAppList$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BA@FCJM@ApplicationName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_08LFLP@KZFXFERO?$AA@	; `string'
	mov	edx, DWORD PTR _pvList$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SetAttributeFromAttribute@24
$L61091:

; 1692 : 
; 1693 :    vList = *pvList;  // Just so it's easier.

	mov	ecx, DWORD PTR _pvList$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _vList$[ebp], edx

; 1694 : 
; 1695 :    GetStringFromAttribute( szFileName, vAppList, "APPLICATION", "APP_ADOBIN" );

	push	OFFSET FLAT:??_C@_0L@GHPH@APP_ADOBIN?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0M@LKKI@APPLICATION?$AA@ ; `string'
	mov	eax, DWORD PTR _vAppList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 1696 :    SysAppendcDirSep( szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 1697 :    zstrcat( szFileName, "*" );

	push	OFFSET FLAT:??_C@_01FDHG@?$CK?$AA@	; `string'
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1698 : 
; 1699 :    hFind = FindFirstFile( szFileName, &FileData );

	lea	ecx, DWORD PTR _FileData$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__FindFirstFileA@8
	mov	DWORD PTR _hFind$[ebp], eax

; 1700 :    if ( hFind != INVALID_HANDLE_VALUE )

	cmp	DWORD PTR _hFind$[ebp], -1
	je	$L61100
$L61101:

; 1704 :          if ( ( FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) == 0 )

	mov	eax, DWORD PTR _FileData$[ebp]
	and	eax, 16					; 00000010H
	test	eax, eax
	jne	$L61104

; 1706 :             zCHAR      szTimestamp[ 50 ];
; 1707 :             SYSTEMTIME lpTime;
; 1708 : 
; 1709 :             CreateEntity( vList, "File", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	ecx, DWORD PTR _vList$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1710 :             SetAttributeFromString( vList, "File", "FileName",
; 1711 :                                     FileData.cFileName );

	lea	edx, DWORD PTR _FileData$[ebp+44]
	push	edx
	push	OFFSET FLAT:??_C@_08NJLM@FileName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	eax, DWORD PTR _vList$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1712 : 
; 1713 :             FileTimeToSystemTime( &FileData.ftLastWriteTime, &lpTime );

	lea	ecx, DWORD PTR _lpTime$61106[ebp]
	push	ecx
	lea	edx, DWORD PTR _FileData$[ebp+20]
	push	edx
	call	DWORD PTR __imp__FileTimeToSystemTime@8

; 1714 :             zsprintf( szTimestamp, "%d%02d%02d%02d%02d%02d%d",
; 1715 :                       lpTime.wYear, lpTime.wMonth, lpTime.wDay, lpTime.wHour,
; 1716 :                       lpTime.wMinute, lpTime.wSecond, lpTime.wMilliseconds );

	mov	eax, DWORD PTR _lpTime$61106[ebp+14]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _lpTime$61106[ebp+12]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	edx, DWORD PTR _lpTime$61106[ebp+10]
	and	edx, 65535				; 0000ffffH
	push	edx
	mov	eax, DWORD PTR _lpTime$61106[ebp+8]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _lpTime$61106[ebp+6]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	edx, DWORD PTR _lpTime$61106[ebp+2]
	and	edx, 65535				; 0000ffffH
	push	edx
	mov	eax, DWORD PTR _lpTime$61106[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	push	OFFSET FLAT:??_C@_0BJ@DKAG@?$CFd?$CF02d?$CF02d?$CF02d?$CF02d?$CF02d?$CFd?$AA@ ; `string'
	lea	ecx, DWORD PTR _szTimestamp$61105[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 36					; 00000024H

; 1717 :             SetAttributeFromString( vList, "File", "ModDate", szTimestamp );

	lea	edx, DWORD PTR _szTimestamp$61105[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_07LNLK@ModDate?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	eax, DWORD PTR _vList$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1718 :             SetAttributeFromInteger( vList, "File", "FileSize",
; 1719 :                                      FileData.nFileSizeLow );

	mov	ecx, DWORD PTR _FileData$[ebp+32]
	push	ecx
	push	OFFSET FLAT:??_C@_08INFO@FileSize?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	edx, DWORD PTR _vList$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16
$L61104:

; 1721 : 
; 1722 :       } while ( FindNextFile( hFind, &FileData ) );

	lea	eax, DWORD PTR _FileData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFind$[ebp]
	push	ecx
	call	DWORD PTR __imp__FindNextFileA@8
	test	eax, eax
	jne	$L61101

; 1723 : 
; 1724 :       FindClose( hFind );

	mov	edx, DWORD PTR _hFind$[ebp]
	push	edx
	call	DWORD PTR __imp__FindClose@4
$L61100:

; 1726 : 
; 1727 :    // Last thing...sort files by name so we can more quickly compare them.
; 1728 :    OrderEntityForView( vList, "File", "FileName" );

	push	OFFSET FLAT:??_C@_08NJLM@FileName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	eax, DWORD PTR _vList$[ebp]
	push	eax
	call	_OrderEntityForView@12

; 1729 : 
; 1730 :    return( 0 );

	xor	ax, ax

; 1731 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_GetDirectoryList@8 ENDP
_TEXT	ENDS
PUBLIC	_CompareFiles@4
PUBLIC	??_C@_06HLLH@ZEIDON?$AA@			; `string'
PUBLIC	??_C@_0L@IIHF@ZEIDON?4APP?$AA@			; `string'
PUBLIC	??_C@_08IHGG@KZAPPLOO?$AA@			; `string'
PUBLIC	??_C@_0CB@EELN@Error?3?5Couldn?8t?5find?5application@ ; `string'
PUBLIC	??_C@_0BJ@KHCK@Application?5Update?5Error?$AA@	; `string'
PUBLIC	??_C@_0BB@GEOD@MaxTotalFileSize?$AA@		; `string'
PUBLIC	??_C@_0CI@PKND@Performing?5Application?5Update?5fo@ ; `string'
PUBLIC	??_C@_0BG@DMEC@_ExecutableSourceList?$AA@	; `string'
PUBLIC	??_C@_01PCJP@Y?$AA@				; `string'
PUBLIC	??_C@_07MIME@Updated?$AA@			; `string'
PUBLIC	??_C@_04EGOH@Data?$AA@				; `string'
EXTRN	_GetViewByName@16:NEAR
EXTRN	_SetNameForView@16:NEAR
EXTRN	_DeleteEntity@12:NEAR
EXTRN	_SetCursorNextEntity@12:NEAR
EXTRN	_SetCursorFirstEntity@12:NEAR
EXTRN	_SetCursorFirstEntityByString@20:NEAR
EXTRN	_SetCursorFirstEntityByAttr@28:NEAR
EXTRN	_SysGetEnvVar@12:NEAR
EXTRN	_GetIntegerFromAttribute@16:NEAR
EXTRN	_SetBlobFromFile@16:NEAR
EXTRN	__imp___stricmp:NEAR
EXTRN	_CompareAttributeToAttribute@24:NEAR
EXTRN	_SetMatchingAttributesByName@20:NEAR
EXTRN	_SfActivateSysOI_FromFile@20:NEAR
;	COMDAT ??_C@_06HLLH@ZEIDON?$AA@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_06HLLH@ZEIDON?$AA@ DB 'ZEIDON', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@IIHF@ZEIDON?4APP?$AA@
_DATA	SEGMENT
??_C@_0L@IIHF@ZEIDON?4APP?$AA@ DB 'ZEIDON.APP', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IHGG@KZAPPLOO?$AA@
_DATA	SEGMENT
??_C@_08IHGG@KZAPPLOO?$AA@ DB 'KZAPPLOO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@EELN@Error?3?5Couldn?8t?5find?5application@
_DATA	SEGMENT
??_C@_0CB@EELN@Error?3?5Couldn?8t?5find?5application@ DB 'Error: Couldn'''
	DB	't find application', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@KHCK@Application?5Update?5Error?$AA@
_DATA	SEGMENT
??_C@_0BJ@KHCK@Application?5Update?5Error?$AA@ DB 'Application Update Err'
	DB	'or', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@GEOD@MaxTotalFileSize?$AA@
_DATA	SEGMENT
??_C@_0BB@GEOD@MaxTotalFileSize?$AA@ DB 'MaxTotalFileSize', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@PKND@Performing?5Application?5Update?5fo@
_DATA	SEGMENT
??_C@_0CI@PKND@Performing?5Application?5Update?5fo@ DB 'Performing Applic'
	DB	'ation Update for app: ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@DMEC@_ExecutableSourceList?$AA@
_DATA	SEGMENT
??_C@_0BG@DMEC@_ExecutableSourceList?$AA@ DB '_ExecutableSourceList', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PCJP@Y?$AA@
_DATA	SEGMENT
??_C@_01PCJP@Y?$AA@ DB 'Y', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_07MIME@Updated?$AA@
_DATA	SEGMENT
??_C@_07MIME@Updated?$AA@ DB 'Updated', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EGOH@Data?$AA@
_DATA	SEGMENT
??_C@_04EGOH@Data?$AA@ DB 'Data', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvList$ = 8
_nRC$ = -284
_nServerRC$ = -300
_nClientRC$ = -264
_nFileCount$ = -280
_lTotalFileSize$ = -296
_lFileSize$ = -276
_iNameIdx$ = -288
_vServerList$ = -268
_vAppList$ = -292
_vClientList$ = -272
_szFileName$ = -260
_szTemp$61136 = -400
_szServerFile$61146 = -920
_szClientFile$61147 = -660
_nCmprResult$61148 = -924
_CompareFiles@4 PROC NEAR

; 1741 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 924				; 0000039cH

; 1742 :    static zLONG lMaxTotalFileSize = 0;
; 1743 : 
; 1744 :    zSHORT nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 1745 :    zSHORT nServerRC;
; 1746 :    zSHORT nClientRC;
; 1747 :    zSHORT nFileCount = 0;

	mov	WORD PTR _nFileCount$[ebp], 0

; 1748 :    zLONG  lTotalFileSize = 0;

	mov	DWORD PTR _lTotalFileSize$[ebp], 0

; 1749 :    zLONG  lFileSize;
; 1750 :    zSHORT iNameIdx;
; 1751 :    zVIEW  vServerList = 0;

	mov	DWORD PTR _vServerList$[ebp], 0

; 1752 :    zVIEW  vAppList;
; 1753 :    zVIEW  vClientList = *pvList;

	mov	eax, DWORD PTR _pvList$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vClientList$[ebp], ecx

; 1754 :    zCHAR  szFileName[ zMAX_FILENAME_LTH + 1 ];
; 1755 : 
; 1756 :    // Activate the object containing the app list.
; 1757 :    SysGetEnvVar( szFileName, "ZEIDON", sizeof( szFileName ) );

	push	257					; 00000101H
	push	OFFSET FLAT:??_C@_06HLLH@ZEIDON?$AA@	; `string'
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysGetEnvVar@12

; 1758 :    SysAppendcDirSep( szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 1759 :    zstrcat( szFileName, "ZEIDON.APP" );

	push	OFFSET FLAT:??_C@_0L@IIHF@ZEIDON?4APP?$AA@ ; `string'
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1760 :    SfActivateSysOI_FromFile( &vAppList, "KZAPPLOO", 0, szFileName, 0 );

	push	0
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	0
	push	OFFSET FLAT:??_C@_08IHGG@KZAPPLOO?$AA@	; `string'
	lea	eax, DWORD PTR _vAppList$[ebp]
	push	eax
	call	_SfActivateSysOI_FromFile@20

; 1764 :                                     vClientList, "KZFXFERO", "ApplicationName",
; 1765 :                                     0 ) < zCURSOR_SET )

	push	0
	push	OFFSET FLAT:??_C@_0BA@FCJM@ApplicationName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_08LFLP@KZFXFERO?$AA@	; `string'
	mov	ecx, DWORD PTR _vClientList$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_08NHNM@APP_NAME?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@LKKI@APPLICATION?$AA@ ; `string'
	mov	edx, DWORD PTR _vAppList$[ebp]
	push	edx
	call	_SetCursorFirstEntityByAttr@28
	movsx	eax, ax
	test	eax, eax
	jge	SHORT $L61132

; 1767 :       SysMessageBox( *pvList, "Application Update Error",
; 1768 :                      "Error: Couldn't find application", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0CB@EELN@Error?3?5Couldn?8t?5find?5application@ ; `string'
	push	OFFSET FLAT:??_C@_0BJ@KHCK@Application?5Update?5Error?$AA@ ; `string'
	mov	ecx, DWORD PTR _pvList$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SysMessageBox@16

; 1769 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L61115
$L61132:

; 1771 : 
; 1772 :    // Get the list of executable files for the app server.
; 1773 :    GetStringFromAttribute( szFileName, vAppList, "APPLICATION", "APP_NAME" );

	push	OFFSET FLAT:??_C@_08NHNM@APP_NAME?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@LKKI@APPLICATION?$AA@ ; `string'
	mov	eax, DWORD PTR _vAppList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 1774 :    if ( lMaxTotalFileSize == 0 )

	cmp	DWORD PTR _?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA, 0
	jne	SHORT $L61139

; 1776 :       zCHAR szTemp[ 100 ];
; 1777 : 
; 1778 :       SysReadZeidonIni( -1, szFileName, "MaxTotalFileSize", szTemp );

	lea	edx, DWORD PTR _szTemp$61136[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BB@GEOD@MaxTotalFileSize?$AA@ ; `string'
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	-1
	call	_SysReadZeidonIni@16

; 1779 :       if ( *szTemp )

	movsx	ecx, BYTE PTR _szTemp$61136[ebp]
	test	ecx, ecx
	je	SHORT $L61138

; 1780 :          lMaxTotalFileSize = zatol( szTemp );

	lea	edx, DWORD PTR _szTemp$61136[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA, eax
$L61138:

; 1781 : 
; 1782 :       if ( lMaxTotalFileSize <= 0 )

	cmp	DWORD PTR _?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA, 0
	jg	SHORT $L61139

; 1783 :          lMaxTotalFileSize = 1000000;

	mov	DWORD PTR _?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA, 1000000 ; 000f4240H
$L61139:

; 1785 : 
; 1786 :    TraceLineS( "Performing Application Update for app: ", szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CI@PKND@Performing?5Application?5Update?5fo@ ; `string'
	call	_TraceLineS@8

; 1787 : 
; 1788 :    zstrcat( szFileName, "_ExecutableSourceList" );

	push	OFFSET FLAT:??_C@_0BG@DMEC@_ExecutableSourceList?$AA@ ; `string'
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1789 :    GetViewByName( &vServerList, szFileName, 0, zLEVEL_SYSTEM );

	push	8
	push	0
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vServerList$[ebp]
	push	eax
	call	_GetViewByName@16

; 1790 :    if ( vServerList == 0 )

	cmp	DWORD PTR _vServerList$[ebp], 0
	jne	SHORT $L61142

; 1792 :       GetDirectoryList( &vServerList, vAppList );

	mov	ecx, DWORD PTR _vAppList$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vServerList$[ebp]
	push	edx
	call	_GetDirectoryList@8

; 1793 :       SetNameForView( vServerList, szFileName, 0, zLEVEL_SYSTEM );

	push	8
	push	0
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vServerList$[ebp]
	push	ecx
	call	_SetNameForView@16
$L61142:

; 1795 : 
; 1796 :    GetStringFromAttribute( szFileName, vAppList, "APPLICATION", "APP_ADOBIN" );

	push	OFFSET FLAT:??_C@_0L@GHPH@APP_ADOBIN?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0M@LKKI@APPLICATION?$AA@ ; `string'
	mov	edx, DWORD PTR _vAppList$[ebp]
	push	edx
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 1797 :    SysAppendcDirSep( szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 1798 :    iNameIdx = zstrlen( szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _iNameIdx$[ebp], ax

; 1799 : 
; 1800 :    nClientRC = SetCursorFirstEntity( vClientList, "File", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	eax, DWORD PTR _vClientList$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nClientRC$[ebp], ax

; 1801 :    nServerRC = SetCursorFirstEntity( vServerList, "File", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	ecx, DWORD PTR _vServerList$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nServerRC$[ebp], ax
$L61144:

; 1802 :    while ( nServerRC >= zCURSOR_SET )

	movsx	edx, WORD PTR _nServerRC$[ebp]
	test	edx, edx
	jl	$L61145

; 1804 :       zCHAR szServerFile[ zMAX_FILENAME_LTH + 1 ];
; 1805 :       zCHAR szClientFile[ zMAX_FILENAME_LTH + 1 ];
; 1806 :       zSHORT nCmprResult;
; 1807 : 
; 1808 :       if ( nClientRC >= zCURSOR_SET )

	movsx	eax, WORD PTR _nClientRC$[ebp]
	test	eax, eax
	jl	SHORT $L61149

; 1810 :          GetStringFromAttribute( szServerFile, vServerList, "File", "FileName" );

	push	OFFSET FLAT:??_C@_08NJLM@FileName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	ecx, DWORD PTR _vServerList$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szServerFile$61146[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 1811 :          GetStringFromAttribute( szClientFile, vClientList, "File", "FileName" );

	push	OFFSET FLAT:??_C@_08NJLM@FileName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	eax, DWORD PTR _vClientList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szClientFile$61147[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 1812 : 
; 1813 :          nCmprResult = zstrcmpi( szServerFile, szClientFile );

	lea	edx, DWORD PTR _szClientFile$61147[ebp]
	push	edx
	lea	eax, DWORD PTR _szServerFile$61146[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _nCmprResult$61148[ebp], ax

; 1815 :       else

	jmp	SHORT $L61150
$L61149:

; 1816 :          nCmprResult = -1;

	mov	WORD PTR _nCmprResult$61148[ebp], -1
$L61150:

; 1817 : 
; 1818 :       if ( nCmprResult != 0 )

	movsx	ecx, WORD PTR _nCmprResult$61148[ebp]
	test	ecx, ecx
	je	SHORT $L61151

; 1820 :          // File names don't match.  Either a file exists on the server that
; 1821 :          // doesn't exist on the client or vice versa.  If the client file is
; 1822 :          // less than the server file then the file doesn't exist on the server.
; 1823 :          if ( nCmprResult > 0 )  // If client file is "lesser"

	movsx	edx, WORD PTR _nCmprResult$61148[ebp]
	test	edx, edx
	jle	SHORT $L61152

; 1825 :             nClientRC = SetCursorNextEntity( vClientList, "File", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	eax, DWORD PTR _vClientList$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nClientRC$[ebp], ax

; 1826 :             continue;

	jmp	$L61144
$L61152:

; 1828 : 
; 1829 :          // A file exists on the server that doesn't exist on the client.
; 1830 :          // Add a new entity to the client list.
; 1831 :          CreateEntity( vClientList, "File", zPOS_PREV );

	push	4
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	ecx, DWORD PTR _vClientList$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1832 :          SetMatchingAttributesByName( vClientList, "File",
; 1833 :                                       vServerList, "File", zSET_ALL );

	push	3
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	edx, DWORD PTR _vServerList$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	eax, DWORD PTR _vClientList$[ebp]
	push	eax
	call	_SetMatchingAttributesByName@20

; 1835 :       else

	jmp	SHORT $L61155
$L61151:

; 1837 :                                         vServerList, "File", "ModDate" ) == 0 )

	push	OFFSET FLAT:??_C@_07LNLK@ModDate?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	ecx, DWORD PTR _vServerList$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_07LNLK@ModDate?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	edx, DWORD PTR _vClientList$[ebp]
	push	edx
	call	_CompareAttributeToAttribute@24
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L61155

; 1839 :          // File mod dates match so we don't have to do anything.  Go on to
; 1840 :          // next files.
; 1841 :          nClientRC = SetCursorNextEntity( vClientList, "File", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	ecx, DWORD PTR _vClientList$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nClientRC$[ebp], ax

; 1842 :          nServerRC = SetCursorNextEntity( vServerList, "File", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	edx, DWORD PTR _vServerList$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nServerRC$[ebp], ax

; 1843 :          continue;

	jmp	$L61144
$L61155:

; 1845 : 
; 1846 :       // Keep track of the number of files we are downloading.
; 1847 :       nFileCount++;

	mov	ax, WORD PTR _nFileCount$[ebp]
	add	ax, 1
	mov	WORD PTR _nFileCount$[ebp], ax

; 1848 : 
; 1849 :       GetStringFromAttribute( &szFileName[ iNameIdx ],
; 1850 :                               vClientList, "File", "FileName" );

	push	OFFSET FLAT:??_C@_08NJLM@FileName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	ecx, DWORD PTR _vClientList$[ebp]
	push	ecx
	movsx	edx, WORD PTR _iNameIdx$[ebp]
	lea	eax, DWORD PTR _szFileName$[ebp+edx]
	push	eax
	call	_GetStringFromAttribute@16

; 1851 :       SetAttributeFromString( vClientList, "File", "Updated", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_07MIME@Updated?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	ecx, DWORD PTR _vClientList$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 1852 :       SetAttributeFromAttribute( vClientList, "File", "ModDate",
; 1853 :                                  vServerList, "File", "ModDate" );

	push	OFFSET FLAT:??_C@_07LNLK@ModDate?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	edx, DWORD PTR _vServerList$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_07LNLK@ModDate?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	eax, DWORD PTR _vClientList$[ebp]
	push	eax
	call	_SetAttributeFromAttribute@24

; 1854 :       SetBlobFromFile( vClientList, "File", "Data", szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04EGOH@Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	edx, DWORD PTR _vClientList$[ebp]
	push	edx
	call	_SetBlobFromFile@16

; 1855 : 
; 1856 :       // We only take so much at a time.
; 1857 :       GetIntegerFromAttribute( &lFileSize, vServerList, "File", "FileSize" );

	push	OFFSET FLAT:??_C@_08INFO@FileSize?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	eax, DWORD PTR _vServerList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lFileSize$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 1858 :       lTotalFileSize += lFileSize;

	mov	edx, DWORD PTR _lTotalFileSize$[ebp]
	add	edx, DWORD PTR _lFileSize$[ebp]
	mov	DWORD PTR _lTotalFileSize$[ebp], edx

; 1859 :       if ( lTotalFileSize > lMaxTotalFileSize )

	mov	eax, DWORD PTR _lTotalFileSize$[ebp]
	cmp	eax, DWORD PTR _?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA
	jle	SHORT $L61159

; 1861 :          nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1

; 1862 :          break;

	jmp	SHORT $L61145
$L61159:

; 1864 : 
; 1865 :       nClientRC = SetCursorNextEntity( vClientList, "File", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	ecx, DWORD PTR _vClientList$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nClientRC$[ebp], ax

; 1866 :       nServerRC = SetCursorNextEntity( vServerList, "File", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	edx, DWORD PTR _vServerList$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nServerRC$[ebp], ax

; 1867 :    }

	jmp	$L61144
$L61145:

; 1871 :                                          0 ) >= zCURSOR_SET )

	push	0
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_07MIME@Updated?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	eax, DWORD PTR _vClientList$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jl	SHORT $L61162

; 1873 :       DeleteEntity( vClientList, "File", zREPOS_FIRST );

	push	1
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	edx, DWORD PTR _vClientList$[ebp]
	push	edx
	call	_DeleteEntity@12

; 1874 :    }

	jmp	SHORT $L61145
$L61162:

; 1875 : 
; 1876 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L61115:

; 1877 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_CompareFiles@4 ENDP
_TEXT	ENDS
PUBLIC	__zCall_CompareFiles@8
PUBLIC	??_C@_0M@BKKK@ReturnValue?$AA@			; `string'
PUBLIC	??_C@_09GMMJ@Operation?$AA@			; `string'
;	COMDAT ??_C@_0M@BKKK@ReturnValue?$AA@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_0M@BKKK@ReturnValue?$AA@ DB 'ReturnValue', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GMMJ@Operation?$AA@
_DATA	SEGMENT
??_C@_09GMMJ@Operation?$AA@ DB 'Operation', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vArgs$ = 8
_pvViewList$ = 12
_ReturnValue$ = -4
__zCall_CompareFiles@8 PROC NEAR

; 1881 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1882 :    zSHORT   ReturnValue;
; 1883 : 
; 1884 :    ReturnValue = CompareFiles( pvViewList[ 0 ] );

	mov	eax, DWORD PTR _pvViewList$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_CompareFiles@4
	mov	WORD PTR _ReturnValue$[ebp], ax

; 1885 :    SetAttributeFromInteger( vArgs, "Operation", "ReturnValue", ReturnValue );

	movsx	edx, WORD PTR _ReturnValue$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0M@BKKK@ReturnValue?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09GMMJ@Operation?$AA@	; `string'
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 1886 : 
; 1887 :    return( 0 );

	xor	ax, ax

; 1888 : }

	mov	esp, ebp
	pop	ebp
	ret	8
__zCall_CompareFiles@8 ENDP
_TEXT	ENDS
PUBLIC	_PerformApplicationUpdate@4
PUBLIC	??_C@_0N@FJNC@SourceServer?$AA@			; `string'
PUBLIC	??_C@_0CI@ECNA@Performing?5application?5update?5fo@ ; `string'
PUBLIC	??_C@_03BPPE@NpV?$AA@				; `string'
PUBLIC	??_C@_0N@OJBC@CompareFiles?$AA@			; `string'
PUBLIC	??_C@_0CO@HHPG@?$DN?$DN?$DN?$DN?$DN?5Files?5that?5being?5downloade@ ; `string'
PUBLIC	??_C@_0L@IOMJ@FileName?3?5?$AA@			; `string'
EXTRN	_NetCallOperation:NEAR
EXTRN	_DropView@4:NEAR
EXTRN	_SysSetFileTime@12:NEAR
EXTRN	_WriteBlobToFile@16:NEAR
EXTRN	_GetAddrForAttribute@16:NEAR
;	COMDAT ??_C@_0N@FJNC@SourceServer?$AA@
; File c:\10c\w\oe\ZWINSOCK.CPP
_DATA	SEGMENT
??_C@_0N@FJNC@SourceServer?$AA@ DB 'SourceServer', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@ECNA@Performing?5application?5update?5fo@
_DATA	SEGMENT
??_C@_0CI@ECNA@Performing?5application?5update?5fo@ DB 'Performing applic'
	DB	'ation update for app: ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03BPPE@NpV?$AA@
_DATA	SEGMENT
??_C@_03BPPE@NpV?$AA@ DB 'NpV', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@OJBC@CompareFiles?$AA@
_DATA	SEGMENT
??_C@_0N@OJBC@CompareFiles?$AA@ DB 'CompareFiles', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CO@HHPG@?$DN?$DN?$DN?$DN?$DN?5Files?5that?5being?5downloade@
_DATA	SEGMENT
??_C@_0CO@HHPG@?$DN?$DN?$DN?$DN?$DN?5Files?5that?5being?5downloade@ DB '='
	DB	'==== Files that being downloaded are: ======', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@IOMJ@FileName?3?5?$AA@
_DATA	SEGMENT
??_C@_0L@IOMJ@FileName?3?5?$AA@ DB 'FileName: ', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_nRC$ = -264
_iFileNameIdx$ = -272
_nMore$ = -268
_vList$ = -276
_vAppList$ = -284
_szFileName$ = -260
_pchAppName$ = -280
_szSourceServer$61183 = -540
_szFileDateTime$61196 = -580
_PerformApplicationUpdate@4 PROC NEAR

; 1892 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H

; 1893 :    zSHORT nRC;
; 1894 :    zSHORT iFileNameIdx;
; 1895 :    zSHORT nMore;
; 1896 :    zVIEW  vList = 0;

	mov	DWORD PTR _vList$[ebp], 0

; 1897 :    zVIEW  vAppList;
; 1898 :    zCHAR  szFileName[ zMAX_FILENAME_LTH + 1 ];
; 1899 :    zPCHAR pchAppName;
; 1900 : 
; 1901 :    // Activate the object containing the app list.
; 1902 :    SysGetEnvVar( szFileName, "ZEIDON", sizeof( szFileName ) );

	push	257					; 00000101H
	push	OFFSET FLAT:??_C@_06HLLH@ZEIDON?$AA@	; `string'
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_SysGetEnvVar@12

; 1903 :    SysAppendcDirSep( szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 1904 :    zstrcat( szFileName, "ZEIDON.APP" );

	push	OFFSET FLAT:??_C@_0L@IIHF@ZEIDON?4APP?$AA@ ; `string'
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1905 :    SfActivateSysOI_FromFile( &vAppList, "KZAPPLOO", lpView, szFileName, 0 );

	push	0
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_08IHGG@KZAPPLOO?$AA@	; `string'
	lea	edx, DWORD PTR _vAppList$[ebp]
	push	edx
	call	_SfActivateSysOI_FromFile@20

; 1906 : 
; 1907 :    for ( nRC = SetCursorFirstEntity( vAppList, "APPLICATION", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0M@LKKI@APPLICATION?$AA@ ; `string'
	mov	eax, DWORD PTR _vAppList$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1908 :          nRC >= zCURSOR_SET;
; 1909 :          nRC = SetCursorNextEntity( vAppList, "APPLICATION", 0 ) )

	jmp	SHORT $L61180
$L61181:
	push	0
	push	OFFSET FLAT:??_C@_0M@LKKI@APPLICATION?$AA@ ; `string'
	mov	ecx, DWORD PTR _vAppList$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L61180:
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$L61182

; 1911 :       zCHAR szSourceServer[ 256 ];
; 1912 : 
; 1913 :       GetAddrForAttribute( &pchAppName, vAppList, "APPLICATION", "APP_NAME" );

	push	OFFSET FLAT:??_C@_08NHNM@APP_NAME?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@LKKI@APPLICATION?$AA@ ; `string'
	mov	eax, DWORD PTR _vAppList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchAppName$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 1914 : 
; 1915 :       // Check to see if a source server is specified for this app.  If not,
; 1916 :       // then skip it.
; 1917 :       SysReadZeidonIni( -1, pchAppName, "SourceServer", szSourceServer );

	lea	edx, DWORD PTR _szSourceServer$61183[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0N@FJNC@SourceServer?$AA@ ; `string'
	mov	eax, DWORD PTR _pchAppName$[ebp]
	push	eax
	push	-1
	call	_SysReadZeidonIni@16

; 1918 :       if ( szSourceServer[ 0 ] == 0 )

	movsx	ecx, BYTE PTR _szSourceServer$61183[ebp]
	test	ecx, ecx
	jne	SHORT $L61185

; 1919 :          continue;

	jmp	SHORT $L61181
$L61185:

; 1920 : 
; 1921 :       TraceLineS( "Performing application update for app: ", pchAppName );

	mov	edx, DWORD PTR _pchAppName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CI@ECNA@Performing?5application?5update?5fo@ ; `string'
	call	_TraceLineS@8
$L61187:

; 1928 :          vList = 0;

	mov	DWORD PTR _vList$[ebp], 0

; 1929 :          GetDirectoryList( &vList, vAppList );

	mov	eax, DWORD PTR _vAppList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vList$[ebp]
	push	ecx
	call	_GetDirectoryList@8

; 1930 : 
; 1931 :          // Call the operation on the server that sends down the latest files.
; 1932 :          NetCallOperation( "zWinSock", szSourceServer, vList, FALSE,
; 1933 :                            "zWinSock", "CompareFiles", &nMore, "NpV", &vList );

	lea	edx, DWORD PTR _vList$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_03BPPE@NpV?$AA@	; `string'
	lea	eax, DWORD PTR _nMore$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0N@OJBC@CompareFiles?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_08GPBK@zWinSock?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _vList$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szSourceServer$61183[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08GPBK@zWinSock?$AA@	; `string'
	call	_NetCallOperation
	add	esp, 36					; 00000024H

; 1934 : 
; 1935 :          GetStringFromAttribute( szFileName, vAppList, "APPLICATION", "APP_ADOBIN" );

	push	OFFSET FLAT:??_C@_0L@GHPH@APP_ADOBIN?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0M@LKKI@APPLICATION?$AA@ ; `string'
	mov	eax, DWORD PTR _vAppList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 1936 :          SysAppendcDirSep( szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 1937 :          iFileNameIdx = zstrlen( szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _iFileNameIdx$[ebp], ax

; 1938 : 
; 1939 :          TraceLineS( "===== Files that being downloaded are: ======", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CO@HHPG@?$DN?$DN?$DN?$DN?$DN?5Files?5that?5being?5downloade@ ; `string'
	call	_TraceLineS@8

; 1940 :          for ( nRC = SetCursorFirstEntity( vList, "File", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	ecx, DWORD PTR _vList$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1941 :                nRC >= zCURSOR_SET;
; 1942 :                nRC = SetCursorNextEntity( vList, "File", 0 ) )

	jmp	SHORT $L61193
$L61194:
	push	0
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	edx, DWORD PTR _vList$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L61193:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L61195

; 1944 :             zCHAR szFileDateTime[ 40 ];
; 1945 : 
; 1946 :             GetStringFromAttribute( &szFileName[ iFileNameIdx ],
; 1947 :                                     vList, "File", "FileName" );

	push	OFFSET FLAT:??_C@_08NJLM@FileName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	ecx, DWORD PTR _vList$[ebp]
	push	ecx
	movsx	edx, WORD PTR _iFileNameIdx$[ebp]
	lea	eax, DWORD PTR _szFileName$[ebp+edx]
	push	eax
	call	_GetStringFromAttribute@16

; 1948 :             TraceLineS( "FileName: ", szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0L@IOMJ@FileName?3?5?$AA@ ; `string'
	call	_TraceLineS@8

; 1949 :             WriteBlobToFile( vList, "File", "Data", szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04EGOH@Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	eax, DWORD PTR _vList$[ebp]
	push	eax
	call	_WriteBlobToFile@16

; 1950 : 
; 1951 :             GetStringFromAttribute( szFileDateTime, vList, "File", "ModDate" );

	push	OFFSET FLAT:??_C@_07LNLK@ModDate?$AA@	; `string'
	push	OFFSET FLAT:??_C@_04OJFH@File?$AA@	; `string'
	mov	ecx, DWORD PTR _vList$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileDateTime$61196[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 1952 :             SysSetFileTime( szFileName, szFileDateTime, 0 );

	push	0
	lea	eax, DWORD PTR _szFileDateTime$61196[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_SysSetFileTime@12

; 1953 :          }

	jmp	$L61194
$L61195:

; 1954 : 
; 1955 :          DropView( vList );

	mov	edx, DWORD PTR _vList$[ebp]
	push	edx
	call	_DropView@4

; 1956 : 
; 1957 :       } while ( nMore == 1 );

	movsx	eax, WORD PTR _nMore$[ebp]
	cmp	eax, 1
	je	$L61187

; 1958 : 
; 1959 :    } // For each APPLICATION...

	jmp	$L61181
$L61182:

; 1960 : 
; 1961 :    DropView( vAppList );

	mov	ecx, DWORD PTR _vAppList$[ebp]
	push	ecx
	call	_DropView@4

; 1962 :    return( 0 );

	xor	ax, ax

; 1963 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_PerformApplicationUpdate@4 ENDP
_TEXT	ENDS
END
