	TITLE	c:\10c\w\oe\KZOESYAA.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BJ@OCLO@ZEIDON?5MUTEX?5?9?9?5INITTERM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@CFG@ZEIDON?5MUTEX?5?9?9?5MEMORY?5ALLOCATIO@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@JMMP@ZEIDON?5MUTEX?5?9?9?5ANCHOR?5BLOCK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@GEKC@ZEIDON?5MUTEX?5?9?9?5ANCHOR?5INIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@FIFA@ZEIDON?5MUTEX?5?9?9?5SHARED?5MEM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OFOI@ZEIDON?5MUTEX?5?9?9?5TASK?5CHAIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@FGNI@ZEIDON?5MUTEX?5?9?9?5TASK?5CHAIN?5WRITE@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@OLDG@ZEIDON?5MUTEX?5?9?9?5MUTEX?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@PPAA@ZEIDON?5MUTEX?5?9?9?5DEBUGCHANGE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@EGB@ZEIDON?5MUTEX?5?9?9?5PESSIMISTIC?5LOCK@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@GGGI@ZEIDON?5MUTEX?5?9?9?5APPLA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OEL@ZEIDON?5MUTEX?5?9?9?5ENTITY?5KEY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@DIIE@ZEIDON?5MUTEX?5?9?9?5TASKPROCESS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@CPDB@ZEIDON?5MUTEX?5?9?9?5PROC?5CHAIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@LBIA@ZEIDON?5MUTEX?5?9?9?5PROC?5CHAIN?5WRITE@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@FOCN@ZEIDON?5MUTEX?5?9?9?5NETWORK?5CHAIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08LNAM@1?40a2?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BHMH@1?40b0?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IOGD@?1SHAREMEM?1KZOENGAA?4SEG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@FLGE@kzoengwa?4exe?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@OAJM@kzoengaa?4dll?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NPBE@?4xod?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EJNG@?4dll?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08A@?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HLLH@ZEIDON?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@JLJG@zeidon?4app?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@LFFP@zeidon?4xdm?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@DNNP@kzomdmoi?4xdm?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JIIE@KZMSGQOO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FPMG@z?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06BADI@Zeidon?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LKKI@APPLICATION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PIJH@OBJECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06NIFE@ENTITY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@PNOD@CHILDENTITY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06BLIJ@ATTRIB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06EIOP@DOMAIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NMBE@MODEL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07OLKB@CONTEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@NJID@NLS_TABLEENTRY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@EDPP@TABLEENTRY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@JION@REGULAREXPRESSION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DLBH@ZEIDON_BIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@NPMB@ZEIDON_SYS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GEFJ@ZEIDON_LOC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@JFF@ZEIDON_SHR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NHNM@APP_NAME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@HKIJ@APP_DFLT_WDOD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07LAPC@APP_DLL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GHPH@APP_ADOBIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HKKN@APP_LOCAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@KNHE@APP_SHARED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09BKCL@APP_QLPLR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09MKDP@APP_QXODS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@NAIP@APP_SOURCE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FEIL@APDM_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@HAFL@ATTRIBUTETYPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CGIJ@ATTRIBUTEDECIMAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CCEG@AUTOCREATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GGKI@AUTOLOADFROMPARENT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FEIG@AUTO_SEQ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CDIB@XVAATT_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07EKKN@CARDMAX?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07KJPL@CARDMIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JHJH@CASESENS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DICE@CONTEXTRESTRICTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JBCM@CREATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07IMJA@CR_DATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JEIA@DATAFIELD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PPLE@DATARECORD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PKJA@DATATYPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PHCI@DBNAME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07OOBD@DECIMAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@GDML@DECIMALFORMAT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06FMHL@DELETE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FJF@DERIVED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08EALH@DERIVEDF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@HPIJ@DFT_DBNAME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@JBCC@DFT_SERVER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DJGK@DLL_NAME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@KGBA@DOMAINTYPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08KCDD@DUPENTIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DECF@DUPRELIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05OAI@ECACC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NDAD@ECCAN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04FPMK@ECCR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05GCOG@ECDEL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FBPG@ECEOPER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KCFA@ECEXC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05GHOJ@ECINC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@LMLE@EDITSTRING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GJOF@ERATT_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@LOJF@EntityName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@EIGE@EntitySpec?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09PPA@ERENT_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GJDI@ERREL_LINK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09DPNM@ERREL_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07EHEP@EXCLUDE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@HLIE@EXTERNALVALUE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05OJOB@FLDID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06GKHE@FLDLTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07NIOD@FLDNAME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09BHNG@FLDOFFSET?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MPNE@FLDTYPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@FLLI@FULLPERSIST?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PPGK@GENKEY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09IICP@GKHANDLER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MHHO@HANDLER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IJMB@HIDDEN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02FECH@Id?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07KACF@INCLSRC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07KOHG@INCLUDE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FKFF@INCRLOAD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NJI@INIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@HIL@INTERNALVALUE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09ECEN@ISDEFAULT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03PHBO@KEY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@IHAG@LanguageIndex?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05IFE@LNAME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NPLI@LOCK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03DGJL@LTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@LMHL@MAXSTRINGLTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DHHO@MR_LIMIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OMJI@__MSGQ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04IALP@NAME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GNJA@NETCOMPRESS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07KFPJ@NETWORK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07GOHG@NumAtts?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07OOMM@NumEnts?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07PICA@NumRels?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05LDPN@OCACT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PJLI@OCACTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KPHB@OCCOM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HHGH@OCDROP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HIHA@OCEOPER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07NHGG@OFRECID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07GKEM@OFBUFSZ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PJJC@OPER_LIBNM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04FKDH@Oper?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@JCEP@OWNER_MEMB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BAEJ@PDELETE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07NIBE@PERSIST?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05ILLO@PNAME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DIOI@QualAttrib?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NKIC@RECID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07NDLE@RECNAME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GDN@RECURSIVE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LNGM@REL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PMNP@RELFIELD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HINM@RELRECORD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@DBKM@RELXVAATT_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BGDD@REQUIRED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GCMK@RESTRICTED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06BJID@SERVER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@FLNJ@SEQUENCING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06LIHO@SEQ_AD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06NHOC@SETID1?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06CIFL@SETID2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FJI@SETNAME1?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PKCB@SETNAME2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@HOCN@SRCXVAATT_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HDAF@Task?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BNNJ@Text?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JHII@TYPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07KJPH@UP_DATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PIPA@USERID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06NDPG@UPDATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JGIO@ZKEY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@BELJ@Object?5Services?5?9?5Application?5Lo@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@FMPG@Data?5Validation?5Error?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@ODOC@OE?5System?5Error?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05HBLJ@AFTER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06COI@BEFORE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@BAHL@MQ_MessageSend?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MBCE@MQ_MessagePrompt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@MAFE@MQ_MessagePromptForInput?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@GMHO@MQ_MessagePresent?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BPKJ@January?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PGBA@February?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05FGPD@March?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JFGC@April?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03MGHB@May?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04ICFP@June?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PIJO@July?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PADP@August?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09MKGD@September?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07IAMM@October?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NJLI@November?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08LIDF@December?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OOEM@Sunday?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06CHLK@Monday?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BMBC@Tuesday?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09PBIN@Wednesday?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08CCFO@Thursday?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06ONCK@Friday?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FAKH@Saturday?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KGMK@Intl?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FKAM@iCountry?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JMM@sCountry?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09IMGC@sLanguage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NLOI@sList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08HHE@iMeasure?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05EMIJ@iTime?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05PLM@sTime?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05PCBI@s1159?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DJMD@s2359?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07LDFB@iTLZero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@NPLI@sShortDate?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JENF@sLongDate?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JDHO@sCurrency?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CBCN@iCurrency?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LKGH@iCurrDigits?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08LHOD@iNegCurr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09BEPN@sThousand?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GFHF@sDecimal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FACE@iDigits?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06LENA@iLzero?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DC@KKHB@KZOEE001?5?9?5Error?5communicating?5w@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CP@JFJD@KZOEE002?5?9?5ZEIDON?5environment?5va@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@LHJO@KZOEE003?5?9?5Error?5starting?5Object@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DE@HPME@KZOEE004?5?9?5Error?5communicating?5w@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DE@HEBF@KZOEE005?5?9?5Error?5communicating?5w@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CP@HIJD@KZOEE006?5?9?5Internal?5error?5freein@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0ED@FDBJ@KZOEE007?5?9?5Internal?5Anchor?5block@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EI@BCLB@KZOEE008?5?9?5Application?5definitio@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DF@MKOJ@KZOEE009?5?9?5Error?5opening?5applica@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@MFKJ@KZOEE010?5?9?5Requested?5application@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DC@DKPD@KZOEE011?5?9?5Error?5opening?5applica@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@KFHE@KZOEE012?5?9?5Error?5allocating?5memo@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@MDMN@KZOEE013?5?9?5Internal?5operation?5ca@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CO@LCNE@KZOEE014?5?9?5Invalid?5suballoc?5memo@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@OGFD@KZOEE015?5?9?5Invalid?5suballoc?5memo@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@EDAJ@KZOEE016?5?9?5Invalid?5Task?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@MOGK@KZOEE017?5?9?5Task?5is?5Disabled?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@DHKC@KZOEE018?5?9?5Error?5in?5Domain?5file?0@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@PAMN@KZOEE019?5?9?5Invalid?5GetTaskInfo?5r@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@COHN@KZOEE020?5?9?5Invalid?5Operation?5cal@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EJ@OFCD@KZOEE021?5?9?5Internal?5error?0?5TaskO@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@PFIN@KZOEE022?5?9?5Error?5writing?5file?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@ENDH@KZOEE023?5?9?5Invalid?5parameter?0?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@LNEH@KZOEE024?5?9?5Error?5opening?5file?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CM@LGJG@KZOEE025?5?9?5Error?5in?5directory?5sp@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@CFOB@KZOEE026?5?9?5Error?5creating?5direct@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CF@MDHP@KZOEE030?5?9?5Error?5loading?5library@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@KCKB@KZOEE031?5?9?5Error?5locating?5Operat@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@KHLN@KZOEE032?5?9?5Mutex?5name?5is?5invalid@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@NPAH@KZOEE050?5?9?5Error?5opening?5View?5Ob@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@EMEJ@KZOEE051?5?9?5Invalid?5View?5Object?5f@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EG@KBNM@KZOEE052?5?9?5Invalid?5Object?5file?0?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CP@CJAD@KZOEE053?5?9?5Invalid?5Entity?5level?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@OIAJ@KZOEE054?5?9?5Invalid?5record?5found?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DM@CCJK@KZOEE055?5?9?5Invalid?5file?0?5LTH?5or?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CF@JDKN@KZOEE056?5?9?5Domain?5not?5found?5on?5l@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DN@EDAD@KZOEE057?5?9?5Invalid?5file?0?5LTH?5bef@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EE@OCOD@KZOEE058?5?9?5Invalid?5file?0?5PERSIST@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EC@PMPM@KZOEE059?5?9?5Invalid?5file?0?5Invalid@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@PNHL@KZOEE060?5?9?5Invalid?5maximum?5root?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DD@IPCF@KZOEE061?5?9?5Persistent?5Attribute?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EH@FCEJ@KZOEE062?5?9?5Conflict?5between?5E?1R?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EG@PGNO@KZOEE063?5?9?5Entity?5attrib?5RECURSI@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@DBKC@KZOEE064?5?9?5TYPE?5obsolete?0?5use?5AP@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DM@HNKG@KZOEE065?5?9?5LTH?5only?5valid?5for?5At@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@DFAB@KZOEE066?5?9?5Attribute?5length?5zero@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DH@DFDK@KZOEE067?5?9?5Could?5not?5initialize?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@GHFO@KZOEE070?5?9?5Object?5instance?5is?5em@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@HPIK@KZOEE071?5?9?5Error?5opening?5instanc@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@EEEO@KZOEE072?5?9?5Error?5reading?5instanc@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@GPMH@KZOEE073?5?9?5Invalid?5instance?5file@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@NBOH@KZOEE074?5?9?5Invalid?5Entity?5name?5o@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@FMPI@KZOEE075?5?9?5Invalid?5Entity?5level?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DP@HHHP@KZOEE076?5?9?5Object?5instance?5conta@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@EOHG@KZOEE077?5?9?5Invalid?5record?5size?5i@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EA@PIKP@KZOEE078?5?9?5Internal?5error?0?5linke@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@GDKG@KZOEE079?5?9?5Trying?5to?5commit?5a?5re@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EI@ENAN@KZOEE080?5?9?5Object?5Definition?5doe@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EG@IICI@KZOEE081?5?9?5Object?5Definition?5doe@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@BEFH@KZOEE082?5?9?5Error?5starting?5Genkey@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0IJ@LNPL@KZOEE083?5?9?5LOD?5does?5not?5have?5phy@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EB@HECI@KZOEE084?5?9?5Entity?5in?5Object?5Defi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EK@GEM@KZOEE085?5?9?5Entity?5in?5Object?5Defi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@ELED@KZOEE086?5?9?5Trying?5to?5commit?50?5vi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@MFDJ@KZOEE087?5?9?5Too?5many?5views?5in?5Vie@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DF@CEHL@KZOEE088?5?9?5Compressed?5OI?5is?5out?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EC@IMDC@KZOEE090?5?9?5Maximum?5number?5of?5ent@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DO@CEAH@KZOEE091?5?9?5Maximum?5number?5of?5ent@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DN@DGMC@KZOEE092?5?9?5Couldn?8t?5re?9activate?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EN@GBNJ@KZOEE093?5?9?5Optimistic?5locking?5er@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@NOMM@KZOEE094?5?9?5Locking?5violation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0JB@CGJ@KZOEE095?5?9?5A?5recursive?5child?5was@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@LDGH@KZOEE096?5?9?5Error?5retrieving?5OI?5f@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@GDIC@KZOEE100?5?9?5Invalid?5View?0?5view?5is@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@NHEC@KZOEE101?5?9?5Invalid?5View?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@JOEN@KZOEE102?5?9?5Invalid?5View?0?5view?5is@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@DCOG@KZOEE103?5?9?5Invalid?5Entity?5name?5f@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DL@IOKD@KZOEE104?5?9?5Invalid?5Attribute?5nam@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@OHNK@KZOEE105?5?9?5Invalid?5scoping?5Entit@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@LNED@KZOEE106?5?9?5Rules?5violation?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@ICEI@KZOEE107?5?9?5Invalid?5Subtask?5View?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@CNMF@KZOEE108?5?9?5Attempt?5to?5drop?5Subta@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DD@IEKN@KZOEE109?5?9?5Invalid?5View?0?5view?5co@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@NIKJ@KZOEE110?5?9?5Invalid?5level?5for?5Vie@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EF@IJII@KZOEE111?5?9?5Attempt?5to?5set?5subtas@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EC@BHLF@KZOEE112?5?9?5Attempt?5to?5set?5subtas@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DD@OJHP@KZOEE113?5?9?5Invalid?5View?0?5view?5co@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DD@NFKB@KZOEE114?5?9?5Source?5and?5Target?5ent@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EB@HFOP@KZOEE115?5?9?5Attempt?5to?5move?5an?5in@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EL@JFCI@KZOEE116?5?9?5Attempt?5to?5include?5an@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@EDAL@KZOEE117?5?9?5Entity?5Instance?5Keys?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DM@BDCF@KZOEE118?5?9?5Internal?5Key?5error?5re@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@GLPJ@KZOEE119?5?9?5Invalid?5View?0?5View?5is@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@MFLA@KZOEE120?5?9?5Invalid?5position?5para@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DG@NDMM@KZOEE121?5?9?5Attempt?5to?5insert?5twi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DI@HBNG@KZOEE122?5?9?5Attempt?5to?5create?5an?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FB@NPFI@KZOEE124?5?9?5Entity?5parent?5is?5incl@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EC@FECD@KZOEE125?5?9?5Target?5and?5Source?5Ent@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DG@JPKB@KZOEE126?5?9?5Target?5or?5Source?5Enti@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EH@IKFL@KZOEE127?5?9?5Source?5?$CG?5target?5do?5no@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EG@KLAD@KZOEE128?5?9?5Target?5Entity?5cardina@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0IA@GFGF@KZOEE129?5?9?5Trying?5to?5create?5a?5re@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EG@DDAB@KZOEE131?5?9?5Attempt?5to?5include?5Su@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DL@FCGD@KZOEE132?5?9?5Error?5establishing?5cu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FA@LJEB@KZOEE134?5?9?5Attempt?5to?5version?5an@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@EFHN@KZOEE135?5?9?5Entity?5Instance?5not?5v@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@MAJK@KZOEE136?5?9?5Entity?5Instance?5alrea@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@LGF@KZOEE137?5?9?5Entity?5Instance?5desce@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EE@IOCN@KZOEE138?5?9?5Attempt?5to?5include?5ta@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DM@EDLN@KZOEE139?5?9?5Error?5establishing?5cu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0ED@EHNP@KZOEE140?5?9?5Target?5and?5source?5Obj@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EK@MPKH@KZOEE141?5?9?5Attempt?5to?5include?5a?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@HOIP@KZOEE190?5?9?5Error?5opening?5tempora@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EC@BIGN@KZOEE191?5?9?5Attribute?5must?5be?5a?5B@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@CNJA@KZOEE231?5?9?5Decimal?5attribute?5ove@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DP@LJHO@KZOEE232?5?9?5Operation?5indicates?5u@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DG@KPMG@KZOEE233?5?9?5Could?5not?5locate?5deri@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EH@EJPO@KZOEE234?5?9?5Attempt?5to?5add?5intege@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@GBBH@KZOEE235?5?9?5Integer?5overflow?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@JFBL@KZOEE236?5?9?5Integer?5underflow?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DI@NJGM@KZOEE237?5?9?5Attempt?5to?5update?5a?5n@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0ED@IIED@KZOEE238?5?9?5Attempt?5to?5update?5a?5n@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@EHLD@KZOEE239?5?9?5Invalid?5Operation?5for@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DM@EDAM@KZOEE240?5?9?5Binary?5large?5object?5?$CI@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@FKDO@KZOEE241?5?9?5Invalid?5Variable?5Type@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CF@KFFO@KZOEE242?5?9?5Invalid?5Domain?5Entry?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@NJPF@KZOEE243?5?9?5Context?5invalid?5for?5D@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@FNBB@KZOEE244?5?9?5Attribute?5has?5no?5Doma@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DM@CLHG@KZOEE245?5?9?5Null?5string?5not?5allow@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@EGIM@KZOEE246?5?9?5Invalid?5Attribute?5typ@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DM@LIOD@KZOEE247?5?9?5Blob?5Attribute?5does?5n@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@JDPP@KZOEE248?5?9?5Required?5attribute?5is@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@HNFJ@KZOEE250?5?9?5Object?5instance?5is?5em@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@PNML@KZOEE252?5?9?5Root?5of?5view?5has?5been@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@ICBE@KZOEE253?5?9?5Entity?5cursor?5is?5NULL@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@DKJB@KZOEE254?5?9?5Entity?5cursor?5is?5unde@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DH@MKIF@KZOEE255?5?9?5Attempt?5to?5update?5a?5p@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@IDGK@KZOEE256?5?9?5Entity?5is?5root?5of?5vie@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EA@FEIJ@KZOEE257?5?9?5Version?5mismatch?5betw@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CO@IOAK@KZOEE258?5?9?5Scoping?5Entity?5cursor@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@MMGH@KZOEE259?5?9?5Scoping?5Entity?5cursor@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EP@DIEE@KZOEE263?5?9?5Input?5Qualifier?5canno@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@DMDO@KZOEE264?5?9?5Invalid?5Operation?5for@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DN@JHKM@KZOEE265?5?9?5Invalid?5Operation?5for@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DO@NFPG@KZOEE266?5?9?5Invalid?5Operation?5for@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CM@LKBG@KZOEE267?5?9?5Hierarchical?5cursor?5i@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DH@KDFJ@KZOEE268?5?9?5Source?5and?5target?5ent@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@FACO@KZOEE269?5?9?5Invalid?5Select?5Set?5ID@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@HOLD@KZOEE270?5?9?5View?5name?5is?5already?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DO@BMHF@KZOEE271?5?9?5Subobject?5Entity?5is?5r@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@LFIF@KZOEE272?5?9?5Subobject?5Parent?5Curs@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DD@DLH@KZOEE273?5?9?5Parent?5Entity?5instanc@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0ED@GMM@KZOEE274?5?9?5Target?5and?5Source?5vie@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@OIHN@KZOEE300?5?9?5Problems?5finding?5a?5pa@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EH@GAK@KZOEE301?5?9?5Return?5buffer?5not?5lar@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@JCI@KZOEE302?5?9?5Invalid?5option?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EA@KHBJ@KZOEE330?5?9?5Message?5Object?5Defini@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@HNHP@KZOEE350?5?9?5Context?5Not?5Valid?5for@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@IIPK@KZOEE351?5?9?5Invalid?5Input?5Data?5Ty@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DB@GJCM@KZOEE352?5?9?5Text?5String?5exceeds?5a@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DC@CBDF@KZOEE353?5?9?5Attribute?5Type?5invali@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@DCAE@KZOEE354?5?9?5Invalid?5Domain?5Entry?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DH@JDFE@KZOEE355?5?9?5Table_Handler?5invalid@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@FNMN@KZOEE356?5?9?5Domain?5has?5an?5unnamed@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@LACG@KZOEE357?5?9?5Invalid?5Input?5Data?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CM@DEPD@KZOEE358?5?9?5Value?5not?5in?5Context?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@BGND@KZOEE359?5?9?5Invalid?5Input?5Data?5Ty@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CF@JLJE@KZOEE360?5?9?5Missing?5ending?5delimi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@PMLE@KZOEE361?5?9?5Invalid?5data?5Format?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DL@IDHP@KZOEE362?5?9?5Variable?5Type?5not?5all@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@NCJC@KZOEE363?5?9?5Context?5Edit?5string?5i@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@MAJI@KZOEE364?5?9?5Picture?5length?5exceed@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DF@EIIB@KZOEE400?5?9?5Error?5transmitting?5OI@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@COPE@KZOEE401?5?9?5Invalid?5User?5Name?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@LCML@KZOEE402?5?9?5Invalid?5Password?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@MFOH@KZOEE403?5?9?5Application?5not?5suppo@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@ICKG@KZOEE404?5?9?5Can?8t?5find?5UserGroup?4@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DL@EBIE@KZOEE405?5?9?5UserGroup?5doesn?8t?5hav@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CF@PDBP@KZOEE450?5?9?5Name?5for?5view?5is?5too?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DK@KFBA@KZOEE451?5?9?5Include?5source?5task?5d@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@DLJN@SfCreateSubtask?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@BDFC@SfDropSubtask?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@FMPJ@DisableTask?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@BBMP@EnableTask?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@BDEP@GetApplDirectoryFromView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OJMF@SfGetApplicationForSubtask?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@FHBI@SfGetTaskInfo?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@PMHK@SfActivateSysOI_FromFile?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@PCON@SfActivateSysEmptyOI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@OIBJ@ActivateEmptyObjectInstance?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NOPG@ActivateObjectInstance?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IMAC@ActivateOI_FromFile?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@GAMK@ActivateOI_FromXML_File?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CGBG@CommitOI_ToXML_File?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@PDFM@ActivateOI_FromOI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@GELD@CommitObjectInstance?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@FMKN@CommitMultipleOIs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@MOCF@DropViewCluster?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@PMGH@AddToViewCluster?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FDOM@CommitOI_ToFile?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@PHBJ@DropObjectInstance?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NEFL@CheckExistenceOfEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@HLNG@CompareEntityToEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@BOMB@CreateEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@DPDF@GetEntityKey?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@ELCK@CreateTemporalEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@EIGM@CreateTemporalSubobjectVersion?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@IEEA@AcceptSubobject?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@MAGB@AcceptAllTemporalSubobjects?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@NIBC@CancelSubobject?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@CNDP@CancelAllTemporalSubobjects?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@NBLH@IncludeSubobjectFromSubobject?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@GDJL@IncludeSubobjectFromSubobjectEx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@JDMH@SubobjectVersionUpdated?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NKPH@DeleteEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@PHBL@ExcludeEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@COBA@DropEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@OJII@MoveSubobject?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@PPIN@SetCursorNextEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@MAGO@SetCursorPrevEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@NEDK@SetCursorFirstEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HACO@SetCursorLastEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@IKOI@SetCursorFirstEntityByString?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@EHFF@SetCursorNextEntityByString?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@GMJK@SetCursorFirstEntityByInteger?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@DEFH@SetCursorNextEntityByInteger?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@COOK@SetCursorFirstEntityByDecimal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@HGCH@SetCursorNextEntityByDecimal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@GLMN@SetCursorFirstEntityByAttr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@MB@SetCursorNextEntityByAttr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@CCIK@SetCursorFirstEntityByEntityCsr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@FIAL@SetCursorNextEntityByEntityCsr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@EMBJ@SetCursorFirstSelectedEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@IBKE@SetCursorNextSelectedEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@GCJI@SetCursorRelativeEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@DKDE@GetRelativeEntityNumber?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@EJOC@DefineHierarchicalCursor?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@COPC@DropHierarchicalCursor?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@CHCH@SetCursorNextEntityHierarchical?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@OPGJ@CreateViewFromView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@HNOF@SetViewFromView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@MNMP@SetViewToSubobject?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@EJFL@ResetViewFromSubobject?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@CBGO@SetNameForView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@LHJJ@DropNameForView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@LOIG@GetViewByName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@NAIK@SetSubtaskView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@KFDN@GetNameForView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@FIPH@SfGetFirstSubtaskView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@INMF@SfGetNextSubtaskView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@EIOP@SfTransferView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@HDM@SfLockView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09MKAH@ResetView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JNKD@DropView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GCHM@SetViewReadOnly?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@HIKI@SetViewFlags?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@BBKK@GetViewFlags?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@CBLC@DropViewObject?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@JNFA@GetAttributeFlags?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CLPD@AttributeUpdated?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IPDO@GetStringFromAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@FFJB@GetIntegerFromAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@DCJK@GetDecimalFromAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@MHPH@GetBlobFromAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@HIGG@GetStructFromEntityAttrs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@PNDJ@GetAddrForAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@IFI@GetVariableFromAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@MMIK@SetAttributeFromString?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@CNM@SetAttributeFromInteger?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@EAKM@SetAttributeFromDecimal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@JCLE@SetAttributeFromBlob?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@MLHG@SetAttributeFromAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@PBPK@SetAttributeFromCurrentDate?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@OEAI@SetAttributeFromVariable?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@KHLN@SetAttributeValueNext?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@FODI@SetAttributeValuePrev?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@JAKJ@SetBlobAttributeFromAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@CGCL@SetEntityAttributesFromBlob?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@MJNM@SetBlobFromEntityAttributes?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@KNHC@AddToAttributeFromInteger?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@OPAC@AddToAttributeFromDecimal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@CKKJ@AddToAttributeFromAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@DLKH@AddToAttributeFromVariable?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@ODPJ@CompareAttributeToString?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@PHPD@CompareAttributeToInteger?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@LFID@CompareAttributeToDecimal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@OPHA@CompareAttributeToAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OCPN@CompareAttributeToVariable?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@HIDA@GetAttributeLength?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@PHGL@SetMatchingAttributesByName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@FLBC@GetFirstTableEntryForAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@BHMO@GetNextTableEntryForAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@ILIL@DisplayEntityInstance?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@KOPK@DisplayObjectInstance?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KOIM@DisplayCursorInfo?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@FKMI@StoreValueInRecord?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@EHIH@StoreValueInDerivedAttribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@JHII@TableEntryExtToInt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DNNI@TableEntryIntToExt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@HNKN@TableEntryForInternalValue?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@OKMC@SetSelectSetForView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@EPHO@GetSelectStateOfEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@JBLI@SetAllSelectStatesForEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IMDL@SetSelectStateOfEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@NKAP@RelinkInstanceToInstance?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@HAMO@RelinkAllSubobjectsForOI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PDG@LoadEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@PEI@ObjectInstanceUpdated?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@OOBH@ObjectInstanceUpdatedFromFile?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@LHCP@GetValueFromRecord?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DIAC@StoreStringInRecord?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@MENK@GetStringFromRecord?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@KGPF@SetEntityCursor?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@CMGB@GetAddrFromRecord?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@FOCF@MiGetParentEntityNameForView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@PCOO@GetTaskDBHandlerTraceLevel?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@NCHN@SetTaskDBHandlerTraceLevel?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@GHM@GetAbsolutePositionForEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@CBHE@GetEntityNameForHierarchicalCsr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@EINL@SetCursorAbsolutePosition?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@LLOG@OrderEntityForView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@JPO@CountEntitiesForView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@DLHM@OrderOI_ByDefaultAttribs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@HLCK@OrderEntitiesByDefaultAttribs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@GOEA@MiGetUpdateForViewEntityAttr?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@PBLM@MessageSend?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@CLJA@MessagePrompt?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@MCGA@MessagePromptForInput?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@HGJE@MessagePresent?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@BKNM@MiGetTemporalStateOfEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KBO@MiGetUpdateForView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@INOA@MiGetInstanceID_ForView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DOBB@MiGetDateTimeForOI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@FHHI@MiGetERTokenForEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@KJIK@MiGetViewEntityForView?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GNDO@UfAddToDateTime?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@NCOA@GetAttributeDisplayLength?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@FFIH@MiGetCardinalityForEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@CJIE@NetActivateOI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FBGD@NetClose?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@DLBE@NetCommitOI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@PHPI@NetGetTraceLevel?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HFPC@NetListen?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@KDCL@NetStopListen?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@KEJB@NetSetTraceLevel?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@BIJE@NetStartup?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09MBHB@NetStatus?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@EMEG@NetProcessMessage?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IGEP@NetCommitOI_ToFile?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@FKGD@NetActivateOI_FromFile?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@HCAL@NetSendBootstrapFile?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DPLM@NetCallOperation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@KJLN@NetGetLocalHostAddress?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@BMMC@NetSendFile?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@PDEP@SetIncrementalUpdateFlags?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@GACK@GetIncrementalUpdateFlags?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@NAKK@SetBlobFromFile?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@HHIJ@WriteBlobToFile?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HLHF@SfCheckOI_Integrity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@JILI@GenerateQualFromEntityList?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@NLM@WriteOI_ToXML?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@MMDJ@WriteSubobjectToXML?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@IOBH@CommitSubobjectToXML_File?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DC@JNDE@Exceeded?5Process?5Limit?5?4?4?4?5Conta@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@FEHM@SysSetDefaultTaskForProcess?5Depr@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@MPNN@Zeidon?5Object?5Services?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@KNBA@Process?5already?5has?5a?5default?5ta@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03JBJA@ON?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CMJG@OFF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@GGNM@Session?5Id?3?5?$CFs?5?5?$DN?$DN?$DO?5?$CFs?5?$CI?$CFs?$CJ?5?5Thr@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DF@MIGE@STP?5S?1V?1T?3?5?$CFs?10x?$CF08x?10x?$CF08x?5?5?$DN?$DN?$DO@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FF@GKII@STP?5S?1V?1T?3?5?$CFs?10x?$CF08x?10x?$CF08x?5?5?$DN?$DN?$DO@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JBPC@?$FLApp?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FIMD@?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@OCBP@WebDirectory?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@IMEJ@?$FLWorkstation?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JJCH@0x?$CF08x?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GACC@KZXMLPGO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IKFC@DialogName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06FPEO@Dialog?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CJHF@WindowName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06FCEH@Window?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KCAL@FocusCtrl?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@GCAG@DynamicBannerName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PIKM@BannerName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IIPE@KZOENGWA?5?9?5Termination?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0GN@DNGN@The?5Zeidon?5Object?5Engine?5hasn?8t?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@KHAA@InitCriticalSection?3?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0GC@PKCM@RegisterZeidonApplication?5?$DN?$DN?$DN?$DN?$DN?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0GH@BDLJ@RegisterZeidonApplication?5?$DN?$DN?$DN?$DN?$DN?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FJ@COG@?$CIUnr?$CJ?5Cleaning?5up?5Registered?5S?1T@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03DCGD@DDD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03PHAE@ddd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02PPJD@DD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03KNBB@MMM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03GIHG@mmm?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02KCEC@MM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02CFPA@mm?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03PHAO@YYY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PJGI@YYYY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@BJED@Missing?5ending?5delimiter?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@EEMD@Zeidon?5Error?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03PLJD@ENU?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CHCO@DEU?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03NOPN@FRC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IDPK@POR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03JNKA@SPA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01KMAE@?0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PKAG@?3?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02ENLM@AM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02DBLP@PM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NNHK@mm?1dd?1yy?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CFAC@mmm?5dd?0?5yyyy?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PILM@$?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PJCK@?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02OOIJ@HH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PBHI@H?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01HMO@?$CC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02IBO@MI?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03PGJ@?5AM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@BDDO@No?5terminating?5?8?$CF?8?5in?5ZEIDON?4APP@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PEHO@zeidon?4ini?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09ODBK@AllocSize?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CJOG@OE?5Anchor?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DBJB@InitAnchor?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02NCFH@?5?8?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01HAF@?8?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02GIEM@?0?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04FEEL@TEMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LDNL@TMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@IKIP@MemoryTraceThreshold?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@CGC@?$FLObjectEngine?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@CGLF@MemoryCeiling?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@NLJM@Object?5Services?5Initialization?5c@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@EGPN@Object?5Services?5Running?5in?5Serve@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@LCNC@Object?5Services?5Running?5in?5Share@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FE@PDLP@fnFreeLocalAnchorBlock?5Page?5Tabl@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@MHCA@Received?5a?5message?5while?5in?5Serv@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@MMNK@Internal?5Error?5?9?5lpRequestProces@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@INJH@Zeidon?5Object?5Engine?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@LLDD@?$CIsy?$CJ?5DuplicateHandle?5RC?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@MJGK@?$CIsy?$CJ?5DuplicateHandle?5Failed?3?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@JGNK@Internal?5error?5?9?9?5DuplicateHandl@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@LBEN@Error?5destroying?5mutex?3?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@KLMC@Unknown?5message?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@EGB@AllocShared?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@OOBG@Zeidon?5Internal?5Error?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@LNJI@Error?5Calling?5SendMsg?$CI?5?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07OCOK@No?5view?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@NCNE@Check?5Pointer?5Error?5for?5TableInd@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@PGOJ@Check?5Pointer?5Error?5for?5TableInd@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@MIHA@Zeidon?5Core?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DI@JMDM@Invalid?5pointer?5handle?5for?5free?3@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CP@HMMO@KZOE0012?5?9?5Error?5allocating?5memo@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EM@LLEE@fnGetAnchorBlock?5Page?5Table?5mapp@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@LDJC@g_lProcessIdx?5?$CB?$DN?5?91?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03FMHJ@DGC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09MIBB@GetAnchor?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@JNJD@Couldn?8t?5find?5ZEIDON_BIN?5specifi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@GCKC@Zeidon?5?9?5Object?5Services?5Init?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03DMDD@?5?9?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@FAPI@MS?5Windows?53?4x?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@FLLN@MS?5Windows?595?198?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CFLM@MS?5Windows?5NT?1XP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IBID@IBM?5OS?12?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@LGIB@?$CIsy?$CJ?5SysStartObjectServices?5star@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DG@KGPA@Invalid?5pointer?5handle?5?$CIget?$CJ?5?3?5h@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DO@NGGI@Invalid?5pointer?5handle?5?$CInull?$CJ?5at@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@IFBI@Invalid?5pointer?3?5hi?9bit?5set?$CB?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@EPII@Invalid?5pointer?3?5hi?9bit?5not?5set?$CB@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@NNIF@Out?5of?5memory?5pages?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EC@HOEL@fnMapFile?5Page?5Table?5conflict?5at@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@OCNM@Diagnostic?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FGLN@?$FLDebug?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@NKGM@ServerDebug?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DM@OLK@Message?5Handler?5Error?5opening?5lo@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@BDGH@WebUserErrorMessages?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@OFLB@SysMessageBox?5Title?3?5?$CFs?5?5?5Error?3@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@FMCK@HH?3MI?3SS?4999?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@FAGA@YYYY?9MM?9DD?5HH?3MI?3SS?4999?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@EADK@?$CFs?5Task?$CI?$CFx?$CJ?5?3?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@FCLN@OE?5Trace?5Unavailable?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@FBHK@?$CIsy?$CJ?5Logon?5Userid?$DN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@GEKD@?$CFsZTF_?$CFlx_?$CFlx?4TMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EP@BOCM@SysRenameFile?5MoveFile?5RC?3?5?$CFld?5?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@OCKP@Zeidon?5MoveFile?5Error?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EA@ECMJ@SysOpenFile?5for?5file?3?5?$CFs?5failed?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IHCD@0x?$CF08x?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CM@PPJA@SysDeleteFile?5Error?3?5?$CFs?5?5?5File?3?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@LAPP@?$CIsy?$CJ?5Could?5not?5open?5file?3?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CEDG@?$CIsy?$CJ?5Reason?5code?5?$DN?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@NLFO@SysReadLine?5null?5OpenFile?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@JEGM@SysReadLine?5?4?4?4?5no?5open?5files?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CL@CHJM@SysReadLine?5?4?4?4?5buffer?5acquisiti@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02PIMC@?$AN?6?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FG@EBEM@fnSysCloseFileWithControl?5?$CFs?5?5?5H@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@FPAN@SysSetFileTime?3?5Couldn?8t?5open?5fi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@PPDE@?$CF4d?$CF02d?$CF02d?$CF02d?$CF02d?$CF02d?$CF03d?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@BLPA@?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@BKKK@ReturnValue?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GMMJ@Operation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@HBNK@Zeidon?5System?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01KGOM@T?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@BHAM@GetDateTime?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NCBN@kzoengaa?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GPBK@zWinSock?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@GMLB@Invalid?5type?5for?5Early?5Date?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@EONO@SysGetDateTimeDifference?3?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@GEFP@Invalid?5type?5for?5Later?5Date?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0GB@KOIH@?$CIsy?$CJ?5SysLoadLibrary?5failed?5to?5lo@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@PAML@Load?5failed?5for?3?5?$CFs?5?$CI?$CFs?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@POOP@System?5Services?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BDOP@SY00101?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EK@FCCD@?$CIsy?$CJ?5SysGetProc?5failed?5with?5erro@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EA@DNMP@FreeLibrary?5sent?5message?5?$CI0x?$CF08x@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DM@HPCG@FreeLibrary?5did?5not?5free?5?$CI0x?$CF08x@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GKDJ@?$FL?$CFs?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DBPH@?$CFs?$DN?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IOL@zeidon?4in?$HO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08KBJI@?$FLZeidon?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@HMIB@?$FLEncyclopedia?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@GKOC@?$FLObject?5Services?$FN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@OHMI@Error?5in?5directory?5specification@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@KAEF@Error?5creating?5directory?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LGM@SYSTEM?5HELP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@DADJ@winhelp?4hlp?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MCON@?4CHM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NHGK@?$DOmainwin?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@OOIH@?$CIsy?$CJ?5Starting?5help?5with?3?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CM@HOD@?$CIsy?$CJ?5Starting?5context?9sensitive?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@BFPA@MyWindowType?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@BGCK@?5?$DN?5?$CFlf?5seconds?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CO@IFCF@?$CIZDecimal?$CJ?5Using?5default?5zDecima@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CC@GDM@?$CIZDecimal?$CJ?5Precision?5?$CIin?5bits?$CJ?5?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GBEO@?$CF?4?$CKf?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02JBAA@?$CFf?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IPNG@0?40?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OJCG@Mutex?5?8?$CFs?8?5already?5created?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@NCB@Error?5creating?5mutex?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@JEKI@Trying?5to?5destroy?5NULL?5Mutex?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@ODA@Error?5destroying?5mutex?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@NAII@Trying?5to?5lock?5NULL?5Mutex?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@PNEP@Trying?5to?5unlock?5NULL?5Mutex?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@HDOA@Error?5releasing?5mutex?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KKLG@Null?5task?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09PEMB@MutexFind?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@KDEH@fnMutexCreate?5Invalid?5mutex?5name@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@MGPE@?$CItm?$CJ?5Error?5trying?5to?5lock?5mutex?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IMPM@Error?5locking?5mutex?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05CKBG@Error?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@FCNG@?5?9?9?9?9?5MUTEX?5LIST?5?9?9?9?9?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@DCCM@MutexQueryStatus?5?$CFs?5?9?9?5Checking?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@LOL@MutexQueryStatus?5?$CFs?5?9?9?5FAILED?5?$CI?$CF@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@INMI@MutexQueryStatus?5?$CFs?5?9?9?5OK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@GMLN@Mutex?5?8?$CFs?8?5locked?5by?5Task?3?5?$CFd?5?5P@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CH@OFLB@Mutex?5?8?$CFs?8?5is?5unlocked?5?5?5Process@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EG@GHCJ@Task?50x?$CF08x?5?$CIprocess?5id?3?$CFd?$CJ?5is?5w@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08EIPD@KZOESYAA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CI@DLDL@SysMainWndProc?5for?5Tomcat?5sessio@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DP@DCII@SysInitApplicationWindow?5Class?3?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08HAKP@KZOESRVC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01OAK@N?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@EMHA@ServerMode?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@JELK@ObjectEngine?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	_szlTask
PUBLIC	??_C@_04HDAF@Task?$AA@				; `string'
PUBLIC	_szlText
PUBLIC	??_C@_04BNNJ@Text?$AA@				; `string'
PUBLIC	_szlTYPE
PUBLIC	??_C@_04JHII@TYPE?$AA@				; `string'
PUBLIC	_szlUP_DATE
PUBLIC	??_C@_07KJPH@UP_DATE?$AA@			; `string'
PUBLIC	_szlUSERID
PUBLIC	??_C@_06PIPA@USERID?$AA@			; `string'
PUBLIC	_szlUPDATE
PUBLIC	??_C@_06NDPG@UPDATE?$AA@			; `string'
PUBLIC	_szlZKEY
PUBLIC	??_C@_04JGIO@ZKEY?$AA@				; `string'
PUBLIC	_szlApplicationLogicError
PUBLIC	??_C@_0CK@BELJ@Object?5Services?5?9?5Application?5Lo@ ; `string'
PUBLIC	_szlDataValidationError
PUBLIC	??_C@_0BG@FMPG@Data?5Validation?5Error?$AA@	; `string'
PUBLIC	_szlOE_SystemError
PUBLIC	??_C@_0BA@ODOC@OE?5System?5Error?$AA@		; `string'
PUBLIC	_szlAFTER
PUBLIC	??_C@_05HBLJ@AFTER?$AA@				; `string'
PUBLIC	_szlBEFORE
PUBLIC	??_C@_06COI@BEFORE?$AA@				; `string'
PUBLIC	_g_pchMQI
PUBLIC	??_C@_0P@BAHL@MQ_MessageSend?$AA@		; `string'
PUBLIC	??_C@_0BB@MBCE@MQ_MessagePrompt?$AA@		; `string'
PUBLIC	??_C@_0BJ@MAFE@MQ_MessagePromptForInput?$AA@	; `string'
PUBLIC	??_C@_0BC@GMHO@MQ_MessagePresent?$AA@		; `string'
PUBLIC	_szGAFANullS
PUBLIC	_g_pchMon
PUBLIC	??_C@_07BPKJ@January?$AA@			; `string'
PUBLIC	??_C@_08PGBA@February?$AA@			; `string'
PUBLIC	??_C@_05FGPD@March?$AA@				; `string'
PUBLIC	??_C@_05JFGC@April?$AA@				; `string'
PUBLIC	??_C@_03MGHB@May?$AA@				; `string'
PUBLIC	??_C@_04ICFP@June?$AA@				; `string'
PUBLIC	??_C@_04PIJO@July?$AA@				; `string'
PUBLIC	??_C@_06PADP@August?$AA@			; `string'
PUBLIC	??_C@_09MKGD@September?$AA@			; `string'
PUBLIC	??_C@_07IAMM@October?$AA@			; `string'
PUBLIC	??_C@_08NJLI@November?$AA@			; `string'
PUBLIC	??_C@_08LIDF@December?$AA@			; `string'
PUBLIC	_g_pchDOW
PUBLIC	??_C@_06OOEM@Sunday?$AA@			; `string'
PUBLIC	??_C@_06CHLK@Monday?$AA@			; `string'
PUBLIC	??_C@_07BMBC@Tuesday?$AA@			; `string'
PUBLIC	??_C@_09PBIN@Wednesday?$AA@			; `string'
PUBLIC	??_C@_08CCFO@Thursday?$AA@			; `string'
PUBLIC	??_C@_06ONCK@Friday?$AA@			; `string'
PUBLIC	??_C@_08FAKH@Saturday?$AA@			; `string'
PUBLIC	_szlINTL
PUBLIC	??_C@_04KGMK@Intl?$AA@				; `string'
PUBLIC	_szlICOUNTRY
PUBLIC	??_C@_08FKAM@iCountry?$AA@			; `string'
PUBLIC	_szlSCOUNTRY
PUBLIC	??_C@_08JMM@sCountry?$AA@			; `string'
PUBLIC	_szlSLANGUAGE
PUBLIC	??_C@_09IMGC@sLanguage?$AA@			; `string'
PUBLIC	_szlSLIST
PUBLIC	??_C@_05NLOI@sList?$AA@				; `string'
PUBLIC	_szlIMEASURE
PUBLIC	??_C@_08HHE@iMeasure?$AA@			; `string'
PUBLIC	_szlITIME
PUBLIC	??_C@_05EMIJ@iTime?$AA@				; `string'
PUBLIC	_szlSTIME
PUBLIC	??_C@_05PLM@sTime?$AA@				; `string'
PUBLIC	_szlS1159
PUBLIC	??_C@_05PCBI@s1159?$AA@				; `string'
PUBLIC	_szlS2359
PUBLIC	??_C@_05DJMD@s2359?$AA@				; `string'
PUBLIC	_szlITLZERO
PUBLIC	??_C@_07LDFB@iTLZero?$AA@			; `string'
PUBLIC	_szlSSHORTDATE
PUBLIC	??_C@_0L@NPLI@sShortDate?$AA@			; `string'
PUBLIC	_szlSLONGDATE
PUBLIC	??_C@_09JENF@sLongDate?$AA@			; `string'
PUBLIC	_szlSCURRENCY
PUBLIC	??_C@_09JDHO@sCurrency?$AA@			; `string'
PUBLIC	_szlICURRENCY
PUBLIC	??_C@_09CBCN@iCurrency?$AA@			; `string'
PUBLIC	_szlICURRDIGITS
PUBLIC	??_C@_0M@LKGH@iCurrDigits?$AA@			; `string'
PUBLIC	_szlINEGCURR
PUBLIC	??_C@_08LHOD@iNegCurr?$AA@			; `string'
PUBLIC	_szlSTHOUSAND
PUBLIC	??_C@_09BEPN@sThousand?$AA@			; `string'
PUBLIC	_szlSDECIMAL
PUBLIC	??_C@_08GFHF@sDecimal?$AA@			; `string'
PUBLIC	_szlIDIGITS
PUBLIC	??_C@_07FACE@iDigits?$AA@			; `string'
PUBLIC	_szlILZERO
PUBLIC	??_C@_06LENA@iLzero?$AA@			; `string'
PUBLIC	??_C@_0DC@KKHB@KZOEE001?5?9?5Error?5communicating?5w@ ; `string'
PUBLIC	??_C@_0CP@JFJD@KZOEE002?5?9?5ZEIDON?5environment?5va@ ; `string'
PUBLIC	??_C@_0CK@LHJO@KZOEE003?5?9?5Error?5starting?5Object@ ; `string'
PUBLIC	??_C@_0DE@HPME@KZOEE004?5?9?5Error?5communicating?5w@ ; `string'
PUBLIC	??_C@_0DE@HEBF@KZOEE005?5?9?5Error?5communicating?5w@ ; `string'
PUBLIC	??_C@_0CP@HIJD@KZOEE006?5?9?5Internal?5error?5freein@ ; `string'
PUBLIC	??_C@_0ED@FDBJ@KZOEE007?5?9?5Internal?5Anchor?5block@ ; `string'
PUBLIC	??_C@_0EI@BCLB@KZOEE008?5?9?5Application?5definitio@ ; `string'
PUBLIC	??_C@_0DF@MKOJ@KZOEE009?5?9?5Error?5opening?5applica@ ; `string'
PUBLIC	??_C@_0CL@MFKJ@KZOEE010?5?9?5Requested?5application@ ; `string'
PUBLIC	??_C@_0DC@DKPD@KZOEE011?5?9?5Error?5opening?5applica@ ; `string'
PUBLIC	??_C@_0CD@KFHE@KZOEE012?5?9?5Error?5allocating?5memo@ ; `string'
PUBLIC	??_C@_0CJ@MDMN@KZOEE013?5?9?5Internal?5operation?5ca@ ; `string'
PUBLIC	??_C@_0CO@LCNE@KZOEE014?5?9?5Invalid?5suballoc?5memo@ ; `string'
PUBLIC	??_C@_0CI@OGFD@KZOEE015?5?9?5Invalid?5suballoc?5memo@ ; `string'
PUBLIC	??_C@_0BI@EDAJ@KZOEE016?5?9?5Invalid?5Task?$AA@	; `string'
PUBLIC	??_C@_0BM@MOGK@KZOEE017?5?9?5Task?5is?5Disabled?$AA@ ; `string'
PUBLIC	??_C@_0CI@DHKC@KZOEE018?5?9?5Error?5in?5Domain?5file?0@ ; `string'
PUBLIC	??_C@_0CJ@PAMN@KZOEE019?5?9?5Invalid?5GetTaskInfo?5r@ ; `string'
PUBLIC	??_C@_0CD@COHN@KZOEE020?5?9?5Invalid?5Operation?5cal@ ; `string'
PUBLIC	??_C@_0EJ@OFCD@KZOEE021?5?9?5Internal?5error?0?5TaskO@ ; `string'
PUBLIC	??_C@_0BO@PFIN@KZOEE022?5?9?5Error?5writing?5file?$AA@ ; `string'
PUBLIC	??_C@_0BP@ENDH@KZOEE023?5?9?5Invalid?5parameter?0?5?$AA@ ; `string'
PUBLIC	??_C@_0BO@LNEH@KZOEE024?5?9?5Error?5opening?5file?$AA@ ; `string'
PUBLIC	??_C@_0CM@LGJG@KZOEE025?5?9?5Error?5in?5directory?5sp@ ; `string'
PUBLIC	??_C@_0CE@CFOB@KZOEE026?5?9?5Error?5creating?5direct@ ; `string'
PUBLIC	??_C@_0CF@MDHP@KZOEE030?5?9?5Error?5loading?5library@ ; `string'
PUBLIC	??_C@_0CI@KCKB@KZOEE031?5?9?5Error?5locating?5Operat@ ; `string'
PUBLIC	??_C@_0CB@KHLN@KZOEE032?5?9?5Mutex?5name?5is?5invalid@ ; `string'
PUBLIC	??_C@_0CL@NPAH@KZOEE050?5?9?5Error?5opening?5View?5Ob@ ; `string'
PUBLIC	??_C@_0CL@EMEJ@KZOEE051?5?9?5Invalid?5View?5Object?5f@ ; `string'
PUBLIC	??_C@_0EG@KBNM@KZOEE052?5?9?5Invalid?5Object?5file?0?5@ ; `string'
PUBLIC	??_C@_0CP@CJAD@KZOEE053?5?9?5Invalid?5Entity?5level?5@ ; `string'
PUBLIC	??_C@_0CJ@OIAJ@KZOEE054?5?9?5Invalid?5record?5found?5@ ; `string'
PUBLIC	??_C@_0DM@CCJK@KZOEE055?5?9?5Invalid?5file?0?5LTH?5or?5@ ; `string'
PUBLIC	??_C@_0CF@JDKN@KZOEE056?5?9?5Domain?5not?5found?5on?5l@ ; `string'
PUBLIC	??_C@_0DN@EDAD@KZOEE057?5?9?5Invalid?5file?0?5LTH?5bef@ ; `string'
PUBLIC	??_C@_0EE@OCOD@KZOEE058?5?9?5Invalid?5file?0?5PERSIST@ ; `string'
PUBLIC	??_C@_0EC@PMPM@KZOEE059?5?9?5Invalid?5file?0?5Invalid@ ; `string'
PUBLIC	??_C@_0CL@PNHL@KZOEE060?5?9?5Invalid?5maximum?5root?5@ ; `string'
PUBLIC	??_C@_0DD@IPCF@KZOEE061?5?9?5Persistent?5Attribute?5@ ; `string'
PUBLIC	??_C@_0EH@FCEJ@KZOEE062?5?9?5Conflict?5between?5E?1R?5@ ; `string'
PUBLIC	??_C@_0EG@PGNO@KZOEE063?5?9?5Entity?5attrib?5RECURSI@ ; `string'
PUBLIC	??_C@_0CI@DBKC@KZOEE064?5?9?5TYPE?5obsolete?0?5use?5AP@ ; `string'
PUBLIC	??_C@_0DM@HNKG@KZOEE065?5?9?5LTH?5only?5valid?5for?5At@ ; `string'
PUBLIC	??_C@_0CC@DFAB@KZOEE066?5?9?5Attribute?5length?5zero@ ; `string'
PUBLIC	??_C@_0DH@DFDK@KZOEE067?5?9?5Could?5not?5initialize?5@ ; `string'
PUBLIC	??_C@_0CE@GHFO@KZOEE070?5?9?5Object?5instance?5is?5em@ ; `string'
PUBLIC	??_C@_0CI@HPIK@KZOEE071?5?9?5Error?5opening?5instanc@ ; `string'
PUBLIC	??_C@_0CI@EEEO@KZOEE072?5?9?5Error?5reading?5instanc@ ; `string'
PUBLIC	??_C@_0CI@GPMH@KZOEE073?5?9?5Invalid?5instance?5file@ ; `string'
PUBLIC	??_C@_0CI@NBOH@KZOEE074?5?9?5Invalid?5Entity?5name?5o@ ; `string'
PUBLIC	??_C@_0CJ@FMPI@KZOEE075?5?9?5Invalid?5Entity?5level?5@ ; `string'
PUBLIC	??_C@_0DP@HHHP@KZOEE076?5?9?5Object?5instance?5conta@ ; `string'
PUBLIC	??_C@_0DJ@EOHG@KZOEE077?5?9?5Invalid?5record?5size?5i@ ; `string'
PUBLIC	??_C@_0EA@PIKP@KZOEE078?5?9?5Internal?5error?0?5linke@ ; `string'
PUBLIC	??_C@_0CN@GDKG@KZOEE079?5?9?5Trying?5to?5commit?5a?5re@ ; `string'
PUBLIC	??_C@_0EI@ENAN@KZOEE080?5?9?5Object?5Definition?5doe@ ; `string'
PUBLIC	??_C@_0EG@IICI@KZOEE081?5?9?5Object?5Definition?5doe@ ; `string'
PUBLIC	??_C@_0CJ@BEFH@KZOEE082?5?9?5Error?5starting?5Genkey@ ; `string'
PUBLIC	??_C@_0IJ@LNPL@KZOEE083?5?9?5LOD?5does?5not?5have?5phy@ ; `string'
PUBLIC	??_C@_0EB@HECI@KZOEE084?5?9?5Entity?5in?5Object?5Defi@ ; `string'
PUBLIC	??_C@_0EK@GEM@KZOEE085?5?9?5Entity?5in?5Object?5Defi@ ; `string'
PUBLIC	??_C@_0CE@ELED@KZOEE086?5?9?5Trying?5to?5commit?50?5vi@ ; `string'
PUBLIC	??_C@_0CI@MFDJ@KZOEE087?5?9?5Too?5many?5views?5in?5Vie@ ; `string'
PUBLIC	??_C@_0DF@CEHL@KZOEE088?5?9?5Compressed?5OI?5is?5out?5@ ; `string'
PUBLIC	??_C@_0EC@IMDC@KZOEE090?5?9?5Maximum?5number?5of?5ent@ ; `string'
PUBLIC	??_C@_0DO@CEAH@KZOEE091?5?9?5Maximum?5number?5of?5ent@ ; `string'
PUBLIC	??_C@_0DN@DGMC@KZOEE092?5?9?5Couldn?8t?5re?9activate?5@ ; `string'
PUBLIC	??_C@_0EN@GBNJ@KZOEE093?5?9?5Optimistic?5locking?5er@ ; `string'
PUBLIC	??_C@_0BN@NOMM@KZOEE094?5?9?5Locking?5violation?$AA@ ; `string'
PUBLIC	??_C@_0JB@CGJ@KZOEE095?5?9?5A?5recursive?5child?5was@ ; `string'
PUBLIC	??_C@_0CK@LDGH@KZOEE096?5?9?5Error?5retrieving?5OI?5f@ ; `string'
PUBLIC	??_C@_0DA@GDIC@KZOEE100?5?9?5Invalid?5View?0?5view?5is@ ; `string'
PUBLIC	??_C@_0BI@NHEC@KZOEE101?5?9?5Invalid?5View?$AA@	; `string'
PUBLIC	??_C@_0CI@JOEN@KZOEE102?5?9?5Invalid?5View?0?5view?5is@ ; `string'
PUBLIC	??_C@_0CI@DCOG@KZOEE103?5?9?5Invalid?5Entity?5name?5f@ ; `string'
PUBLIC	??_C@_0DL@IOKD@KZOEE104?5?9?5Invalid?5Attribute?5nam@ ; `string'
PUBLIC	??_C@_0DA@OHNK@KZOEE105?5?9?5Invalid?5scoping?5Entit@ ; `string'
PUBLIC	??_C@_0BM@LNED@KZOEE106?5?9?5Rules?5violation?5?$AA@ ; `string'
PUBLIC	??_C@_0CA@ICEI@KZOEE107?5?9?5Invalid?5Subtask?5View?$AA@ ; `string'
PUBLIC	??_C@_0CI@CNMF@KZOEE108?5?9?5Attempt?5to?5drop?5Subta@ ; `string'
PUBLIC	??_C@_0DD@IEKN@KZOEE109?5?9?5Invalid?5View?0?5view?5co@ ; `string'
PUBLIC	??_C@_0CH@NIKJ@KZOEE110?5?9?5Invalid?5level?5for?5Vie@ ; `string'
PUBLIC	??_C@_0EF@IJII@KZOEE111?5?9?5Attempt?5to?5set?5subtas@ ; `string'
PUBLIC	??_C@_0EC@BHLF@KZOEE112?5?9?5Attempt?5to?5set?5subtas@ ; `string'
PUBLIC	??_C@_0DD@OJHP@KZOEE113?5?9?5Invalid?5View?0?5view?5co@ ; `string'
PUBLIC	??_C@_0DD@NFKB@KZOEE114?5?9?5Source?5and?5Target?5ent@ ; `string'
PUBLIC	??_C@_0EB@HFOP@KZOEE115?5?9?5Attempt?5to?5move?5an?5in@ ; `string'
PUBLIC	??_C@_0EL@JFCI@KZOEE116?5?9?5Attempt?5to?5include?5an@ ; `string'
PUBLIC	??_C@_0CN@EDAL@KZOEE117?5?9?5Entity?5Instance?5Keys?5@ ; `string'
PUBLIC	??_C@_0DM@BDCF@KZOEE118?5?9?5Internal?5Key?5error?5re@ ; `string'
PUBLIC	??_C@_0CL@GLPJ@KZOEE119?5?9?5Invalid?5View?0?5View?5is@ ; `string'
PUBLIC	??_C@_0CG@MFLA@KZOEE120?5?9?5Invalid?5position?5para@ ; `string'
PUBLIC	??_C@_0DG@NDMM@KZOEE121?5?9?5Attempt?5to?5insert?5twi@ ; `string'
PUBLIC	??_C@_0DI@HBNG@KZOEE122?5?9?5Attempt?5to?5create?5an?5@ ; `string'
PUBLIC	??_C@_0FB@NPFI@KZOEE124?5?9?5Entity?5parent?5is?5incl@ ; `string'
PUBLIC	??_C@_0EC@FECD@KZOEE125?5?9?5Target?5and?5Source?5Ent@ ; `string'
PUBLIC	??_C@_0DG@JPKB@KZOEE126?5?9?5Target?5or?5Source?5Enti@ ; `string'
PUBLIC	??_C@_0EH@IKFL@KZOEE127?5?9?5Source?5?$CG?5target?5do?5no@ ; `string'
PUBLIC	??_C@_0EG@KLAD@KZOEE128?5?9?5Target?5Entity?5cardina@ ; `string'
PUBLIC	??_C@_0IA@GFGF@KZOEE129?5?9?5Trying?5to?5create?5a?5re@ ; `string'
PUBLIC	??_C@_0EG@DDAB@KZOEE131?5?9?5Attempt?5to?5include?5Su@ ; `string'
PUBLIC	??_C@_0DL@FCGD@KZOEE132?5?9?5Error?5establishing?5cu@ ; `string'
PUBLIC	??_C@_0FA@LJEB@KZOEE134?5?9?5Attempt?5to?5version?5an@ ; `string'
PUBLIC	??_C@_0CJ@EFHN@KZOEE135?5?9?5Entity?5Instance?5not?5v@ ; `string'
PUBLIC	??_C@_0CN@MAJK@KZOEE136?5?9?5Entity?5Instance?5alrea@ ; `string'
PUBLIC	??_C@_0DA@LGF@KZOEE137?5?9?5Entity?5Instance?5desce@ ; `string'
PUBLIC	??_C@_0EE@IOCN@KZOEE138?5?9?5Attempt?5to?5include?5ta@ ; `string'
PUBLIC	??_C@_0DM@EDLN@KZOEE139?5?9?5Error?5establishing?5cu@ ; `string'
PUBLIC	??_C@_0ED@EHNP@KZOEE140?5?9?5Target?5and?5source?5Obj@ ; `string'
PUBLIC	??_C@_0EK@MPKH@KZOEE141?5?9?5Attempt?5to?5include?5a?5@ ; `string'
PUBLIC	??_C@_0CI@HOIP@KZOEE190?5?9?5Error?5opening?5tempora@ ; `string'
PUBLIC	??_C@_0EC@BIGN@KZOEE191?5?9?5Attribute?5must?5be?5a?5B@ ; `string'
PUBLIC	??_C@_0DA@CNJA@KZOEE231?5?9?5Decimal?5attribute?5ove@ ; `string'
PUBLIC	??_C@_0DP@LJHO@KZOEE232?5?9?5Operation?5indicates?5u@ ; `string'
PUBLIC	??_C@_0DG@KPMG@KZOEE233?5?9?5Could?5not?5locate?5deri@ ; `string'
PUBLIC	??_C@_0EH@EJPO@KZOEE234?5?9?5Attempt?5to?5add?5intege@ ; `string'
PUBLIC	??_C@_0BM@GBBH@KZOEE235?5?9?5Integer?5overflow?$AA@ ; `string'
PUBLIC	??_C@_0BN@JFBL@KZOEE236?5?9?5Integer?5underflow?$AA@ ; `string'
PUBLIC	??_C@_0DI@NJGM@KZOEE237?5?9?5Attempt?5to?5update?5a?5n@ ; `string'
PUBLIC	??_C@_0ED@IIED@KZOEE238?5?9?5Attempt?5to?5update?5a?5n@ ; `string'
PUBLIC	??_C@_0DA@EHLD@KZOEE239?5?9?5Invalid?5Operation?5for@ ; `string'
PUBLIC	??_C@_0DM@EDAM@KZOEE240?5?9?5Binary?5large?5object?5?$CI@ ; `string'
PUBLIC	??_C@_0CC@FKDO@KZOEE241?5?9?5Invalid?5Variable?5Type@ ; `string'
PUBLIC	??_C@_0CF@KFFO@KZOEE242?5?9?5Invalid?5Domain?5Entry?5@ ; `string'
PUBLIC	??_C@_0CG@NJPF@KZOEE243?5?9?5Context?5invalid?5for?5D@ ; `string'
PUBLIC	??_C@_0CD@FNBB@KZOEE244?5?9?5Attribute?5has?5no?5Doma@ ; `string'
PUBLIC	??_C@_0DM@CLHG@KZOEE245?5?9?5Null?5string?5not?5allow@ ; `string'
PUBLIC	??_C@_0CD@EGIM@KZOEE246?5?9?5Invalid?5Attribute?5typ@ ; `string'
PUBLIC	??_C@_0DM@LIOD@KZOEE247?5?9?5Blob?5Attribute?5does?5n@ ; `string'
PUBLIC	??_C@_0CG@JDPP@KZOEE248?5?9?5Required?5attribute?5is@ ; `string'
PUBLIC	??_C@_0CE@HNFJ@KZOEE250?5?9?5Object?5instance?5is?5em@ ; `string'
PUBLIC	??_C@_0CJ@PNML@KZOEE252?5?9?5Root?5of?5view?5has?5been@ ; `string'
PUBLIC	??_C@_0CB@ICBE@KZOEE253?5?9?5Entity?5cursor?5is?5NULL@ ; `string'
PUBLIC	??_C@_0CG@DKJB@KZOEE254?5?9?5Entity?5cursor?5is?5unde@ ; `string'
PUBLIC	??_C@_0DH@MKIF@KZOEE255?5?9?5Attempt?5to?5update?5a?5p@ ; `string'
PUBLIC	??_C@_0CC@IDGK@KZOEE256?5?9?5Entity?5is?5root?5of?5vie@ ; `string'
PUBLIC	??_C@_0EA@FEIJ@KZOEE257?5?9?5Version?5mismatch?5betw@ ; `string'
PUBLIC	??_C@_0CO@IOAK@KZOEE258?5?9?5Scoping?5Entity?5cursor@ ; `string'
PUBLIC	??_C@_0CJ@MMGH@KZOEE259?5?9?5Scoping?5Entity?5cursor@ ; `string'
PUBLIC	??_C@_0EP@DIEE@KZOEE263?5?9?5Input?5Qualifier?5canno@ ; `string'
PUBLIC	??_C@_0DJ@DMDO@KZOEE264?5?9?5Invalid?5Operation?5for@ ; `string'
PUBLIC	??_C@_0DN@JHKM@KZOEE265?5?9?5Invalid?5Operation?5for@ ; `string'
PUBLIC	??_C@_0DO@NFPG@KZOEE266?5?9?5Invalid?5Operation?5for@ ; `string'
PUBLIC	??_C@_0CM@LKBG@KZOEE267?5?9?5Hierarchical?5cursor?5i@ ; `string'
PUBLIC	??_C@_0DH@KDFJ@KZOEE268?5?9?5Source?5and?5target?5ent@ ; `string'
PUBLIC	??_C@_0CG@FACO@KZOEE269?5?9?5Invalid?5Select?5Set?5ID@ ; `string'
PUBLIC	??_C@_0CH@HOLD@KZOEE270?5?9?5View?5name?5is?5already?5@ ; `string'
PUBLIC	??_C@_0DO@BMHF@KZOEE271?5?9?5Subobject?5Entity?5is?5r@ ; `string'
PUBLIC	??_C@_0CL@LFIF@KZOEE272?5?9?5Subobject?5Parent?5Curs@ ; `string'
PUBLIC	??_C@_0DD@DLH@KZOEE273?5?9?5Parent?5Entity?5instanc@ ; `string'
PUBLIC	??_C@_0ED@GMM@KZOEE274?5?9?5Target?5and?5Source?5vie@ ; `string'
PUBLIC	??_C@_0CG@OIHN@KZOEE300?5?9?5Problems?5finding?5a?5pa@ ; `string'
PUBLIC	??_C@_0EH@GAK@KZOEE301?5?9?5Return?5buffer?5not?5lar@ ; `string'
PUBLIC	??_C@_0BK@JCI@KZOEE302?5?9?5Invalid?5option?$AA@ ; `string'
PUBLIC	??_C@_0EA@KHBJ@KZOEE330?5?9?5Message?5Object?5Defini@ ; `string'
PUBLIC	??_C@_0CI@HNHP@KZOEE350?5?9?5Context?5Not?5Valid?5for@ ; `string'
PUBLIC	??_C@_0CD@IIPK@KZOEE351?5?9?5Invalid?5Input?5Data?5Ty@ ; `string'
PUBLIC	??_C@_0DB@GJCM@KZOEE352?5?9?5Text?5String?5exceeds?5a@ ; `string'
PUBLIC	??_C@_0DC@CBDF@KZOEE353?5?9?5Attribute?5Type?5invali@ ; `string'
PUBLIC	??_C@_0CG@DCAE@KZOEE354?5?9?5Invalid?5Domain?5Entry?5@ ; `string'
PUBLIC	??_C@_0DH@JDFE@KZOEE355?5?9?5Table_Handler?5invalid@ ; `string'
PUBLIC	??_C@_0CK@FNMN@KZOEE356?5?9?5Domain?5has?5an?5unnamed@ ; `string'
PUBLIC	??_C@_0BO@LACG@KZOEE357?5?9?5Invalid?5Input?5Data?$AA@ ; `string'
PUBLIC	??_C@_0CM@DEPD@KZOEE358?5?9?5Value?5not?5in?5Context?5@ ; `string'
PUBLIC	??_C@_0DJ@BGND@KZOEE359?5?9?5Invalid?5Input?5Data?5Ty@ ; `string'
PUBLIC	??_C@_0CF@JLJE@KZOEE360?5?9?5Missing?5ending?5delimi@ ; `string'
PUBLIC	??_C@_0CA@PMLE@KZOEE361?5?9?5Invalid?5data?5Format?5?$AA@ ; `string'
PUBLIC	??_C@_0DL@IDHP@KZOEE362?5?9?5Variable?5Type?5not?5all@ ; `string'
PUBLIC	??_C@_0CL@NCJC@KZOEE363?5?9?5Context?5Edit?5string?5i@ ; `string'
PUBLIC	??_C@_0DA@MAJI@KZOEE364?5?9?5Picture?5length?5exceed@ ; `string'
PUBLIC	??_C@_0DF@EIIB@KZOEE400?5?9?5Error?5transmitting?5OI@ ; `string'
PUBLIC	??_C@_0BO@COPE@KZOEE401?5?9?5Invalid?5User?5Name?4?$AA@ ; `string'
PUBLIC	??_C@_0BN@LCML@KZOEE402?5?9?5Invalid?5Password?4?$AA@ ; `string'
PUBLIC	??_C@_0DJ@MFOH@KZOEE403?5?9?5Application?5not?5suppo@ ; `string'
PUBLIC	??_C@_0CB@ICKG@KZOEE404?5?9?5Can?8t?5find?5UserGroup?4@ ; `string'
PUBLIC	??_C@_0DL@EBIE@KZOEE405?5?9?5UserGroup?5doesn?8t?5hav@ ; `string'
PUBLIC	??_C@_0CF@PDBP@KZOEE450?5?9?5Name?5for?5view?5is?5too?5@ ; `string'
PUBLIC	??_C@_0DK@KFBA@KZOEE451?5?9?5Include?5source?5task?5d@ ; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
PUBLIC	??_C@_0BA@DLJN@SfCreateSubtask?$AA@		; `string'
PUBLIC	??_C@_0O@BDFC@SfDropSubtask?$AA@		; `string'
PUBLIC	??_C@_0M@FMPJ@DisableTask?$AA@			; `string'
PUBLIC	??_C@_0L@BBMP@EnableTask?$AA@			; `string'
PUBLIC	??_C@_0BJ@BDEP@GetApplDirectoryFromView?$AA@	; `string'
PUBLIC	??_C@_0BL@OJMF@SfGetApplicationForSubtask?$AA@	; `string'
PUBLIC	??_C@_0O@FHBI@SfGetTaskInfo?$AA@		; `string'
PUBLIC	??_C@_0BJ@PMHK@SfActivateSysOI_FromFile?$AA@	; `string'
PUBLIC	??_C@_0BF@PCON@SfActivateSysEmptyOI?$AA@	; `string'
PUBLIC	??_C@_0BM@OIBJ@ActivateEmptyObjectInstance?$AA@	; `string'
PUBLIC	??_C@_0BH@NOPG@ActivateObjectInstance?$AA@	; `string'
PUBLIC	??_C@_0BE@IMAC@ActivateOI_FromFile?$AA@		; `string'
PUBLIC	??_C@_0BI@GAMK@ActivateOI_FromXML_File?$AA@	; `string'
PUBLIC	??_C@_0BE@CGBG@CommitOI_ToXML_File?$AA@		; `string'
PUBLIC	??_C@_0BC@PDFM@ActivateOI_FromOI?$AA@		; `string'
PUBLIC	??_C@_0BF@GELD@CommitObjectInstance?$AA@	; `string'
PUBLIC	??_C@_0BC@FMKN@CommitMultipleOIs?$AA@		; `string'
PUBLIC	??_C@_0BA@MOCF@DropViewCluster?$AA@		; `string'
PUBLIC	??_C@_0BB@PMGH@AddToViewCluster?$AA@		; `string'
PUBLIC	??_C@_0BA@FDOM@CommitOI_ToFile?$AA@		; `string'
PUBLIC	??_C@_0BD@PHBJ@DropObjectInstance?$AA@		; `string'
PUBLIC	??_C@_0BH@NEFL@CheckExistenceOfEntity?$AA@	; `string'
PUBLIC	??_C@_0BG@HLNG@CompareEntityToEntity?$AA@	; `string'
PUBLIC	??_C@_0N@BOMB@CreateEntity?$AA@			; `string'
PUBLIC	??_C@_0N@DPDF@GetEntityKey?$AA@			; `string'
PUBLIC	??_C@_0BF@ELCK@CreateTemporalEntity?$AA@	; `string'
PUBLIC	??_C@_0BP@EIGM@CreateTemporalSubobjectVersion?$AA@ ; `string'
PUBLIC	??_C@_0BA@IEEA@AcceptSubobject?$AA@		; `string'
PUBLIC	??_C@_0BM@MAGB@AcceptAllTemporalSubobjects?$AA@	; `string'
PUBLIC	??_C@_0BA@NIBC@CancelSubobject?$AA@		; `string'
PUBLIC	??_C@_0BM@CNDP@CancelAllTemporalSubobjects?$AA@	; `string'
PUBLIC	??_C@_0BO@NBLH@IncludeSubobjectFromSubobject?$AA@ ; `string'
PUBLIC	??_C@_0CA@GDJL@IncludeSubobjectFromSubobjectEx?$AA@ ; `string'
PUBLIC	??_C@_0BI@JDMH@SubobjectVersionUpdated?$AA@	; `string'
PUBLIC	??_C@_0N@NKPH@DeleteEntity?$AA@			; `string'
PUBLIC	??_C@_0O@PHBL@ExcludeEntity?$AA@		; `string'
PUBLIC	??_C@_0L@COBA@DropEntity?$AA@			; `string'
PUBLIC	??_C@_0O@OJII@MoveSubobject?$AA@		; `string'
PUBLIC	??_C@_0BE@PPIN@SetCursorNextEntity?$AA@		; `string'
PUBLIC	??_C@_0BE@MAGO@SetCursorPrevEntity?$AA@		; `string'
PUBLIC	??_C@_0BF@NEDK@SetCursorFirstEntity?$AA@	; `string'
PUBLIC	??_C@_0BE@HACO@SetCursorLastEntity?$AA@		; `string'
PUBLIC	??_C@_0BN@IKOI@SetCursorFirstEntityByString?$AA@ ; `string'
PUBLIC	??_C@_0BM@EHFF@SetCursorNextEntityByString?$AA@	; `string'
PUBLIC	??_C@_0BO@GMJK@SetCursorFirstEntityByInteger?$AA@ ; `string'
PUBLIC	??_C@_0BN@DEFH@SetCursorNextEntityByInteger?$AA@ ; `string'
PUBLIC	??_C@_0BO@COOK@SetCursorFirstEntityByDecimal?$AA@ ; `string'
PUBLIC	??_C@_0BN@HGCH@SetCursorNextEntityByDecimal?$AA@ ; `string'
PUBLIC	??_C@_0BL@GLMN@SetCursorFirstEntityByAttr?$AA@	; `string'
PUBLIC	??_C@_0BK@MB@SetCursorNextEntityByAttr?$AA@	; `string'
PUBLIC	??_C@_0CA@CCIK@SetCursorFirstEntityByEntityCsr?$AA@ ; `string'
PUBLIC	??_C@_0BP@FIAL@SetCursorNextEntityByEntityCsr?$AA@ ; `string'
PUBLIC	??_C@_0BN@EMBJ@SetCursorFirstSelectedEntity?$AA@ ; `string'
PUBLIC	??_C@_0BM@IBKE@SetCursorNextSelectedEntity?$AA@	; `string'
PUBLIC	??_C@_0BI@GCJI@SetCursorRelativeEntity?$AA@	; `string'
PUBLIC	??_C@_0BI@DKDE@GetRelativeEntityNumber?$AA@	; `string'
PUBLIC	??_C@_0BJ@EJOC@DefineHierarchicalCursor?$AA@	; `string'
PUBLIC	??_C@_0BH@COPC@DropHierarchicalCursor?$AA@	; `string'
PUBLIC	??_C@_0CA@CHCH@SetCursorNextEntityHierarchical?$AA@ ; `string'
PUBLIC	??_C@_0BD@OPGJ@CreateViewFromView?$AA@		; `string'
PUBLIC	??_C@_0BA@HNOF@SetViewFromView?$AA@		; `string'
PUBLIC	??_C@_0BD@MNMP@SetViewToSubobject?$AA@		; `string'
PUBLIC	??_C@_0BH@EJFL@ResetViewFromSubobject?$AA@	; `string'
PUBLIC	??_C@_0P@CBGO@SetNameForView?$AA@		; `string'
PUBLIC	??_C@_0BA@LHJJ@DropNameForView?$AA@		; `string'
PUBLIC	??_C@_0O@LOIG@GetViewByName?$AA@		; `string'
PUBLIC	??_C@_0P@NAIK@SetSubtaskView?$AA@		; `string'
PUBLIC	??_C@_0P@KFDN@GetNameForView?$AA@		; `string'
PUBLIC	??_C@_0BG@FIPH@SfGetFirstSubtaskView?$AA@	; `string'
PUBLIC	??_C@_0BF@INMF@SfGetNextSubtaskView?$AA@	; `string'
PUBLIC	??_C@_0P@EIOP@SfTransferView?$AA@		; `string'
PUBLIC	??_C@_0L@HDM@SfLockView?$AA@			; `string'
PUBLIC	??_C@_09MKAH@ResetView?$AA@			; `string'
PUBLIC	??_C@_08JNKD@DropView?$AA@			; `string'
PUBLIC	??_C@_0BA@GCHM@SetViewReadOnly?$AA@		; `string'
PUBLIC	??_C@_0N@HIKI@SetViewFlags?$AA@			; `string'
PUBLIC	??_C@_0N@BBKK@GetViewFlags?$AA@			; `string'
PUBLIC	??_C@_0P@CBLC@DropViewObject?$AA@		; `string'
PUBLIC	??_C@_0BC@JNFA@GetAttributeFlags?$AA@		; `string'
PUBLIC	??_C@_0BB@CLPD@AttributeUpdated?$AA@		; `string'
PUBLIC	??_C@_0BH@IPDO@GetStringFromAttribute?$AA@	; `string'
PUBLIC	??_C@_0BI@FFJB@GetIntegerFromAttribute?$AA@	; `string'
PUBLIC	??_C@_0BI@DCJK@GetDecimalFromAttribute?$AA@	; `string'
PUBLIC	??_C@_0BF@MHPH@GetBlobFromAttribute?$AA@	; `string'
PUBLIC	??_C@_0BJ@HIGG@GetStructFromEntityAttrs?$AA@	; `string'
PUBLIC	??_C@_0BE@PNDJ@GetAddrForAttribute?$AA@		; `string'
PUBLIC	??_C@_0BJ@IFI@GetVariableFromAttribute?$AA@	; `string'
PUBLIC	??_C@_0BH@MMIK@SetAttributeFromString?$AA@	; `string'
PUBLIC	??_C@_0BI@CNM@SetAttributeFromInteger?$AA@	; `string'
PUBLIC	??_C@_0BI@EAKM@SetAttributeFromDecimal?$AA@	; `string'
PUBLIC	??_C@_0BF@JCLE@SetAttributeFromBlob?$AA@	; `string'
PUBLIC	??_C@_0BK@MLHG@SetAttributeFromAttribute?$AA@	; `string'
PUBLIC	??_C@_0BM@PBPK@SetAttributeFromCurrentDate?$AA@	; `string'
PUBLIC	??_C@_0BJ@OEAI@SetAttributeFromVariable?$AA@	; `string'
PUBLIC	??_C@_0BG@KHLN@SetAttributeValueNext?$AA@	; `string'
PUBLIC	??_C@_0BG@FODI@SetAttributeValuePrev?$AA@	; `string'
PUBLIC	??_C@_0BO@JAKJ@SetBlobAttributeFromAttribute?$AA@ ; `string'
PUBLIC	??_C@_0BM@CGCL@SetEntityAttributesFromBlob?$AA@	; `string'
PUBLIC	??_C@_0BM@MJNM@SetBlobFromEntityAttributes?$AA@	; `string'
PUBLIC	??_C@_0BK@KNHC@AddToAttributeFromInteger?$AA@	; `string'
PUBLIC	??_C@_0BK@OPAC@AddToAttributeFromDecimal?$AA@	; `string'
PUBLIC	??_C@_0BM@CKKJ@AddToAttributeFromAttribute?$AA@	; `string'
PUBLIC	??_C@_0BL@DLKH@AddToAttributeFromVariable?$AA@	; `string'
PUBLIC	??_C@_0BJ@ODPJ@CompareAttributeToString?$AA@	; `string'
PUBLIC	??_C@_0BK@PHPD@CompareAttributeToInteger?$AA@	; `string'
PUBLIC	??_C@_0BK@LFID@CompareAttributeToDecimal?$AA@	; `string'
PUBLIC	??_C@_0BM@OPHA@CompareAttributeToAttribute?$AA@	; `string'
PUBLIC	??_C@_0BL@OCPN@CompareAttributeToVariable?$AA@	; `string'
PUBLIC	??_C@_0BD@HIDA@GetAttributeLength?$AA@		; `string'
PUBLIC	??_C@_0BM@PHGL@SetMatchingAttributesByName?$AA@	; `string'
PUBLIC	??_C@_0BP@FLBC@GetFirstTableEntryForAttribute?$AA@ ; `string'
PUBLIC	??_C@_0BO@BHMO@GetNextTableEntryForAttribute?$AA@ ; `string'
PUBLIC	??_C@_0BG@ILIL@DisplayEntityInstance?$AA@	; `string'
PUBLIC	??_C@_0BG@KOPK@DisplayObjectInstance?$AA@	; `string'
PUBLIC	??_C@_0BC@KOIM@DisplayCursorInfo?$AA@		; `string'
PUBLIC	??_C@_0BD@FKMI@StoreValueInRecord?$AA@		; `string'
PUBLIC	??_C@_0BN@EHIH@StoreValueInDerivedAttribute?$AA@ ; `string'
PUBLIC	??_C@_0BD@JHII@TableEntryExtToInt?$AA@		; `string'
PUBLIC	??_C@_0BD@DNNI@TableEntryIntToExt?$AA@		; `string'
PUBLIC	??_C@_0BL@HNKN@TableEntryForInternalValue?$AA@	; `string'
PUBLIC	??_C@_0BE@OKMC@SetSelectSetForView?$AA@		; `string'
PUBLIC	??_C@_0BH@EPHO@GetSelectStateOfEntity?$AA@	; `string'
PUBLIC	??_C@_0BM@JBLI@SetAllSelectStatesForEntity?$AA@	; `string'
PUBLIC	??_C@_0BH@IMDL@SetSelectStateOfEntity?$AA@	; `string'
PUBLIC	??_C@_0BJ@NKAP@RelinkInstanceToInstance?$AA@	; `string'
PUBLIC	??_C@_0BJ@HAMO@RelinkAllSubobjectsForOI?$AA@	; `string'
PUBLIC	??_C@_0L@PDG@LoadEntity?$AA@			; `string'
PUBLIC	??_C@_0BG@PEI@ObjectInstanceUpdated?$AA@	; `string'
PUBLIC	??_C@_0BO@OOBH@ObjectInstanceUpdatedFromFile?$AA@ ; `string'
PUBLIC	??_C@_0BD@LHCP@GetValueFromRecord?$AA@		; `string'
PUBLIC	??_C@_0BE@DIAC@StoreStringInRecord?$AA@		; `string'
PUBLIC	??_C@_0BE@MENK@GetStringFromRecord?$AA@		; `string'
PUBLIC	??_C@_0BA@KGPF@SetEntityCursor?$AA@		; `string'
PUBLIC	??_C@_0BC@CMGB@GetAddrFromRecord?$AA@		; `string'
PUBLIC	??_C@_0BN@FOCF@MiGetParentEntityNameForView?$AA@ ; `string'
PUBLIC	??_C@_0BL@PCOO@GetTaskDBHandlerTraceLevel?$AA@	; `string'
PUBLIC	??_C@_0BL@NCHN@SetTaskDBHandlerTraceLevel?$AA@	; `string'
PUBLIC	??_C@_0BN@GHM@GetAbsolutePositionForEntity?$AA@	; `string'
PUBLIC	??_C@_0CA@CBHE@GetEntityNameForHierarchicalCsr?$AA@ ; `string'
PUBLIC	??_C@_0BK@EINL@SetCursorAbsolutePosition?$AA@	; `string'
PUBLIC	??_C@_0BD@LLOG@OrderEntityForView?$AA@		; `string'
PUBLIC	??_C@_0BF@JPO@CountEntitiesForView?$AA@		; `string'
PUBLIC	??_C@_0BJ@DLHM@OrderOI_ByDefaultAttribs?$AA@	; `string'
PUBLIC	??_C@_0BO@HLCK@OrderEntitiesByDefaultAttribs?$AA@ ; `string'
PUBLIC	??_C@_0BN@GOEA@MiGetUpdateForViewEntityAttr?$AA@ ; `string'
PUBLIC	??_C@_0M@PBLM@MessageSend?$AA@			; `string'
PUBLIC	??_C@_0O@CLJA@MessagePrompt?$AA@		; `string'
PUBLIC	??_C@_0BG@MCGA@MessagePromptForInput?$AA@	; `string'
PUBLIC	??_C@_0P@HGJE@MessagePresent?$AA@		; `string'
PUBLIC	??_C@_0BL@BKNM@MiGetTemporalStateOfEntity?$AA@	; `string'
PUBLIC	??_C@_0BD@KBO@MiGetUpdateForView?$AA@		; `string'
PUBLIC	??_C@_0BI@INOA@MiGetInstanceID_ForView?$AA@	; `string'
PUBLIC	??_C@_0BD@DOBB@MiGetDateTimeForOI?$AA@		; `string'
PUBLIC	??_C@_0BG@FHHI@MiGetERTokenForEntity?$AA@	; `string'
PUBLIC	??_C@_0BH@KJIK@MiGetViewEntityForView?$AA@	; `string'
PUBLIC	??_C@_0BA@GNDO@UfAddToDateTime?$AA@		; `string'
PUBLIC	??_C@_0BK@NCOA@GetAttributeDisplayLength?$AA@	; `string'
PUBLIC	??_C@_0BK@FFIH@MiGetCardinalityForEntity?$AA@	; `string'
PUBLIC	??_C@_0O@CJIE@NetActivateOI?$AA@		; `string'
PUBLIC	??_C@_08FBGD@NetClose?$AA@			; `string'
PUBLIC	??_C@_0M@DLBE@NetCommitOI?$AA@			; `string'
PUBLIC	??_C@_0BB@PHPI@NetGetTraceLevel?$AA@		; `string'
PUBLIC	??_C@_09HFPC@NetListen?$AA@			; `string'
PUBLIC	??_C@_0O@KDCL@NetStopListen?$AA@		; `string'
PUBLIC	??_C@_0BB@KEJB@NetSetTraceLevel?$AA@		; `string'
PUBLIC	??_C@_0L@BIJE@NetStartup?$AA@			; `string'
PUBLIC	??_C@_09MBHB@NetStatus?$AA@			; `string'
PUBLIC	??_C@_0BC@EMEG@NetProcessMessage?$AA@		; `string'
PUBLIC	??_C@_0BD@IGEP@NetCommitOI_ToFile?$AA@		; `string'
PUBLIC	??_C@_0BH@FKGD@NetActivateOI_FromFile?$AA@	; `string'
PUBLIC	??_C@_0BF@HCAL@NetSendBootstrapFile?$AA@	; `string'
PUBLIC	??_C@_0BB@DPLM@NetCallOperation?$AA@		; `string'
PUBLIC	??_C@_0BH@KJLN@NetGetLocalHostAddress?$AA@	; `string'
PUBLIC	??_C@_0M@BMMC@NetSendFile?$AA@			; `string'
PUBLIC	??_C@_0BK@PDEP@SetIncrementalUpdateFlags?$AA@	; `string'
PUBLIC	??_C@_0BK@GACK@GetIncrementalUpdateFlags?$AA@	; `string'
PUBLIC	??_C@_0BA@NAKK@SetBlobFromFile?$AA@		; `string'
PUBLIC	??_C@_0BA@HHIJ@WriteBlobToFile?$AA@		; `string'
PUBLIC	??_C@_0BE@HLHF@SfCheckOI_Integrity?$AA@		; `string'
PUBLIC	??_C@_0BL@JILI@GenerateQualFromEntityList?$AA@	; `string'
PUBLIC	??_C@_0O@NLM@WriteOI_ToXML?$AA@			; `string'
PUBLIC	??_C@_0BE@MMDJ@WriteSubobjectToXML?$AA@		; `string'
PUBLIC	??_C@_0BK@IOBH@CommitSubobjectToXML_File?$AA@	; `string'
PUBLIC	_g_wOENG_Message
PUBLIC	_g_wClientMessage
PUBLIC	_g_bWin95
PUBLIC	_g_ZeidonMutexLockCnt
PUBLIC	_g_hInstance
PUBLIC	_g_bProcessRegistered
PUBLIC	_szlNT_ThreadClassName
PUBLIC	_g_lProcessIdx
PUBLIC	_g_ZeidonPageTable
PUBLIC	_g_FileMappingHandles
PUBLIC	_g_hAnchorBlock
PUBLIC	_AnchorBlock
PUBLIC	_g_bServerMode
PUBLIC	_szlReleaseCompatible
PUBLIC	??_C@_08LNAM@1?40a2?5?5?5?$AA@			; `string'
PUBLIC	_szlReleaseCurrent
PUBLIC	??_C@_08BHMH@1?40b0?5?5?5?$AA@			; `string'
PUBLIC	_szlShareSeg
PUBLIC	_g_nOE_TraceWarning
PUBLIC	??_C@_0BH@IOGD@?1SHAREMEM?1KZOENGAA?4SEG?$AA@	; `string'
PUBLIC	_g_vRealTaskView
PUBLIC	_g_vDefaultTaskView
PUBLIC	_g_ulMaxRecordStringLth
PUBLIC	_cDirSep
PUBLIC	_g_lProcessID
PUBLIC	_szObjectEngineName
PUBLIC	??_C@_0N@FLGE@kzoengwa?4exe?$AA@		; `string'
PUBLIC	_szObjectEngineDll
PUBLIC	??_C@_0N@OAJM@kzoengaa?4dll?$AA@		; `string'
PUBLIC	_szObjectSuffix
PUBLIC	??_C@_04NPBE@?4xod?$AA@				; `string'
PUBLIC	_szDllSuffix
PUBLIC	??_C@_04EJNG@?4dll?$AA@				; `string'
PUBLIC	_lpNullP
PUBLIC	_szNullS
PUBLIC	??_C@_08A@?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@	; `string'
PUBLIC	_lNullInteger
PUBLIC	_stNullDateTime
PUBLIC	_pHab
PUBLIC	_g_ZeidonMutexTable
PUBLIC	_hModule
PUBLIC	_g_ZeidonMutexName
PUBLIC	_szlZEIDON
PUBLIC	??_C@_0BJ@OCLO@ZEIDON?5MUTEX?5?9?9?5INITTERM?$AA@ ; `string'
PUBLIC	??_C@_06HLLH@ZEIDON?$AA@			; `string'
PUBLIC	??_C@_0CC@CFG@ZEIDON?5MUTEX?5?9?9?5MEMORY?5ALLOCATIO@ ; `string'
PUBLIC	_szlAppFile
PUBLIC	??_C@_0BN@JMMP@ZEIDON?5MUTEX?5?9?9?5ANCHOR?5BLOCK?$AA@ ; `string'
PUBLIC	??_C@_0L@JLJG@zeidon?4app?$AA@			; `string'
PUBLIC	??_C@_0BM@GEKC@ZEIDON?5MUTEX?5?9?9?5ANCHOR?5INIT?$AA@ ; `string'
PUBLIC	_szlDomainFile
PUBLIC	??_C@_0BL@FIFA@ZEIDON?5MUTEX?5?9?9?5SHARED?5MEM?$AA@ ; `string'
PUBLIC	??_C@_0L@LFFP@zeidon?4xdm?$AA@			; `string'
PUBLIC	??_C@_0BL@OFOI@ZEIDON?5MUTEX?5?9?9?5TASK?5CHAIN?$AA@ ; `string'
PUBLIC	_szlSystemDomainFile
PUBLIC	??_C@_0CB@FGNI@ZEIDON?5MUTEX?5?9?9?5TASK?5CHAIN?5WRITE@ ; `string'
PUBLIC	??_C@_0N@DNNP@kzomdmoi?4xdm?$AA@		; `string'
PUBLIC	??_C@_0BG@OLDG@ZEIDON?5MUTEX?5?9?9?5MUTEX?$AA@	; `string'
PUBLIC	_szlMessageObject
PUBLIC	??_C@_0BM@PPAA@ZEIDON?5MUTEX?5?9?9?5DEBUGCHANGE?$AA@ ; `string'
PUBLIC	??_C@_08JIIE@KZMSGQOO?$AA@			; `string'
PUBLIC	??_C@_0CB@EGB@ZEIDON?5MUTEX?5?9?9?5PESSIMISTIC?5LOCK@ ; `string'
PUBLIC	_szlNewPortableHeader
PUBLIC	??_C@_0BG@GGGI@ZEIDON?5MUTEX?5?9?9?5APPLA?$AA@	; `string'
PUBLIC	??_C@_01FPMG@z?$AA@				; `string'
PUBLIC	??_C@_0BL@OEL@ZEIDON?5MUTEX?5?9?9?5ENTITY?5KEY?$AA@ ; `string'
PUBLIC	_szlmZeidon
PUBLIC	??_C@_0BM@DIIE@ZEIDON?5MUTEX?5?9?9?5TASKPROCESS?$AA@ ; `string'
PUBLIC	??_C@_06BADI@Zeidon?$AA@			; `string'
PUBLIC	??_C@_0BL@CPDB@ZEIDON?5MUTEX?5?9?9?5PROC?5CHAIN?$AA@ ; `string'
PUBLIC	_szlAPPLICATION
PUBLIC	??_C@_0CB@LBIA@ZEIDON?5MUTEX?5?9?9?5PROC?5CHAIN?5WRITE@ ; `string'
PUBLIC	??_C@_0M@LKKI@APPLICATION?$AA@			; `string'
PUBLIC	??_C@_0BO@FOCN@ZEIDON?5MUTEX?5?9?9?5NETWORK?5CHAIN?$AA@ ; `string'
PUBLIC	_szlOBJECT
PUBLIC	??_C@_06PIJH@OBJECT?$AA@			; `string'
PUBLIC	_szlENTITY
PUBLIC	??_C@_06NIFE@ENTITY?$AA@			; `string'
PUBLIC	_szlCHILDENTITY
PUBLIC	??_C@_0M@PNOD@CHILDENTITY?$AA@			; `string'
PUBLIC	_szlATTRIB
PUBLIC	??_C@_06BLIJ@ATTRIB?$AA@			; `string'
PUBLIC	_szlDOMAIN
PUBLIC	??_C@_06EIOP@DOMAIN?$AA@			; `string'
PUBLIC	_szlMODEL
PUBLIC	??_C@_05NMBE@MODEL?$AA@				; `string'
PUBLIC	_szlCONTEXT
PUBLIC	??_C@_07OLKB@CONTEXT?$AA@			; `string'
PUBLIC	_szlNLS_TABLEENTRY
PUBLIC	??_C@_0P@NJID@NLS_TABLEENTRY?$AA@		; `string'
PUBLIC	_szlTABLEENTRY
PUBLIC	??_C@_0L@EDPP@TABLEENTRY?$AA@			; `string'
PUBLIC	_szlREGULAREXPRESSION
PUBLIC	??_C@_0BC@JION@REGULAREXPRESSION?$AA@		; `string'
PUBLIC	_szlZEIDON_BIN
PUBLIC	??_C@_0L@DLBH@ZEIDON_BIN?$AA@			; `string'
PUBLIC	_szlZEIDON_SYS
PUBLIC	??_C@_0L@NPMB@ZEIDON_SYS?$AA@			; `string'
PUBLIC	_szlZEIDON_LOC
PUBLIC	??_C@_0L@GEFJ@ZEIDON_LOC?$AA@			; `string'
PUBLIC	_szlZEIDON_SHR
PUBLIC	??_C@_0L@JFF@ZEIDON_SHR?$AA@			; `string'
PUBLIC	_szlAPP_NAME
PUBLIC	??_C@_08NHNM@APP_NAME?$AA@			; `string'
PUBLIC	_szlAPP_DFLT_Dialog
PUBLIC	??_C@_0O@HKIJ@APP_DFLT_WDOD?$AA@		; `string'
PUBLIC	_szlAPP_DLL
PUBLIC	??_C@_07LAPC@APP_DLL?$AA@			; `string'
PUBLIC	_szlAPP_ADOBIN
PUBLIC	??_C@_0L@GHPH@APP_ADOBIN?$AA@			; `string'
PUBLIC	_szlAPP_LOCAL
PUBLIC	??_C@_09HKKN@APP_LOCAL?$AA@			; `string'
PUBLIC	_szlAPP_SHARED
PUBLIC	??_C@_0L@KNHE@APP_SHARED?$AA@			; `string'
PUBLIC	_szlAPP_QLPLR
PUBLIC	??_C@_09BKCL@APP_QLPLR?$AA@			; `string'
PUBLIC	_szlAPP_QXODS
PUBLIC	??_C@_09MKDP@APP_QXODS?$AA@			; `string'
PUBLIC	_szlAPP_SOURCE
PUBLIC	??_C@_0L@NAIP@APP_SOURCE?$AA@			; `string'
PUBLIC	_szlAPDM_TOK
PUBLIC	??_C@_08FEIL@APDM_TOK?$AA@			; `string'
PUBLIC	_szlATTRIBUTETYPE
PUBLIC	??_C@_0O@HAFL@ATTRIBUTETYPE?$AA@		; `string'
PUBLIC	_szlATTRIBUTEDECIMAL
PUBLIC	??_C@_0BB@CGIJ@ATTRIBUTEDECIMAL?$AA@		; `string'
PUBLIC	_szlAUTOCREATE
PUBLIC	??_C@_0L@CCEG@AUTOCREATE?$AA@			; `string'
PUBLIC	_szlAUTOLOADFROMPARENT
PUBLIC	??_C@_0BD@GGKI@AUTOLOADFROMPARENT?$AA@		; `string'
PUBLIC	_szlAUTO_SEQ
PUBLIC	??_C@_08FEIG@AUTO_SEQ?$AA@			; `string'
PUBLIC	_szlXVAATT_TOK
PUBLIC	??_C@_0L@CDIB@XVAATT_TOK?$AA@			; `string'
PUBLIC	_szlCARDMAX
PUBLIC	??_C@_07EKKN@CARDMAX?$AA@			; `string'
PUBLIC	_szlCARDMIN
PUBLIC	??_C@_07KJPL@CARDMIN?$AA@			; `string'
PUBLIC	_szlCASESENS
PUBLIC	??_C@_08JHJH@CASESENS?$AA@			; `string'
PUBLIC	_szlCONTEXTRESTRICTION
PUBLIC	??_C@_0BD@DICE@CONTEXTRESTRICTION?$AA@		; `string'
PUBLIC	_szlCREATE
PUBLIC	??_C@_06JBCM@CREATE?$AA@			; `string'
PUBLIC	_szlCR_DATE
PUBLIC	??_C@_07IMJA@CR_DATE?$AA@			; `string'
PUBLIC	_szlDATAFIELD
PUBLIC	??_C@_09JEIA@DATAFIELD?$AA@			; `string'
PUBLIC	_szlDATARECORD
PUBLIC	??_C@_0L@PPLE@DATARECORD?$AA@			; `string'
PUBLIC	_szlDATATYPE
PUBLIC	??_C@_08PKJA@DATATYPE?$AA@			; `string'
PUBLIC	_szlDBNAME
PUBLIC	??_C@_06PHCI@DBNAME?$AA@			; `string'
PUBLIC	_szlDECIMAL
PUBLIC	??_C@_07OOBD@DECIMAL?$AA@			; `string'
PUBLIC	_szlDECIMALFORMAT
PUBLIC	??_C@_0O@GDML@DECIMALFORMAT?$AA@		; `string'
PUBLIC	_szlDELETE
PUBLIC	??_C@_06FMHL@DELETE?$AA@			; `string'
PUBLIC	_szlDERIVED
PUBLIC	??_C@_07FJF@DERIVED?$AA@			; `string'
PUBLIC	_szlDERIVEDF
PUBLIC	??_C@_08EALH@DERIVEDF?$AA@			; `string'
PUBLIC	_szlDFT_DBNAME
PUBLIC	??_C@_0L@HPIJ@DFT_DBNAME?$AA@			; `string'
PUBLIC	_szlDFT_SERVER
PUBLIC	??_C@_0L@JBCC@DFT_SERVER?$AA@			; `string'
PUBLIC	_szlDLL_NAME
PUBLIC	??_C@_08DJGK@DLL_NAME?$AA@			; `string'
PUBLIC	_szlDOMAINTYPE
PUBLIC	??_C@_0L@KGBA@DOMAINTYPE?$AA@			; `string'
PUBLIC	_szlDUPENTIN
PUBLIC	??_C@_08KCDD@DUPENTIN?$AA@			; `string'
PUBLIC	_szlDUPRELIN
PUBLIC	??_C@_08DECF@DUPRELIN?$AA@			; `string'
PUBLIC	_szlECACC
PUBLIC	??_C@_05OAI@ECACC?$AA@				; `string'
PUBLIC	_szlECCAN
PUBLIC	??_C@_05NDAD@ECCAN?$AA@				; `string'
PUBLIC	_szlECCR
PUBLIC	??_C@_04FPMK@ECCR?$AA@				; `string'
PUBLIC	_szlECDEL
PUBLIC	??_C@_05GCOG@ECDEL?$AA@				; `string'
PUBLIC	_szlECEOPER
PUBLIC	??_C@_07FBPG@ECEOPER?$AA@			; `string'
PUBLIC	_szlECEXC
PUBLIC	??_C@_05KCFA@ECEXC?$AA@				; `string'
PUBLIC	_szlECINC
PUBLIC	??_C@_05GHOJ@ECINC?$AA@				; `string'
PUBLIC	_szlEDITSTRING
PUBLIC	??_C@_0L@LMLE@EDITSTRING?$AA@			; `string'
PUBLIC	_szlERATT_TOK
PUBLIC	??_C@_09GJOF@ERATT_TOK?$AA@			; `string'
PUBLIC	_szlEntityName
PUBLIC	??_C@_0L@LOJF@EntityName?$AA@			; `string'
PUBLIC	_szlEntitySpec
PUBLIC	??_C@_0L@EIGE@EntitySpec?$AA@			; `string'
PUBLIC	_szlERENT_TOK
PUBLIC	??_C@_09PPA@ERENT_TOK?$AA@			; `string'
PUBLIC	_szlERREL_LINK
PUBLIC	??_C@_0L@GJDI@ERREL_LINK?$AA@			; `string'
PUBLIC	_szlERREL_TOK
PUBLIC	??_C@_09DPNM@ERREL_TOK?$AA@			; `string'
PUBLIC	_szlEXCLUDE
PUBLIC	??_C@_07EHEP@EXCLUDE?$AA@			; `string'
PUBLIC	_szlEXTERNALVALUE
PUBLIC	??_C@_0O@HLIE@EXTERNALVALUE?$AA@		; `string'
PUBLIC	_szlFLDID
PUBLIC	??_C@_05OJOB@FLDID?$AA@				; `string'
PUBLIC	_szlFLDLTH
PUBLIC	??_C@_06GKHE@FLDLTH?$AA@			; `string'
PUBLIC	_szlFLDNAME
PUBLIC	??_C@_07NIOD@FLDNAME?$AA@			; `string'
PUBLIC	_szlFLDOFFSET
PUBLIC	??_C@_09BHNG@FLDOFFSET?$AA@			; `string'
PUBLIC	_szlFLDTYPE
PUBLIC	??_C@_07MPNE@FLDTYPE?$AA@			; `string'
PUBLIC	_szlFULLPERSIST
PUBLIC	??_C@_0M@FLLI@FULLPERSIST?$AA@			; `string'
PUBLIC	_szlGENKEY
PUBLIC	??_C@_06PPGK@GENKEY?$AA@			; `string'
PUBLIC	_szlGKHANDLER
PUBLIC	??_C@_09IICP@GKHANDLER?$AA@			; `string'
PUBLIC	_szlHANDLER
PUBLIC	??_C@_07MHHO@HANDLER?$AA@			; `string'
PUBLIC	_szlHIDDEN
PUBLIC	??_C@_06IJMB@HIDDEN?$AA@			; `string'
PUBLIC	_szlId
PUBLIC	??_C@_02FECH@Id?$AA@				; `string'
PUBLIC	_szlINCLSRC
PUBLIC	??_C@_07KACF@INCLSRC?$AA@			; `string'
PUBLIC	_szlINCLUDE
PUBLIC	??_C@_07KOHG@INCLUDE?$AA@			; `string'
PUBLIC	_szlINCRLOAD
PUBLIC	??_C@_08FKFF@INCRLOAD?$AA@			; `string'
PUBLIC	_szlINIT
PUBLIC	??_C@_04NJI@INIT?$AA@				; `string'
PUBLIC	_szlINTERNALVALUE
PUBLIC	??_C@_0O@HIL@INTERNALVALUE?$AA@			; `string'
PUBLIC	_szlISDEFAULT
PUBLIC	??_C@_09ECEN@ISDEFAULT?$AA@			; `string'
PUBLIC	_szlKEY
PUBLIC	??_C@_03PHBO@KEY?$AA@				; `string'
PUBLIC	_szlLanguageIndex
PUBLIC	??_C@_0O@IHAG@LanguageIndex?$AA@		; `string'
PUBLIC	_szlLNAME
PUBLIC	??_C@_05IFE@LNAME?$AA@				; `string'
PUBLIC	_szlLOCK
PUBLIC	??_C@_04NPLI@LOCK?$AA@				; `string'
PUBLIC	_szlLTH
PUBLIC	??_C@_03DGJL@LTH?$AA@				; `string'
PUBLIC	_szlMAXSTRINGLTH
PUBLIC	??_C@_0N@LMHL@MAXSTRINGLTH?$AA@			; `string'
PUBLIC	_szlMR_LIMIT
PUBLIC	??_C@_08DHHO@MR_LIMIT?$AA@			; `string'
PUBLIC	_szl__MSGQ
PUBLIC	??_C@_06OMJI@__MSGQ?$AA@			; `string'
PUBLIC	_szlNAME
PUBLIC	??_C@_04IALP@NAME?$AA@				; `string'
PUBLIC	_szlNETCOMPRESS
PUBLIC	??_C@_0M@GNJA@NETCOMPRESS?$AA@			; `string'
PUBLIC	_szlNETWORK
PUBLIC	??_C@_07KFPJ@NETWORK?$AA@			; `string'
PUBLIC	_szlNumAtts
PUBLIC	??_C@_07GOHG@NumAtts?$AA@			; `string'
PUBLIC	_szlNumEnts
PUBLIC	??_C@_07OOMM@NumEnts?$AA@			; `string'
PUBLIC	_szlNumRels
PUBLIC	??_C@_07PICA@NumRels?$AA@			; `string'
PUBLIC	_szlOCACT
PUBLIC	??_C@_05LDPN@OCACT?$AA@				; `string'
PUBLIC	_szlOCACTE
PUBLIC	??_C@_06PJLI@OCACTE?$AA@			; `string'
PUBLIC	_szlOCCOM
PUBLIC	??_C@_05KPHB@OCCOM?$AA@				; `string'
PUBLIC	_szlOCDROP
PUBLIC	??_C@_06HHGH@OCDROP?$AA@			; `string'
PUBLIC	_szlOCEOPER
PUBLIC	??_C@_07HIHA@OCEOPER?$AA@			; `string'
PUBLIC	_szlOFRECID
PUBLIC	??_C@_07NHGG@OFRECID?$AA@			; `string'
PUBLIC	_szlOFBUFSZ
PUBLIC	??_C@_07GKEM@OFBUFSZ?$AA@			; `string'
PUBLIC	_szlOPER_LIBNM
PUBLIC	??_C@_0L@PJJC@OPER_LIBNM?$AA@			; `string'
PUBLIC	_szlOper
PUBLIC	??_C@_04FKDH@Oper?$AA@				; `string'
PUBLIC	_szlOWNER_MEMB
PUBLIC	??_C@_0L@JCEP@OWNER_MEMB?$AA@			; `string'
PUBLIC	_szlPDELETE
PUBLIC	??_C@_07BAEJ@PDELETE?$AA@			; `string'
PUBLIC	_szlPERSIST
PUBLIC	??_C@_07NIBE@PERSIST?$AA@			; `string'
PUBLIC	_szlPNAME
PUBLIC	??_C@_05ILLO@PNAME?$AA@				; `string'
PUBLIC	_szlQualAttrib
PUBLIC	??_C@_0L@DIOI@QualAttrib?$AA@			; `string'
PUBLIC	_szlRECID
PUBLIC	??_C@_05NKIC@RECID?$AA@				; `string'
PUBLIC	_szlRECNAME
PUBLIC	??_C@_07NDLE@RECNAME?$AA@			; `string'
PUBLIC	_szlRECURSIVE
PUBLIC	??_C@_09GDN@RECURSIVE?$AA@			; `string'
PUBLIC	_szlREL
PUBLIC	??_C@_03LNGM@REL?$AA@				; `string'
PUBLIC	_szlRELFIELD
PUBLIC	??_C@_08PMNP@RELFIELD?$AA@			; `string'
PUBLIC	_szlRELRECORD
PUBLIC	??_C@_09HINM@RELRECORD?$AA@			; `string'
PUBLIC	_szlRELXVAATT_TOK
PUBLIC	??_C@_0O@DBKM@RELXVAATT_TOK?$AA@		; `string'
PUBLIC	_szlREQUIRED
PUBLIC	??_C@_08BGDD@REQUIRED?$AA@			; `string'
PUBLIC	_szlRESTRICTED
PUBLIC	??_C@_0L@GCMK@RESTRICTED?$AA@			; `string'
PUBLIC	_szlSERVER
PUBLIC	??_C@_06BJID@SERVER?$AA@			; `string'
PUBLIC	_szlSEQUENCING
PUBLIC	??_C@_0L@FLNJ@SEQUENCING?$AA@			; `string'
PUBLIC	_szlSEQ_AD
PUBLIC	??_C@_06LIHO@SEQ_AD?$AA@			; `string'
PUBLIC	_szlSETID1
PUBLIC	??_C@_06NHOC@SETID1?$AA@			; `string'
PUBLIC	_szlSETID2
PUBLIC	??_C@_06CIFL@SETID2?$AA@			; `string'
PUBLIC	_szlSETNAME1
PUBLIC	??_C@_08FJI@SETNAME1?$AA@			; `string'
PUBLIC	_szlSETNAME2
PUBLIC	??_C@_08PKCB@SETNAME2?$AA@			; `string'
PUBLIC	_szlSRCXVAATT_TOK
PUBLIC	??_C@_0O@HOCN@SRCXVAATT_TOK?$AA@		; `string'
;	COMDAT ??_C@_00A@?$AA@
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
_BSS	SEGMENT
_g_wOENG_Message DD 01H DUP (?)
_g_wClientMessage DD 01H DUP (?)
_g_ZeidonMutexLockCnt DD 010H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_ZeidonCritTable:BYTE:0180H
COMM	_g_csSysLoadLibrary:BYTE:018H
COMM	_g_csReuseEntity:BYTE:018H
_DATA	ENDS
_BSS	SEGMENT
_g_hInstance DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_hThreadInfo:DWORD
_DATA	ENDS
_BSS	SEGMENT
_g_bProcessRegistered DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_lCurrentProcessID:DWORD
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

_?szLastDateTime@?2??SysMessageList@@9@9 DB 014H DUP (?)
_g_ZeidonPageTable DD 0100H DUP (?)
_g_FileMappingHandles DD 0100H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_pfnGetPtr:DWORD
COMM	_g_pfnGetHndl:DWORD
_DATA	ENDS
_BSS	SEGMENT
_g_hAnchorBlock DD 01H DUP (?)
_AnchorBlock DD	01H DUP (?)
_g_bServerMode DB 01H DUP (?)
	ALIGN	4

_g_nOE_TraceWarning DW 01H DUP (?)
	ALIGN	4

_g_vRealTaskView DD 01H DUP (?)
_g_vDefaultTaskView DD 01H DUP (?)
_g_lProcessID DD 01H DUP (?)
_lpNullP DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_08A@?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@
_BSS	SEGMENT
??_C@_08A@?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@ DB 09H DUP (?) ; `string'
_BSS	ENDS
_BSS	SEGMENT
_pHab	DD	01H DUP (?)
_g_ZeidonMutexTable DD 010H DUP (?)
_hModule DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_lTable:DWORD:0aH
_g_ZeidonMutexName DD FLAT:??_C@_0BJ@OCLO@ZEIDON?5MUTEX?5?9?9?5INITTERM?$AA@
	DD	FLAT:??_C@_0CC@CFG@ZEIDON?5MUTEX?5?9?9?5MEMORY?5ALLOCATIO@
	DD	FLAT:??_C@_0BN@JMMP@ZEIDON?5MUTEX?5?9?9?5ANCHOR?5BLOCK?$AA@
	DD	FLAT:??_C@_0BM@GEKC@ZEIDON?5MUTEX?5?9?9?5ANCHOR?5INIT?$AA@
	DD	FLAT:??_C@_0BL@FIFA@ZEIDON?5MUTEX?5?9?9?5SHARED?5MEM?$AA@
	DD	FLAT:??_C@_0BL@OFOI@ZEIDON?5MUTEX?5?9?9?5TASK?5CHAIN?$AA@
	DD	FLAT:??_C@_0CB@FGNI@ZEIDON?5MUTEX?5?9?9?5TASK?5CHAIN?5WRITE@
	DD	FLAT:??_C@_0BG@OLDG@ZEIDON?5MUTEX?5?9?9?5MUTEX?$AA@
	DD	FLAT:??_C@_0BM@PPAA@ZEIDON?5MUTEX?5?9?9?5DEBUGCHANGE?$AA@
	DD	FLAT:??_C@_0CB@EGB@ZEIDON?5MUTEX?5?9?9?5PESSIMISTIC?5LOCK@
	DD	FLAT:??_C@_0BG@GGGI@ZEIDON?5MUTEX?5?9?9?5APPLA?$AA@
	DD	FLAT:??_C@_0BL@OEL@ZEIDON?5MUTEX?5?9?9?5ENTITY?5KEY?$AA@
	DD	FLAT:??_C@_0BM@DIIE@ZEIDON?5MUTEX?5?9?9?5TASKPROCESS?$AA@
	DD	FLAT:??_C@_0BL@CPDB@ZEIDON?5MUTEX?5?9?9?5PROC?5CHAIN?$AA@
	DD	FLAT:??_C@_0CB@LBIA@ZEIDON?5MUTEX?5?9?9?5PROC?5CHAIN?5WRITE@
	DD	FLAT:??_C@_0BO@FOCN@ZEIDON?5MUTEX?5?9?9?5NETWORK?5CHAIN?$AA@
_szlReleaseCompatible DD FLAT:??_C@_08LNAM@1?40a2?5?5?5?$AA@
_szlReleaseCurrent DD FLAT:??_C@_08BHMH@1?40b0?5?5?5?$AA@
_szlShareSeg DD	FLAT:??_C@_0BH@IOGD@?1SHAREMEM?1KZOENGAA?4SEG?$AA@
_g_ulMaxRecordStringLth DD 09H
_cDirSep DB	05cH
	ORG $+3
_szObjectEngineName DD FLAT:??_C@_0N@FLGE@kzoengwa?4exe?$AA@
_szObjectEngineDll DD FLAT:??_C@_0N@OAJM@kzoengaa?4dll?$AA@
_szObjectSuffix DD FLAT:??_C@_04NPBE@?4xod?$AA@
_szDllSuffix DD	FLAT:??_C@_04EJNG@?4dll?$AA@
_szNullS DD	FLAT:??_C@_08A@?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@
_lNullInteger DD 080000000H
_stNullDateTime DD 080000000H
	DW	00H
	ORG $+2
_szlZEIDON DD	FLAT:??_C@_06HLLH@ZEIDON?$AA@
_szlAppFile DD	FLAT:??_C@_0L@JLJG@zeidon?4app?$AA@
_szlDomainFile DD FLAT:??_C@_0L@LFFP@zeidon?4xdm?$AA@
_szlSystemDomainFile DD FLAT:??_C@_0N@DNNP@kzomdmoi?4xdm?$AA@
_szlMessageObject DD FLAT:??_C@_08JIIE@KZMSGQOO?$AA@
_szlNewPortableHeader DD FLAT:??_C@_01FPMG@z?$AA@
_szlmZeidon DD	FLAT:??_C@_06BADI@Zeidon?$AA@
_szlAPPLICATION DD FLAT:??_C@_0M@LKKI@APPLICATION?$AA@
_szlOBJECT DD	FLAT:??_C@_06PIJH@OBJECT?$AA@
_szlENTITY DD	FLAT:??_C@_06NIFE@ENTITY?$AA@
_szlCHILDENTITY DD FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@
_szlATTRIB DD	FLAT:??_C@_06BLIJ@ATTRIB?$AA@
_szlDOMAIN DD	FLAT:??_C@_06EIOP@DOMAIN?$AA@
_szlMODEL DD	FLAT:??_C@_05NMBE@MODEL?$AA@
_szlCONTEXT DD	FLAT:??_C@_07OLKB@CONTEXT?$AA@
_szlNLS_TABLEENTRY DD FLAT:??_C@_0P@NJID@NLS_TABLEENTRY?$AA@
_szlTABLEENTRY DD FLAT:??_C@_0L@EDPP@TABLEENTRY?$AA@
_szlREGULAREXPRESSION DD FLAT:??_C@_0BC@JION@REGULAREXPRESSION?$AA@
_szlZEIDON_BIN DD FLAT:??_C@_0L@DLBH@ZEIDON_BIN?$AA@
_szlZEIDON_SYS DD FLAT:??_C@_0L@NPMB@ZEIDON_SYS?$AA@
_szlZEIDON_LOC DD FLAT:??_C@_0L@GEFJ@ZEIDON_LOC?$AA@
_szlZEIDON_SHR DD FLAT:??_C@_0L@JFF@ZEIDON_SHR?$AA@
_szlAPP_NAME DD	FLAT:??_C@_08NHNM@APP_NAME?$AA@
_szlAPP_DFLT_Dialog DD FLAT:??_C@_0O@HKIJ@APP_DFLT_WDOD?$AA@
_szlAPP_DLL DD	FLAT:??_C@_07LAPC@APP_DLL?$AA@
_szlAPP_ADOBIN DD FLAT:??_C@_0L@GHPH@APP_ADOBIN?$AA@
_szlAPP_LOCAL DD FLAT:??_C@_09HKKN@APP_LOCAL?$AA@
_szlAPP_SHARED DD FLAT:??_C@_0L@KNHE@APP_SHARED?$AA@
_szlAPP_QLPLR DD FLAT:??_C@_09BKCL@APP_QLPLR?$AA@
_szlAPP_QXODS DD FLAT:??_C@_09MKDP@APP_QXODS?$AA@
_szlAPP_SOURCE DD FLAT:??_C@_0L@NAIP@APP_SOURCE?$AA@
_szlAPDM_TOK DD	FLAT:??_C@_08FEIL@APDM_TOK?$AA@
_szlATTRIBUTETYPE DD FLAT:??_C@_0O@HAFL@ATTRIBUTETYPE?$AA@
_szlATTRIBUTEDECIMAL DD FLAT:??_C@_0BB@CGIJ@ATTRIBUTEDECIMAL?$AA@
_szlAUTOCREATE DD FLAT:??_C@_0L@CCEG@AUTOCREATE?$AA@
_szlAUTOLOADFROMPARENT DD FLAT:??_C@_0BD@GGKI@AUTOLOADFROMPARENT?$AA@
_szlAUTO_SEQ DD	FLAT:??_C@_08FEIG@AUTO_SEQ?$AA@
_szlXVAATT_TOK DD FLAT:??_C@_0L@CDIB@XVAATT_TOK?$AA@
_szlCARDMAX DD	FLAT:??_C@_07EKKN@CARDMAX?$AA@
_szlCARDMIN DD	FLAT:??_C@_07KJPL@CARDMIN?$AA@
_szlCASESENS DD	FLAT:??_C@_08JHJH@CASESENS?$AA@
_szlCONTEXTRESTRICTION DD FLAT:??_C@_0BD@DICE@CONTEXTRESTRICTION?$AA@
_szlCREATE DD	FLAT:??_C@_06JBCM@CREATE?$AA@
_szlCR_DATE DD	FLAT:??_C@_07IMJA@CR_DATE?$AA@
_szlDATAFIELD DD FLAT:??_C@_09JEIA@DATAFIELD?$AA@
_szlDATARECORD DD FLAT:??_C@_0L@PPLE@DATARECORD?$AA@
_szlDATATYPE DD	FLAT:??_C@_08PKJA@DATATYPE?$AA@
_szlDBNAME DD	FLAT:??_C@_06PHCI@DBNAME?$AA@
_szlDECIMAL DD	FLAT:??_C@_07OOBD@DECIMAL?$AA@
_szlDECIMALFORMAT DD FLAT:??_C@_0O@GDML@DECIMALFORMAT?$AA@
_szlDELETE DD	FLAT:??_C@_06FMHL@DELETE?$AA@
_szlDERIVED DD	FLAT:??_C@_07FJF@DERIVED?$AA@
_szlDERIVEDF DD	FLAT:??_C@_08EALH@DERIVEDF?$AA@
_szlDFT_DBNAME DD FLAT:??_C@_0L@HPIJ@DFT_DBNAME?$AA@
_szlDFT_SERVER DD FLAT:??_C@_0L@JBCC@DFT_SERVER?$AA@
_szlDLL_NAME DD	FLAT:??_C@_08DJGK@DLL_NAME?$AA@
_szlDOMAINTYPE DD FLAT:??_C@_0L@KGBA@DOMAINTYPE?$AA@
_szlDUPENTIN DD	FLAT:??_C@_08KCDD@DUPENTIN?$AA@
_szlDUPRELIN DD	FLAT:??_C@_08DECF@DUPRELIN?$AA@
_szlECACC DD	FLAT:??_C@_05OAI@ECACC?$AA@
_szlECCAN DD	FLAT:??_C@_05NDAD@ECCAN?$AA@
_szlECCR DD	FLAT:??_C@_04FPMK@ECCR?$AA@
_szlECDEL DD	FLAT:??_C@_05GCOG@ECDEL?$AA@
_szlECEOPER DD	FLAT:??_C@_07FBPG@ECEOPER?$AA@
_szlECEXC DD	FLAT:??_C@_05KCFA@ECEXC?$AA@
_szlECINC DD	FLAT:??_C@_05GHOJ@ECINC?$AA@
_szlEDITSTRING DD FLAT:??_C@_0L@LMLE@EDITSTRING?$AA@
_szlERATT_TOK DD FLAT:??_C@_09GJOF@ERATT_TOK?$AA@
_szlEntityName DD FLAT:??_C@_0L@LOJF@EntityName?$AA@
_szlEntitySpec DD FLAT:??_C@_0L@EIGE@EntitySpec?$AA@
_szlERENT_TOK DD FLAT:??_C@_09PPA@ERENT_TOK?$AA@
_szlERREL_LINK DD FLAT:??_C@_0L@GJDI@ERREL_LINK?$AA@
_szlERREL_TOK DD FLAT:??_C@_09DPNM@ERREL_TOK?$AA@
_szlEXCLUDE DD	FLAT:??_C@_07EHEP@EXCLUDE?$AA@
_szlEXTERNALVALUE DD FLAT:??_C@_0O@HLIE@EXTERNALVALUE?$AA@
_szlFLDID DD	FLAT:??_C@_05OJOB@FLDID?$AA@
_szlFLDLTH DD	FLAT:??_C@_06GKHE@FLDLTH?$AA@
_szlFLDNAME DD	FLAT:??_C@_07NIOD@FLDNAME?$AA@
_szlFLDOFFSET DD FLAT:??_C@_09BHNG@FLDOFFSET?$AA@
_szlFLDTYPE DD	FLAT:??_C@_07MPNE@FLDTYPE?$AA@
_szlFULLPERSIST DD FLAT:??_C@_0M@FLLI@FULLPERSIST?$AA@
_szlGENKEY DD	FLAT:??_C@_06PPGK@GENKEY?$AA@
_szlGKHANDLER DD FLAT:??_C@_09IICP@GKHANDLER?$AA@
_szlHANDLER DD	FLAT:??_C@_07MHHO@HANDLER?$AA@
_szlHIDDEN DD	FLAT:??_C@_06IJMB@HIDDEN?$AA@
_szlId	DD	FLAT:??_C@_02FECH@Id?$AA@
_szlINCLSRC DD	FLAT:??_C@_07KACF@INCLSRC?$AA@
_szlINCLUDE DD	FLAT:??_C@_07KOHG@INCLUDE?$AA@
_szlINCRLOAD DD	FLAT:??_C@_08FKFF@INCRLOAD?$AA@
_szlINIT DD	FLAT:??_C@_04NJI@INIT?$AA@
_szlINTERNALVALUE DD FLAT:??_C@_0O@HIL@INTERNALVALUE?$AA@
_szlISDEFAULT DD FLAT:??_C@_09ECEN@ISDEFAULT?$AA@
_szlKEY	DD	FLAT:??_C@_03PHBO@KEY?$AA@
_szlLanguageIndex DD FLAT:??_C@_0O@IHAG@LanguageIndex?$AA@
_szlLNAME DD	FLAT:??_C@_05IFE@LNAME?$AA@
_szlLOCK DD	FLAT:??_C@_04NPLI@LOCK?$AA@
_szlLTH	DD	FLAT:??_C@_03DGJL@LTH?$AA@
_szlMAXSTRINGLTH DD FLAT:??_C@_0N@LMHL@MAXSTRINGLTH?$AA@
_szlMR_LIMIT DD	FLAT:??_C@_08DHHO@MR_LIMIT?$AA@
_szl__MSGQ DD	FLAT:??_C@_06OMJI@__MSGQ?$AA@
_szlNAME DD	FLAT:??_C@_04IALP@NAME?$AA@
_szlNETCOMPRESS DD FLAT:??_C@_0M@GNJA@NETCOMPRESS?$AA@
_szlNETWORK DD	FLAT:??_C@_07KFPJ@NETWORK?$AA@
_szlNumAtts DD	FLAT:??_C@_07GOHG@NumAtts?$AA@
_szlNumEnts DD	FLAT:??_C@_07OOMM@NumEnts?$AA@
_szlNumRels DD	FLAT:??_C@_07PICA@NumRels?$AA@
_szlOCACT DD	FLAT:??_C@_05LDPN@OCACT?$AA@
_szlOCACTE DD	FLAT:??_C@_06PJLI@OCACTE?$AA@
_szlOCCOM DD	FLAT:??_C@_05KPHB@OCCOM?$AA@
_szlOCDROP DD	FLAT:??_C@_06HHGH@OCDROP?$AA@
_szlOCEOPER DD	FLAT:??_C@_07HIHA@OCEOPER?$AA@
_szlOFRECID DD	FLAT:??_C@_07NHGG@OFRECID?$AA@
_szlOFBUFSZ DD	FLAT:??_C@_07GKEM@OFBUFSZ?$AA@
_szlOPER_LIBNM DD FLAT:??_C@_0L@PJJC@OPER_LIBNM?$AA@
_szlOper DD	FLAT:??_C@_04FKDH@Oper?$AA@
_szlOWNER_MEMB DD FLAT:??_C@_0L@JCEP@OWNER_MEMB?$AA@
_szlPDELETE DD	FLAT:??_C@_07BAEJ@PDELETE?$AA@
_szlPERSIST DD	FLAT:??_C@_07NIBE@PERSIST?$AA@
_szlPNAME DD	FLAT:??_C@_05ILLO@PNAME?$AA@
_szlQualAttrib DD FLAT:??_C@_0L@DIOI@QualAttrib?$AA@
_szlRECID DD	FLAT:??_C@_05NKIC@RECID?$AA@
_szlRECNAME DD	FLAT:??_C@_07NDLE@RECNAME?$AA@
_szlRECURSIVE DD FLAT:??_C@_09GDN@RECURSIVE?$AA@
_szlREL	DD	FLAT:??_C@_03LNGM@REL?$AA@
_szlRELFIELD DD	FLAT:??_C@_08PMNP@RELFIELD?$AA@
_szlRELRECORD DD FLAT:??_C@_09HINM@RELRECORD?$AA@
_szlRELXVAATT_TOK DD FLAT:??_C@_0O@DBKM@RELXVAATT_TOK?$AA@
_szlREQUIRED DD	FLAT:??_C@_08BGDD@REQUIRED?$AA@
_szlRESTRICTED DD FLAT:??_C@_0L@GCMK@RESTRICTED?$AA@
_szlSERVER DD	FLAT:??_C@_06BJID@SERVER?$AA@
_szlSEQUENCING DD FLAT:??_C@_0L@FLNJ@SEQUENCING?$AA@
_szlSEQ_AD DD	FLAT:??_C@_06LIHO@SEQ_AD?$AA@
_szlSETID1 DD	FLAT:??_C@_06NHOC@SETID1?$AA@
_szlSETID2 DD	FLAT:??_C@_06CIFL@SETID2?$AA@
_szlSETNAME1 DD	FLAT:??_C@_08FJI@SETNAME1?$AA@
_szlSETNAME2 DD	FLAT:??_C@_08PKCB@SETNAME2?$AA@
_szlSRCXVAATT_TOK DD FLAT:??_C@_0O@HOCN@SRCXVAATT_TOK?$AA@
_szlTask DD	FLAT:??_C@_04HDAF@Task?$AA@
_szlText DD	FLAT:??_C@_04BNNJ@Text?$AA@
_szlTYPE DD	FLAT:??_C@_04JHII@TYPE?$AA@
_szlUP_DATE DD	FLAT:??_C@_07KJPH@UP_DATE?$AA@
_szlUSERID DD	FLAT:??_C@_06PIPA@USERID?$AA@
_szlUPDATE DD	FLAT:??_C@_06NDPG@UPDATE?$AA@
_szlZKEY DD	FLAT:??_C@_04JGIO@ZKEY?$AA@
_szlApplicationLogicError DD FLAT:??_C@_0CK@BELJ@Object?5Services?5?9?5Application?5Lo@
_szlDataValidationError DD FLAT:??_C@_0BG@FMPG@Data?5Validation?5Error?$AA@
_szlOE_SystemError DD FLAT:??_C@_0BA@ODOC@OE?5System?5Error?$AA@
_szlAFTER DD	FLAT:??_C@_05HBLJ@AFTER?$AA@
_szlBEFORE DD	FLAT:??_C@_06COI@BEFORE?$AA@
_g_pchMQI DD	FLAT:??_C@_0P@BAHL@MQ_MessageSend?$AA@
	DD	FLAT:??_C@_0BB@MBCE@MQ_MessagePrompt?$AA@
	DD	FLAT:??_C@_0BJ@MAFE@MQ_MessagePromptForInput?$AA@
	DD	FLAT:??_C@_0BC@GMHO@MQ_MessagePresent?$AA@
_szGAFANullS DD	FLAT:??_C@_08A@?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@
_g_pchMon DD	FLAT:??_C@_07BPKJ@January?$AA@
	DD	FLAT:??_C@_08PGBA@February?$AA@
	DD	FLAT:??_C@_05FGPD@March?$AA@
	DD	FLAT:??_C@_05JFGC@April?$AA@
	DD	FLAT:??_C@_03MGHB@May?$AA@
	DD	FLAT:??_C@_04ICFP@June?$AA@
	DD	FLAT:??_C@_04PIJO@July?$AA@
	DD	FLAT:??_C@_06PADP@August?$AA@
	DD	FLAT:??_C@_09MKGD@September?$AA@
	DD	FLAT:??_C@_07IAMM@October?$AA@
	DD	FLAT:??_C@_08NJLI@November?$AA@
	DD	FLAT:??_C@_08LIDF@December?$AA@
_g_pchDOW DD	FLAT:??_C@_06OOEM@Sunday?$AA@
	DD	FLAT:??_C@_06CHLK@Monday?$AA@
	DD	FLAT:??_C@_07BMBC@Tuesday?$AA@
	DD	FLAT:??_C@_09PBIN@Wednesday?$AA@
	DD	FLAT:??_C@_08CCFO@Thursday?$AA@
	DD	FLAT:??_C@_06ONCK@Friday?$AA@
	DD	FLAT:??_C@_08FAKH@Saturday?$AA@
_szlINTL DD	FLAT:??_C@_04KGMK@Intl?$AA@
_szlICOUNTRY DD	FLAT:??_C@_08FKAM@iCountry?$AA@
_szlSCOUNTRY DD	FLAT:??_C@_08JMM@sCountry?$AA@
_szlSLANGUAGE DD FLAT:??_C@_09IMGC@sLanguage?$AA@
_szlSLIST DD	FLAT:??_C@_05NLOI@sList?$AA@
_szlIMEASURE DD	FLAT:??_C@_08HHE@iMeasure?$AA@
_szlITIME DD	FLAT:??_C@_05EMIJ@iTime?$AA@
_szlSTIME DD	FLAT:??_C@_05PLM@sTime?$AA@
_szlS1159 DD	FLAT:??_C@_05PCBI@s1159?$AA@
_szlS2359 DD	FLAT:??_C@_05DJMD@s2359?$AA@
_szlITLZERO DD	FLAT:??_C@_07LDFB@iTLZero?$AA@
_szlSSHORTDATE DD FLAT:??_C@_0L@NPLI@sShortDate?$AA@
_szlSLONGDATE DD FLAT:??_C@_09JENF@sLongDate?$AA@
_szlSCURRENCY DD FLAT:??_C@_09JDHO@sCurrency?$AA@
_szlICURRENCY DD FLAT:??_C@_09CBCN@iCurrency?$AA@
_szlICURRDIGITS DD FLAT:??_C@_0M@LKGH@iCurrDigits?$AA@
_szlINEGCURR DD	FLAT:??_C@_08LHOD@iNegCurr?$AA@
_szlSTHOUSAND DD FLAT:??_C@_09BEPN@sThousand?$AA@
_szlSDECIMAL DD	FLAT:??_C@_08GFHF@sDecimal?$AA@
_szlIDIGITS DD	FLAT:??_C@_07FACE@iDigits?$AA@
_szlILZERO DD	FLAT:??_C@_06LENA@iLzero?$AA@
_DATA	ENDS
CONST	SEGMENT
_BaseMsgTable DW 01H
	DD	FLAT:??_C@_0DC@KKHB@KZOEE001?5?9?5Error?5communicating?5w@
	DW	02H
	DD	FLAT:??_C@_0CP@JFJD@KZOEE002?5?9?5ZEIDON?5environment?5va@
	DW	03H
	DD	FLAT:??_C@_0CK@LHJO@KZOEE003?5?9?5Error?5starting?5Object@
	DW	04H
	DD	FLAT:??_C@_0DE@HPME@KZOEE004?5?9?5Error?5communicating?5w@
	DW	05H
	DD	FLAT:??_C@_0DE@HEBF@KZOEE005?5?9?5Error?5communicating?5w@
	DW	06H
	DD	FLAT:??_C@_0CP@HIJD@KZOEE006?5?9?5Internal?5error?5freein@
	DW	07H
	DD	FLAT:??_C@_0ED@FDBJ@KZOEE007?5?9?5Internal?5Anchor?5block@
	DW	08H
	DD	FLAT:??_C@_0EI@BCLB@KZOEE008?5?9?5Application?5definitio@
	DW	09H
	DD	FLAT:??_C@_0DF@MKOJ@KZOEE009?5?9?5Error?5opening?5applica@
	DW	0aH
	DD	FLAT:??_C@_0CL@MFKJ@KZOEE010?5?9?5Requested?5application@
	DW	0bH
	DD	FLAT:??_C@_0DC@DKPD@KZOEE011?5?9?5Error?5opening?5applica@
	DW	0cH
	DD	FLAT:??_C@_0CD@KFHE@KZOEE012?5?9?5Error?5allocating?5memo@
	DW	0dH
	DD	FLAT:??_C@_0CJ@MDMN@KZOEE013?5?9?5Internal?5operation?5ca@
	DW	0eH
	DD	FLAT:??_C@_0CO@LCNE@KZOEE014?5?9?5Invalid?5suballoc?5memo@
	DW	0fH
	DD	FLAT:??_C@_0CI@OGFD@KZOEE015?5?9?5Invalid?5suballoc?5memo@
	DW	010H
	DD	FLAT:??_C@_0BI@EDAJ@KZOEE016?5?9?5Invalid?5Task?$AA@
	DW	011H
	DD	FLAT:??_C@_0BM@MOGK@KZOEE017?5?9?5Task?5is?5Disabled?$AA@
	DW	012H
	DD	FLAT:??_C@_0CI@DHKC@KZOEE018?5?9?5Error?5in?5Domain?5file?0@
	DW	013H
	DD	FLAT:??_C@_0CJ@PAMN@KZOEE019?5?9?5Invalid?5GetTaskInfo?5r@
	DW	014H
	DD	FLAT:??_C@_0CD@COHN@KZOEE020?5?9?5Invalid?5Operation?5cal@
	DW	015H
	DD	FLAT:??_C@_0EJ@OFCD@KZOEE021?5?9?5Internal?5error?0?5TaskO@
	DW	016H
	DD	FLAT:??_C@_0BO@PFIN@KZOEE022?5?9?5Error?5writing?5file?$AA@
	DW	017H
	DD	FLAT:??_C@_0BP@ENDH@KZOEE023?5?9?5Invalid?5parameter?0?5?$AA@
	DW	018H
	DD	FLAT:??_C@_0BO@LNEH@KZOEE024?5?9?5Error?5opening?5file?$AA@
	DW	019H
	DD	FLAT:??_C@_0CM@LGJG@KZOEE025?5?9?5Error?5in?5directory?5sp@
	DW	01aH
	DD	FLAT:??_C@_0CE@CFOB@KZOEE026?5?9?5Error?5creating?5direct@
	DW	01eH
	DD	FLAT:??_C@_0CF@MDHP@KZOEE030?5?9?5Error?5loading?5library@
	DW	01fH
	DD	FLAT:??_C@_0CI@KCKB@KZOEE031?5?9?5Error?5locating?5Operat@
	DW	020H
	DD	FLAT:??_C@_0CB@KHLN@KZOEE032?5?9?5Mutex?5name?5is?5invalid@
	DW	032H
	DD	FLAT:??_C@_0CL@NPAH@KZOEE050?5?9?5Error?5opening?5View?5Ob@
	DW	033H
	DD	FLAT:??_C@_0CL@EMEJ@KZOEE051?5?9?5Invalid?5View?5Object?5f@
	DW	034H
	DD	FLAT:??_C@_0EG@KBNM@KZOEE052?5?9?5Invalid?5Object?5file?0?5@
	DW	035H
	DD	FLAT:??_C@_0CP@CJAD@KZOEE053?5?9?5Invalid?5Entity?5level?5@
	DW	036H
	DD	FLAT:??_C@_0CJ@OIAJ@KZOEE054?5?9?5Invalid?5record?5found?5@
	DW	037H
	DD	FLAT:??_C@_0DM@CCJK@KZOEE055?5?9?5Invalid?5file?0?5LTH?5or?5@
	DW	038H
	DD	FLAT:??_C@_0CF@JDKN@KZOEE056?5?9?5Domain?5not?5found?5on?5l@
	DW	039H
	DD	FLAT:??_C@_0DN@EDAD@KZOEE057?5?9?5Invalid?5file?0?5LTH?5bef@
	DW	03aH
	DD	FLAT:??_C@_0EE@OCOD@KZOEE058?5?9?5Invalid?5file?0?5PERSIST@
	DW	03bH
	DD	FLAT:??_C@_0EC@PMPM@KZOEE059?5?9?5Invalid?5file?0?5Invalid@
	DW	03cH
	DD	FLAT:??_C@_0CL@PNHL@KZOEE060?5?9?5Invalid?5maximum?5root?5@
	DW	03dH
	DD	FLAT:??_C@_0DD@IPCF@KZOEE061?5?9?5Persistent?5Attribute?5@
	DW	03eH
	DD	FLAT:??_C@_0EH@FCEJ@KZOEE062?5?9?5Conflict?5between?5E?1R?5@
	DW	03fH
	DD	FLAT:??_C@_0EG@PGNO@KZOEE063?5?9?5Entity?5attrib?5RECURSI@
	DW	040H
	DD	FLAT:??_C@_0CI@DBKC@KZOEE064?5?9?5TYPE?5obsolete?0?5use?5AP@
	DW	041H
	DD	FLAT:??_C@_0DM@HNKG@KZOEE065?5?9?5LTH?5only?5valid?5for?5At@
	DW	042H
	DD	FLAT:??_C@_0CC@DFAB@KZOEE066?5?9?5Attribute?5length?5zero@
	DW	043H
	DD	FLAT:??_C@_0DH@DFDK@KZOEE067?5?9?5Could?5not?5initialize?5@
	DW	046H
	DD	FLAT:??_C@_0CE@GHFO@KZOEE070?5?9?5Object?5instance?5is?5em@
	DW	047H
	DD	FLAT:??_C@_0CI@HPIK@KZOEE071?5?9?5Error?5opening?5instanc@
	DW	048H
	DD	FLAT:??_C@_0CI@EEEO@KZOEE072?5?9?5Error?5reading?5instanc@
	DW	049H
	DD	FLAT:??_C@_0CI@GPMH@KZOEE073?5?9?5Invalid?5instance?5file@
	DW	04aH
	DD	FLAT:??_C@_0CI@NBOH@KZOEE074?5?9?5Invalid?5Entity?5name?5o@
	DW	04bH
	DD	FLAT:??_C@_0CJ@FMPI@KZOEE075?5?9?5Invalid?5Entity?5level?5@
	DW	04cH
	DD	FLAT:??_C@_0DP@HHHP@KZOEE076?5?9?5Object?5instance?5conta@
	DW	04dH
	DD	FLAT:??_C@_0DJ@EOHG@KZOEE077?5?9?5Invalid?5record?5size?5i@
	DW	04eH
	DD	FLAT:??_C@_0EA@PIKP@KZOEE078?5?9?5Internal?5error?0?5linke@
	DW	04fH
	DD	FLAT:??_C@_0CN@GDKG@KZOEE079?5?9?5Trying?5to?5commit?5a?5re@
	DW	050H
	DD	FLAT:??_C@_0EI@ENAN@KZOEE080?5?9?5Object?5Definition?5doe@
	DW	051H
	DD	FLAT:??_C@_0EG@IICI@KZOEE081?5?9?5Object?5Definition?5doe@
	DW	052H
	DD	FLAT:??_C@_0CJ@BEFH@KZOEE082?5?9?5Error?5starting?5Genkey@
	DW	053H
	DD	FLAT:??_C@_0IJ@LNPL@KZOEE083?5?9?5LOD?5does?5not?5have?5phy@
	DW	054H
	DD	FLAT:??_C@_0EB@HECI@KZOEE084?5?9?5Entity?5in?5Object?5Defi@
	DW	055H
	DD	FLAT:??_C@_0EK@GEM@KZOEE085?5?9?5Entity?5in?5Object?5Defi@
	DW	056H
	DD	FLAT:??_C@_0CE@ELED@KZOEE086?5?9?5Trying?5to?5commit?50?5vi@
	DW	057H
	DD	FLAT:??_C@_0CI@MFDJ@KZOEE087?5?9?5Too?5many?5views?5in?5Vie@
	DW	058H
	DD	FLAT:??_C@_0DF@CEHL@KZOEE088?5?9?5Compressed?5OI?5is?5out?5@
	DW	05aH
	DD	FLAT:??_C@_0EC@IMDC@KZOEE090?5?9?5Maximum?5number?5of?5ent@
	DW	05bH
	DD	FLAT:??_C@_0DO@CEAH@KZOEE091?5?9?5Maximum?5number?5of?5ent@
	DW	05cH
	DD	FLAT:??_C@_0DN@DGMC@KZOEE092?5?9?5Couldn?8t?5re?9activate?5@
	DW	05dH
	DD	FLAT:??_C@_0EN@GBNJ@KZOEE093?5?9?5Optimistic?5locking?5er@
	DW	05eH
	DD	FLAT:??_C@_0BN@NOMM@KZOEE094?5?9?5Locking?5violation?$AA@
	DW	05fH
	DD	FLAT:??_C@_0JB@CGJ@KZOEE095?5?9?5A?5recursive?5child?5was@
	DW	060H
	DD	FLAT:??_C@_0CK@LDGH@KZOEE096?5?9?5Error?5retrieving?5OI?5f@
	DW	064H
	DD	FLAT:??_C@_0DA@GDIC@KZOEE100?5?9?5Invalid?5View?0?5view?5is@
	DW	065H
	DD	FLAT:??_C@_0BI@NHEC@KZOEE101?5?9?5Invalid?5View?$AA@
	DW	066H
	DD	FLAT:??_C@_0CI@JOEN@KZOEE102?5?9?5Invalid?5View?0?5view?5is@
	DW	067H
	DD	FLAT:??_C@_0CI@DCOG@KZOEE103?5?9?5Invalid?5Entity?5name?5f@
	DW	068H
	DD	FLAT:??_C@_0DL@IOKD@KZOEE104?5?9?5Invalid?5Attribute?5nam@
	DW	069H
	DD	FLAT:??_C@_0DA@OHNK@KZOEE105?5?9?5Invalid?5scoping?5Entit@
	DW	06aH
	DD	FLAT:??_C@_0BM@LNED@KZOEE106?5?9?5Rules?5violation?5?$AA@
	DW	06bH
	DD	FLAT:??_C@_0CA@ICEI@KZOEE107?5?9?5Invalid?5Subtask?5View?$AA@
	DW	06cH
	DD	FLAT:??_C@_0CI@CNMF@KZOEE108?5?9?5Attempt?5to?5drop?5Subta@
	DW	06dH
	DD	FLAT:??_C@_0DD@IEKN@KZOEE109?5?9?5Invalid?5View?0?5view?5co@
	DW	06eH
	DD	FLAT:??_C@_0CH@NIKJ@KZOEE110?5?9?5Invalid?5level?5for?5Vie@
	DW	06fH
	DD	FLAT:??_C@_0EF@IJII@KZOEE111?5?9?5Attempt?5to?5set?5subtas@
	DW	070H
	DD	FLAT:??_C@_0EC@BHLF@KZOEE112?5?9?5Attempt?5to?5set?5subtas@
	DW	071H
	DD	FLAT:??_C@_0DD@OJHP@KZOEE113?5?9?5Invalid?5View?0?5view?5co@
	DW	072H
	DD	FLAT:??_C@_0DD@NFKB@KZOEE114?5?9?5Source?5and?5Target?5ent@
	DW	073H
	DD	FLAT:??_C@_0EB@HFOP@KZOEE115?5?9?5Attempt?5to?5move?5an?5in@
	DW	074H
	DD	FLAT:??_C@_0EL@JFCI@KZOEE116?5?9?5Attempt?5to?5include?5an@
	DW	075H
	DD	FLAT:??_C@_0CN@EDAL@KZOEE117?5?9?5Entity?5Instance?5Keys?5@
	DW	076H
	DD	FLAT:??_C@_0DM@BDCF@KZOEE118?5?9?5Internal?5Key?5error?5re@
	DW	077H
	DD	FLAT:??_C@_0CL@GLPJ@KZOEE119?5?9?5Invalid?5View?0?5View?5is@
	DW	078H
	DD	FLAT:??_C@_0CG@MFLA@KZOEE120?5?9?5Invalid?5position?5para@
	DW	079H
	DD	FLAT:??_C@_0DG@NDMM@KZOEE121?5?9?5Attempt?5to?5insert?5twi@
	DW	07aH
	DD	FLAT:??_C@_0DI@HBNG@KZOEE122?5?9?5Attempt?5to?5create?5an?5@
	DW	07cH
	DD	FLAT:??_C@_0FB@NPFI@KZOEE124?5?9?5Entity?5parent?5is?5incl@
	DW	07dH
	DD	FLAT:??_C@_0EC@FECD@KZOEE125?5?9?5Target?5and?5Source?5Ent@
	DW	07eH
	DD	FLAT:??_C@_0DG@JPKB@KZOEE126?5?9?5Target?5or?5Source?5Enti@
	DW	07fH
	DD	FLAT:??_C@_0EH@IKFL@KZOEE127?5?9?5Source?5?$CG?5target?5do?5no@
	DW	080H
	DD	FLAT:??_C@_0EG@KLAD@KZOEE128?5?9?5Target?5Entity?5cardina@
	DW	081H
	DD	FLAT:??_C@_0IA@GFGF@KZOEE129?5?9?5Trying?5to?5create?5a?5re@
	DW	083H
	DD	FLAT:??_C@_0EG@DDAB@KZOEE131?5?9?5Attempt?5to?5include?5Su@
	DW	084H
	DD	FLAT:??_C@_0DL@FCGD@KZOEE132?5?9?5Error?5establishing?5cu@
	DW	086H
	DD	FLAT:??_C@_0FA@LJEB@KZOEE134?5?9?5Attempt?5to?5version?5an@
	DW	087H
	DD	FLAT:??_C@_0CJ@EFHN@KZOEE135?5?9?5Entity?5Instance?5not?5v@
	DW	088H
	DD	FLAT:??_C@_0CN@MAJK@KZOEE136?5?9?5Entity?5Instance?5alrea@
	DW	089H
	DD	FLAT:??_C@_0DA@LGF@KZOEE137?5?9?5Entity?5Instance?5desce@
	DW	08aH
	DD	FLAT:??_C@_0EE@IOCN@KZOEE138?5?9?5Attempt?5to?5include?5ta@
	DW	08bH
	DD	FLAT:??_C@_0DM@EDLN@KZOEE139?5?9?5Error?5establishing?5cu@
	DW	08cH
	DD	FLAT:??_C@_0ED@EHNP@KZOEE140?5?9?5Target?5and?5source?5Obj@
	DW	08dH
	DD	FLAT:??_C@_0EK@MPKH@KZOEE141?5?9?5Attempt?5to?5include?5a?5@
	DW	0beH
	DD	FLAT:??_C@_0CI@HOIP@KZOEE190?5?9?5Error?5opening?5tempora@
	DW	0bfH
	DD	FLAT:??_C@_0EC@BIGN@KZOEE191?5?9?5Attribute?5must?5be?5a?5B@
	DW	0e7H
	DD	FLAT:??_C@_0DA@CNJA@KZOEE231?5?9?5Decimal?5attribute?5ove@
	DW	0e8H
	DD	FLAT:??_C@_0DP@LJHO@KZOEE232?5?9?5Operation?5indicates?5u@
	DW	0e9H
	DD	FLAT:??_C@_0DG@KPMG@KZOEE233?5?9?5Could?5not?5locate?5deri@
	DW	0eaH
	DD	FLAT:??_C@_0EH@EJPO@KZOEE234?5?9?5Attempt?5to?5add?5intege@
	DW	0ebH
	DD	FLAT:??_C@_0BM@GBBH@KZOEE235?5?9?5Integer?5overflow?$AA@
	DW	0ecH
	DD	FLAT:??_C@_0BN@JFBL@KZOEE236?5?9?5Integer?5underflow?$AA@
	DW	0edH
	DD	FLAT:??_C@_0DI@NJGM@KZOEE237?5?9?5Attempt?5to?5update?5a?5n@
	DW	0eeH
	DD	FLAT:??_C@_0ED@IIED@KZOEE238?5?9?5Attempt?5to?5update?5a?5n@
	DW	0efH
	DD	FLAT:??_C@_0DA@EHLD@KZOEE239?5?9?5Invalid?5Operation?5for@
	DW	0f0H
	DD	FLAT:??_C@_0DM@EDAM@KZOEE240?5?9?5Binary?5large?5object?5?$CI@
	DW	0f1H
	DD	FLAT:??_C@_0CC@FKDO@KZOEE241?5?9?5Invalid?5Variable?5Type@
	DW	0f2H
	DD	FLAT:??_C@_0CF@KFFO@KZOEE242?5?9?5Invalid?5Domain?5Entry?5@
	DW	0f3H
	DD	FLAT:??_C@_0CG@NJPF@KZOEE243?5?9?5Context?5invalid?5for?5D@
	DW	0f4H
	DD	FLAT:??_C@_0CD@FNBB@KZOEE244?5?9?5Attribute?5has?5no?5Doma@
	DW	0f5H
	DD	FLAT:??_C@_0DM@CLHG@KZOEE245?5?9?5Null?5string?5not?5allow@
	DW	0f6H
	DD	FLAT:??_C@_0CD@EGIM@KZOEE246?5?9?5Invalid?5Attribute?5typ@
	DW	0f7H
	DD	FLAT:??_C@_0DM@LIOD@KZOEE247?5?9?5Blob?5Attribute?5does?5n@
	DW	0f8H
	DD	FLAT:??_C@_0CG@JDPP@KZOEE248?5?9?5Required?5attribute?5is@
	DW	0faH
	DD	FLAT:??_C@_0CE@HNFJ@KZOEE250?5?9?5Object?5instance?5is?5em@
	DW	0fcH
	DD	FLAT:??_C@_0CJ@PNML@KZOEE252?5?9?5Root?5of?5view?5has?5been@
	DW	0fdH
	DD	FLAT:??_C@_0CB@ICBE@KZOEE253?5?9?5Entity?5cursor?5is?5NULL@
	DW	0feH
	DD	FLAT:??_C@_0CG@DKJB@KZOEE254?5?9?5Entity?5cursor?5is?5unde@
	DW	0ffH
	DD	FLAT:??_C@_0DH@MKIF@KZOEE255?5?9?5Attempt?5to?5update?5a?5p@
	DW	0100H
	DD	FLAT:??_C@_0CC@IDGK@KZOEE256?5?9?5Entity?5is?5root?5of?5vie@
	DW	0101H
	DD	FLAT:??_C@_0EA@FEIJ@KZOEE257?5?9?5Version?5mismatch?5betw@
	DW	0102H
	DD	FLAT:??_C@_0CO@IOAK@KZOEE258?5?9?5Scoping?5Entity?5cursor@
	DW	0103H
	DD	FLAT:??_C@_0CJ@MMGH@KZOEE259?5?9?5Scoping?5Entity?5cursor@
	DW	0107H
	DD	FLAT:??_C@_0EP@DIEE@KZOEE263?5?9?5Input?5Qualifier?5canno@
	DW	0108H
	DD	FLAT:??_C@_0DJ@DMDO@KZOEE264?5?9?5Invalid?5Operation?5for@
	DW	0109H
	DD	FLAT:??_C@_0DN@JHKM@KZOEE265?5?9?5Invalid?5Operation?5for@
	DW	010aH
	DD	FLAT:??_C@_0DO@NFPG@KZOEE266?5?9?5Invalid?5Operation?5for@
	DW	010bH
	DD	FLAT:??_C@_0CM@LKBG@KZOEE267?5?9?5Hierarchical?5cursor?5i@
	DW	010cH
	DD	FLAT:??_C@_0DH@KDFJ@KZOEE268?5?9?5Source?5and?5target?5ent@
	DW	010dH
	DD	FLAT:??_C@_0CG@FACO@KZOEE269?5?9?5Invalid?5Select?5Set?5ID@
	DW	010eH
	DD	FLAT:??_C@_0CH@HOLD@KZOEE270?5?9?5View?5name?5is?5already?5@
	DW	010fH
	DD	FLAT:??_C@_0DO@BMHF@KZOEE271?5?9?5Subobject?5Entity?5is?5r@
	DW	0110H
	DD	FLAT:??_C@_0CL@LFIF@KZOEE272?5?9?5Subobject?5Parent?5Curs@
	DW	0111H
	DD	FLAT:??_C@_0DD@DLH@KZOEE273?5?9?5Parent?5Entity?5instanc@
	DW	0112H
	DD	FLAT:??_C@_0ED@GMM@KZOEE274?5?9?5Target?5and?5Source?5vie@
	DW	012cH
	DD	FLAT:??_C@_0CG@OIHN@KZOEE300?5?9?5Problems?5finding?5a?5pa@
	DW	012dH
	DD	FLAT:??_C@_0EH@GAK@KZOEE301?5?9?5Return?5buffer?5not?5lar@
	DW	012eH
	DD	FLAT:??_C@_0BK@JCI@KZOEE302?5?9?5Invalid?5option?$AA@
	DW	014aH
	DD	FLAT:??_C@_0EA@KHBJ@KZOEE330?5?9?5Message?5Object?5Defini@
	DW	015eH
	DD	FLAT:??_C@_0CI@HNHP@KZOEE350?5?9?5Context?5Not?5Valid?5for@
	DW	015fH
	DD	FLAT:??_C@_0CD@IIPK@KZOEE351?5?9?5Invalid?5Input?5Data?5Ty@
	DW	0160H
	DD	FLAT:??_C@_0DB@GJCM@KZOEE352?5?9?5Text?5String?5exceeds?5a@
	DW	0161H
	DD	FLAT:??_C@_0DC@CBDF@KZOEE353?5?9?5Attribute?5Type?5invali@
	DW	0162H
	DD	FLAT:??_C@_0CG@DCAE@KZOEE354?5?9?5Invalid?5Domain?5Entry?5@
	DW	0163H
	DD	FLAT:??_C@_0DH@JDFE@KZOEE355?5?9?5Table_Handler?5invalid@
	DW	0164H
	DD	FLAT:??_C@_0CK@FNMN@KZOEE356?5?9?5Domain?5has?5an?5unnamed@
	DW	0165H
	DD	FLAT:??_C@_0BO@LACG@KZOEE357?5?9?5Invalid?5Input?5Data?$AA@
	DW	0166H
	DD	FLAT:??_C@_0CM@DEPD@KZOEE358?5?9?5Value?5not?5in?5Context?5@
	DW	0167H
	DD	FLAT:??_C@_0DJ@BGND@KZOEE359?5?9?5Invalid?5Input?5Data?5Ty@
	DW	0168H
	DD	FLAT:??_C@_0CF@JLJE@KZOEE360?5?9?5Missing?5ending?5delimi@
	DW	0169H
	DD	FLAT:??_C@_0CA@PMLE@KZOEE361?5?9?5Invalid?5data?5Format?5?$AA@
	DW	016aH
	DD	FLAT:??_C@_0DL@IDHP@KZOEE362?5?9?5Variable?5Type?5not?5all@
	DW	016bH
	DD	FLAT:??_C@_0CL@NCJC@KZOEE363?5?9?5Context?5Edit?5string?5i@
	DW	016cH
	DD	FLAT:??_C@_0DA@MAJI@KZOEE364?5?9?5Picture?5length?5exceed@
	DW	0190H
	DD	FLAT:??_C@_0DF@EIIB@KZOEE400?5?9?5Error?5transmitting?5OI@
	DW	0191H
	DD	FLAT:??_C@_0BO@COPE@KZOEE401?5?9?5Invalid?5User?5Name?4?$AA@
	DW	0192H
	DD	FLAT:??_C@_0BN@LCML@KZOEE402?5?9?5Invalid?5Password?4?$AA@
	DW	0193H
	DD	FLAT:??_C@_0DJ@MFOH@KZOEE403?5?9?5Application?5not?5suppo@
	DW	0194H
	DD	FLAT:??_C@_0CB@ICKG@KZOEE404?5?9?5Can?8t?5find?5UserGroup?4@
	DW	0195H
	DD	FLAT:??_C@_0DL@EBIE@KZOEE405?5?9?5UserGroup?5doesn?8t?5hav@
	DW	01c2H
	DD	FLAT:??_C@_0CF@PDBP@KZOEE450?5?9?5Name?5for?5view?5is?5too?5@
	DW	01c3H
	DD	FLAT:??_C@_0DK@KFBA@KZOEE451?5?9?5Include?5source?5task?5d@
	DW	0270fH
	DD	FLAT:??_C@_00A@?$AA@
	ORG $+2
_OperationMsgTable DW 0aH
	DD	FLAT:??_C@_0BA@DLJN@SfCreateSubtask?$AA@
	DW	0bH
	DD	FLAT:??_C@_0O@BDFC@SfDropSubtask?$AA@
	DW	0cH
	DD	FLAT:??_C@_0M@FMPJ@DisableTask?$AA@
	DW	0dH
	DD	FLAT:??_C@_0L@BBMP@EnableTask?$AA@
	DW	014H
	DD	FLAT:??_C@_0BJ@BDEP@GetApplDirectoryFromView?$AA@
	DW	015H
	DD	FLAT:??_C@_0BL@OJMF@SfGetApplicationForSubtask?$AA@
	DW	018H
	DD	FLAT:??_C@_0O@FHBI@SfGetTaskInfo?$AA@
	DW	0d7H
	DD	FLAT:??_C@_0BJ@PMHK@SfActivateSysOI_FromFile?$AA@
	DW	0d8H
	DD	FLAT:??_C@_0BF@PCON@SfActivateSysEmptyOI?$AA@
	DW	032H
	DD	FLAT:??_C@_0BM@OIBJ@ActivateEmptyObjectInstance?$AA@
	DW	034H
	DD	FLAT:??_C@_0BH@NOPG@ActivateObjectInstance?$AA@
	DW	036H
	DD	FLAT:??_C@_0BE@IMAC@ActivateOI_FromFile?$AA@
	DW	0227H
	DD	FLAT:??_C@_0BI@GAMK@ActivateOI_FromXML_File?$AA@
	DW	0228H
	DD	FLAT:??_C@_0BE@CGBG@CommitOI_ToXML_File?$AA@
	DW	037H
	DD	FLAT:??_C@_0BC@PDFM@ActivateOI_FromOI?$AA@
	DW	03cH
	DD	FLAT:??_C@_0BF@GELD@CommitObjectInstance?$AA@
	DW	03eH
	DD	FLAT:??_C@_0BC@FMKN@CommitMultipleOIs?$AA@
	DW	03fH
	DD	FLAT:??_C@_0BA@MOCF@DropViewCluster?$AA@
	DW	040H
	DD	FLAT:??_C@_0BB@PMGH@AddToViewCluster?$AA@
	DW	03dH
	DD	FLAT:??_C@_0BA@FDOM@CommitOI_ToFile?$AA@
	DW	046H
	DD	FLAT:??_C@_0BD@PHBJ@DropObjectInstance?$AA@
	DW	064H
	DD	FLAT:??_C@_0BH@NEFL@CheckExistenceOfEntity?$AA@
	DW	0196H
	DD	FLAT:??_C@_0BG@HLNG@CompareEntityToEntity?$AA@
	DW	065H
	DD	FLAT:??_C@_0N@BOMB@CreateEntity?$AA@
	DW	06cH
	DD	FLAT:??_C@_0N@DPDF@GetEntityKey?$AA@
	DW	073H
	DD	FLAT:??_C@_0BF@ELCK@CreateTemporalEntity?$AA@
	DW	066H
	DD	FLAT:??_C@_0BP@EIGM@CreateTemporalSubobjectVersion?$AA@
	DW	067H
	DD	FLAT:??_C@_0BA@IEEA@AcceptSubobject?$AA@
	DW	07fH
	DD	FLAT:??_C@_0BM@MAGB@AcceptAllTemporalSubobjects?$AA@
	DW	068H
	DD	FLAT:??_C@_0BA@NIBC@CancelSubobject?$AA@
	DW	080H
	DD	FLAT:??_C@_0BM@CNDP@CancelAllTemporalSubobjects?$AA@
	DW	069H
	DD	FLAT:??_C@_0BO@NBLH@IncludeSubobjectFromSubobject?$AA@
	DW	085H
	DD	FLAT:??_C@_0CA@GDJL@IncludeSubobjectFromSubobjectEx?$AA@
	DW	086H
	DD	FLAT:??_C@_0BI@JDMH@SubobjectVersionUpdated?$AA@
	DW	06aH
	DD	FLAT:??_C@_0N@NKPH@DeleteEntity?$AA@
	DW	06bH
	DD	FLAT:??_C@_0O@PHBL@ExcludeEntity?$AA@
	DW	07eH
	DD	FLAT:??_C@_0L@COBA@DropEntity?$AA@
	DW	06eH
	DD	FLAT:??_C@_0O@OJII@MoveSubobject?$AA@
	DW	096H
	DD	FLAT:??_C@_0BE@PPIN@SetCursorNextEntity?$AA@
	DW	097H
	DD	FLAT:??_C@_0BE@MAGO@SetCursorPrevEntity?$AA@
	DW	098H
	DD	FLAT:??_C@_0BF@NEDK@SetCursorFirstEntity?$AA@
	DW	099H
	DD	FLAT:??_C@_0BE@HACO@SetCursorLastEntity?$AA@
	DW	0aaH
	DD	FLAT:??_C@_0BN@IKOI@SetCursorFirstEntityByString?$AA@
	DW	0abH
	DD	FLAT:??_C@_0BM@EHFF@SetCursorNextEntityByString?$AA@
	DW	0acH
	DD	FLAT:??_C@_0BO@GMJK@SetCursorFirstEntityByInteger?$AA@
	DW	0adH
	DD	FLAT:??_C@_0BN@DEFH@SetCursorNextEntityByInteger?$AA@
	DW	0aeH
	DD	FLAT:??_C@_0BO@COOK@SetCursorFirstEntityByDecimal?$AA@
	DW	0afH
	DD	FLAT:??_C@_0BN@HGCH@SetCursorNextEntityByDecimal?$AA@
	DW	0b0H
	DD	FLAT:??_C@_0BL@GLMN@SetCursorFirstEntityByAttr?$AA@
	DW	0b1H
	DD	FLAT:??_C@_0BK@MB@SetCursorNextEntityByAttr?$AA@
	DW	0b2H
	DD	FLAT:??_C@_0CA@CCIK@SetCursorFirstEntityByEntityCsr?$AA@
	DW	0b3H
	DD	FLAT:??_C@_0BP@FIAL@SetCursorNextEntityByEntityCsr?$AA@
	DW	0b4H
	DD	FLAT:??_C@_0BN@EMBJ@SetCursorFirstSelectedEntity?$AA@
	DW	0b5H
	DD	FLAT:??_C@_0BM@IBKE@SetCursorNextSelectedEntity?$AA@
	DW	0b6H
	DD	FLAT:??_C@_0BI@GCJI@SetCursorRelativeEntity?$AA@
	DW	0b7H
	DD	FLAT:??_C@_0BI@DKDE@GetRelativeEntityNumber?$AA@
	DW	0beH
	DD	FLAT:??_C@_0BJ@EJOC@DefineHierarchicalCursor?$AA@
	DW	0bfH
	DD	FLAT:??_C@_0BH@COPC@DropHierarchicalCursor?$AA@
	DW	0c0H
	DD	FLAT:??_C@_0CA@CHCH@SetCursorNextEntityHierarchical?$AA@
	DW	0c8H
	DD	FLAT:??_C@_0BD@OPGJ@CreateViewFromView?$AA@
	DW	0c9H
	DD	FLAT:??_C@_0BA@HNOF@SetViewFromView?$AA@
	DW	0caH
	DD	FLAT:??_C@_0BD@MNMP@SetViewToSubobject?$AA@
	DW	0cbH
	DD	FLAT:??_C@_0BH@EJFL@ResetViewFromSubobject?$AA@
	DW	0ccH
	DD	FLAT:??_C@_0P@CBGO@SetNameForView?$AA@
	DW	0cdH
	DD	FLAT:??_C@_0BA@LHJJ@DropNameForView?$AA@
	DW	0ceH
	DD	FLAT:??_C@_0O@LOIG@GetViewByName?$AA@
	DW	0cfH
	DD	FLAT:??_C@_0P@NAIK@SetSubtaskView?$AA@
	DW	0d0H
	DD	FLAT:??_C@_0P@KFDN@GetNameForView?$AA@
	DW	0d1H
	DD	FLAT:??_C@_0BG@FIPH@SfGetFirstSubtaskView?$AA@
	DW	0d2H
	DD	FLAT:??_C@_0BF@INMF@SfGetNextSubtaskView?$AA@
	DW	0d5H
	DD	FLAT:??_C@_0P@EIOP@SfTransferView?$AA@
	DW	0d6H
	DD	FLAT:??_C@_0L@HDM@SfLockView?$AA@
	DW	0d3H
	DD	FLAT:??_C@_09MKAH@ResetView?$AA@
	DW	0d4H
	DD	FLAT:??_C@_08JNKD@DropView?$AA@
	DW	0d9H
	DD	FLAT:??_C@_0BA@GCHM@SetViewReadOnly?$AA@
	DW	0deH
	DD	FLAT:??_C@_0N@HIKI@SetViewFlags?$AA@
	DW	0e0H
	DD	FLAT:??_C@_0N@BBKK@GetViewFlags?$AA@
	DW	0dfH
	DD	FLAT:??_C@_0P@CBLC@DropViewObject?$AA@
	DW	0feH
	DD	FLAT:??_C@_0BC@JNFA@GetAttributeFlags?$AA@
	DW	0ffH
	DD	FLAT:??_C@_0BB@CLPD@AttributeUpdated?$AA@
	DW	0faH
	DD	FLAT:??_C@_0BH@IPDO@GetStringFromAttribute?$AA@
	DW	0fbH
	DD	FLAT:??_C@_0BI@FFJB@GetIntegerFromAttribute?$AA@
	DW	0fcH
	DD	FLAT:??_C@_0BI@DCJK@GetDecimalFromAttribute?$AA@
	DW	0fdH
	DD	FLAT:??_C@_0BF@MHPH@GetBlobFromAttribute?$AA@
	DW	0102H
	DD	FLAT:??_C@_0BJ@HIGG@GetStructFromEntityAttrs?$AA@
	DW	0103H
	DD	FLAT:??_C@_0BE@PNDJ@GetAddrForAttribute?$AA@
	DW	0117H
	DD	FLAT:??_C@_0BJ@IFI@GetVariableFromAttribute?$AA@
	DW	0104H
	DD	FLAT:??_C@_0BH@MMIK@SetAttributeFromString?$AA@
	DW	0105H
	DD	FLAT:??_C@_0BI@CNM@SetAttributeFromInteger?$AA@
	DW	0106H
	DD	FLAT:??_C@_0BI@EAKM@SetAttributeFromDecimal?$AA@
	DW	0107H
	DD	FLAT:??_C@_0BF@JCLE@SetAttributeFromBlob?$AA@
	DW	0108H
	DD	FLAT:??_C@_0BK@MLHG@SetAttributeFromAttribute?$AA@
	DW	0109H
	DD	FLAT:??_C@_0BM@PBPK@SetAttributeFromCurrentDate?$AA@
	DW	0115H
	DD	FLAT:??_C@_0BJ@OEAI@SetAttributeFromVariable?$AA@
	DW	011aH
	DD	FLAT:??_C@_0BG@KHLN@SetAttributeValueNext?$AA@
	DW	011bH
	DD	FLAT:??_C@_0BG@FODI@SetAttributeValuePrev?$AA@
	DW	0114H
	DD	FLAT:??_C@_0BO@JAKJ@SetBlobAttributeFromAttribute?$AA@
	DW	0124H
	DD	FLAT:??_C@_0BM@CGCL@SetEntityAttributesFromBlob?$AA@
	DW	0123H
	DD	FLAT:??_C@_0BM@MJNM@SetBlobFromEntityAttributes?$AA@
	DW	010aH
	DD	FLAT:??_C@_0BK@KNHC@AddToAttributeFromInteger?$AA@
	DW	010bH
	DD	FLAT:??_C@_0BK@OPAC@AddToAttributeFromDecimal?$AA@
	DW	010cH
	DD	FLAT:??_C@_0BM@CKKJ@AddToAttributeFromAttribute?$AA@
	DW	011dH
	DD	FLAT:??_C@_0BL@DLKH@AddToAttributeFromVariable?$AA@
	DW	010eH
	DD	FLAT:??_C@_0BJ@ODPJ@CompareAttributeToString?$AA@
	DW	010fH
	DD	FLAT:??_C@_0BK@PHPD@CompareAttributeToInteger?$AA@
	DW	0110H
	DD	FLAT:??_C@_0BK@LFID@CompareAttributeToDecimal?$AA@
	DW	0111H
	DD	FLAT:??_C@_0BM@OPHA@CompareAttributeToAttribute?$AA@
	DW	0116H
	DD	FLAT:??_C@_0BL@OCPN@CompareAttributeToVariable?$AA@
	DW	0112H
	DD	FLAT:??_C@_0BD@HIDA@GetAttributeLength?$AA@
	DW	0113H
	DD	FLAT:??_C@_0BM@PHGL@SetMatchingAttributesByName?$AA@
	DW	0118H
	DD	FLAT:??_C@_0BP@FLBC@GetFirstTableEntryForAttribute?$AA@
	DW	0119H
	DD	FLAT:??_C@_0BO@BHMO@GetNextTableEntryForAttribute?$AA@
	DW	0190H
	DD	FLAT:??_C@_0BG@ILIL@DisplayEntityInstance?$AA@
	DW	0191H
	DD	FLAT:??_C@_0BG@KOPK@DisplayObjectInstance?$AA@
	DW	0192H
	DD	FLAT:??_C@_0BC@KOIM@DisplayCursorInfo?$AA@
	DW	011cH
	DD	FLAT:??_C@_0BD@FKMI@StoreValueInRecord?$AA@
	DW	012aH
	DD	FLAT:??_C@_0BN@EHIH@StoreValueInDerivedAttribute?$AA@
	DW	012aH
	DD	FLAT:??_C@_0BN@EHIH@StoreValueInDerivedAttribute?$AA@
	DW	015eH
	DD	FLAT:??_C@_0BD@JHII@TableEntryExtToInt?$AA@
	DW	015fH
	DD	FLAT:??_C@_0BD@DNNI@TableEntryIntToExt?$AA@
	DW	0160H
	DD	FLAT:??_C@_0BL@HNKN@TableEntryForInternalValue?$AA@
	DW	081H
	DD	FLAT:??_C@_0BE@OKMC@SetSelectSetForView?$AA@
	DW	070H
	DD	FLAT:??_C@_0BH@EPHO@GetSelectStateOfEntity?$AA@
	DW	071H
	DD	FLAT:??_C@_0BM@JBLI@SetAllSelectStatesForEntity?$AA@
	DW	072H
	DD	FLAT:??_C@_0BH@IMDL@SetSelectStateOfEntity?$AA@
	DW	074H
	DD	FLAT:??_C@_0BJ@NKAP@RelinkInstanceToInstance?$AA@
	DW	079H
	DD	FLAT:??_C@_0BJ@HAMO@RelinkAllSubobjectsForOI?$AA@
	DW	075H
	DD	FLAT:??_C@_0L@PDG@LoadEntity?$AA@
	DW	076H
	DD	FLAT:??_C@_0BG@PEI@ObjectInstanceUpdated?$AA@
	DW	082H
	DD	FLAT:??_C@_0BO@OOBH@ObjectInstanceUpdatedFromFile?$AA@
	DW	011eH
	DD	FLAT:??_C@_0BD@LHCP@GetValueFromRecord?$AA@
	DW	011fH
	DD	FLAT:??_C@_0BE@DIAC@StoreStringInRecord?$AA@
	DW	0120H
	DD	FLAT:??_C@_0BE@MENK@GetStringFromRecord?$AA@
	DW	0b8H
	DD	FLAT:??_C@_0BA@KGPF@SetEntityCursor?$AA@
	DW	0122H
	DD	FLAT:??_C@_0BC@CMGB@GetAddrFromRecord?$AA@
	DW	01c2H
	DD	FLAT:??_C@_0BN@FOCF@MiGetParentEntityNameForView?$AA@
	DW	0193H
	DD	FLAT:??_C@_0BL@PCOO@GetTaskDBHandlerTraceLevel?$AA@
	DW	0194H
	DD	FLAT:??_C@_0BL@NCHN@SetTaskDBHandlerTraceLevel?$AA@
	DW	0baH
	DD	FLAT:??_C@_0BN@GHM@GetAbsolutePositionForEntity?$AA@
	DW	0c1H
	DD	FLAT:??_C@_0CA@CBHE@GetEntityNameForHierarchicalCsr?$AA@
	DW	0bbH
	DD	FLAT:??_C@_0BK@EINL@SetCursorAbsolutePosition?$AA@
	DW	07aH
	DD	FLAT:??_C@_0BD@LLOG@OrderEntityForView?$AA@
	DW	07bH
	DD	FLAT:??_C@_0BF@JPO@CountEntitiesForView?$AA@
	DW	07dH
	DD	FLAT:??_C@_0BJ@DLHM@OrderOI_ByDefaultAttribs?$AA@
	DW	07cH
	DD	FLAT:??_C@_0BO@HLCK@OrderEntitiesByDefaultAttribs?$AA@
	DW	01c5H
	DD	FLAT:??_C@_0BN@GOEA@MiGetUpdateForViewEntityAttr?$AA@
	DW	0168H
	DD	FLAT:??_C@_0M@PBLM@MessageSend?$AA@
	DW	0169H
	DD	FLAT:??_C@_0O@CLJA@MessagePrompt?$AA@
	DW	016aH
	DD	FLAT:??_C@_0BG@MCGA@MessagePromptForInput?$AA@
	DW	016bH
	DD	FLAT:??_C@_0P@HGJE@MessagePresent?$AA@
	DW	01c6H
	DD	FLAT:??_C@_0BL@BKNM@MiGetTemporalStateOfEntity?$AA@
	DW	01c4H
	DD	FLAT:??_C@_0BD@KBO@MiGetUpdateForView?$AA@
	DW	01c3H
	DD	FLAT:??_C@_0BI@INOA@MiGetInstanceID_ForView?$AA@
	DW	01c7H
	DD	FLAT:??_C@_0BD@DOBB@MiGetDateTimeForOI?$AA@
	DW	01c8H
	DD	FLAT:??_C@_0BG@FHHI@MiGetERTokenForEntity?$AA@
	DW	01caH
	DD	FLAT:??_C@_0BH@KJIK@MiGetViewEntityForView?$AA@
	DW	0172H
	DD	FLAT:??_C@_0BA@GNDO@UfAddToDateTime?$AA@
	DW	0125H
	DD	FLAT:??_C@_0BK@NCOA@GetAttributeDisplayLength?$AA@
	DW	01cbH
	DD	FLAT:??_C@_0BK@FFIH@MiGetCardinalityForEntity?$AA@
	DW	01f4H
	DD	FLAT:??_C@_0O@CJIE@NetActivateOI?$AA@
	DW	01f6H
	DD	FLAT:??_C@_08FBGD@NetClose?$AA@
	DW	01f5H
	DD	FLAT:??_C@_0M@DLBE@NetCommitOI?$AA@
	DW	01f7H
	DD	FLAT:??_C@_0BB@PHPI@NetGetTraceLevel?$AA@
	DW	01f8H
	DD	FLAT:??_C@_09HFPC@NetListen?$AA@
	DW	01fdH
	DD	FLAT:??_C@_0O@KDCL@NetStopListen?$AA@
	DW	01faH
	DD	FLAT:??_C@_0BB@KEJB@NetSetTraceLevel?$AA@
	DW	01fbH
	DD	FLAT:??_C@_0L@BIJE@NetStartup?$AA@
	DW	01fcH
	DD	FLAT:??_C@_09MBHB@NetStatus?$AA@
	DW	01f9H
	DD	FLAT:??_C@_0BC@EMEG@NetProcessMessage?$AA@
	DW	01feH
	DD	FLAT:??_C@_0BD@IGEP@NetCommitOI_ToFile?$AA@
	DW	01ffH
	DD	FLAT:??_C@_0BH@FKGD@NetActivateOI_FromFile?$AA@
	DW	0200H
	DD	FLAT:??_C@_0BF@HCAL@NetSendBootstrapFile?$AA@
	DW	0201H
	DD	FLAT:??_C@_0BB@DPLM@NetCallOperation?$AA@
	DW	0202H
	DD	FLAT:??_C@_0BH@KJLN@NetGetLocalHostAddress?$AA@
	DW	0203H
	DD	FLAT:??_C@_0M@BMMC@NetSendFile?$AA@
	DW	077H
	DD	FLAT:??_C@_0BK@PDEP@SetIncrementalUpdateFlags?$AA@
	DW	078H
	DD	FLAT:??_C@_0BK@GACK@GetIncrementalUpdateFlags?$AA@
	DW	0128H
	DD	FLAT:??_C@_0BA@NAKK@SetBlobFromFile?$AA@
	DW	0129H
	DD	FLAT:??_C@_0BA@HHIJ@WriteBlobToFile?$AA@
	DW	01cH
	DD	FLAT:??_C@_0BE@HLHF@SfCheckOI_Integrity?$AA@
	DW	041H
	DD	FLAT:??_C@_0BL@JILI@GenerateQualFromEntityList?$AA@
	DW	0226H
	DD	FLAT:??_C@_0O@NLM@WriteOI_ToXML?$AA@
	DW	0229H
	DD	FLAT:??_C@_0BE@MMDJ@WriteSubobjectToXML?$AA@
	DW	022aH
	DD	FLAT:??_C@_0BK@IOBH@CommitSubobjectToXML_File?$AA@
	DW	0270fH
	DD	FLAT:??_C@_00A@?$AA@
CONST	ENDS
_DATA	SEGMENT
_g_bWin95 DB	01H
	ORG $+3
_szlNT_ThreadClassName DB 'ZeidonNT_ThreadClass', 00H
	ORG $+3
_g_lProcessIdx DD 0ffffffffH
_?cShowPopup@?1??fnSysMessageBox@@9@9 DB 020H
	ORG $+3
_?g_dNull@?1??fnDecimalOperation@@9@9 DQ 0c2d6bcc41e8ffffar ; -1e+014
_DATA	ENDS
;	COMDAT ??_C@_0BJ@OCLO@ZEIDON?5MUTEX?5?9?9?5INITTERM?$AA@
_DATA	SEGMENT
??_C@_0BJ@OCLO@ZEIDON?5MUTEX?5?9?9?5INITTERM?$AA@ DB 'ZEIDON MUTEX -- INI'
	DB	'TTERM', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@CFG@ZEIDON?5MUTEX?5?9?9?5MEMORY?5ALLOCATIO@
_DATA	SEGMENT
??_C@_0CC@CFG@ZEIDON?5MUTEX?5?9?9?5MEMORY?5ALLOCATIO@ DB 'ZEIDON MUTEX --'
	DB	' MEMORY ALLOCATION', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@JMMP@ZEIDON?5MUTEX?5?9?9?5ANCHOR?5BLOCK?$AA@
_DATA	SEGMENT
??_C@_0BN@JMMP@ZEIDON?5MUTEX?5?9?9?5ANCHOR?5BLOCK?$AA@ DB 'ZEIDON MUTEX -'
	DB	'- ANCHOR BLOCK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@GEKC@ZEIDON?5MUTEX?5?9?9?5ANCHOR?5INIT?$AA@
_DATA	SEGMENT
??_C@_0BM@GEKC@ZEIDON?5MUTEX?5?9?9?5ANCHOR?5INIT?$AA@ DB 'ZEIDON MUTEX --'
	DB	' ANCHOR INIT', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@FIFA@ZEIDON?5MUTEX?5?9?9?5SHARED?5MEM?$AA@
_DATA	SEGMENT
??_C@_0BL@FIFA@ZEIDON?5MUTEX?5?9?9?5SHARED?5MEM?$AA@ DB 'ZEIDON MUTEX -- '
	DB	'SHARED MEM', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OFOI@ZEIDON?5MUTEX?5?9?9?5TASK?5CHAIN?$AA@
_DATA	SEGMENT
??_C@_0BL@OFOI@ZEIDON?5MUTEX?5?9?9?5TASK?5CHAIN?$AA@ DB 'ZEIDON MUTEX -- '
	DB	'TASK CHAIN', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@FGNI@ZEIDON?5MUTEX?5?9?9?5TASK?5CHAIN?5WRITE@
_DATA	SEGMENT
??_C@_0CB@FGNI@ZEIDON?5MUTEX?5?9?9?5TASK?5CHAIN?5WRITE@ DB 'ZEIDON MUTEX '
	DB	'-- TASK CHAIN WRITE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@OLDG@ZEIDON?5MUTEX?5?9?9?5MUTEX?$AA@
_DATA	SEGMENT
??_C@_0BG@OLDG@ZEIDON?5MUTEX?5?9?9?5MUTEX?$AA@ DB 'ZEIDON MUTEX -- MUTEX', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@PPAA@ZEIDON?5MUTEX?5?9?9?5DEBUGCHANGE?$AA@
_DATA	SEGMENT
??_C@_0BM@PPAA@ZEIDON?5MUTEX?5?9?9?5DEBUGCHANGE?$AA@ DB 'ZEIDON MUTEX -- '
	DB	'DEBUGCHANGE', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@EGB@ZEIDON?5MUTEX?5?9?9?5PESSIMISTIC?5LOCK@
_DATA	SEGMENT
??_C@_0CB@EGB@ZEIDON?5MUTEX?5?9?9?5PESSIMISTIC?5LOCK@ DB 'ZEIDON MUTEX --'
	DB	' PESSIMISTIC LOCK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@GGGI@ZEIDON?5MUTEX?5?9?9?5APPLA?$AA@
_DATA	SEGMENT
??_C@_0BG@GGGI@ZEIDON?5MUTEX?5?9?9?5APPLA?$AA@ DB 'ZEIDON MUTEX -- APPLA', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OEL@ZEIDON?5MUTEX?5?9?9?5ENTITY?5KEY?$AA@
_DATA	SEGMENT
??_C@_0BL@OEL@ZEIDON?5MUTEX?5?9?9?5ENTITY?5KEY?$AA@ DB 'ZEIDON MUTEX -- E'
	DB	'NTITY KEY', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@DIIE@ZEIDON?5MUTEX?5?9?9?5TASKPROCESS?$AA@
_DATA	SEGMENT
??_C@_0BM@DIIE@ZEIDON?5MUTEX?5?9?9?5TASKPROCESS?$AA@ DB 'ZEIDON MUTEX -- '
	DB	'TASKPROCESS', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@CPDB@ZEIDON?5MUTEX?5?9?9?5PROC?5CHAIN?$AA@
_DATA	SEGMENT
??_C@_0BL@CPDB@ZEIDON?5MUTEX?5?9?9?5PROC?5CHAIN?$AA@ DB 'ZEIDON MUTEX -- '
	DB	'PROC CHAIN', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@LBIA@ZEIDON?5MUTEX?5?9?9?5PROC?5CHAIN?5WRITE@
_DATA	SEGMENT
??_C@_0CB@LBIA@ZEIDON?5MUTEX?5?9?9?5PROC?5CHAIN?5WRITE@ DB 'ZEIDON MUTEX '
	DB	'-- PROC CHAIN WRITE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@FOCN@ZEIDON?5MUTEX?5?9?9?5NETWORK?5CHAIN?$AA@
_DATA	SEGMENT
??_C@_0BO@FOCN@ZEIDON?5MUTEX?5?9?9?5NETWORK?5CHAIN?$AA@ DB 'ZEIDON MUTEX '
	DB	'-- NETWORK CHAIN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08LNAM@1?40a2?5?5?5?$AA@
_DATA	SEGMENT
??_C@_08LNAM@1?40a2?5?5?5?$AA@ DB '1.0a2   ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08BHMH@1?40b0?5?5?5?$AA@
_DATA	SEGMENT
??_C@_08BHMH@1?40b0?5?5?5?$AA@ DB '1.0b0   ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IOGD@?1SHAREMEM?1KZOENGAA?4SEG?$AA@
_DATA	SEGMENT
??_C@_0BH@IOGD@?1SHAREMEM?1KZOENGAA?4SEG?$AA@ DB '/SHAREMEM/KZOENGAA.SEG', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@FLGE@kzoengwa?4exe?$AA@
_DATA	SEGMENT
??_C@_0N@FLGE@kzoengwa?4exe?$AA@ DB 'kzoengwa.exe', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@OAJM@kzoengaa?4dll?$AA@
_DATA	SEGMENT
??_C@_0N@OAJM@kzoengaa?4dll?$AA@ DB 'kzoengaa.dll', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NPBE@?4xod?$AA@
_DATA	SEGMENT
??_C@_04NPBE@?4xod?$AA@ DB '.xod', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EJNG@?4dll?$AA@
_DATA	SEGMENT
??_C@_04EJNG@?4dll?$AA@ DB '.dll', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06HLLH@ZEIDON?$AA@
_DATA	SEGMENT
??_C@_06HLLH@ZEIDON?$AA@ DB 'ZEIDON', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@JLJG@zeidon?4app?$AA@
_DATA	SEGMENT
??_C@_0L@JLJG@zeidon?4app?$AA@ DB 'zeidon.app', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@LFFP@zeidon?4xdm?$AA@
_DATA	SEGMENT
??_C@_0L@LFFP@zeidon?4xdm?$AA@ DB 'zeidon.xdm', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@DNNP@kzomdmoi?4xdm?$AA@
_DATA	SEGMENT
??_C@_0N@DNNP@kzomdmoi?4xdm?$AA@ DB 'kzomdmoi.xdm', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08JIIE@KZMSGQOO?$AA@
_DATA	SEGMENT
??_C@_08JIIE@KZMSGQOO?$AA@ DB 'KZMSGQOO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FPMG@z?$AA@
_DATA	SEGMENT
??_C@_01FPMG@z?$AA@ DB 'z', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_06BADI@Zeidon?$AA@
_DATA	SEGMENT
??_C@_06BADI@Zeidon?$AA@ DB 'Zeidon', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@LKKI@APPLICATION?$AA@
_DATA	SEGMENT
??_C@_0M@LKKI@APPLICATION?$AA@ DB 'APPLICATION', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PIJH@OBJECT?$AA@
_DATA	SEGMENT
??_C@_06PIJH@OBJECT?$AA@ DB 'OBJECT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06NIFE@ENTITY?$AA@
_DATA	SEGMENT
??_C@_06NIFE@ENTITY?$AA@ DB 'ENTITY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@PNOD@CHILDENTITY?$AA@
_DATA	SEGMENT
??_C@_0M@PNOD@CHILDENTITY?$AA@ DB 'CHILDENTITY', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06BLIJ@ATTRIB?$AA@
_DATA	SEGMENT
??_C@_06BLIJ@ATTRIB?$AA@ DB 'ATTRIB', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06EIOP@DOMAIN?$AA@
_DATA	SEGMENT
??_C@_06EIOP@DOMAIN?$AA@ DB 'DOMAIN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05NMBE@MODEL?$AA@
_DATA	SEGMENT
??_C@_05NMBE@MODEL?$AA@ DB 'MODEL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07OLKB@CONTEXT?$AA@
_DATA	SEGMENT
??_C@_07OLKB@CONTEXT?$AA@ DB 'CONTEXT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@NJID@NLS_TABLEENTRY?$AA@
_DATA	SEGMENT
??_C@_0P@NJID@NLS_TABLEENTRY?$AA@ DB 'NLS_TABLEENTRY', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@EDPP@TABLEENTRY?$AA@
_DATA	SEGMENT
??_C@_0L@EDPP@TABLEENTRY?$AA@ DB 'TABLEENTRY', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@JION@REGULAREXPRESSION?$AA@
_DATA	SEGMENT
??_C@_0BC@JION@REGULAREXPRESSION?$AA@ DB 'REGULAREXPRESSION', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DLBH@ZEIDON_BIN?$AA@
_DATA	SEGMENT
??_C@_0L@DLBH@ZEIDON_BIN?$AA@ DB 'ZEIDON_BIN', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@NPMB@ZEIDON_SYS?$AA@
_DATA	SEGMENT
??_C@_0L@NPMB@ZEIDON_SYS?$AA@ DB 'ZEIDON_SYS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GEFJ@ZEIDON_LOC?$AA@
_DATA	SEGMENT
??_C@_0L@GEFJ@ZEIDON_LOC?$AA@ DB 'ZEIDON_LOC', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@JFF@ZEIDON_SHR?$AA@
_DATA	SEGMENT
??_C@_0L@JFF@ZEIDON_SHR?$AA@ DB 'ZEIDON_SHR', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08NHNM@APP_NAME?$AA@
_DATA	SEGMENT
??_C@_08NHNM@APP_NAME?$AA@ DB 'APP_NAME', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@HKIJ@APP_DFLT_WDOD?$AA@
_DATA	SEGMENT
??_C@_0O@HKIJ@APP_DFLT_WDOD?$AA@ DB 'APP_DFLT_WDOD', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_07LAPC@APP_DLL?$AA@
_DATA	SEGMENT
??_C@_07LAPC@APP_DLL?$AA@ DB 'APP_DLL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GHPH@APP_ADOBIN?$AA@
_DATA	SEGMENT
??_C@_0L@GHPH@APP_ADOBIN?$AA@ DB 'APP_ADOBIN', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09HKKN@APP_LOCAL?$AA@
_DATA	SEGMENT
??_C@_09HKKN@APP_LOCAL?$AA@ DB 'APP_LOCAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@KNHE@APP_SHARED?$AA@
_DATA	SEGMENT
??_C@_0L@KNHE@APP_SHARED?$AA@ DB 'APP_SHARED', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09BKCL@APP_QLPLR?$AA@
_DATA	SEGMENT
??_C@_09BKCL@APP_QLPLR?$AA@ DB 'APP_QLPLR', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09MKDP@APP_QXODS?$AA@
_DATA	SEGMENT
??_C@_09MKDP@APP_QXODS?$AA@ DB 'APP_QXODS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@NAIP@APP_SOURCE?$AA@
_DATA	SEGMENT
??_C@_0L@NAIP@APP_SOURCE?$AA@ DB 'APP_SOURCE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FEIL@APDM_TOK?$AA@
_DATA	SEGMENT
??_C@_08FEIL@APDM_TOK?$AA@ DB 'APDM_TOK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@HAFL@ATTRIBUTETYPE?$AA@
_DATA	SEGMENT
??_C@_0O@HAFL@ATTRIBUTETYPE?$AA@ DB 'ATTRIBUTETYPE', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CGIJ@ATTRIBUTEDECIMAL?$AA@
_DATA	SEGMENT
??_C@_0BB@CGIJ@ATTRIBUTEDECIMAL?$AA@ DB 'ATTRIBUTEDECIMAL', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@CCEG@AUTOCREATE?$AA@
_DATA	SEGMENT
??_C@_0L@CCEG@AUTOCREATE?$AA@ DB 'AUTOCREATE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GGKI@AUTOLOADFROMPARENT?$AA@
_DATA	SEGMENT
??_C@_0BD@GGKI@AUTOLOADFROMPARENT?$AA@ DB 'AUTOLOADFROMPARENT', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FEIG@AUTO_SEQ?$AA@
_DATA	SEGMENT
??_C@_08FEIG@AUTO_SEQ?$AA@ DB 'AUTO_SEQ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@CDIB@XVAATT_TOK?$AA@
_DATA	SEGMENT
??_C@_0L@CDIB@XVAATT_TOK?$AA@ DB 'XVAATT_TOK', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07EKKN@CARDMAX?$AA@
_DATA	SEGMENT
??_C@_07EKKN@CARDMAX?$AA@ DB 'CARDMAX', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07KJPL@CARDMIN?$AA@
_DATA	SEGMENT
??_C@_07KJPL@CARDMIN?$AA@ DB 'CARDMIN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08JHJH@CASESENS?$AA@
_DATA	SEGMENT
??_C@_08JHJH@CASESENS?$AA@ DB 'CASESENS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DICE@CONTEXTRESTRICTION?$AA@
_DATA	SEGMENT
??_C@_0BD@DICE@CONTEXTRESTRICTION?$AA@ DB 'CONTEXTRESTRICTION', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JBCM@CREATE?$AA@
_DATA	SEGMENT
??_C@_06JBCM@CREATE?$AA@ DB 'CREATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07IMJA@CR_DATE?$AA@
_DATA	SEGMENT
??_C@_07IMJA@CR_DATE?$AA@ DB 'CR_DATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JEIA@DATAFIELD?$AA@
_DATA	SEGMENT
??_C@_09JEIA@DATAFIELD?$AA@ DB 'DATAFIELD', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@PPLE@DATARECORD?$AA@
_DATA	SEGMENT
??_C@_0L@PPLE@DATARECORD?$AA@ DB 'DATARECORD', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08PKJA@DATATYPE?$AA@
_DATA	SEGMENT
??_C@_08PKJA@DATATYPE?$AA@ DB 'DATATYPE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PHCI@DBNAME?$AA@
_DATA	SEGMENT
??_C@_06PHCI@DBNAME?$AA@ DB 'DBNAME', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07OOBD@DECIMAL?$AA@
_DATA	SEGMENT
??_C@_07OOBD@DECIMAL?$AA@ DB 'DECIMAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@GDML@DECIMALFORMAT?$AA@
_DATA	SEGMENT
??_C@_0O@GDML@DECIMALFORMAT?$AA@ DB 'DECIMALFORMAT', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_06FMHL@DELETE?$AA@
_DATA	SEGMENT
??_C@_06FMHL@DELETE?$AA@ DB 'DELETE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FJF@DERIVED?$AA@
_DATA	SEGMENT
??_C@_07FJF@DERIVED?$AA@ DB 'DERIVED', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08EALH@DERIVEDF?$AA@
_DATA	SEGMENT
??_C@_08EALH@DERIVEDF?$AA@ DB 'DERIVEDF', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@HPIJ@DFT_DBNAME?$AA@
_DATA	SEGMENT
??_C@_0L@HPIJ@DFT_DBNAME?$AA@ DB 'DFT_DBNAME', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@JBCC@DFT_SERVER?$AA@
_DATA	SEGMENT
??_C@_0L@JBCC@DFT_SERVER?$AA@ DB 'DFT_SERVER', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DJGK@DLL_NAME?$AA@
_DATA	SEGMENT
??_C@_08DJGK@DLL_NAME?$AA@ DB 'DLL_NAME', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@KGBA@DOMAINTYPE?$AA@
_DATA	SEGMENT
??_C@_0L@KGBA@DOMAINTYPE?$AA@ DB 'DOMAINTYPE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08KCDD@DUPENTIN?$AA@
_DATA	SEGMENT
??_C@_08KCDD@DUPENTIN?$AA@ DB 'DUPENTIN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DECF@DUPRELIN?$AA@
_DATA	SEGMENT
??_C@_08DECF@DUPRELIN?$AA@ DB 'DUPRELIN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05OAI@ECACC?$AA@
_DATA	SEGMENT
??_C@_05OAI@ECACC?$AA@ DB 'ECACC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05NDAD@ECCAN?$AA@
_DATA	SEGMENT
??_C@_05NDAD@ECCAN?$AA@ DB 'ECCAN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04FPMK@ECCR?$AA@
_DATA	SEGMENT
??_C@_04FPMK@ECCR?$AA@ DB 'ECCR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05GCOG@ECDEL?$AA@
_DATA	SEGMENT
??_C@_05GCOG@ECDEL?$AA@ DB 'ECDEL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FBPG@ECEOPER?$AA@
_DATA	SEGMENT
??_C@_07FBPG@ECEOPER?$AA@ DB 'ECEOPER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KCFA@ECEXC?$AA@
_DATA	SEGMENT
??_C@_05KCFA@ECEXC?$AA@ DB 'ECEXC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05GHOJ@ECINC?$AA@
_DATA	SEGMENT
??_C@_05GHOJ@ECINC?$AA@ DB 'ECINC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@LMLE@EDITSTRING?$AA@
_DATA	SEGMENT
??_C@_0L@LMLE@EDITSTRING?$AA@ DB 'EDITSTRING', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GJOF@ERATT_TOK?$AA@
_DATA	SEGMENT
??_C@_09GJOF@ERATT_TOK?$AA@ DB 'ERATT_TOK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@LOJF@EntityName?$AA@
_DATA	SEGMENT
??_C@_0L@LOJF@EntityName?$AA@ DB 'EntityName', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@EIGE@EntitySpec?$AA@
_DATA	SEGMENT
??_C@_0L@EIGE@EntitySpec?$AA@ DB 'EntitySpec', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09PPA@ERENT_TOK?$AA@
_DATA	SEGMENT
??_C@_09PPA@ERENT_TOK?$AA@ DB 'ERENT_TOK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GJDI@ERREL_LINK?$AA@
_DATA	SEGMENT
??_C@_0L@GJDI@ERREL_LINK?$AA@ DB 'ERREL_LINK', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09DPNM@ERREL_TOK?$AA@
_DATA	SEGMENT
??_C@_09DPNM@ERREL_TOK?$AA@ DB 'ERREL_TOK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07EHEP@EXCLUDE?$AA@
_DATA	SEGMENT
??_C@_07EHEP@EXCLUDE?$AA@ DB 'EXCLUDE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@HLIE@EXTERNALVALUE?$AA@
_DATA	SEGMENT
??_C@_0O@HLIE@EXTERNALVALUE?$AA@ DB 'EXTERNALVALUE', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_05OJOB@FLDID?$AA@
_DATA	SEGMENT
??_C@_05OJOB@FLDID?$AA@ DB 'FLDID', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06GKHE@FLDLTH?$AA@
_DATA	SEGMENT
??_C@_06GKHE@FLDLTH?$AA@ DB 'FLDLTH', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07NIOD@FLDNAME?$AA@
_DATA	SEGMENT
??_C@_07NIOD@FLDNAME?$AA@ DB 'FLDNAME', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09BHNG@FLDOFFSET?$AA@
_DATA	SEGMENT
??_C@_09BHNG@FLDOFFSET?$AA@ DB 'FLDOFFSET', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07MPNE@FLDTYPE?$AA@
_DATA	SEGMENT
??_C@_07MPNE@FLDTYPE?$AA@ DB 'FLDTYPE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@FLLI@FULLPERSIST?$AA@
_DATA	SEGMENT
??_C@_0M@FLLI@FULLPERSIST?$AA@ DB 'FULLPERSIST', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PPGK@GENKEY?$AA@
_DATA	SEGMENT
??_C@_06PPGK@GENKEY?$AA@ DB 'GENKEY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09IICP@GKHANDLER?$AA@
_DATA	SEGMENT
??_C@_09IICP@GKHANDLER?$AA@ DB 'GKHANDLER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07MHHO@HANDLER?$AA@
_DATA	SEGMENT
??_C@_07MHHO@HANDLER?$AA@ DB 'HANDLER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IJMB@HIDDEN?$AA@
_DATA	SEGMENT
??_C@_06IJMB@HIDDEN?$AA@ DB 'HIDDEN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02FECH@Id?$AA@
_DATA	SEGMENT
??_C@_02FECH@Id?$AA@ DB 'Id', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07KACF@INCLSRC?$AA@
_DATA	SEGMENT
??_C@_07KACF@INCLSRC?$AA@ DB 'INCLSRC', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07KOHG@INCLUDE?$AA@
_DATA	SEGMENT
??_C@_07KOHG@INCLUDE?$AA@ DB 'INCLUDE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FKFF@INCRLOAD?$AA@
_DATA	SEGMENT
??_C@_08FKFF@INCRLOAD?$AA@ DB 'INCRLOAD', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NJI@INIT?$AA@
_DATA	SEGMENT
??_C@_04NJI@INIT?$AA@ DB 'INIT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@HIL@INTERNALVALUE?$AA@
_DATA	SEGMENT
??_C@_0O@HIL@INTERNALVALUE?$AA@ DB 'INTERNALVALUE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09ECEN@ISDEFAULT?$AA@
_DATA	SEGMENT
??_C@_09ECEN@ISDEFAULT?$AA@ DB 'ISDEFAULT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03PHBO@KEY?$AA@
_DATA	SEGMENT
??_C@_03PHBO@KEY?$AA@ DB 'KEY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@IHAG@LanguageIndex?$AA@
_DATA	SEGMENT
??_C@_0O@IHAG@LanguageIndex?$AA@ DB 'LanguageIndex', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_05IFE@LNAME?$AA@
_DATA	SEGMENT
??_C@_05IFE@LNAME?$AA@ DB 'LNAME', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NPLI@LOCK?$AA@
_DATA	SEGMENT
??_C@_04NPLI@LOCK?$AA@ DB 'LOCK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03DGJL@LTH?$AA@
_DATA	SEGMENT
??_C@_03DGJL@LTH?$AA@ DB 'LTH', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@LMHL@MAXSTRINGLTH?$AA@
_DATA	SEGMENT
??_C@_0N@LMHL@MAXSTRINGLTH?$AA@ DB 'MAXSTRINGLTH', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DHHO@MR_LIMIT?$AA@
_DATA	SEGMENT
??_C@_08DHHO@MR_LIMIT?$AA@ DB 'MR_LIMIT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06OMJI@__MSGQ?$AA@
_DATA	SEGMENT
??_C@_06OMJI@__MSGQ?$AA@ DB '__MSGQ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04IALP@NAME?$AA@
_DATA	SEGMENT
??_C@_04IALP@NAME?$AA@ DB 'NAME', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@GNJA@NETCOMPRESS?$AA@
_DATA	SEGMENT
??_C@_0M@GNJA@NETCOMPRESS?$AA@ DB 'NETCOMPRESS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07KFPJ@NETWORK?$AA@
_DATA	SEGMENT
??_C@_07KFPJ@NETWORK?$AA@ DB 'NETWORK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07GOHG@NumAtts?$AA@
_DATA	SEGMENT
??_C@_07GOHG@NumAtts?$AA@ DB 'NumAtts', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07OOMM@NumEnts?$AA@
_DATA	SEGMENT
??_C@_07OOMM@NumEnts?$AA@ DB 'NumEnts', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07PICA@NumRels?$AA@
_DATA	SEGMENT
??_C@_07PICA@NumRels?$AA@ DB 'NumRels', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05LDPN@OCACT?$AA@
_DATA	SEGMENT
??_C@_05LDPN@OCACT?$AA@ DB 'OCACT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PJLI@OCACTE?$AA@
_DATA	SEGMENT
??_C@_06PJLI@OCACTE?$AA@ DB 'OCACTE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KPHB@OCCOM?$AA@
_DATA	SEGMENT
??_C@_05KPHB@OCCOM?$AA@ DB 'OCCOM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06HHGH@OCDROP?$AA@
_DATA	SEGMENT
??_C@_06HHGH@OCDROP?$AA@ DB 'OCDROP', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HIHA@OCEOPER?$AA@
_DATA	SEGMENT
??_C@_07HIHA@OCEOPER?$AA@ DB 'OCEOPER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07NHGG@OFRECID?$AA@
_DATA	SEGMENT
??_C@_07NHGG@OFRECID?$AA@ DB 'OFRECID', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07GKEM@OFBUFSZ?$AA@
_DATA	SEGMENT
??_C@_07GKEM@OFBUFSZ?$AA@ DB 'OFBUFSZ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@PJJC@OPER_LIBNM?$AA@
_DATA	SEGMENT
??_C@_0L@PJJC@OPER_LIBNM?$AA@ DB 'OPER_LIBNM', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04FKDH@Oper?$AA@
_DATA	SEGMENT
??_C@_04FKDH@Oper?$AA@ DB 'Oper', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@JCEP@OWNER_MEMB?$AA@
_DATA	SEGMENT
??_C@_0L@JCEP@OWNER_MEMB?$AA@ DB 'OWNER_MEMB', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07BAEJ@PDELETE?$AA@
_DATA	SEGMENT
??_C@_07BAEJ@PDELETE?$AA@ DB 'PDELETE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07NIBE@PERSIST?$AA@
_DATA	SEGMENT
??_C@_07NIBE@PERSIST?$AA@ DB 'PERSIST', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05ILLO@PNAME?$AA@
_DATA	SEGMENT
??_C@_05ILLO@PNAME?$AA@ DB 'PNAME', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DIOI@QualAttrib?$AA@
_DATA	SEGMENT
??_C@_0L@DIOI@QualAttrib?$AA@ DB 'QualAttrib', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05NKIC@RECID?$AA@
_DATA	SEGMENT
??_C@_05NKIC@RECID?$AA@ DB 'RECID', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07NDLE@RECNAME?$AA@
_DATA	SEGMENT
??_C@_07NDLE@RECNAME?$AA@ DB 'RECNAME', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GDN@RECURSIVE?$AA@
_DATA	SEGMENT
??_C@_09GDN@RECURSIVE?$AA@ DB 'RECURSIVE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03LNGM@REL?$AA@
_DATA	SEGMENT
??_C@_03LNGM@REL?$AA@ DB 'REL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08PMNP@RELFIELD?$AA@
_DATA	SEGMENT
??_C@_08PMNP@RELFIELD?$AA@ DB 'RELFIELD', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09HINM@RELRECORD?$AA@
_DATA	SEGMENT
??_C@_09HINM@RELRECORD?$AA@ DB 'RELRECORD', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@DBKM@RELXVAATT_TOK?$AA@
_DATA	SEGMENT
??_C@_0O@DBKM@RELXVAATT_TOK?$AA@ DB 'RELXVAATT_TOK', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08BGDD@REQUIRED?$AA@
_DATA	SEGMENT
??_C@_08BGDD@REQUIRED?$AA@ DB 'REQUIRED', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GCMK@RESTRICTED?$AA@
_DATA	SEGMENT
??_C@_0L@GCMK@RESTRICTED?$AA@ DB 'RESTRICTED', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06BJID@SERVER?$AA@
_DATA	SEGMENT
??_C@_06BJID@SERVER?$AA@ DB 'SERVER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@FLNJ@SEQUENCING?$AA@
_DATA	SEGMENT
??_C@_0L@FLNJ@SEQUENCING?$AA@ DB 'SEQUENCING', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06LIHO@SEQ_AD?$AA@
_DATA	SEGMENT
??_C@_06LIHO@SEQ_AD?$AA@ DB 'SEQ_AD', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06NHOC@SETID1?$AA@
_DATA	SEGMENT
??_C@_06NHOC@SETID1?$AA@ DB 'SETID1', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06CIFL@SETID2?$AA@
_DATA	SEGMENT
??_C@_06CIFL@SETID2?$AA@ DB 'SETID2', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FJI@SETNAME1?$AA@
_DATA	SEGMENT
??_C@_08FJI@SETNAME1?$AA@ DB 'SETNAME1', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08PKCB@SETNAME2?$AA@
_DATA	SEGMENT
??_C@_08PKCB@SETNAME2?$AA@ DB 'SETNAME2', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@HOCN@SRCXVAATT_TOK?$AA@
_DATA	SEGMENT
??_C@_0O@HOCN@SRCXVAATT_TOK?$AA@ DB 'SRCXVAATT_TOK', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HDAF@Task?$AA@
_DATA	SEGMENT
??_C@_04HDAF@Task?$AA@ DB 'Task', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BNNJ@Text?$AA@
_DATA	SEGMENT
??_C@_04BNNJ@Text?$AA@ DB 'Text', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04JHII@TYPE?$AA@
_DATA	SEGMENT
??_C@_04JHII@TYPE?$AA@ DB 'TYPE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07KJPH@UP_DATE?$AA@
_DATA	SEGMENT
??_C@_07KJPH@UP_DATE?$AA@ DB 'UP_DATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PIPA@USERID?$AA@
_DATA	SEGMENT
??_C@_06PIPA@USERID?$AA@ DB 'USERID', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06NDPG@UPDATE?$AA@
_DATA	SEGMENT
??_C@_06NDPG@UPDATE?$AA@ DB 'UPDATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04JGIO@ZKEY?$AA@
_DATA	SEGMENT
??_C@_04JGIO@ZKEY?$AA@ DB 'ZKEY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CK@BELJ@Object?5Services?5?9?5Application?5Lo@
_DATA	SEGMENT
??_C@_0CK@BELJ@Object?5Services?5?9?5Application?5Lo@ DB 'Object Services'
	DB	' - Application Logic Error', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@FMPG@Data?5Validation?5Error?$AA@
_DATA	SEGMENT
??_C@_0BG@FMPG@Data?5Validation?5Error?$AA@ DB 'Data Validation Error', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@ODOC@OE?5System?5Error?$AA@
_DATA	SEGMENT
??_C@_0BA@ODOC@OE?5System?5Error?$AA@ DB 'OE System Error', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_05HBLJ@AFTER?$AA@
_DATA	SEGMENT
??_C@_05HBLJ@AFTER?$AA@ DB 'AFTER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06COI@BEFORE?$AA@
_DATA	SEGMENT
??_C@_06COI@BEFORE?$AA@ DB 'BEFORE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@BAHL@MQ_MessageSend?$AA@
_DATA	SEGMENT
??_C@_0P@BAHL@MQ_MessageSend?$AA@ DB 'MQ_MessageSend', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MBCE@MQ_MessagePrompt?$AA@
_DATA	SEGMENT
??_C@_0BB@MBCE@MQ_MessagePrompt?$AA@ DB 'MQ_MessagePrompt', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@MAFE@MQ_MessagePromptForInput?$AA@
_DATA	SEGMENT
??_C@_0BJ@MAFE@MQ_MessagePromptForInput?$AA@ DB 'MQ_MessagePromptForInput'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@GMHO@MQ_MessagePresent?$AA@
_DATA	SEGMENT
??_C@_0BC@GMHO@MQ_MessagePresent?$AA@ DB 'MQ_MessagePresent', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_07BPKJ@January?$AA@
_DATA	SEGMENT
??_C@_07BPKJ@January?$AA@ DB 'January', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08PGBA@February?$AA@
_DATA	SEGMENT
??_C@_08PGBA@February?$AA@ DB 'February', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05FGPD@March?$AA@
_DATA	SEGMENT
??_C@_05FGPD@March?$AA@ DB 'March', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JFGC@April?$AA@
_DATA	SEGMENT
??_C@_05JFGC@April?$AA@ DB 'April', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03MGHB@May?$AA@
_DATA	SEGMENT
??_C@_03MGHB@May?$AA@ DB 'May', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04ICFP@June?$AA@
_DATA	SEGMENT
??_C@_04ICFP@June?$AA@ DB 'June', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PIJO@July?$AA@
_DATA	SEGMENT
??_C@_04PIJO@July?$AA@ DB 'July', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PADP@August?$AA@
_DATA	SEGMENT
??_C@_06PADP@August?$AA@ DB 'August', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09MKGD@September?$AA@
_DATA	SEGMENT
??_C@_09MKGD@September?$AA@ DB 'September', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07IAMM@October?$AA@
_DATA	SEGMENT
??_C@_07IAMM@October?$AA@ DB 'October', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08NJLI@November?$AA@
_DATA	SEGMENT
??_C@_08NJLI@November?$AA@ DB 'November', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08LIDF@December?$AA@
_DATA	SEGMENT
??_C@_08LIDF@December?$AA@ DB 'December', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06OOEM@Sunday?$AA@
_DATA	SEGMENT
??_C@_06OOEM@Sunday?$AA@ DB 'Sunday', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06CHLK@Monday?$AA@
_DATA	SEGMENT
??_C@_06CHLK@Monday?$AA@ DB 'Monday', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07BMBC@Tuesday?$AA@
_DATA	SEGMENT
??_C@_07BMBC@Tuesday?$AA@ DB 'Tuesday', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09PBIN@Wednesday?$AA@
_DATA	SEGMENT
??_C@_09PBIN@Wednesday?$AA@ DB 'Wednesday', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08CCFO@Thursday?$AA@
_DATA	SEGMENT
??_C@_08CCFO@Thursday?$AA@ DB 'Thursday', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06ONCK@Friday?$AA@
_DATA	SEGMENT
??_C@_06ONCK@Friday?$AA@ DB 'Friday', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FAKH@Saturday?$AA@
_DATA	SEGMENT
??_C@_08FAKH@Saturday?$AA@ DB 'Saturday', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04KGMK@Intl?$AA@
_DATA	SEGMENT
??_C@_04KGMK@Intl?$AA@ DB 'Intl', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FKAM@iCountry?$AA@
_DATA	SEGMENT
??_C@_08FKAM@iCountry?$AA@ DB 'iCountry', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08JMM@sCountry?$AA@
_DATA	SEGMENT
??_C@_08JMM@sCountry?$AA@ DB 'sCountry', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09IMGC@sLanguage?$AA@
_DATA	SEGMENT
??_C@_09IMGC@sLanguage?$AA@ DB 'sLanguage', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05NLOI@sList?$AA@
_DATA	SEGMENT
??_C@_05NLOI@sList?$AA@ DB 'sList', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08HHE@iMeasure?$AA@
_DATA	SEGMENT
??_C@_08HHE@iMeasure?$AA@ DB 'iMeasure', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05EMIJ@iTime?$AA@
_DATA	SEGMENT
??_C@_05EMIJ@iTime?$AA@ DB 'iTime', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05PLM@sTime?$AA@
_DATA	SEGMENT
??_C@_05PLM@sTime?$AA@ DB 'sTime', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05PCBI@s1159?$AA@
_DATA	SEGMENT
??_C@_05PCBI@s1159?$AA@ DB 's1159', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05DJMD@s2359?$AA@
_DATA	SEGMENT
??_C@_05DJMD@s2359?$AA@ DB 's2359', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07LDFB@iTLZero?$AA@
_DATA	SEGMENT
??_C@_07LDFB@iTLZero?$AA@ DB 'iTLZero', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@NPLI@sShortDate?$AA@
_DATA	SEGMENT
??_C@_0L@NPLI@sShortDate?$AA@ DB 'sShortDate', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JENF@sLongDate?$AA@
_DATA	SEGMENT
??_C@_09JENF@sLongDate?$AA@ DB 'sLongDate', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JDHO@sCurrency?$AA@
_DATA	SEGMENT
??_C@_09JDHO@sCurrency?$AA@ DB 'sCurrency', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09CBCN@iCurrency?$AA@
_DATA	SEGMENT
??_C@_09CBCN@iCurrency?$AA@ DB 'iCurrency', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@LKGH@iCurrDigits?$AA@
_DATA	SEGMENT
??_C@_0M@LKGH@iCurrDigits?$AA@ DB 'iCurrDigits', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08LHOD@iNegCurr?$AA@
_DATA	SEGMENT
??_C@_08LHOD@iNegCurr?$AA@ DB 'iNegCurr', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09BEPN@sThousand?$AA@
_DATA	SEGMENT
??_C@_09BEPN@sThousand?$AA@ DB 'sThousand', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GFHF@sDecimal?$AA@
_DATA	SEGMENT
??_C@_08GFHF@sDecimal?$AA@ DB 'sDecimal', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FACE@iDigits?$AA@
_DATA	SEGMENT
??_C@_07FACE@iDigits?$AA@ DB 'iDigits', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06LENA@iLzero?$AA@
_DATA	SEGMENT
??_C@_06LENA@iLzero?$AA@ DB 'iLzero', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DC@KKHB@KZOEE001?5?9?5Error?5communicating?5w@
_DATA	SEGMENT
??_C@_0DC@KKHB@KZOEE001?5?9?5Error?5communicating?5w@ DB 'KZOEE001 - Erro'
	DB	'r communicating with client window', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CP@JFJD@KZOEE002?5?9?5ZEIDON?5environment?5va@
_DATA	SEGMENT
??_C@_0CP@JFJD@KZOEE002?5?9?5ZEIDON?5environment?5va@ DB 'KZOEE002 - ZEID'
	DB	'ON environment variable not set', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CK@LHJO@KZOEE003?5?9?5Error?5starting?5Object@
_DATA	SEGMENT
??_C@_0CK@LHJO@KZOEE003?5?9?5Error?5starting?5Object@ DB 'KZOEE003 - Erro'
	DB	'r starting Object Services', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DE@HPME@KZOEE004?5?9?5Error?5communicating?5w@
_DATA	SEGMENT
??_C@_0DE@HPME@KZOEE004?5?9?5Error?5communicating?5w@ DB 'KZOEE004 - Erro'
	DB	'r communicating with Object Services', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DE@HEBF@KZOEE005?5?9?5Error?5communicating?5w@
_DATA	SEGMENT
??_C@_0DE@HEBF@KZOEE005?5?9?5Error?5communicating?5w@ DB 'KZOEE005 - Erro'
	DB	'r communicating with Object Services', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CP@HIJD@KZOEE006?5?9?5Internal?5error?5freein@
_DATA	SEGMENT
??_C@_0CP@HIJD@KZOEE006?5?9?5Internal?5error?5freein@ DB 'KZOEE006 - Inte'
	DB	'rnal error freeing Anchor Block', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0ED@FDBJ@KZOEE007?5?9?5Internal?5Anchor?5block@
_DATA	SEGMENT
??_C@_0ED@FDBJ@KZOEE007?5?9?5Internal?5Anchor?5block@ DB 'KZOEE007 - Inte'
	DB	'rnal Anchor block error, system restart recommended', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EI@BCLB@KZOEE008?5?9?5Application?5definitio@
_DATA	SEGMENT
??_C@_0EI@BCLB@KZOEE008?5?9?5Application?5definitio@ DB 'KZOEE008 - Appli'
	DB	'cation definition file missing ZEIDON_BIN or ZEIDON_SYS', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DF@MKOJ@KZOEE009?5?9?5Error?5opening?5applica@
_DATA	SEGMENT
??_C@_0DF@MKOJ@KZOEE009?5?9?5Error?5opening?5applica@ DB 'KZOEE009 - Erro'
	DB	'r opening application definition file', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@MFKJ@KZOEE010?5?9?5Requested?5application@
_DATA	SEGMENT
??_C@_0CL@MFKJ@KZOEE010?5?9?5Requested?5application@ DB 'KZOEE010 - Reque'
	DB	'sted application not found', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DC@DKPD@KZOEE011?5?9?5Error?5opening?5applica@
_DATA	SEGMENT
??_C@_0DC@DKPD@KZOEE011?5?9?5Error?5opening?5applica@ DB 'KZOEE011 - Erro'
	DB	'r opening application domains file', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@KFHE@KZOEE012?5?9?5Error?5allocating?5memo@
_DATA	SEGMENT
??_C@_0CD@KFHE@KZOEE012?5?9?5Error?5allocating?5memo@ DB 'KZOEE012 - Erro'
	DB	'r allocating memory', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@MDMN@KZOEE013?5?9?5Internal?5operation?5ca@
_DATA	SEGMENT
??_C@_0CJ@MDMN@KZOEE013?5?9?5Internal?5operation?5ca@ DB 'KZOEE013 - Inte'
	DB	'rnal operation call error', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CO@LCNE@KZOEE014?5?9?5Invalid?5suballoc?5memo@
_DATA	SEGMENT
??_C@_0CO@LCNE@KZOEE014?5?9?5Invalid?5suballoc?5memo@ DB 'KZOEE014 - Inva'
	DB	'lid suballoc memory free - ID=', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@OGFD@KZOEE015?5?9?5Invalid?5suballoc?5memo@
_DATA	SEGMENT
??_C@_0CI@OGFD@KZOEE015?5?9?5Invalid?5suballoc?5memo@ DB 'KZOEE015 - Inva'
	DB	'lid suballoc memory free', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@EDAJ@KZOEE016?5?9?5Invalid?5Task?$AA@
_DATA	SEGMENT
??_C@_0BI@EDAJ@KZOEE016?5?9?5Invalid?5Task?$AA@ DB 'KZOEE016 - Invalid Ta'
	DB	'sk', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@MOGK@KZOEE017?5?9?5Task?5is?5Disabled?$AA@
_DATA	SEGMENT
??_C@_0BM@MOGK@KZOEE017?5?9?5Task?5is?5Disabled?$AA@ DB 'KZOEE017 - Task '
	DB	'is Disabled', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@DHKC@KZOEE018?5?9?5Error?5in?5Domain?5file?0@
_DATA	SEGMENT
??_C@_0CI@DHKC@KZOEE018?5?9?5Error?5in?5Domain?5file?0@ DB 'KZOEE018 - Er'
	DB	'ror in Domain file, line: ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@PAMN@KZOEE019?5?9?5Invalid?5GetTaskInfo?5r@
_DATA	SEGMENT
??_C@_0CJ@PAMN@KZOEE019?5?9?5Invalid?5GetTaskInfo?5r@ DB 'KZOEE019 - Inva'
	DB	'lid GetTaskInfo request: ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@COHN@KZOEE020?5?9?5Invalid?5Operation?5cal@
_DATA	SEGMENT
??_C@_0CD@COHN@KZOEE020?5?9?5Invalid?5Operation?5cal@ DB 'KZOEE020 - Inva'
	DB	'lid Operation call ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EJ@OFCD@KZOEE021?5?9?5Internal?5error?0?5TaskO@
_DATA	SEGMENT
??_C@_0EJ@OFCD@KZOEE021?5?9?5Internal?5error?0?5TaskO@ DB 'KZOEE021 - Int'
	DB	'ernal error, TaskOperation block has no Object/Entity/Attr', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@PFIN@KZOEE022?5?9?5Error?5writing?5file?$AA@
_DATA	SEGMENT
??_C@_0BO@PFIN@KZOEE022?5?9?5Error?5writing?5file?$AA@ DB 'KZOEE022 - Err'
	DB	'or writing file', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@ENDH@KZOEE023?5?9?5Invalid?5parameter?0?5?$AA@
_DATA	SEGMENT
??_C@_0BP@ENDH@KZOEE023?5?9?5Invalid?5parameter?0?5?$AA@ DB 'KZOEE023 - I'
	DB	'nvalid parameter, ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@LNEH@KZOEE024?5?9?5Error?5opening?5file?$AA@
_DATA	SEGMENT
??_C@_0BO@LNEH@KZOEE024?5?9?5Error?5opening?5file?$AA@ DB 'KZOEE024 - Err'
	DB	'or opening file', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@LGJG@KZOEE025?5?9?5Error?5in?5directory?5sp@
_DATA	SEGMENT
??_C@_0CM@LGJG@KZOEE025?5?9?5Error?5in?5directory?5sp@ DB 'KZOEE025 - Err'
	DB	'or in directory specification', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CE@CFOB@KZOEE026?5?9?5Error?5creating?5direct@
_DATA	SEGMENT
??_C@_0CE@CFOB@KZOEE026?5?9?5Error?5creating?5direct@ DB 'KZOEE026 - Erro'
	DB	'r creating directory', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CF@MDHP@KZOEE030?5?9?5Error?5loading?5library@
_DATA	SEGMENT
??_C@_0CF@MDHP@KZOEE030?5?9?5Error?5loading?5library@ DB 'KZOEE030 - Erro'
	DB	'r loading library rc=', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@KCKB@KZOEE031?5?9?5Error?5locating?5Operat@
_DATA	SEGMENT
??_C@_0CI@KCKB@KZOEE031?5?9?5Error?5locating?5Operat@ DB 'KZOEE031 - Erro'
	DB	'r locating Operation rc=', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@KHLN@KZOEE032?5?9?5Mutex?5name?5is?5invalid@
_DATA	SEGMENT
??_C@_0CB@KHLN@KZOEE032?5?9?5Mutex?5name?5is?5invalid@ DB 'KZOEE032 - Mut'
	DB	'ex name is invalid', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@NPAH@KZOEE050?5?9?5Error?5opening?5View?5Ob@
_DATA	SEGMENT
??_C@_0CL@NPAH@KZOEE050?5?9?5Error?5opening?5View?5Ob@ DB 'KZOEE050 - Err'
	DB	'or opening View Object file ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@EMEJ@KZOEE051?5?9?5Invalid?5View?5Object?5f@
_DATA	SEGMENT
??_C@_0CL@EMEJ@KZOEE051?5?9?5Invalid?5View?5Object?5f@ DB 'KZOEE051 - Inv'
	DB	'alid View Object file header', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EG@KBNM@KZOEE052?5?9?5Invalid?5Object?5file?0?5@
_DATA	SEGMENT
??_C@_0EG@KBNM@KZOEE052?5?9?5Invalid?5Object?5file?0?5@ DB 'KZOEE052 - In'
	DB	'valid Object file, Attrib w/o lth in defin prev to line ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CP@CJAD@KZOEE053?5?9?5Invalid?5Entity?5level?5@
_DATA	SEGMENT
??_C@_0CP@CJAD@KZOEE053?5?9?5Invalid?5Entity?5level?5@ DB 'KZOEE053 - Inv'
	DB	'alid Entity level found on line ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@OIAJ@KZOEE054?5?9?5Invalid?5record?5found?5@
_DATA	SEGMENT
??_C@_0CJ@OIAJ@KZOEE054?5?9?5Invalid?5record?5found?5@ DB 'KZOEE054 - Inv'
	DB	'alid record found on line ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DM@CCJK@KZOEE055?5?9?5Invalid?5file?0?5LTH?5or?5@
_DATA	SEGMENT
??_C@_0DM@CCJK@KZOEE055?5?9?5Invalid?5file?0?5LTH?5or?5@ DB 'KZOEE055 - I'
	DB	'nvalid file, LTH or TYPE before DOMAIN on line ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CF@JDKN@KZOEE056?5?9?5Domain?5not?5found?5on?5l@
_DATA	SEGMENT
??_C@_0CF@JDKN@KZOEE056?5?9?5Domain?5not?5found?5on?5l@ DB 'KZOEE056 - Do'
	DB	'main not found on line ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DN@EDAD@KZOEE057?5?9?5Invalid?5file?0?5LTH?5bef@
_DATA	SEGMENT
??_C@_0DN@EDAD@KZOEE057?5?9?5Invalid?5file?0?5LTH?5bef@ DB 'KZOEE057 - In'
	DB	'valid file, LTH before type and DOMAIN on line ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EE@OCOD@KZOEE058?5?9?5Invalid?5file?0?5PERSIST@
_DATA	SEGMENT
??_C@_0EE@OCOD@KZOEE058?5?9?5Invalid?5file?0?5PERSIST@ DB 'KZOEE058 - Inv'
	DB	'alid file, PERSIST after DOMAIN, TYPE or LTH on line ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EC@PMPM@KZOEE059?5?9?5Invalid?5file?0?5Invalid@
_DATA	SEGMENT
??_C@_0EC@PMPM@KZOEE059?5?9?5Invalid?5file?0?5Invalid@ DB 'KZOEE059 - Inv'
	DB	'alid file, Invalid Attribute Token located on line ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@PNHL@KZOEE060?5?9?5Invalid?5maximum?5root?5@
_DATA	SEGMENT
??_C@_0CL@PNHL@KZOEE060?5?9?5Invalid?5maximum?5root?5@ DB 'KZOEE060 - Inv'
	DB	'alid maximum root qualifier ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DD@IPCF@KZOEE061?5?9?5Persistent?5Attribute?5@
_DATA	SEGMENT
??_C@_0DD@IPCF@KZOEE061?5?9?5Persistent?5Attribute?5@ DB 'KZOEE061 - Pers'
	DB	'istent Attribute mismatch on Token ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EH@FCEJ@KZOEE062?5?9?5Conflict?5between?5E?1R?5@
_DATA	SEGMENT
??_C@_0EH@FCEJ@KZOEE062?5?9?5Conflict?5between?5E?1R?5@ DB 'KZOEE062 - Co'
	DB	'nflict between E/R Attribute Type and TE Field Type for: ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EG@PGNO@KZOEE063?5?9?5Entity?5attrib?5RECURSI@
_DATA	SEGMENT
??_C@_0EG@PGNO@KZOEE063?5?9?5Entity?5attrib?5RECURSI@ DB 'KZOEE063 - Enti'
	DB	'ty attrib RECURSIVE Y, but not structurally recursive ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@DBKC@KZOEE064?5?9?5TYPE?5obsolete?0?5use?5AP@
_DATA	SEGMENT
??_C@_0CI@DBKC@KZOEE064?5?9?5TYPE?5obsolete?0?5use?5AP@ DB 'KZOEE064 - TY'
	DB	'PE obsolete, use APDM_TOK ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DM@HNKG@KZOEE065?5?9?5LTH?5only?5valid?5for?5At@
_DATA	SEGMENT
??_C@_0DM@HNKG@KZOEE065?5?9?5LTH?5only?5valid?5for?5At@ DB 'KZOEE065 - LT'
	DB	'H only valid for Attribute w/type string line ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@DFAB@KZOEE066?5?9?5Attribute?5length?5zero@
_DATA	SEGMENT
??_C@_0CC@DFAB@KZOEE066?5?9?5Attribute?5length?5zero@ DB 'KZOEE066 - Attr'
	DB	'ibute length zero ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DH@DFDK@KZOEE067?5?9?5Could?5not?5initialize?5@
_DATA	SEGMENT
??_C@_0DH@DFDK@KZOEE067?5?9?5Could?5not?5initialize?5@ DB 'KZOEE067 - Cou'
	DB	'ld not initialize the Core-MQ interface ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CE@GHFO@KZOEE070?5?9?5Object?5instance?5is?5em@
_DATA	SEGMENT
??_C@_0CE@GHFO@KZOEE070?5?9?5Object?5instance?5is?5em@ DB 'KZOEE070 - Obj'
	DB	'ect instance is empty', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@HPIK@KZOEE071?5?9?5Error?5opening?5instanc@
_DATA	SEGMENT
??_C@_0CI@HPIK@KZOEE071?5?9?5Error?5opening?5instanc@ DB 'KZOEE071 - Erro'
	DB	'r opening instance file ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@EEEO@KZOEE072?5?9?5Error?5reading?5instanc@
_DATA	SEGMENT
??_C@_0CI@EEEO@KZOEE072?5?9?5Error?5reading?5instanc@ DB 'KZOEE072 - Erro'
	DB	'r reading instance file ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@GPMH@KZOEE073?5?9?5Invalid?5instance?5file@
_DATA	SEGMENT
??_C@_0CI@GPMH@KZOEE073?5?9?5Invalid?5instance?5file@ DB 'KZOEE073 - Inva'
	DB	'lid instance file header', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@NBOH@KZOEE074?5?9?5Invalid?5Entity?5name?5o@
_DATA	SEGMENT
??_C@_0CI@NBOH@KZOEE074?5?9?5Invalid?5Entity?5name?5o@ DB 'KZOEE074 - Inv'
	DB	'alid Entity name on line ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@FMPI@KZOEE075?5?9?5Invalid?5Entity?5level?5@
_DATA	SEGMENT
??_C@_0CJ@FMPI@KZOEE075?5?9?5Invalid?5Entity?5level?5@ DB 'KZOEE075 - Inv'
	DB	'alid Entity level on line ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DP@HHHP@KZOEE076?5?9?5Object?5instance?5conta@
_DATA	SEGMENT
??_C@_0DP@HHHP@KZOEE076?5?9?5Object?5instance?5conta@ DB 'KZOEE076 - Obje'
	DB	'ct instance contains versioned entity instances', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@EOHG@KZOEE077?5?9?5Invalid?5record?5size?5i@
_DATA	SEGMENT
??_C@_0DJ@EOHG@KZOEE077?5?9?5Invalid?5record?5size?5i@ DB 'KZOEE077 - Inv'
	DB	'alid record size in binary object instance', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EA@PIKP@KZOEE078?5?9?5Internal?5error?0?5linke@
_DATA	SEGMENT
??_C@_0EA@PIKP@KZOEE078?5?9?5Internal?5error?0?5linke@ DB 'KZOEE078 - Int'
	DB	'ernal error, linked instance has no visible owner', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CN@GDKG@KZOEE079?5?9?5Trying?5to?5commit?5a?5re@
_DATA	SEGMENT
??_C@_0CN@GDKG@KZOEE079?5?9?5Trying?5to?5commit?5a?5re@ DB 'KZOEE079 - Tr'
	DB	'ying to commit a read-only view', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EI@ENAN@KZOEE080?5?9?5Object?5Definition?5doe@
_DATA	SEGMENT
??_C@_0EI@ENAN@KZOEE080?5?9?5Object?5Definition?5doe@ DB 'KZOEE080 - Obje'
	DB	'ct Definition does not have a Database handler specified', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EG@IICI@KZOEE081?5?9?5Object?5Definition?5doe@
_DATA	SEGMENT
??_C@_0EG@IICI@KZOEE081?5?9?5Object?5Definition?5doe@ DB 'KZOEE081 - Obje'
	DB	'ct Definition does not have a Genkey handler specified', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@BEFH@KZOEE082?5?9?5Error?5starting?5Genkey@
_DATA	SEGMENT
??_C@_0CJ@BEFH@KZOEE082?5?9?5Error?5starting?5Genkey@ DB 'KZOEE082 - Erro'
	DB	'r starting Genkey handler', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0IJ@LNPL@KZOEE083?5?9?5LOD?5does?5not?5have?5phy@
_DATA	SEGMENT
??_C@_0IJ@LNPL@KZOEE083?5?9?5LOD?5does?5not?5have?5phy@ DB 'KZOEE083 - LO'
	DB	'D does not have physical information.  Possibly the LOD was s'
	DB	'aved without DB information or the entities are work entities'
	DB	'.', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EB@HECI@KZOEE084?5?9?5Entity?5in?5Object?5Defi@
_DATA	SEGMENT
??_C@_0EB@HECI@KZOEE084?5?9?5Entity?5in?5Object?5Defi@ DB 'KZOEE084 - Ent'
	DB	'ity in Object Definition does not have Data Fields', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EK@GEM@KZOEE085?5?9?5Entity?5in?5Object?5Defi@
_DATA	SEGMENT
??_C@_0EK@GEM@KZOEE085?5?9?5Entity?5in?5Object?5Defi@ DB 'KZOEE085 - Enti'
	DB	'ty in Object Definition does not have Relationship Records', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CE@ELED@KZOEE086?5?9?5Trying?5to?5commit?50?5vi@
_DATA	SEGMENT
??_C@_0CE@ELED@KZOEE086?5?9?5Trying?5to?5commit?50?5vi@ DB 'KZOEE086 - Tr'
	DB	'ying to commit 0 views', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@MFDJ@KZOEE087?5?9?5Too?5many?5views?5in?5Vie@
_DATA	SEGMENT
??_C@_0CI@MFDJ@KZOEE087?5?9?5Too?5many?5views?5in?5Vie@ DB 'KZOEE087 - To'
	DB	'o many views in View array', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DF@CEHL@KZOEE088?5?9?5Compressed?5OI?5is?5out?5@
_DATA	SEGMENT
??_C@_0DF@CEHL@KZOEE088?5?9?5Compressed?5OI?5is?5out?5@ DB 'KZOEE088 - Co'
	DB	'mpressed OI is out of sync with LOD/XOD', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EC@IMDC@KZOEE090?5?9?5Maximum?5number?5of?5ent@
_DATA	SEGMENT
??_C@_0EC@IMDC@KZOEE090?5?9?5Maximum?5number?5of?5ent@ DB 'KZOEE090 - Max'
	DB	'imum number of entities in portable file exceeded: ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DO@CEAH@KZOEE091?5?9?5Maximum?5number?5of?5ent@
_DATA	SEGMENT
??_C@_0DO@CEAH@KZOEE091?5?9?5Maximum?5number?5of?5ent@ DB 'KZOEE091 - Max'
	DB	'imum number of entities in binary file exceeded', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DN@DGMC@KZOEE092?5?9?5Couldn?8t?5re?9activate?5@
_DATA	SEGMENT
??_C@_0DN@DGMC@KZOEE092?5?9?5Couldn?8t?5re?9activate?5@ DB 'KZOEE092 - Co'
	DB	'uldn''t re-activate OI for optimistic lock check', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EN@GBNJ@KZOEE093?5?9?5Optimistic?5locking?5er@
_DATA	SEGMENT
??_C@_0EN@GBNJ@KZOEE093?5?9?5Optimistic?5locking?5er@ DB 'KZOEE093 - Opti'
	DB	'mistic locking error -- OI has changed since it was activated'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@NOMM@KZOEE094?5?9?5Locking?5violation?$AA@
_DATA	SEGMENT
??_C@_0BN@NOMM@KZOEE094?5?9?5Locking?5violation?$AA@ DB 'KZOEE094 - Locki'
	DB	'ng violation', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0JB@CGJ@KZOEE095?5?9?5A?5recursive?5child?5was@
_DATA	SEGMENT
??_C@_0JB@CGJ@KZOEE095?5?9?5A?5recursive?5child?5was@ DB 'KZOEE095 - A re'
	DB	'cursive child was found that matches a parent.  This will cau'
	DB	'se an infinite loop in the recursive subobject.  See Trace fo'
	DB	'r more.', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CK@LDGH@KZOEE096?5?9?5Error?5retrieving?5OI?5f@
_DATA	SEGMENT
??_C@_0CK@LDGH@KZOEE096?5?9?5Error?5retrieving?5OI?5f@ DB 'KZOEE096 - Err'
	DB	'or retrieving OI from blob.', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DA@GDIC@KZOEE100?5?9?5Invalid?5View?0?5view?5is@
_DATA	SEGMENT
??_C@_0DA@GDIC@KZOEE100?5?9?5Invalid?5View?0?5view?5is@ DB 'KZOEE100 - In'
	DB	'valid View, view is a Subtask View', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@NHEC@KZOEE101?5?9?5Invalid?5View?$AA@
_DATA	SEGMENT
??_C@_0BI@NHEC@KZOEE101?5?9?5Invalid?5View?$AA@ DB 'KZOEE101 - Invalid Vi'
	DB	'ew', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@JOEN@KZOEE102?5?9?5Invalid?5View?0?5view?5is@
_DATA	SEGMENT
??_C@_0CI@JOEN@KZOEE102?5?9?5Invalid?5View?0?5view?5is@ DB 'KZOEE102 - In'
	DB	'valid View, view is hidden', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@DCOG@KZOEE103?5?9?5Invalid?5Entity?5name?5f@
_DATA	SEGMENT
??_C@_0CI@DCOG@KZOEE103?5?9?5Invalid?5Entity?5name?5f@ DB 'KZOEE103 - Inv'
	DB	'alid Entity name for View', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DL@IOKD@KZOEE104?5?9?5Invalid?5Attribute?5nam@
_DATA	SEGMENT
??_C@_0DL@IOKD@KZOEE104?5?9?5Invalid?5Attribute?5nam@ DB 'KZOEE104 - Inva'
	DB	'lid Attribute name for LOD/Entity/Attribute', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DA@OHNK@KZOEE105?5?9?5Invalid?5scoping?5Entit@
_DATA	SEGMENT
??_C@_0DA@OHNK@KZOEE105?5?9?5Invalid?5scoping?5Entit@ DB 'KZOEE105 - Inva'
	DB	'lid scoping Entity name for View', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@LNED@KZOEE106?5?9?5Rules?5violation?5?$AA@
_DATA	SEGMENT
??_C@_0BM@LNED@KZOEE106?5?9?5Rules?5violation?5?$AA@ DB 'KZOEE106 - Rules'
	DB	' violation ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@ICEI@KZOEE107?5?9?5Invalid?5Subtask?5View?$AA@
_DATA	SEGMENT
??_C@_0CA@ICEI@KZOEE107?5?9?5Invalid?5Subtask?5View?$AA@ DB 'KZOEE107 - I'
	DB	'nvalid Subtask View', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@CNMF@KZOEE108?5?9?5Attempt?5to?5drop?5Subta@
_DATA	SEGMENT
??_C@_0CI@CNMF@KZOEE108?5?9?5Attempt?5to?5drop?5Subta@ DB 'KZOEE108 - Att'
	DB	'empt to drop Subtask View', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DD@IEKN@KZOEE109?5?9?5Invalid?5View?0?5view?5co@
_DATA	SEGMENT
??_C@_0DD@IEKN@KZOEE109?5?9?5Invalid?5View?0?5view?5co@ DB 'KZOEE109 - In'
	DB	'valid View, view contains no instance', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CH@NIKJ@KZOEE110?5?9?5Invalid?5level?5for?5Vie@
_DATA	SEGMENT
??_C@_0CH@NIKJ@KZOEE110?5?9?5Invalid?5level?5for?5Vie@ DB 'KZOEE110 - Inv'
	DB	'alid level for View name', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EF@IJII@KZOEE111?5?9?5Attempt?5to?5set?5subtas@
_DATA	SEGMENT
??_C@_0EF@IJII@KZOEE111?5?9?5Attempt?5to?5set?5subtas@ DB 'KZOEE111 - Att'
	DB	'empt to set subtask view with a view from another task', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EC@BHLF@KZOEE112?5?9?5Attempt?5to?5set?5subtas@
_DATA	SEGMENT
??_C@_0EC@BHLF@KZOEE112?5?9?5Attempt?5to?5set?5subtas@ DB 'KZOEE112 - Att'
	DB	'empt to set subtask view attached to an application', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DD@OJHP@KZOEE113?5?9?5Invalid?5View?0?5view?5co@
_DATA	SEGMENT
??_C@_0DD@OJHP@KZOEE113?5?9?5Invalid?5View?0?5view?5co@ DB 'KZOEE113 - In'
	DB	'valid View, view contains an instance', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DD@NFKB@KZOEE114?5?9?5Source?5and?5Target?5ent@
_DATA	SEGMENT
??_C@_0DD@NFKB@KZOEE114?5?9?5Source?5and?5Target?5ent@ DB 'KZOEE114 - Sou'
	DB	'rce and Target entities do not match', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EB@HFOP@KZOEE115?5?9?5Attempt?5to?5move?5an?5in@
_DATA	SEGMENT
??_C@_0EB@HFOP@KZOEE115?5?9?5Attempt?5to?5move?5an?5in@ DB 'KZOEE115 - At'
	DB	'tempt to move an instance under one of its children', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EL@JFCI@KZOEE116?5?9?5Attempt?5to?5include?5an@
_DATA	SEGMENT
??_C@_0EL@JFCI@KZOEE116?5?9?5Attempt?5to?5include?5an@ DB 'KZOEE116 - Att'
	DB	'empt to include an instance created under a versioned parent', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CN@EDAL@KZOEE117?5?9?5Entity?5Instance?5Keys?5@
_DATA	SEGMENT
??_C@_0CN@EDAL@KZOEE117?5?9?5Entity?5Instance?5Keys?5@ DB 'KZOEE117 - Ent'
	DB	'ity Instance Keys do not match', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DM@BDCF@KZOEE118?5?9?5Internal?5Key?5error?5re@
_DATA	SEGMENT
??_C@_0DM@BDCF@KZOEE118?5?9?5Internal?5Key?5error?5re@ DB 'KZOEE118 - Int'
	DB	'ernal Key error relinking versioned Subobject', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@GLPJ@KZOEE119?5?9?5Invalid?5View?0?5View?5is@
_DATA	SEGMENT
??_C@_0CL@GLPJ@KZOEE119?5?9?5Invalid?5View?0?5View?5is@ DB 'KZOEE119 - In'
	DB	'valid View, View is Read Only', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@MFLA@KZOEE120?5?9?5Invalid?5position?5para@
_DATA	SEGMENT
??_C@_0CG@MFLA@KZOEE120?5?9?5Invalid?5position?5para@ DB 'KZOEE120 - Inva'
	DB	'lid position parameter', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DG@NDMM@KZOEE121?5?9?5Attempt?5to?5insert?5twi@
_DATA	SEGMENT
??_C@_0DG@NDMM@KZOEE121?5?9?5Attempt?5to?5insert?5twi@ DB 'KZOEE121 - Att'
	DB	'empt to insert twin to root of Instance', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DI@HBNG@KZOEE122?5?9?5Attempt?5to?5create?5an?5@
_DATA	SEGMENT
??_C@_0DI@HBNG@KZOEE122?5?9?5Attempt?5to?5create?5an?5@ DB 'KZOEE122 - At'
	DB	'tempt to create an Entity without a parent', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FB@NPFI@KZOEE124?5?9?5Entity?5parent?5is?5incl@
_DATA	SEGMENT
??_C@_0FB@NPFI@KZOEE124?5?9?5Entity?5parent?5is?5incl@ DB 'KZOEE124 - Ent'
	DB	'ity parent is included in another path containing same entity'
	DB	' type', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EC@FECD@KZOEE125?5?9?5Target?5and?5Source?5Ent@
_DATA	SEGMENT
??_C@_0EC@FECD@KZOEE125?5?9?5Target?5and?5Source?5Ent@ DB 'KZOEE125 - Tar'
	DB	'get and Source Entities are not the same E/R Entity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DG@JPKB@KZOEE126?5?9?5Target?5or?5Source?5Enti@
_DATA	SEGMENT
??_C@_0DG@JPKB@KZOEE126?5?9?5Target?5or?5Source?5Enti@ DB 'KZOEE126 - Tar'
	DB	'get or Source Entity is not Includeable', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EH@IKFL@KZOEE127?5?9?5Source?5?$CG?5target?5do?5no@
_DATA	SEGMENT
??_C@_0EH@IKFL@KZOEE127?5?9?5Source?5?$CG?5target?5do?5no@ DB 'KZOEE127 -'
	DB	' Source & target do not match on both Entity & Relationship.', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EG@KLAD@KZOEE128?5?9?5Target?5Entity?5cardina@
_DATA	SEGMENT
??_C@_0EG@KLAD@KZOEE128?5?9?5Target?5Entity?5cardina@ DB 'KZOEE128 - Targ'
	DB	'et Entity cardinality max not 1 for inverted Subobject', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0IA@GFGF@KZOEE129?5?9?5Trying?5to?5create?5a?5re@
_DATA	SEGMENT
??_C@_0IA@GFGF@KZOEE129?5?9?5Trying?5to?5create?5a?5re@ DB 'KZOEE129 - Tr'
	DB	'ying to create a relationship (via Include, possibly as part '
	DB	'of a spawn) that already exists.  See trace for more.', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EG@DDAB@KZOEE131?5?9?5Attempt?5to?5include?5Su@
_DATA	SEGMENT
??_C@_0EG@DDAB@KZOEE131?5?9?5Attempt?5to?5include?5Su@ DB 'KZOEE131 - Att'
	DB	'empt to include Subobject from another Application Task', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DL@FCGD@KZOEE132?5?9?5Error?5establishing?5cu@
_DATA	SEGMENT
??_C@_0DL@FCGD@KZOEE132?5?9?5Error?5establishing?5cu@ DB 'KZOEE132 - Erro'
	DB	'r establishing cursor for Subobject include', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FA@LJEB@KZOEE134?5?9?5Attempt?5to?5version?5an@
_DATA	SEGMENT
??_C@_0FA@LJEB@KZOEE134?5?9?5Attempt?5to?5version?5an@ DB 'KZOEE134 - Att'
	DB	'empt to version an Entity Instance versioned via a differen, '
	DB	'path', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@EFHN@KZOEE135?5?9?5Entity?5Instance?5not?5v@
_DATA	SEGMENT
??_C@_0CJ@EFHN@KZOEE135?5?9?5Entity?5Instance?5not?5v@ DB 'KZOEE135 - Ent'
	DB	'ity Instance not versioned', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CN@MAJK@KZOEE136?5?9?5Entity?5Instance?5alrea@
_DATA	SEGMENT
??_C@_0CN@MAJK@KZOEE136?5?9?5Entity?5Instance?5alrea@ DB 'KZOEE136 - Enti'
	DB	'ty Instance already versioned', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DA@LGF@KZOEE137?5?9?5Entity?5Instance?5desce@
_DATA	SEGMENT
??_C@_0DA@LGF@KZOEE137?5?9?5Entity?5Instance?5desce@ DB 'KZOEE137 - Entit'
	DB	'y Instance descendent versioned', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EE@IOCN@KZOEE138?5?9?5Attempt?5to?5include?5ta@
_DATA	SEGMENT
??_C@_0EE@IOCN@KZOEE138?5?9?5Attempt?5to?5include?5ta@ DB 'KZOEE138 - Att'
	DB	'empt to include target entity with recursive behavior', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DM@EDLN@KZOEE139?5?9?5Error?5establishing?5cu@
_DATA	SEGMENT
??_C@_0DM@EDLN@KZOEE139?5?9?5Error?5establishing?5cu@ DB 'KZOEE139 - Erro'
	DB	'r establishing cursor for CreateEntity spawn', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0ED@EHNP@KZOEE140?5?9?5Target?5and?5source?5Obj@
_DATA	SEGMENT
??_C@_0ED@EHNP@KZOEE140?5?9?5Target?5and?5source?5Obj@ DB 'KZOEE140 - Tar'
	DB	'get and source Object instance are the same instance', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EK@MPKH@KZOEE141?5?9?5Attempt?5to?5include?5a?5@
_DATA	SEGMENT
??_C@_0EK@MPKH@KZOEE141?5?9?5Attempt?5to?5include?5a?5@ DB 'KZOEE141 - At'
	DB	'tempt to include a subobject whose root is a Temporal Entity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@HOIP@KZOEE190?5?9?5Error?5opening?5tempora@
_DATA	SEGMENT
??_C@_0CI@HOIP@KZOEE190?5?9?5Error?5opening?5tempora@ DB 'KZOEE190 - Erro'
	DB	'r opening temporary file', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EC@BIGN@KZOEE191?5?9?5Attribute?5must?5be?5a?5B@
_DATA	SEGMENT
??_C@_0EC@BIGN@KZOEE191?5?9?5Attribute?5must?5be?5a?5B@ DB 'KZOEE191 - At'
	DB	'tribute must be a Blob or String for this operation.', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DA@CNJA@KZOEE231?5?9?5Decimal?5attribute?5ove@
_DATA	SEGMENT
??_C@_0DA@CNJA@KZOEE231?5?9?5Decimal?5attribute?5ove@ DB 'KZOEE231 - Deci'
	DB	'mal attribute overflow (garbage)', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DP@LJHO@KZOEE232?5?9?5Operation?5indicates?5u@
_DATA	SEGMENT
??_C@_0DP@LJHO@KZOEE232?5?9?5Operation?5indicates?5u@ DB 'KZOEE232 - Oper'
	DB	'ation indicates use default context, none found', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DG@KPMG@KZOEE233?5?9?5Could?5not?5locate?5deri@
_DATA	SEGMENT
??_C@_0DG@KPMG@KZOEE233?5?9?5Could?5not?5locate?5deri@ DB 'KZOEE233 - Cou'
	DB	'ld not locate derived library/operation', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EH@EJPO@KZOEE234?5?9?5Attempt?5to?5add?5intege@
_DATA	SEGMENT
??_C@_0EH@EJPO@KZOEE234?5?9?5Attempt?5to?5add?5intege@ DB 'KZOEE234 - Att'
	DB	'empt to add integer or decimal to invalid attribute type', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@GBBH@KZOEE235?5?9?5Integer?5overflow?$AA@
_DATA	SEGMENT
??_C@_0BM@GBBH@KZOEE235?5?9?5Integer?5overflow?$AA@ DB 'KZOEE235 - Intege'
	DB	'r overflow', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@JFBL@KZOEE236?5?9?5Integer?5underflow?$AA@
_DATA	SEGMENT
??_C@_0BN@JFBL@KZOEE236?5?9?5Integer?5underflow?$AA@ DB 'KZOEE236 - Integ'
	DB	'er underflow', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DI@NJGM@KZOEE237?5?9?5Attempt?5to?5update?5a?5n@
_DATA	SEGMENT
??_C@_0DI@NJGM@KZOEE237?5?9?5Attempt?5to?5update?5a?5n@ DB 'KZOEE237 - At'
	DB	'tempt to update a non-updateable attribute', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0ED@IIED@KZOEE238?5?9?5Attempt?5to?5update?5a?5n@
_DATA	SEGMENT
??_C@_0ED@IIED@KZOEE238?5?9?5Attempt?5to?5update?5a?5n@ DB 'KZOEE238 - At'
	DB	'tempt to update a non-updateable persistent attribute', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DA@EHLD@KZOEE239?5?9?5Invalid?5Operation?5for@
_DATA	SEGMENT
??_C@_0DA@EHLD@KZOEE239?5?9?5Invalid?5Operation?5for@ DB 'KZOEE239 - Inva'
	DB	'lid Operation for attribute type', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DM@EDAM@KZOEE240?5?9?5Binary?5large?5object?5?$CI@
_DATA	SEGMENT
??_C@_0DM@EDAM@KZOEE240?5?9?5Binary?5large?5object?5?$CI@ DB 'KZOEE240 - '
	DB	'Binary large object (Blob) exceeds passed length', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@FKDO@KZOEE241?5?9?5Invalid?5Variable?5Type@
_DATA	SEGMENT
??_C@_0CC@FKDO@KZOEE241?5?9?5Invalid?5Variable?5Type@ DB 'KZOEE241 - Inva'
	DB	'lid Variable Type ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CF@KFFO@KZOEE242?5?9?5Invalid?5Domain?5Entry?5@
_DATA	SEGMENT
??_C@_0CF@KFFO@KZOEE242?5?9?5Invalid?5Domain?5Entry?5@ DB 'KZOEE242 - Inv'
	DB	'alid Domain Entry Type', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@NJPF@KZOEE243?5?9?5Context?5invalid?5for?5D@
_DATA	SEGMENT
??_C@_0CG@NJPF@KZOEE243?5?9?5Context?5invalid?5for?5D@ DB 'KZOEE243 - Con'
	DB	'text invalid for Domain', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@FNBB@KZOEE244?5?9?5Attribute?5has?5no?5Doma@
_DATA	SEGMENT
??_C@_0CD@FNBB@KZOEE244?5?9?5Attribute?5has?5no?5Doma@ DB 'KZOEE244 - Att'
	DB	'ribute has no Domain', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DM@CLHG@KZOEE245?5?9?5Null?5string?5not?5allow@
_DATA	SEGMENT
??_C@_0DM@CLHG@KZOEE245?5?9?5Null?5string?5not?5allow@ DB 'KZOEE245 - Nul'
	DB	'l string not allowed for a required attribute', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@EGIM@KZOEE246?5?9?5Invalid?5Attribute?5typ@
_DATA	SEGMENT
??_C@_0CD@EGIM@KZOEE246?5?9?5Invalid?5Attribute?5typ@ DB 'KZOEE246 - Inva'
	DB	'lid Attribute type ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DM@LIOD@KZOEE247?5?9?5Blob?5Attribute?5does?5n@
_DATA	SEGMENT
??_C@_0DM@LIOD@KZOEE247?5?9?5Blob?5Attribute?5does?5n@ DB 'KZOEE247 - Blo'
	DB	'b Attribute does not match Target Entity Type', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@JDPP@KZOEE248?5?9?5Required?5attribute?5is@
_DATA	SEGMENT
??_C@_0CG@JDPP@KZOEE248?5?9?5Required?5attribute?5is@ DB 'KZOEE248 - Requ'
	DB	'ired attribute is null', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CE@HNFJ@KZOEE250?5?9?5Object?5instance?5is?5em@
_DATA	SEGMENT
??_C@_0CE@HNFJ@KZOEE250?5?9?5Object?5instance?5is?5em@ DB 'KZOEE250 - Obj'
	DB	'ect instance is empty', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@PNML@KZOEE252?5?9?5Root?5of?5view?5has?5been@
_DATA	SEGMENT
??_C@_0CJ@PNML@KZOEE252?5?9?5Root?5of?5view?5has?5been@ DB 'KZOEE252 - Ro'
	DB	'ot of view has been deleted', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@ICBE@KZOEE253?5?9?5Entity?5cursor?5is?5NULL@
_DATA	SEGMENT
??_C@_0CB@ICBE@KZOEE253?5?9?5Entity?5cursor?5is?5NULL@ DB 'KZOEE253 - Ent'
	DB	'ity cursor is NULL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@DKJB@KZOEE254?5?9?5Entity?5cursor?5is?5unde@
_DATA	SEGMENT
??_C@_0CG@DKJB@KZOEE254?5?9?5Entity?5cursor?5is?5unde@ DB 'KZOEE254 - Ent'
	DB	'ity cursor is undefined', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DH@MKIF@KZOEE255?5?9?5Attempt?5to?5update?5a?5p@
_DATA	SEGMENT
??_C@_0DH@MKIF@KZOEE255?5?9?5Attempt?5to?5update?5a?5p@ DB 'KZOEE255 - At'
	DB	'tempt to update a previous entity version', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@IDGK@KZOEE256?5?9?5Entity?5is?5root?5of?5vie@
_DATA	SEGMENT
??_C@_0CC@IDGK@KZOEE256?5?9?5Entity?5is?5root?5of?5vie@ DB 'KZOEE256 - En'
	DB	'tity is root of view', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EA@FEIJ@KZOEE257?5?9?5Version?5mismatch?5betw@
_DATA	SEGMENT
??_C@_0EA@FEIJ@KZOEE257?5?9?5Version?5mismatch?5betw@ DB 'KZOEE257 - Vers'
	DB	'ion mismatch between scoping and target Entities', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CO@IOAK@KZOEE258?5?9?5Scoping?5Entity?5cursor@
_DATA	SEGMENT
??_C@_0CO@IOAK@KZOEE258?5?9?5Scoping?5Entity?5cursor@ DB 'KZOEE258 - Scop'
	DB	'ing Entity cursor is undefined', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@MMGH@KZOEE259?5?9?5Scoping?5Entity?5cursor@
_DATA	SEGMENT
??_C@_0CJ@MMGH@KZOEE259?5?9?5Scoping?5Entity?5cursor@ DB 'KZOEE259 - Scop'
	DB	'ing Entity cursor is NULL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EP@DIEE@KZOEE263?5?9?5Input?5Qualifier?5canno@
_DATA	SEGMENT
??_C@_0EP@DIEE@KZOEE263?5?9?5Input?5Qualifier?5canno@ DB 'KZOEE263 - Inpu'
	DB	't Qualifier cannot be converted to internal attribute data ty'
	DB	'pe', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@DMDO@KZOEE264?5?9?5Invalid?5Operation?5for@
_DATA	SEGMENT
??_C@_0DJ@DMDO@KZOEE264?5?9?5Invalid?5Operation?5for@ DB 'KZOEE264 - Inva'
	DB	'lid Operation for Hierarchical processing', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DN@JHKM@KZOEE265?5?9?5Invalid?5Operation?5for@
_DATA	SEGMENT
??_C@_0DN@JHKM@KZOEE265?5?9?5Invalid?5Operation?5for@ DB 'KZOEE265 - Inva'
	DB	'lid Operation for non-Hierarchical processing', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DO@NFPG@KZOEE266?5?9?5Invalid?5Operation?5for@
_DATA	SEGMENT
??_C@_0DO@NFPG@KZOEE266?5?9?5Invalid?5Operation?5for@ DB 'KZOEE266 - Inva'
	DB	'lid Operation for Hierarchical cursor position', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@LKBG@KZOEE267?5?9?5Hierarchical?5cursor?5i@
_DATA	SEGMENT
??_C@_0CM@LKBG@KZOEE267?5?9?5Hierarchical?5cursor?5i@ DB 'KZOEE267 - Hier'
	DB	'archical cursor is undefined', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DH@KDFJ@KZOEE268?5?9?5Source?5and?5target?5ent@
_DATA	SEGMENT
??_C@_0DH@KDFJ@KZOEE268?5?9?5Source?5and?5target?5ent@ DB 'KZOEE268 - Sou'
	DB	'rce and target entity types do not match', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@FACO@KZOEE269?5?9?5Invalid?5Select?5Set?5ID@
_DATA	SEGMENT
??_C@_0CG@FACO@KZOEE269?5?9?5Invalid?5Select?5Set?5ID@ DB 'KZOEE269 - Inv'
	DB	'alid Select Set ID, ID=', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CH@HOLD@KZOEE270?5?9?5View?5name?5is?5already?5@
_DATA	SEGMENT
??_C@_0CH@HOLD@KZOEE270?5?9?5View?5name?5is?5already?5@ DB 'KZOEE270 - Vi'
	DB	'ew name is already in use', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DO@BMHF@KZOEE271?5?9?5Subobject?5Entity?5is?5r@
_DATA	SEGMENT
??_C@_0DO@BMHF@KZOEE271?5?9?5Subobject?5Entity?5is?5r@ DB 'KZOEE271 - Sub'
	DB	'object Entity is root of View Object Definition', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@LFIF@KZOEE272?5?9?5Subobject?5Parent?5Curs@
_DATA	SEGMENT
??_C@_0CL@LFIF@KZOEE272?5?9?5Subobject?5Parent?5Curs@ DB 'KZOEE272 - Subo'
	DB	'bject Parent Cursor is NULL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DD@DLH@KZOEE273?5?9?5Parent?5Entity?5instanc@
_DATA	SEGMENT
??_C@_0DD@DLH@KZOEE273?5?9?5Parent?5Entity?5instanc@ DB 'KZOEE273 - Paren'
	DB	't Entity instance for View deleted', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0ED@GMM@KZOEE274?5?9?5Target?5and?5Source?5vie@
_DATA	SEGMENT
??_C@_0ED@GMM@KZOEE274?5?9?5Target?5and?5Source?5vie@ DB 'KZOEE274 - Targ'
	DB	'et and Source views are different View Object types', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@OIHN@KZOEE300?5?9?5Problems?5finding?5a?5pa@
_DATA	SEGMENT
??_C@_0CG@OIHN@KZOEE300?5?9?5Problems?5finding?5a?5pa@ DB 'KZOEE300 - Pro'
	DB	'blems finding a parent ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EH@GAK@KZOEE301?5?9?5Return?5buffer?5not?5lar@
_DATA	SEGMENT
??_C@_0EH@GAK@KZOEE301?5?9?5Return?5buffer?5not?5lar@ DB 'KZOEE301 - Retu'
	DB	'rn buffer not large enough to contain concatenated keys', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@JCI@KZOEE302?5?9?5Invalid?5option?$AA@
_DATA	SEGMENT
??_C@_0BK@JCI@KZOEE302?5?9?5Invalid?5option?$AA@ DB 'KZOEE302 - Invalid o'
	DB	'ption', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EA@KHBJ@KZOEE330?5?9?5Message?5Object?5Defini@
_DATA	SEGMENT
??_C@_0EA@KHBJ@KZOEE330?5?9?5Message?5Object?5Defini@ DB 'KZOEE330 - Mess'
	DB	'age Object Definition not loaded for Application', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CI@HNHP@KZOEE350?5?9?5Context?5Not?5Valid?5for@
_DATA	SEGMENT
??_C@_0CI@HNHP@KZOEE350?5?9?5Context?5Not?5Valid?5for@ DB 'KZOEE350 - Con'
	DB	'text Not Valid for Domain', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@IIPK@KZOEE351?5?9?5Invalid?5Input?5Data?5Ty@
_DATA	SEGMENT
??_C@_0CD@IIPK@KZOEE351?5?9?5Invalid?5Input?5Data?5Ty@ DB 'KZOEE351 - Inv'
	DB	'alid Input Data Type', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DB@GJCM@KZOEE352?5?9?5Text?5String?5exceeds?5a@
_DATA	SEGMENT
??_C@_0DB@GJCM@KZOEE352?5?9?5Text?5String?5exceeds?5a@ DB 'KZOEE352 - Tex'
	DB	't String exceeds attribute length ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DC@CBDF@KZOEE353?5?9?5Attribute?5Type?5invali@
_DATA	SEGMENT
??_C@_0DC@CBDF@KZOEE353?5?9?5Attribute?5Type?5invali@ DB 'KZOEE353 - Attr'
	DB	'ibute Type invalid for this Domain', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CG@DCAE@KZOEE354?5?9?5Invalid?5Domain?5Entry?5@
_DATA	SEGMENT
??_C@_0CG@DCAE@KZOEE354?5?9?5Invalid?5Domain?5Entry?5@ DB 'KZOEE354 - Inv'
	DB	'alid Domain Entry Type ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DH@JDFE@KZOEE355?5?9?5Table_Handler?5invalid@
_DATA	SEGMENT
??_C@_0DH@JDFE@KZOEE355?5?9?5Table_Handler?5invalid@ DB 'KZOEE355 - Table'
	DB	'_Handler invalid for this Domain Type ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CK@FNMN@KZOEE356?5?9?5Domain?5has?5an?5unnamed@
_DATA	SEGMENT
??_C@_0CK@FNMN@KZOEE356?5?9?5Domain?5has?5an?5unnamed@ DB 'KZOEE356 - Dom'
	DB	'ain has an unnamed Context ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@LACG@KZOEE357?5?9?5Invalid?5Input?5Data?$AA@
_DATA	SEGMENT
??_C@_0BO@LACG@KZOEE357?5?9?5Invalid?5Input?5Data?$AA@ DB 'KZOEE357 - Inv'
	DB	'alid Input Data', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@DEPD@KZOEE358?5?9?5Value?5not?5in?5Context?5@
_DATA	SEGMENT
??_C@_0CM@DEPD@KZOEE358?5?9?5Value?5not?5in?5Context?5@ DB 'KZOEE358 - Va'
	DB	'lue not in Context for Domain ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@BGND@KZOEE359?5?9?5Invalid?5Input?5Data?5Ty@
_DATA	SEGMENT
??_C@_0DJ@BGND@KZOEE359?5?9?5Invalid?5Input?5Data?5Ty@ DB 'KZOEE359 - Inv'
	DB	'alid Input Data Type for Domain Entry Type', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CF@JLJE@KZOEE360?5?9?5Missing?5ending?5delimi@
_DATA	SEGMENT
??_C@_0CF@JLJE@KZOEE360?5?9?5Missing?5ending?5delimi@ DB 'KZOEE360 - Miss'
	DB	'ing ending delimiter ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@PMLE@KZOEE361?5?9?5Invalid?5data?5Format?5?$AA@
_DATA	SEGMENT
??_C@_0CA@PMLE@KZOEE361?5?9?5Invalid?5data?5Format?5?$AA@ DB 'KZOEE361 - '
	DB	'Invalid data Format ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DL@IDHP@KZOEE362?5?9?5Variable?5Type?5not?5all@
_DATA	SEGMENT
??_C@_0DL@IDHP@KZOEE362?5?9?5Variable?5Type?5not?5all@ DB 'KZOEE362 - Var'
	DB	'iable Type not allowed for this Domain Type ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@NCJC@KZOEE363?5?9?5Context?5Edit?5string?5i@
_DATA	SEGMENT
??_C@_0CL@NCJC@KZOEE363?5?9?5Context?5Edit?5string?5i@ DB 'KZOEE363 - Con'
	DB	'text Edit string is invalid ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DA@MAJI@KZOEE364?5?9?5Picture?5length?5exceed@
_DATA	SEGMENT
??_C@_0DA@MAJI@KZOEE364?5?9?5Picture?5length?5exceed@ DB 'KZOEE364 - Pict'
	DB	'ure length exceeds input length ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DF@EIIB@KZOEE400?5?9?5Error?5transmitting?5OI@
_DATA	SEGMENT
??_C@_0DF@EIIB@KZOEE400?5?9?5Error?5transmitting?5OI@ DB 'KZOEE400 - Erro'
	DB	'r transmitting OI -- some lines lost.', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@COPE@KZOEE401?5?9?5Invalid?5User?5Name?4?$AA@
_DATA	SEGMENT
??_C@_0BO@COPE@KZOEE401?5?9?5Invalid?5User?5Name?4?$AA@ DB 'KZOEE401 - In'
	DB	'valid User Name.', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@LCML@KZOEE402?5?9?5Invalid?5Password?4?$AA@
_DATA	SEGMENT
??_C@_0BN@LCML@KZOEE402?5?9?5Invalid?5Password?4?$AA@ DB 'KZOEE402 - Inva'
	DB	'lid Password.', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@MFOH@KZOEE403?5?9?5Application?5not?5suppo@
_DATA	SEGMENT
??_C@_0DJ@MFOH@KZOEE403?5?9?5Application?5not?5suppo@ DB 'KZOEE403 - Appl'
	DB	'ication not supported by Security Object.', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@ICKG@KZOEE404?5?9?5Can?8t?5find?5UserGroup?4@
_DATA	SEGMENT
??_C@_0CB@ICKG@KZOEE404?5?9?5Can?8t?5find?5UserGroup?4@ DB 'KZOEE404 - Ca'
	DB	'n''t find UserGroup.', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DL@EBIE@KZOEE405?5?9?5UserGroup?5doesn?8t?5hav@
_DATA	SEGMENT
??_C@_0DL@EBIE@KZOEE405?5?9?5UserGroup?5doesn?8t?5hav@ DB 'KZOEE405 - Use'
	DB	'rGroup doesn''t have authority for operation.', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CF@PDBP@KZOEE450?5?9?5Name?5for?5view?5is?5too?5@
_DATA	SEGMENT
??_C@_0CF@PDBP@KZOEE450?5?9?5Name?5for?5view?5is?5too?5@ DB 'KZOEE450 - N'
	DB	'ame for view is too long', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DK@KFBA@KZOEE451?5?9?5Include?5source?5task?5d@
_DATA	SEGMENT
??_C@_0DK@KFBA@KZOEE451?5?9?5Include?5source?5task?5d@ DB 'KZOEE451 - Inc'
	DB	'lude source task does not match target task', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@DLJN@SfCreateSubtask?$AA@
_DATA	SEGMENT
??_C@_0BA@DLJN@SfCreateSubtask?$AA@ DB 'SfCreateSubtask', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@BDFC@SfDropSubtask?$AA@
_DATA	SEGMENT
??_C@_0O@BDFC@SfDropSubtask?$AA@ DB 'SfDropSubtask', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@FMPJ@DisableTask?$AA@
_DATA	SEGMENT
??_C@_0M@FMPJ@DisableTask?$AA@ DB 'DisableTask', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@BBMP@EnableTask?$AA@
_DATA	SEGMENT
??_C@_0L@BBMP@EnableTask?$AA@ DB 'EnableTask', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@BDEP@GetApplDirectoryFromView?$AA@
_DATA	SEGMENT
??_C@_0BJ@BDEP@GetApplDirectoryFromView?$AA@ DB 'GetApplDirectoryFromView'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OJMF@SfGetApplicationForSubtask?$AA@
_DATA	SEGMENT
??_C@_0BL@OJMF@SfGetApplicationForSubtask?$AA@ DB 'SfGetApplicationForSub'
	DB	'task', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@FHBI@SfGetTaskInfo?$AA@
_DATA	SEGMENT
??_C@_0O@FHBI@SfGetTaskInfo?$AA@ DB 'SfGetTaskInfo', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@PMHK@SfActivateSysOI_FromFile?$AA@
_DATA	SEGMENT
??_C@_0BJ@PMHK@SfActivateSysOI_FromFile?$AA@ DB 'SfActivateSysOI_FromFile'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@PCON@SfActivateSysEmptyOI?$AA@
_DATA	SEGMENT
??_C@_0BF@PCON@SfActivateSysEmptyOI?$AA@ DB 'SfActivateSysEmptyOI', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@OIBJ@ActivateEmptyObjectInstance?$AA@
_DATA	SEGMENT
??_C@_0BM@OIBJ@ActivateEmptyObjectInstance?$AA@ DB 'ActivateEmptyObjectIn'
	DB	'stance', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NOPG@ActivateObjectInstance?$AA@
_DATA	SEGMENT
??_C@_0BH@NOPG@ActivateObjectInstance?$AA@ DB 'ActivateObjectInstance', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IMAC@ActivateOI_FromFile?$AA@
_DATA	SEGMENT
??_C@_0BE@IMAC@ActivateOI_FromFile?$AA@ DB 'ActivateOI_FromFile', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@GAMK@ActivateOI_FromXML_File?$AA@
_DATA	SEGMENT
??_C@_0BI@GAMK@ActivateOI_FromXML_File?$AA@ DB 'ActivateOI_FromXML_File', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CGBG@CommitOI_ToXML_File?$AA@
_DATA	SEGMENT
??_C@_0BE@CGBG@CommitOI_ToXML_File?$AA@ DB 'CommitOI_ToXML_File', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@PDFM@ActivateOI_FromOI?$AA@
_DATA	SEGMENT
??_C@_0BC@PDFM@ActivateOI_FromOI?$AA@ DB 'ActivateOI_FromOI', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@GELD@CommitObjectInstance?$AA@
_DATA	SEGMENT
??_C@_0BF@GELD@CommitObjectInstance?$AA@ DB 'CommitObjectInstance', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@FMKN@CommitMultipleOIs?$AA@
_DATA	SEGMENT
??_C@_0BC@FMKN@CommitMultipleOIs?$AA@ DB 'CommitMultipleOIs', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@MOCF@DropViewCluster?$AA@
_DATA	SEGMENT
??_C@_0BA@MOCF@DropViewCluster?$AA@ DB 'DropViewCluster', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@PMGH@AddToViewCluster?$AA@
_DATA	SEGMENT
??_C@_0BB@PMGH@AddToViewCluster?$AA@ DB 'AddToViewCluster', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FDOM@CommitOI_ToFile?$AA@
_DATA	SEGMENT
??_C@_0BA@FDOM@CommitOI_ToFile?$AA@ DB 'CommitOI_ToFile', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@PHBJ@DropObjectInstance?$AA@
_DATA	SEGMENT
??_C@_0BD@PHBJ@DropObjectInstance?$AA@ DB 'DropObjectInstance', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NEFL@CheckExistenceOfEntity?$AA@
_DATA	SEGMENT
??_C@_0BH@NEFL@CheckExistenceOfEntity?$AA@ DB 'CheckExistenceOfEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@HLNG@CompareEntityToEntity?$AA@
_DATA	SEGMENT
??_C@_0BG@HLNG@CompareEntityToEntity?$AA@ DB 'CompareEntityToEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@BOMB@CreateEntity?$AA@
_DATA	SEGMENT
??_C@_0N@BOMB@CreateEntity?$AA@ DB 'CreateEntity', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@DPDF@GetEntityKey?$AA@
_DATA	SEGMENT
??_C@_0N@DPDF@GetEntityKey?$AA@ DB 'GetEntityKey', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@ELCK@CreateTemporalEntity?$AA@
_DATA	SEGMENT
??_C@_0BF@ELCK@CreateTemporalEntity?$AA@ DB 'CreateTemporalEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@EIGM@CreateTemporalSubobjectVersion?$AA@
_DATA	SEGMENT
??_C@_0BP@EIGM@CreateTemporalSubobjectVersion?$AA@ DB 'CreateTemporalSubo'
	DB	'bjectVersion', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@IEEA@AcceptSubobject?$AA@
_DATA	SEGMENT
??_C@_0BA@IEEA@AcceptSubobject?$AA@ DB 'AcceptSubobject', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@MAGB@AcceptAllTemporalSubobjects?$AA@
_DATA	SEGMENT
??_C@_0BM@MAGB@AcceptAllTemporalSubobjects?$AA@ DB 'AcceptAllTemporalSubo'
	DB	'bjects', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@NIBC@CancelSubobject?$AA@
_DATA	SEGMENT
??_C@_0BA@NIBC@CancelSubobject?$AA@ DB 'CancelSubobject', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@CNDP@CancelAllTemporalSubobjects?$AA@
_DATA	SEGMENT
??_C@_0BM@CNDP@CancelAllTemporalSubobjects?$AA@ DB 'CancelAllTemporalSubo'
	DB	'bjects', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@NBLH@IncludeSubobjectFromSubobject?$AA@
_DATA	SEGMENT
??_C@_0BO@NBLH@IncludeSubobjectFromSubobject?$AA@ DB 'IncludeSubobjectFro'
	DB	'mSubobject', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@GDJL@IncludeSubobjectFromSubobjectEx?$AA@
_DATA	SEGMENT
??_C@_0CA@GDJL@IncludeSubobjectFromSubobjectEx?$AA@ DB 'IncludeSubobjectF'
	DB	'romSubobjectEx', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@JDMH@SubobjectVersionUpdated?$AA@
_DATA	SEGMENT
??_C@_0BI@JDMH@SubobjectVersionUpdated?$AA@ DB 'SubobjectVersionUpdated', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NKPH@DeleteEntity?$AA@
_DATA	SEGMENT
??_C@_0N@NKPH@DeleteEntity?$AA@ DB 'DeleteEntity', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@PHBL@ExcludeEntity?$AA@
_DATA	SEGMENT
??_C@_0O@PHBL@ExcludeEntity?$AA@ DB 'ExcludeEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@COBA@DropEntity?$AA@
_DATA	SEGMENT
??_C@_0L@COBA@DropEntity?$AA@ DB 'DropEntity', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@OJII@MoveSubobject?$AA@
_DATA	SEGMENT
??_C@_0O@OJII@MoveSubobject?$AA@ DB 'MoveSubobject', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@PPIN@SetCursorNextEntity?$AA@
_DATA	SEGMENT
??_C@_0BE@PPIN@SetCursorNextEntity?$AA@ DB 'SetCursorNextEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@MAGO@SetCursorPrevEntity?$AA@
_DATA	SEGMENT
??_C@_0BE@MAGO@SetCursorPrevEntity?$AA@ DB 'SetCursorPrevEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@NEDK@SetCursorFirstEntity?$AA@
_DATA	SEGMENT
??_C@_0BF@NEDK@SetCursorFirstEntity?$AA@ DB 'SetCursorFirstEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HACO@SetCursorLastEntity?$AA@
_DATA	SEGMENT
??_C@_0BE@HACO@SetCursorLastEntity?$AA@ DB 'SetCursorLastEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@IKOI@SetCursorFirstEntityByString?$AA@
_DATA	SEGMENT
??_C@_0BN@IKOI@SetCursorFirstEntityByString?$AA@ DB 'SetCursorFirstEntity'
	DB	'ByString', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@EHFF@SetCursorNextEntityByString?$AA@
_DATA	SEGMENT
??_C@_0BM@EHFF@SetCursorNextEntityByString?$AA@ DB 'SetCursorNextEntityBy'
	DB	'String', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@GMJK@SetCursorFirstEntityByInteger?$AA@
_DATA	SEGMENT
??_C@_0BO@GMJK@SetCursorFirstEntityByInteger?$AA@ DB 'SetCursorFirstEntit'
	DB	'yByInteger', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@DEFH@SetCursorNextEntityByInteger?$AA@
_DATA	SEGMENT
??_C@_0BN@DEFH@SetCursorNextEntityByInteger?$AA@ DB 'SetCursorNextEntityB'
	DB	'yInteger', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@COOK@SetCursorFirstEntityByDecimal?$AA@
_DATA	SEGMENT
??_C@_0BO@COOK@SetCursorFirstEntityByDecimal?$AA@ DB 'SetCursorFirstEntit'
	DB	'yByDecimal', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@HGCH@SetCursorNextEntityByDecimal?$AA@
_DATA	SEGMENT
??_C@_0BN@HGCH@SetCursorNextEntityByDecimal?$AA@ DB 'SetCursorNextEntityB'
	DB	'yDecimal', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@GLMN@SetCursorFirstEntityByAttr?$AA@
_DATA	SEGMENT
??_C@_0BL@GLMN@SetCursorFirstEntityByAttr?$AA@ DB 'SetCursorFirstEntityBy'
	DB	'Attr', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@MB@SetCursorNextEntityByAttr?$AA@
_DATA	SEGMENT
??_C@_0BK@MB@SetCursorNextEntityByAttr?$AA@ DB 'SetCursorNextEntityByAttr'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@CCIK@SetCursorFirstEntityByEntityCsr?$AA@
_DATA	SEGMENT
??_C@_0CA@CCIK@SetCursorFirstEntityByEntityCsr?$AA@ DB 'SetCursorFirstEnt'
	DB	'ityByEntityCsr', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@FIAL@SetCursorNextEntityByEntityCsr?$AA@
_DATA	SEGMENT
??_C@_0BP@FIAL@SetCursorNextEntityByEntityCsr?$AA@ DB 'SetCursorNextEntit'
	DB	'yByEntityCsr', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@EMBJ@SetCursorFirstSelectedEntity?$AA@
_DATA	SEGMENT
??_C@_0BN@EMBJ@SetCursorFirstSelectedEntity?$AA@ DB 'SetCursorFirstSelect'
	DB	'edEntity', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@IBKE@SetCursorNextSelectedEntity?$AA@
_DATA	SEGMENT
??_C@_0BM@IBKE@SetCursorNextSelectedEntity?$AA@ DB 'SetCursorNextSelected'
	DB	'Entity', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@GCJI@SetCursorRelativeEntity?$AA@
_DATA	SEGMENT
??_C@_0BI@GCJI@SetCursorRelativeEntity?$AA@ DB 'SetCursorRelativeEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@DKDE@GetRelativeEntityNumber?$AA@
_DATA	SEGMENT
??_C@_0BI@DKDE@GetRelativeEntityNumber?$AA@ DB 'GetRelativeEntityNumber', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@EJOC@DefineHierarchicalCursor?$AA@
_DATA	SEGMENT
??_C@_0BJ@EJOC@DefineHierarchicalCursor?$AA@ DB 'DefineHierarchicalCursor'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@COPC@DropHierarchicalCursor?$AA@
_DATA	SEGMENT
??_C@_0BH@COPC@DropHierarchicalCursor?$AA@ DB 'DropHierarchicalCursor', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@CHCH@SetCursorNextEntityHierarchical?$AA@
_DATA	SEGMENT
??_C@_0CA@CHCH@SetCursorNextEntityHierarchical?$AA@ DB 'SetCursorNextEnti'
	DB	'tyHierarchical', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@OPGJ@CreateViewFromView?$AA@
_DATA	SEGMENT
??_C@_0BD@OPGJ@CreateViewFromView?$AA@ DB 'CreateViewFromView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@HNOF@SetViewFromView?$AA@
_DATA	SEGMENT
??_C@_0BA@HNOF@SetViewFromView?$AA@ DB 'SetViewFromView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@MNMP@SetViewToSubobject?$AA@
_DATA	SEGMENT
??_C@_0BD@MNMP@SetViewToSubobject?$AA@ DB 'SetViewToSubobject', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@EJFL@ResetViewFromSubobject?$AA@
_DATA	SEGMENT
??_C@_0BH@EJFL@ResetViewFromSubobject?$AA@ DB 'ResetViewFromSubobject', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@CBGO@SetNameForView?$AA@
_DATA	SEGMENT
??_C@_0P@CBGO@SetNameForView?$AA@ DB 'SetNameForView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@LHJJ@DropNameForView?$AA@
_DATA	SEGMENT
??_C@_0BA@LHJJ@DropNameForView?$AA@ DB 'DropNameForView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@LOIG@GetViewByName?$AA@
_DATA	SEGMENT
??_C@_0O@LOIG@GetViewByName?$AA@ DB 'GetViewByName', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@NAIK@SetSubtaskView?$AA@
_DATA	SEGMENT
??_C@_0P@NAIK@SetSubtaskView?$AA@ DB 'SetSubtaskView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@KFDN@GetNameForView?$AA@
_DATA	SEGMENT
??_C@_0P@KFDN@GetNameForView?$AA@ DB 'GetNameForView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@FIPH@SfGetFirstSubtaskView?$AA@
_DATA	SEGMENT
??_C@_0BG@FIPH@SfGetFirstSubtaskView?$AA@ DB 'SfGetFirstSubtaskView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@INMF@SfGetNextSubtaskView?$AA@
_DATA	SEGMENT
??_C@_0BF@INMF@SfGetNextSubtaskView?$AA@ DB 'SfGetNextSubtaskView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@EIOP@SfTransferView?$AA@
_DATA	SEGMENT
??_C@_0P@EIOP@SfTransferView?$AA@ DB 'SfTransferView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@HDM@SfLockView?$AA@
_DATA	SEGMENT
??_C@_0L@HDM@SfLockView?$AA@ DB 'SfLockView', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09MKAH@ResetView?$AA@
_DATA	SEGMENT
??_C@_09MKAH@ResetView?$AA@ DB 'ResetView', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08JNKD@DropView?$AA@
_DATA	SEGMENT
??_C@_08JNKD@DropView?$AA@ DB 'DropView', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GCHM@SetViewReadOnly?$AA@
_DATA	SEGMENT
??_C@_0BA@GCHM@SetViewReadOnly?$AA@ DB 'SetViewReadOnly', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@HIKI@SetViewFlags?$AA@
_DATA	SEGMENT
??_C@_0N@HIKI@SetViewFlags?$AA@ DB 'SetViewFlags', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@BBKK@GetViewFlags?$AA@
_DATA	SEGMENT
??_C@_0N@BBKK@GetViewFlags?$AA@ DB 'GetViewFlags', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@CBLC@DropViewObject?$AA@
_DATA	SEGMENT
??_C@_0P@CBLC@DropViewObject?$AA@ DB 'DropViewObject', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@JNFA@GetAttributeFlags?$AA@
_DATA	SEGMENT
??_C@_0BC@JNFA@GetAttributeFlags?$AA@ DB 'GetAttributeFlags', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CLPD@AttributeUpdated?$AA@
_DATA	SEGMENT
??_C@_0BB@CLPD@AttributeUpdated?$AA@ DB 'AttributeUpdated', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IPDO@GetStringFromAttribute?$AA@
_DATA	SEGMENT
??_C@_0BH@IPDO@GetStringFromAttribute?$AA@ DB 'GetStringFromAttribute', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@FFJB@GetIntegerFromAttribute?$AA@
_DATA	SEGMENT
??_C@_0BI@FFJB@GetIntegerFromAttribute?$AA@ DB 'GetIntegerFromAttribute', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@DCJK@GetDecimalFromAttribute?$AA@
_DATA	SEGMENT
??_C@_0BI@DCJK@GetDecimalFromAttribute?$AA@ DB 'GetDecimalFromAttribute', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@MHPH@GetBlobFromAttribute?$AA@
_DATA	SEGMENT
??_C@_0BF@MHPH@GetBlobFromAttribute?$AA@ DB 'GetBlobFromAttribute', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@HIGG@GetStructFromEntityAttrs?$AA@
_DATA	SEGMENT
??_C@_0BJ@HIGG@GetStructFromEntityAttrs?$AA@ DB 'GetStructFromEntityAttrs'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@PNDJ@GetAddrForAttribute?$AA@
_DATA	SEGMENT
??_C@_0BE@PNDJ@GetAddrForAttribute?$AA@ DB 'GetAddrForAttribute', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@IFI@GetVariableFromAttribute?$AA@
_DATA	SEGMENT
??_C@_0BJ@IFI@GetVariableFromAttribute?$AA@ DB 'GetVariableFromAttribute', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@MMIK@SetAttributeFromString?$AA@
_DATA	SEGMENT
??_C@_0BH@MMIK@SetAttributeFromString?$AA@ DB 'SetAttributeFromString', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@CNM@SetAttributeFromInteger?$AA@
_DATA	SEGMENT
??_C@_0BI@CNM@SetAttributeFromInteger?$AA@ DB 'SetAttributeFromInteger', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@EAKM@SetAttributeFromDecimal?$AA@
_DATA	SEGMENT
??_C@_0BI@EAKM@SetAttributeFromDecimal?$AA@ DB 'SetAttributeFromDecimal', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@JCLE@SetAttributeFromBlob?$AA@
_DATA	SEGMENT
??_C@_0BF@JCLE@SetAttributeFromBlob?$AA@ DB 'SetAttributeFromBlob', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@MLHG@SetAttributeFromAttribute?$AA@
_DATA	SEGMENT
??_C@_0BK@MLHG@SetAttributeFromAttribute?$AA@ DB 'SetAttributeFromAttribu'
	DB	'te', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@PBPK@SetAttributeFromCurrentDate?$AA@
_DATA	SEGMENT
??_C@_0BM@PBPK@SetAttributeFromCurrentDate?$AA@ DB 'SetAttributeFromCurre'
	DB	'ntDate', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@OEAI@SetAttributeFromVariable?$AA@
_DATA	SEGMENT
??_C@_0BJ@OEAI@SetAttributeFromVariable?$AA@ DB 'SetAttributeFromVariable'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@KHLN@SetAttributeValueNext?$AA@
_DATA	SEGMENT
??_C@_0BG@KHLN@SetAttributeValueNext?$AA@ DB 'SetAttributeValueNext', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@FODI@SetAttributeValuePrev?$AA@
_DATA	SEGMENT
??_C@_0BG@FODI@SetAttributeValuePrev?$AA@ DB 'SetAttributeValuePrev', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@JAKJ@SetBlobAttributeFromAttribute?$AA@
_DATA	SEGMENT
??_C@_0BO@JAKJ@SetBlobAttributeFromAttribute?$AA@ DB 'SetBlobAttributeFro'
	DB	'mAttribute', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@CGCL@SetEntityAttributesFromBlob?$AA@
_DATA	SEGMENT
??_C@_0BM@CGCL@SetEntityAttributesFromBlob?$AA@ DB 'SetEntityAttributesFr'
	DB	'omBlob', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@MJNM@SetBlobFromEntityAttributes?$AA@
_DATA	SEGMENT
??_C@_0BM@MJNM@SetBlobFromEntityAttributes?$AA@ DB 'SetBlobFromEntityAttr'
	DB	'ibutes', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@KNHC@AddToAttributeFromInteger?$AA@
_DATA	SEGMENT
??_C@_0BK@KNHC@AddToAttributeFromInteger?$AA@ DB 'AddToAttributeFromInteg'
	DB	'er', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@OPAC@AddToAttributeFromDecimal?$AA@
_DATA	SEGMENT
??_C@_0BK@OPAC@AddToAttributeFromDecimal?$AA@ DB 'AddToAttributeFromDecim'
	DB	'al', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@CKKJ@AddToAttributeFromAttribute?$AA@
_DATA	SEGMENT
??_C@_0BM@CKKJ@AddToAttributeFromAttribute?$AA@ DB 'AddToAttributeFromAtt'
	DB	'ribute', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@DLKH@AddToAttributeFromVariable?$AA@
_DATA	SEGMENT
??_C@_0BL@DLKH@AddToAttributeFromVariable?$AA@ DB 'AddToAttributeFromVari'
	DB	'able', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@ODPJ@CompareAttributeToString?$AA@
_DATA	SEGMENT
??_C@_0BJ@ODPJ@CompareAttributeToString?$AA@ DB 'CompareAttributeToString'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@PHPD@CompareAttributeToInteger?$AA@
_DATA	SEGMENT
??_C@_0BK@PHPD@CompareAttributeToInteger?$AA@ DB 'CompareAttributeToInteg'
	DB	'er', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@LFID@CompareAttributeToDecimal?$AA@
_DATA	SEGMENT
??_C@_0BK@LFID@CompareAttributeToDecimal?$AA@ DB 'CompareAttributeToDecim'
	DB	'al', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@OPHA@CompareAttributeToAttribute?$AA@
_DATA	SEGMENT
??_C@_0BM@OPHA@CompareAttributeToAttribute?$AA@ DB 'CompareAttributeToAtt'
	DB	'ribute', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@OCPN@CompareAttributeToVariable?$AA@
_DATA	SEGMENT
??_C@_0BL@OCPN@CompareAttributeToVariable?$AA@ DB 'CompareAttributeToVari'
	DB	'able', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@HIDA@GetAttributeLength?$AA@
_DATA	SEGMENT
??_C@_0BD@HIDA@GetAttributeLength?$AA@ DB 'GetAttributeLength', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@PHGL@SetMatchingAttributesByName?$AA@
_DATA	SEGMENT
??_C@_0BM@PHGL@SetMatchingAttributesByName?$AA@ DB 'SetMatchingAttributes'
	DB	'ByName', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@FLBC@GetFirstTableEntryForAttribute?$AA@
_DATA	SEGMENT
??_C@_0BP@FLBC@GetFirstTableEntryForAttribute?$AA@ DB 'GetFirstTableEntry'
	DB	'ForAttribute', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@BHMO@GetNextTableEntryForAttribute?$AA@
_DATA	SEGMENT
??_C@_0BO@BHMO@GetNextTableEntryForAttribute?$AA@ DB 'GetNextTableEntryFo'
	DB	'rAttribute', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@ILIL@DisplayEntityInstance?$AA@
_DATA	SEGMENT
??_C@_0BG@ILIL@DisplayEntityInstance?$AA@ DB 'DisplayEntityInstance', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@KOPK@DisplayObjectInstance?$AA@
_DATA	SEGMENT
??_C@_0BG@KOPK@DisplayObjectInstance?$AA@ DB 'DisplayObjectInstance', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KOIM@DisplayCursorInfo?$AA@
_DATA	SEGMENT
??_C@_0BC@KOIM@DisplayCursorInfo?$AA@ DB 'DisplayCursorInfo', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@FKMI@StoreValueInRecord?$AA@
_DATA	SEGMENT
??_C@_0BD@FKMI@StoreValueInRecord?$AA@ DB 'StoreValueInRecord', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@EHIH@StoreValueInDerivedAttribute?$AA@
_DATA	SEGMENT
??_C@_0BN@EHIH@StoreValueInDerivedAttribute?$AA@ DB 'StoreValueInDerivedA'
	DB	'ttribute', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@JHII@TableEntryExtToInt?$AA@
_DATA	SEGMENT
??_C@_0BD@JHII@TableEntryExtToInt?$AA@ DB 'TableEntryExtToInt', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DNNI@TableEntryIntToExt?$AA@
_DATA	SEGMENT
??_C@_0BD@DNNI@TableEntryIntToExt?$AA@ DB 'TableEntryIntToExt', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@HNKN@TableEntryForInternalValue?$AA@
_DATA	SEGMENT
??_C@_0BL@HNKN@TableEntryForInternalValue?$AA@ DB 'TableEntryForInternalV'
	DB	'alue', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@OKMC@SetSelectSetForView?$AA@
_DATA	SEGMENT
??_C@_0BE@OKMC@SetSelectSetForView?$AA@ DB 'SetSelectSetForView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@EPHO@GetSelectStateOfEntity?$AA@
_DATA	SEGMENT
??_C@_0BH@EPHO@GetSelectStateOfEntity?$AA@ DB 'GetSelectStateOfEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@JBLI@SetAllSelectStatesForEntity?$AA@
_DATA	SEGMENT
??_C@_0BM@JBLI@SetAllSelectStatesForEntity?$AA@ DB 'SetAllSelectStatesFor'
	DB	'Entity', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IMDL@SetSelectStateOfEntity?$AA@
_DATA	SEGMENT
??_C@_0BH@IMDL@SetSelectStateOfEntity?$AA@ DB 'SetSelectStateOfEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@NKAP@RelinkInstanceToInstance?$AA@
_DATA	SEGMENT
??_C@_0BJ@NKAP@RelinkInstanceToInstance?$AA@ DB 'RelinkInstanceToInstance'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@HAMO@RelinkAllSubobjectsForOI?$AA@
_DATA	SEGMENT
??_C@_0BJ@HAMO@RelinkAllSubobjectsForOI?$AA@ DB 'RelinkAllSubobjectsForOI'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@PDG@LoadEntity?$AA@
_DATA	SEGMENT
??_C@_0L@PDG@LoadEntity?$AA@ DB 'LoadEntity', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@PEI@ObjectInstanceUpdated?$AA@
_DATA	SEGMENT
??_C@_0BG@PEI@ObjectInstanceUpdated?$AA@ DB 'ObjectInstanceUpdated', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@OOBH@ObjectInstanceUpdatedFromFile?$AA@
_DATA	SEGMENT
??_C@_0BO@OOBH@ObjectInstanceUpdatedFromFile?$AA@ DB 'ObjectInstanceUpdat'
	DB	'edFromFile', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@LHCP@GetValueFromRecord?$AA@
_DATA	SEGMENT
??_C@_0BD@LHCP@GetValueFromRecord?$AA@ DB 'GetValueFromRecord', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DIAC@StoreStringInRecord?$AA@
_DATA	SEGMENT
??_C@_0BE@DIAC@StoreStringInRecord?$AA@ DB 'StoreStringInRecord', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@MENK@GetStringFromRecord?$AA@
_DATA	SEGMENT
??_C@_0BE@MENK@GetStringFromRecord?$AA@ DB 'GetStringFromRecord', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@KGPF@SetEntityCursor?$AA@
_DATA	SEGMENT
??_C@_0BA@KGPF@SetEntityCursor?$AA@ DB 'SetEntityCursor', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@CMGB@GetAddrFromRecord?$AA@
_DATA	SEGMENT
??_C@_0BC@CMGB@GetAddrFromRecord?$AA@ DB 'GetAddrFromRecord', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@FOCF@MiGetParentEntityNameForView?$AA@
_DATA	SEGMENT
??_C@_0BN@FOCF@MiGetParentEntityNameForView?$AA@ DB 'MiGetParentEntityNam'
	DB	'eForView', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@PCOO@GetTaskDBHandlerTraceLevel?$AA@
_DATA	SEGMENT
??_C@_0BL@PCOO@GetTaskDBHandlerTraceLevel?$AA@ DB 'GetTaskDBHandlerTraceL'
	DB	'evel', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@NCHN@SetTaskDBHandlerTraceLevel?$AA@
_DATA	SEGMENT
??_C@_0BL@NCHN@SetTaskDBHandlerTraceLevel?$AA@ DB 'SetTaskDBHandlerTraceL'
	DB	'evel', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@GHM@GetAbsolutePositionForEntity?$AA@
_DATA	SEGMENT
??_C@_0BN@GHM@GetAbsolutePositionForEntity?$AA@ DB 'GetAbsolutePositionFo'
	DB	'rEntity', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@CBHE@GetEntityNameForHierarchicalCsr?$AA@
_DATA	SEGMENT
??_C@_0CA@CBHE@GetEntityNameForHierarchicalCsr?$AA@ DB 'GetEntityNameForH'
	DB	'ierarchicalCsr', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@EINL@SetCursorAbsolutePosition?$AA@
_DATA	SEGMENT
??_C@_0BK@EINL@SetCursorAbsolutePosition?$AA@ DB 'SetCursorAbsolutePositi'
	DB	'on', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@LLOG@OrderEntityForView?$AA@
_DATA	SEGMENT
??_C@_0BD@LLOG@OrderEntityForView?$AA@ DB 'OrderEntityForView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@JPO@CountEntitiesForView?$AA@
_DATA	SEGMENT
??_C@_0BF@JPO@CountEntitiesForView?$AA@ DB 'CountEntitiesForView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@DLHM@OrderOI_ByDefaultAttribs?$AA@
_DATA	SEGMENT
??_C@_0BJ@DLHM@OrderOI_ByDefaultAttribs?$AA@ DB 'OrderOI_ByDefaultAttribs'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@HLCK@OrderEntitiesByDefaultAttribs?$AA@
_DATA	SEGMENT
??_C@_0BO@HLCK@OrderEntitiesByDefaultAttribs?$AA@ DB 'OrderEntitiesByDefa'
	DB	'ultAttribs', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@GOEA@MiGetUpdateForViewEntityAttr?$AA@
_DATA	SEGMENT
??_C@_0BN@GOEA@MiGetUpdateForViewEntityAttr?$AA@ DB 'MiGetUpdateForViewEn'
	DB	'tityAttr', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@PBLM@MessageSend?$AA@
_DATA	SEGMENT
??_C@_0M@PBLM@MessageSend?$AA@ DB 'MessageSend', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@CLJA@MessagePrompt?$AA@
_DATA	SEGMENT
??_C@_0O@CLJA@MessagePrompt?$AA@ DB 'MessagePrompt', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@MCGA@MessagePromptForInput?$AA@
_DATA	SEGMENT
??_C@_0BG@MCGA@MessagePromptForInput?$AA@ DB 'MessagePromptForInput', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@HGJE@MessagePresent?$AA@
_DATA	SEGMENT
??_C@_0P@HGJE@MessagePresent?$AA@ DB 'MessagePresent', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@BKNM@MiGetTemporalStateOfEntity?$AA@
_DATA	SEGMENT
??_C@_0BL@BKNM@MiGetTemporalStateOfEntity?$AA@ DB 'MiGetTemporalStateOfEn'
	DB	'tity', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KBO@MiGetUpdateForView?$AA@
_DATA	SEGMENT
??_C@_0BD@KBO@MiGetUpdateForView?$AA@ DB 'MiGetUpdateForView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@INOA@MiGetInstanceID_ForView?$AA@
_DATA	SEGMENT
??_C@_0BI@INOA@MiGetInstanceID_ForView?$AA@ DB 'MiGetInstanceID_ForView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DOBB@MiGetDateTimeForOI?$AA@
_DATA	SEGMENT
??_C@_0BD@DOBB@MiGetDateTimeForOI?$AA@ DB 'MiGetDateTimeForOI', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@FHHI@MiGetERTokenForEntity?$AA@
_DATA	SEGMENT
??_C@_0BG@FHHI@MiGetERTokenForEntity?$AA@ DB 'MiGetERTokenForEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@KJIK@MiGetViewEntityForView?$AA@
_DATA	SEGMENT
??_C@_0BH@KJIK@MiGetViewEntityForView?$AA@ DB 'MiGetViewEntityForView', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@GNDO@UfAddToDateTime?$AA@
_DATA	SEGMENT
??_C@_0BA@GNDO@UfAddToDateTime?$AA@ DB 'UfAddToDateTime', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@NCOA@GetAttributeDisplayLength?$AA@
_DATA	SEGMENT
??_C@_0BK@NCOA@GetAttributeDisplayLength?$AA@ DB 'GetAttributeDisplayLeng'
	DB	'th', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@FFIH@MiGetCardinalityForEntity?$AA@
_DATA	SEGMENT
??_C@_0BK@FFIH@MiGetCardinalityForEntity?$AA@ DB 'MiGetCardinalityForEnti'
	DB	'ty', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@CJIE@NetActivateOI?$AA@
_DATA	SEGMENT
??_C@_0O@CJIE@NetActivateOI?$AA@ DB 'NetActivateOI', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FBGD@NetClose?$AA@
_DATA	SEGMENT
??_C@_08FBGD@NetClose?$AA@ DB 'NetClose', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@DLBE@NetCommitOI?$AA@
_DATA	SEGMENT
??_C@_0M@DLBE@NetCommitOI?$AA@ DB 'NetCommitOI', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@PHPI@NetGetTraceLevel?$AA@
_DATA	SEGMENT
??_C@_0BB@PHPI@NetGetTraceLevel?$AA@ DB 'NetGetTraceLevel', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_09HFPC@NetListen?$AA@
_DATA	SEGMENT
??_C@_09HFPC@NetListen?$AA@ DB 'NetListen', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@KDCL@NetStopListen?$AA@
_DATA	SEGMENT
??_C@_0O@KDCL@NetStopListen?$AA@ DB 'NetStopListen', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@KEJB@NetSetTraceLevel?$AA@
_DATA	SEGMENT
??_C@_0BB@KEJB@NetSetTraceLevel?$AA@ DB 'NetSetTraceLevel', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@BIJE@NetStartup?$AA@
_DATA	SEGMENT
??_C@_0L@BIJE@NetStartup?$AA@ DB 'NetStartup', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09MBHB@NetStatus?$AA@
_DATA	SEGMENT
??_C@_09MBHB@NetStatus?$AA@ DB 'NetStatus', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@EMEG@NetProcessMessage?$AA@
_DATA	SEGMENT
??_C@_0BC@EMEG@NetProcessMessage?$AA@ DB 'NetProcessMessage', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@IGEP@NetCommitOI_ToFile?$AA@
_DATA	SEGMENT
??_C@_0BD@IGEP@NetCommitOI_ToFile?$AA@ DB 'NetCommitOI_ToFile', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@FKGD@NetActivateOI_FromFile?$AA@
_DATA	SEGMENT
??_C@_0BH@FKGD@NetActivateOI_FromFile?$AA@ DB 'NetActivateOI_FromFile', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@HCAL@NetSendBootstrapFile?$AA@
_DATA	SEGMENT
??_C@_0BF@HCAL@NetSendBootstrapFile?$AA@ DB 'NetSendBootstrapFile', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@DPLM@NetCallOperation?$AA@
_DATA	SEGMENT
??_C@_0BB@DPLM@NetCallOperation?$AA@ DB 'NetCallOperation', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@KJLN@NetGetLocalHostAddress?$AA@
_DATA	SEGMENT
??_C@_0BH@KJLN@NetGetLocalHostAddress?$AA@ DB 'NetGetLocalHostAddress', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@BMMC@NetSendFile?$AA@
_DATA	SEGMENT
??_C@_0M@BMMC@NetSendFile?$AA@ DB 'NetSendFile', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@PDEP@SetIncrementalUpdateFlags?$AA@
_DATA	SEGMENT
??_C@_0BK@PDEP@SetIncrementalUpdateFlags?$AA@ DB 'SetIncrementalUpdateFla'
	DB	'gs', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@GACK@GetIncrementalUpdateFlags?$AA@
_DATA	SEGMENT
??_C@_0BK@GACK@GetIncrementalUpdateFlags?$AA@ DB 'GetIncrementalUpdateFla'
	DB	'gs', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@NAKK@SetBlobFromFile?$AA@
_DATA	SEGMENT
??_C@_0BA@NAKK@SetBlobFromFile?$AA@ DB 'SetBlobFromFile', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@HHIJ@WriteBlobToFile?$AA@
_DATA	SEGMENT
??_C@_0BA@HHIJ@WriteBlobToFile?$AA@ DB 'WriteBlobToFile', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@HLHF@SfCheckOI_Integrity?$AA@
_DATA	SEGMENT
??_C@_0BE@HLHF@SfCheckOI_Integrity?$AA@ DB 'SfCheckOI_Integrity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@JILI@GenerateQualFromEntityList?$AA@
_DATA	SEGMENT
??_C@_0BL@JILI@GenerateQualFromEntityList?$AA@ DB 'GenerateQualFromEntity'
	DB	'List', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@NLM@WriteOI_ToXML?$AA@
_DATA	SEGMENT
??_C@_0O@NLM@WriteOI_ToXML?$AA@ DB 'WriteOI_ToXML', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@MMDJ@WriteSubobjectToXML?$AA@
_DATA	SEGMENT
??_C@_0BE@MMDJ@WriteSubobjectToXML?$AA@ DB 'WriteSubobjectToXML', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@IOBH@CommitSubobjectToXML_File?$AA@
_DATA	SEGMENT
??_C@_0BK@IOBH@CommitSubobjectToXML_File?$AA@ DB 'CommitSubobjectToXML_Fi'
	DB	'le', 00H					; `string'
_DATA	ENDS
PUBLIC	_SysMessageBox@16
PUBLIC	_fnSetProcessIdx
PUBLIC	??_C@_0DC@JNDE@Exceeded?5Process?5Limit?5?4?4?4?5Conta@ ; `string'
EXTRN	__imp__GetCurrentProcessId@0:NEAR
;	COMDAT ??_C@_0DC@JNDE@Exceeded?5Process?5Limit?5?4?4?4?5Conta@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0DC@JNDE@Exceeded?5Process?5Limit?5?4?4?4?5Conta@ DB 'Exceeded Proc'
	DB	'ess Limit ... Contact Zeidon Support', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_ppProcessList$ = 12
_pOS_Record$ = -4
_fnSetProcessIdx PROC NEAR

; 415  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 416  :    LPANCHOROS_RECORD pOS_Record = &AnchorBlock->OS_Data;

	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 1503				; 000005dfH
	mov	DWORD PTR _pOS_Record$[ebp], eax

; 417  : 
; 418  :    if ( g_lProcessIdx == -1 )

	cmp	DWORD PTR _g_lProcessIdx, -1
	jne	SHORT $L60974

; 420  :       // Find an open cell in the Process record.
; 421  :       for ( g_lProcessIdx = 0;
; 422  :             pOS_Record->ProcessList[ g_lProcessIdx ].lProcessID != 0;
; 423  :             g_lProcessIdx++ )

	mov	DWORD PTR _g_lProcessIdx, 0
	jmp	SHORT $L60969
$L60970:
	mov	ecx, DWORD PTR _g_lProcessIdx
	add	ecx, 1
	mov	DWORD PTR _g_lProcessIdx, ecx
$L60969:
	mov	edx, DWORD PTR _g_lProcessIdx
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _pOS_Record$[ebp]
	cmp	DWORD PTR [eax+edx+24], 0
	je	SHORT $L60971

; 425  :          if ( g_lProcessIdx >= zMAX_PROCESSES )

	cmp	DWORD PTR _g_lProcessIdx, 50		; 00000032H
	jl	SHORT $L60972

; 427  :             SysMessageBox( 0, szlOE_SystemError, "Exceeded Process Limit ... Contact Zeidon Support", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0DC@JNDE@Exceeded?5Process?5Limit?5?4?4?4?5Conta@ ; `string'
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 428  :             break;

	jmp	SHORT $L60971
$L60972:

; 430  :       }

	jmp	SHORT $L60970
$L60971:

; 431  : 
; 432  :       // pOS_Record->lProcessCount keeps track of the highest process idx.
; 433  :       if ( g_lProcessIdx >= pOS_Record->lProcessCount )

	mov	edx, DWORD PTR _pOS_Record$[ebp]
	mov	eax, DWORD PTR _g_lProcessIdx
	cmp	eax, DWORD PTR [edx+4]
	jl	SHORT $L60974

; 434  :          pOS_Record->lProcessCount = g_lProcessIdx + 1;

	mov	ecx, DWORD PTR _g_lProcessIdx
	add	ecx, 1
	mov	edx, DWORD PTR _pOS_Record$[ebp]
	mov	DWORD PTR [edx+4], ecx
$L60974:

; 436  : 
; 437  :    *ppProcessList = &pOS_Record->ProcessList[ g_lProcessIdx ];

	mov	eax, DWORD PTR _g_lProcessIdx
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _pOS_Record$[ebp]
	lea	edx, DWORD PTR [ecx+eax+8]
	mov	eax, DWORD PTR _ppProcessList$[ebp]
	mov	DWORD PTR [eax], edx

; 438  :    (*ppProcessList)->lProcessID = GetCurrentProcessId( );

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	ecx, DWORD PTR _ppProcessList$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+16], eax

; 439  : 
; 440  : // TraceLine( "%s:  fnSetProcessIdx =======================>>>>> ProcessIdx: %d   CurrentProcess: %d",
; 441  : //            cpcText, g_lProcessIdx, (*ppProcessList)->lProcessID );
; 442  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSetProcessIdx ENDP
_TEXT	ENDS
PUBLIC	_FindWebSubtask@4
EXTRN	_fnStartBrowseOfTaskList@8:NEAR
EXTRN	_fnEndBrowseOfTaskList@4:NEAR
EXTRN	_strcmp:NEAR
_TEXT	SEGMENT
_cpcSessionId$ = 8
_lpTask$ = -4
_FindWebSubtask@4 PROC NEAR

; 461  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 462  :    LPTASK lpTask;
; 463  : 
; 464  :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $L60979

; 465  :       return( 0 );

	xor	eax, eax
	jmp	$L60993
$L60979:

; 466  : 
; 467  :    // Make sure nobody else is creating/deleting a task.
; 468  :    fnStartBrowseOfTaskList( AnchorBlock->hFirstTask, FALSE );

	push	0
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	_fnStartBrowseOfTaskList@8

; 469  : 
; 470  :    lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+130]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$L60982:

; 471  :    while ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$L60983

; 473  :       if ( lpTask->bTransientTask && lpTask->bShutdown == FALSE &&
; 474  :            zstrcmp( lpTask->szSessionId, cpcSessionId ) == 0 )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	je	SHORT $L60990
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 5
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L60990
	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, BYTE PTR [edx+194]
	mov	ecx, DWORD PTR _cpcSessionId$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $L64763
	mov	eax, DWORD PTR _cpcSessionId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 194				; 000000c2H
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64764
$L64763:
	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, BYTE PTR [edx+194]
	mov	ecx, DWORD PTR _cpcSessionId$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	xor	ecx, ecx
	test	eax, eax
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -8+[ebp], ecx
$L64764:
	cmp	DWORD PTR -8+[ebp], 0
	jne	SHORT $L60990

; 476  :          break;

	jmp	SHORT $L60983
$L60990:

; 478  : 
; 479  :       lpTask = zGETPTR( lpTask->hNextTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 480  :    }

	jmp	$L60982
$L60983:

; 481  : 
; 482  :    fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 483  : 
; 484  :    if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $L60992

; 485  :       return( lpTask->vWebSubtask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	jmp	SHORT $L60993
$L60992:

; 486  :    else
; 487  :       return( 0 );

	xor	eax, eax
$L60993:

; 488  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_FindWebSubtask@4 ENDP
_TEXT	ENDS
PUBLIC	_SysGetProcessID@4
EXTRN	__imp__GetCurrentThreadId@0:NEAR
_TEXT	SEGMENT
_plThreadID$ = 8
_lProcessID$ = -4
_SysGetProcessID@4 PROC NEAR

; 506  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 507  :    zLONG lProcessID = (zLONG) GetCurrentProcessId( );

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	DWORD PTR _lProcessID$[ebp], eax

; 508  :    if ( plThreadID )

	cmp	DWORD PTR _plThreadID$[ebp], 0
	je	SHORT $L60999

; 509  :       *plThreadID = (zLONG) GetCurrentThreadId( );

	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	ecx, DWORD PTR _plThreadID$[ebp]
	mov	DWORD PTR [ecx], eax
$L60999:

; 510  : 
; 511  :    return( lProcessID );

	mov	eax, DWORD PTR _lProcessID$[ebp]

; 512  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetProcessID@4 ENDP
_TEXT	ENDS
PUBLIC	_SysGetTaskFromView@4
_TEXT	SEGMENT
_lpView$ = 8
_SysGetTaskFromView@4 PROC NEAR

; 530  : {

	push	ebp
	mov	ebp, esp

; 531  :    if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $L61004

; 532  :       return( (zLONG) lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [eax+14]
	jmp	SHORT $L61006
$L61004:

; 533  :    else
; 534  :       return( 0 );

	xor	eax, eax
$L61006:

; 535  : }

	pop	ebp
	ret	4
_SysGetTaskFromView@4 ENDP
_TEXT	ENDS
PUBLIC	_SysSetDefaultTaskForProcess@4
PUBLIC	??_C@_0CH@FEHM@SysSetDefaultTaskForProcess?5Depr@ ; `string'
PUBLIC	??_C@_0BH@MPNN@Zeidon?5Object?5Services?$AA@	; `string'
;	COMDAT ??_C@_0CH@FEHM@SysSetDefaultTaskForProcess?5Depr@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CH@FEHM@SysSetDefaultTaskForProcess?5Depr@ DB 'SysSetDefaultTaskFo'
	DB	'rProcess Deprecated', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@MPNN@Zeidon?5Object?5Services?$AA@
_DATA	SEGMENT
??_C@_0BH@MPNN@Zeidon?5Object?5Services?$AA@ DB 'Zeidon Object Services', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vTaskView$ = 8
_SysSetDefaultTaskForProcess@4 PROC NEAR

; 539  : {

	push	ebp
	mov	ebp, esp

; 540  :    SysMessageBox( vTaskView, "Zeidon Object Services",
; 541  :                   "SysSetDefaultTaskForProcess Deprecated", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0CH@FEHM@SysSetDefaultTaskForProcess?5Depr@ ; `string'
	push	OFFSET FLAT:??_C@_0BH@MPNN@Zeidon?5Object?5Services?$AA@ ; `string'
	mov	eax, DWORD PTR _vTaskView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 542  :    return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H

; 550  : 
; 551  :    g_vDefaultTaskView = vTaskView;
; 552  :    return( 0 );
; 553  : }

	pop	ebp
	ret	4
_SysSetDefaultTaskForProcess@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_03JBJA@ON?5?$AA@				; `string'
PUBLIC	??_C@_03CMJG@OFF?$AA@				; `string'
PUBLIC	??_C@_0DJ@GGNM@Session?5Id?3?5?$CFs?5?5?$DN?$DN?$DO?5?$CFs?5?$CI?$CFs?$CJ?5?5Thr@ ; `string'
PUBLIC	??_C@_0DF@MIGE@STP?5S?1V?1T?3?5?$CFs?10x?$CF08x?10x?$CF08x?5?5?$DN?$DN?$DO@ ; `string'
PUBLIC	??_C@_0FF@GKII@STP?5S?1V?1T?3?5?$CFs?10x?$CF08x?10x?$CF08x?5?5?$DN?$DN?$DO@ ; `string'
PUBLIC	_SysGetDateTime@4
PUBLIC	_SetTransientTaskProcess@16
EXTRN	_TraceLine:NEAR
EXTRN	__imp__EnterCriticalSection@4:NEAR
EXTRN	__imp__LeaveCriticalSection@4:NEAR
;	COMDAT ??_C@_03JBJA@ON?5?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_03JBJA@ON?5?$AA@ DB 'ON ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03CMJG@OFF?$AA@
_DATA	SEGMENT
??_C@_03CMJG@OFF?$AA@ DB 'OFF', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@GGNM@Session?5Id?3?5?$CFs?5?5?$DN?$DN?$DO?5?$CFs?5?$CI?$CFs?$CJ?5?5Thr@
_DATA	SEGMENT
??_C@_0DJ@GGNM@Session?5Id?3?5?$CFs?5?5?$DN?$DN?$DO?5?$CFs?5?$CI?$CFs?$CJ?5?5Thr@ DB 'S'
	DB	'ession Id: %s  ==> %s (%s)  Thread: %d ... null Subtask', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DF@MIGE@STP?5S?1V?1T?3?5?$CFs?10x?$CF08x?10x?$CF08x?5?5?$DN?$DN?$DO@
_DATA	SEGMENT
??_C@_0DF@MIGE@STP?5S?1V?1T?3?5?$CFs?10x?$CF08x?10x?$CF08x?5?5?$DN?$DN?$DO@ DB 'S'
	DB	'TP S/V/T: %s/0x%08x/0x%08x  ==> %s (%s)  Thread: %d', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FF@GKII@STP?5S?1V?1T?3?5?$CFs?10x?$CF08x?10x?$CF08x?5?5?$DN?$DN?$DO@
_DATA	SEGMENT
??_C@_0FF@GKII@STP?5S?1V?1T?3?5?$CFs?10x?$CF08x?10x?$CF08x?5?5?$DN?$DN?$DO@ DB 'S'
	DB	'TP S/V/T: %s/0x%08x/0x%08x  ==> Conflict with Task Session Id'
	DB	': %s  (%s)  Thread: %d', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_cpcSessionId$ = 8
_vSubtask$ = 12
_bOn$ = 16
_cpcTitle$ = 20
_lpTask$ = -8
_lProcessID$ = -4
_lThreadID$ = -12
_SetTransientTaskProcess@16 PROC NEAR

; 640  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 641  :    LPTASK lpTask;
; 642  :    zLONG  lProcessID;
; 643  :    zLONG  lThreadID;
; 644  : 
; 645  :    lProcessID = SysGetProcessID( &lThreadID );

	lea	eax, DWORD PTR _lThreadID$[ebp]
	push	eax
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 646  :    if ( vSubtask == 0 )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	jne	SHORT $L61026

; 648  :       TraceLine( "Session Id: %s  ==> %s (%s)  Thread: %d ... null Subtask",
; 649  :                  cpcSessionId, bOn ? "ON " : "OFF", cpcTitle, lThreadID );

	mov	ecx, DWORD PTR _bOn$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L64769
	mov	DWORD PTR -16+[ebp], OFFSET FLAT:??_C@_03JBJA@ON?5?$AA@ ; `string'
	jmp	SHORT $L64770
$L64769:
	mov	DWORD PTR -16+[ebp], OFFSET FLAT:??_C@_03CMJG@OFF?$AA@ ; `string'
$L64770:
	mov	edx, DWORD PTR _lThreadID$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR -16+[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcSessionId$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0DJ@GGNM@Session?5Id?3?5?$CFs?5?5?$DN?$DN?$DO?5?$CFs?5?$CI?$CFs?$CJ?5?5Thr@ ; `string'
	call	_TraceLine
	add	esp, 20					; 00000014H

; 650  :       return( -1 );

	or	eax, -1
	jmp	$L61022
$L61026:

; 652  : 
; 653  :    lpTask = zGETPTR( vSubtask->hTask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 654  :    if ( lpTask->bWebTrace )

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	shr	eax, 12					; 0000000cH
	and	eax, 1
	test	eax, eax
	je	SHORT $L61031

; 656  :       TraceLine( "STP S/V/T: %s/0x%08x/0x%08x  ==> %s (%s)  Thread: %d",
; 657  :                  cpcSessionId, vSubtask, vSubtask->hTask, bOn ? "ON " : "OFF", cpcTitle, lThreadID );

	mov	ecx, DWORD PTR _bOn$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L64771
	mov	DWORD PTR -20+[ebp], OFFSET FLAT:??_C@_03JBJA@ON?5?$AA@ ; `string'
	jmp	SHORT $L64772
$L64771:
	mov	DWORD PTR -20+[ebp], OFFSET FLAT:??_C@_03CMJG@OFF?$AA@ ; `string'
$L64772:
	mov	edx, DWORD PTR _lThreadID$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR -20+[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcSessionId$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0DF@MIGE@STP?5S?1V?1T?3?5?$CFs?10x?$CF08x?10x?$CF08x?5?5?$DN?$DN?$DO@ ; `string'
	call	_TraceLine
	add	esp, 28					; 0000001cH
$L61031:

; 659  : 
; 660  :    if ( zstrcmp( cpcSessionId, lpTask->szSessionId ) != 0 )

	mov	eax, DWORD PTR _cpcSessionId$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, BYTE PTR [edx+194]
	cmp	ecx, eax
	jne	SHORT $L64773
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 194				; 000000c2H
	push	ecx
	mov	edx, DWORD PTR _cpcSessionId$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L64774
$L64773:
	mov	eax, DWORD PTR _cpcSessionId$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, BYTE PTR [edx+194]
	sub	ecx, eax
	xor	edx, edx
	test	ecx, ecx
	setle	dl
	dec	edx
	and	edx, 2
	add	edx, -1
	mov	DWORD PTR -24+[ebp], edx
$L64774:
	cmp	DWORD PTR -24+[ebp], 0
	je	SHORT $L61039

; 662  :       TraceLine( "STP S/V/T: %s/0x%08x/0x%08x  ==> Conflict with Task Session Id: %s  (%s)  Thread: %d",
; 663  :                  cpcSessionId, vSubtask, vSubtask->hTask, lpTask->szSessionId, cpcTitle, lThreadID );

	mov	eax, DWORD PTR _lThreadID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	add	edx, 194				; 000000c2H
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcSessionId$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0FF@GKII@STP?5S?1V?1T?3?5?$CFs?10x?$CF08x?10x?$CF08x?5?5?$DN?$DN?$DO@ ; `string'
	call	_TraceLine
	add	esp, 28					; 0000001cH
$L61039:

; 666  : 
; 667  :    if ( bOn )

	mov	ecx, DWORD PTR _bOn$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L61041

; 669  :       // Lock critical section so other threads don't muck stuff.
; 670  :       EnterCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+439]
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4

; 671  :    // TraceLine( "EnterCriticalSection STP S/V/T: %s/0x%08x/0x%08x  ==> %s (%s)  Thread: %d",
; 672  :    //            cpcSessionId, vSubtask, vSubtask->hTask, bOn ? "ON " : "OFF", cpcTitle, lThreadID );
; 673  : #if 1
; 674  :       SysGetDateTime( lpTask->szTimeStamp );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 174				; 000000aeH
	push	ecx
	call	_SysGetDateTime@4

; 687  :    else

	jmp	SHORT $L61043
$L61041:

; 689  : #if 0 // The task is running as a thread within the process, so the resources should be
; 690  :       // good to go.
; 691  :       fnCloseTaskNetworkModules( lpTask );
; 692  :       fnDropTaskHandlers( lpTask );
; 693  :       fnCloseTaskOpenFiles( lpTask );
; 694  :       fnDropTaskDomains( lpTask );
; 695  :       fnFreeTaskModules( lpTask );
; 696  :       fnDropTaskOperations( lpTask );
; 697  :       fnDropTaskMutexes( lpTask );
; 698  : #endif
; 699  : 
; 700  :    // TraceLine( "LeaveCriticalSection STP S/V/T: %s/0x%08x/0x%08x  ==> %s (%s)  Thread: %d",
; 701  :    //            cpcSessionId, vSubtask, vSubtask->hTask, bOn ? "ON " : "OFF", cpcTitle, lThreadID );
; 702  :       LeaveCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+439]
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4
$L61043:

; 706  : 
; 707  :    return( 0 );

	xor	eax, eax
$L61022:

; 708  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SetTransientTaskProcess@16 ENDP
_TEXT	ENDS
PUBLIC	_SysReadZeidonIni@16
PUBLIC	??_C@_05JBPC@?$FLApp?4?$AA@			; `string'
PUBLIC	??_C@_01FIMD@?$FN?$AA@				; `string'
PUBLIC	??_C@_0N@OCBP@WebDirectory?$AA@			; `string'
PUBLIC	??_C@_0O@IMEJ@?$FLWorkstation?$FN?$AA@		; `string'
PUBLIC	??_C@_06JJCH@0x?$CF08x?$AA@			; `string'
PUBLIC	_SysAppendcDirSep@4
PUBLIC	_SysMakeWebFileName@12
EXTRN	_SfGetApplicationForSubtask@8:NEAR
EXTRN	__imp__sprintf:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_strcat:NEAR
EXTRN	_strlen:NEAR
;	COMDAT ??_C@_05JBPC@?$FLApp?4?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_05JBPC@?$FLApp?4?$AA@ DB '[App.', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FIMD@?$FN?$AA@
_DATA	SEGMENT
??_C@_01FIMD@?$FN?$AA@ DB ']', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@OCBP@WebDirectory?$AA@
_DATA	SEGMENT
??_C@_0N@OCBP@WebDirectory?$AA@ DB 'WebDirectory', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@IMEJ@?$FLWorkstation?$FN?$AA@
_DATA	SEGMENT
??_C@_0O@IMEJ@?$FLWorkstation?$FN?$AA@ DB '[Workstation]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JJCH@0x?$CF08x?$AA@
_DATA	SEGMENT
??_C@_06JJCH@0x?$CF08x?$AA@ DB '0x%08x', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchReturnName$ = 8
_v$ = 12
_lFlags$ = 16
_lpApp$ = -72
_lpTask$ = -68
_szName$ = -64
_SysMakeWebFileName@12 PROC NEAR

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 713  :    LPAPP  lpApp;
; 714  :    LPTASK lpTask;
; 715  :    zCHAR  szName[ 64 ];
; 716  : 
; 717  :    SfGetApplicationForSubtask( &lpApp, v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_SfGetApplicationForSubtask@8

; 718  : 
; 719  :    pchReturnName[ 0 ] = 0;

	mov	edx, DWORD PTR _pchReturnName$[ebp]
	mov	BYTE PTR [edx], 0

; 720  :    if ( lFlags & 0x00000001 )  // use Application

	mov	eax, DWORD PTR _lFlags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L61055

; 722  :       if ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $L61056

; 723  :          zstrcpy( pchReturnName, lpApp->szLocalDir );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 604				; 0000025cH
	push	ecx
	mov	edx, DWORD PTR _pchReturnName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L61056:

; 725  :    else

	jmp	SHORT $L61063
$L61055:

; 726  :    if ( lFlags & 0x00000002 )  // use Ini WebDirectory

	mov	eax, DWORD PTR _lFlags$[ebp]
	and	eax, 2
	test	eax, eax
	je	SHORT $L61063

; 728  :       if ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $L61059

; 730  :          zstrcpy( szName, "[App." );

	push	OFFSET FLAT:??_C@_05JBPC@?$FLApp?4?$AA@	; `string'
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 731  :          zstrcpy( szName + 5, lpApp->szName );

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 6
	push	edx
	lea	eax, DWORD PTR _szName$[ebp+5]
	push	eax
	call	_strcpy
	add	esp, 8

; 732  :          zstrcat( szName, "]" );

	push	OFFSET FLAT:??_C@_01FIMD@?$FN?$AA@	; `string'
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 733  :          SysReadZeidonIni( -1, szName, "WebDirectory", pchReturnName );

	mov	edx, DWORD PTR _pchReturnName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0N@OCBP@WebDirectory?$AA@ ; `string'
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	push	-1
	call	_SysReadZeidonIni@16
$L61059:

; 735  : 
; 736  :       if ( pchReturnName[ 0 ] == 0 )

	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L61063

; 737  :          SysReadZeidonIni( -1, "[Workstation]", "WebDirectory", pchReturnName );

	mov	eax, DWORD PTR _pchReturnName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0N@OCBP@WebDirectory?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0O@IMEJ@?$FLWorkstation?$FN?$AA@ ; `string'
	push	-1
	call	_SysReadZeidonIni@16
$L61063:

; 739  : 
; 740  :    if ( pchReturnName[ 0 ] )

	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L61065

; 741  :       SysAppendcDirSep( pchReturnName );

	mov	eax, DWORD PTR _pchReturnName$[ebp]
	push	eax
	call	_SysAppendcDirSep@4
$L61065:

; 742  : 
; 743  :    lpTask = zGETPTR( v->hTask );

	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 744  :    if ( lpTask->szSessionId[ 0 ] )

	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, BYTE PTR [eax+194]
	test	ecx, ecx
	je	SHORT $L61067

; 746  :       szName[ 0 ] = 's';

	mov	BYTE PTR _szName$[ebp], 115		; 00000073H

; 747  :       szName[ 1 ] = 'i';

	mov	BYTE PTR _szName$[ebp+1], 105		; 00000069H

; 748  :       zstrcpy( szName + 2, lpTask->szSessionId );

	mov	edx, DWORD PTR _lpTask$[ebp]
	add	edx, 194				; 000000c2H
	push	edx
	lea	eax, DWORD PTR _szName$[ebp+2]
	push	eax
	call	_strcpy
	add	esp, 8

; 750  :    else

	jmp	SHORT $L61068
$L61067:

; 752  :       zsprintf( szName, "0x%08x", v );

	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_06JJCH@0x?$CF08x?$AA@	; `string'
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L61068:

; 754  : 
; 755  :    zstrcat( pchReturnName, szName );

	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 756  : // TraceLineS( "SysMakeWebFileName: ", pchReturnName );
; 757  :    return( zstrlen( pchReturnName ) );

	mov	edx, DWORD PTR _pchReturnName$[ebp]
	push	edx
	call	_strlen
	add	esp, 4

; 758  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysMakeWebFileName@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_08GACC@KZXMLPGO?$AA@			; `string'
PUBLIC	??_C@_0L@IKFC@DialogName?$AA@			; `string'
PUBLIC	??_C@_06FPEO@Dialog?$AA@			; `string'
PUBLIC	??_C@_0L@CJHF@WindowName?$AA@			; `string'
PUBLIC	??_C@_06FCEH@Window?$AA@			; `string'
PUBLIC	??_C@_09KCAL@FocusCtrl?$AA@			; `string'
PUBLIC	_SysSetFocusToWebCtrl@20
EXTRN	__imp___ltoa:NEAR
EXTRN	_GetViewByName@16:NEAR
EXTRN	_CreateEntity@12:NEAR
EXTRN	_GetEntityKey@8:NEAR
EXTRN	_SetCursorFirstEntityByString@20:NEAR
EXTRN	_SetAttributeFromString@16:NEAR
;	COMDAT ??_C@_08GACC@KZXMLPGO?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_08GACC@KZXMLPGO?$AA@ DB 'KZXMLPGO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@IKFC@DialogName?$AA@
_DATA	SEGMENT
??_C@_0L@IKFC@DialogName?$AA@ DB 'DialogName', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06FPEO@Dialog?$AA@
_DATA	SEGMENT
??_C@_06FPEO@Dialog?$AA@ DB 'Dialog', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@CJHF@WindowName?$AA@
_DATA	SEGMENT
??_C@_0L@CJHF@WindowName?$AA@ DB 'WindowName', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06FCEH@Window?$AA@
_DATA	SEGMENT
??_C@_06FCEH@Window?$AA@ DB 'Window', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09KCAL@FocusCtrl?$AA@
_DATA	SEGMENT
??_C@_09KCAL@FocusCtrl?$AA@ DB 'FocusCtrl', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_v$ = 8
_cpcDialog$ = 12
_cpcWindow$ = 16
_cpcEntity$ = 20
_cpcCtrlTag$ = 24
_vKZXMLPGO$ = -4
_szFullCtrlTag$61084 = -68
_lKey$61094 = -76
_nLth$61095 = -72
_SysSetFocusToWebCtrl@20 PROC NEAR

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 764  :    zVIEW      vKZXMLPGO;
; 765  : 
; 766  :    GetViewByName( &vKZXMLPGO, "KZXMLPGO", v, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08GACC@KZXMLPGO?$AA@	; `string'
	lea	ecx, DWORD PTR _vKZXMLPGO$[ebp]
	push	ecx
	call	_GetViewByName@16

; 767  :    if ( vKZXMLPGO )

	cmp	DWORD PTR _vKZXMLPGO$[ebp], 0
	je	$L61083

; 769  :       zCHAR szFullCtrlTag[ 64 ];
; 770  : 
; 771  :       if ( SetCursorFirstEntityByString( vKZXMLPGO, "Dialog", "DialogName",
; 772  :                                          cpcDialog, "" ) < zCURSOR_SET )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	edx, DWORD PTR _cpcDialog$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0L@IKFC@DialogName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06FPEO@Dialog?$AA@	; `string'
	mov	eax, DWORD PTR _vKZXMLPGO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $L61085

; 774  :          CreateEntity( vKZXMLPGO, "Dialog", zPOS_FIRST );

	push	1
	push	OFFSET FLAT:??_C@_06FPEO@Dialog?$AA@	; `string'
	mov	edx, DWORD PTR _vKZXMLPGO$[ebp]
	push	edx
	call	_CreateEntity@12

; 775  :          SetAttributeFromString( vKZXMLPGO, "Dialog", "DialogName", cpcDialog );

	mov	eax, DWORD PTR _cpcDialog$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@IKFC@DialogName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06FPEO@Dialog?$AA@	; `string'
	mov	ecx, DWORD PTR _vKZXMLPGO$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$L61085:

; 777  : 
; 778  :       if ( SetCursorFirstEntityByString( vKZXMLPGO, "Window", "WindowName",
; 779  :                                          cpcWindow, "" ) < zCURSOR_SET )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	edx, DWORD PTR _cpcWindow$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0L@CJHF@WindowName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06FCEH@Window?$AA@	; `string'
	mov	eax, DWORD PTR _vKZXMLPGO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $L61089

; 781  :          CreateEntity( vKZXMLPGO, "Window", zPOS_FIRST );

	push	1
	push	OFFSET FLAT:??_C@_06FCEH@Window?$AA@	; `string'
	mov	edx, DWORD PTR _vKZXMLPGO$[ebp]
	push	edx
	call	_CreateEntity@12

; 782  :          SetAttributeFromString( vKZXMLPGO, "Window", "WindowName", cpcWindow );

	mov	eax, DWORD PTR _cpcWindow$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@CJHF@WindowName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06FCEH@Window?$AA@	; `string'
	mov	ecx, DWORD PTR _vKZXMLPGO$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$L61089:

; 784  : 
; 785  :       if ( cpcEntity && cpcEntity[ 0 ] )

	cmp	DWORD PTR _cpcEntity$[ebp], 0
	je	SHORT $L61093
	mov	edx, DWORD PTR _cpcEntity$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L61093

; 787  :          zLONG  lKey = GetEntityKey( v, cpcEntity );

	mov	ecx, DWORD PTR _cpcEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	call	_GetEntityKey@8
	mov	DWORD PTR _lKey$61094[ebp], eax

; 788  :          zSHORT nLth;
; 789  : 
; 790  :          szFullCtrlTag[ 0 ] = '@';

	mov	BYTE PTR _szFullCtrlTag$61084[ebp], 64	; 00000040H

; 791  :          zstrcpy( szFullCtrlTag + 1, cpcCtrlTag );

	mov	eax, DWORD PTR _cpcCtrlTag$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFullCtrlTag$61084[ebp+1]
	push	ecx
	call	_strcpy
	add	esp, 8

; 792  :          nLth = zstrlen( szFullCtrlTag );

	lea	edx, DWORD PTR _szFullCtrlTag$61084[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$61095[ebp], ax

; 793  :          szFullCtrlTag[ nLth++ ] = '#';

	movsx	eax, WORD PTR _nLth$61095[ebp]
	mov	BYTE PTR _szFullCtrlTag$61084[ebp+eax], 35 ; 00000023H
	mov	cx, WORD PTR _nLth$61095[ebp]
	add	cx, 1
	mov	WORD PTR _nLth$61095[ebp], cx

; 794  :          zltoa( lKey, szFullCtrlTag + nLth );

	push	10					; 0000000aH
	movsx	edx, WORD PTR _nLth$61095[ebp]
	lea	eax, DWORD PTR _szFullCtrlTag$61084[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _lKey$61094[ebp]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 796  :       else

	jmp	SHORT $L61096
$L61093:

; 797  :          zstrcpy( szFullCtrlTag, cpcCtrlTag );

	mov	edx, DWORD PTR _cpcCtrlTag$[ebp]
	push	edx
	lea	eax, DWORD PTR _szFullCtrlTag$61084[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L61096:

; 798  : 
; 799  :       SetAttributeFromString( vKZXMLPGO, "Window", "FocusCtrl", szFullCtrlTag );

	lea	ecx, DWORD PTR _szFullCtrlTag$61084[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_09KCAL@FocusCtrl?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06FCEH@Window?$AA@	; `string'
	mov	edx, DWORD PTR _vKZXMLPGO$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 800  : 
; 801  :       return( 0 );

	xor	ax, ax
	jmp	SHORT $L61080
$L61083:

; 803  : 
; 804  :    return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
$L61080:

; 805  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SysSetFocusToWebCtrl@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@GCAG@DynamicBannerName?$AA@		; `string'
PUBLIC	??_C@_0L@PIKM@BannerName?$AA@			; `string'
PUBLIC	_SysSetWebBannerName@12
;	COMDAT ??_C@_0BC@GCAG@DynamicBannerName?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BC@GCAG@DynamicBannerName?$AA@ DB 'DynamicBannerName', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@PIKM@BannerName?$AA@
_DATA	SEGMENT
??_C@_0L@PIKM@BannerName?$AA@ DB 'BannerName', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_v$ = 8
_cpcDialog$ = 12
_cpcBannerName$ = 16
_vKZXMLPGO$ = -4
_SysSetWebBannerName@12 PROC NEAR

; 809  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 810  :    zVIEW      vKZXMLPGO;
; 811  : 
; 812  :    GetViewByName( &vKZXMLPGO, "KZXMLPGO", v, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08GACC@KZXMLPGO?$AA@	; `string'
	lea	ecx, DWORD PTR _vKZXMLPGO$[ebp]
	push	ecx
	call	_GetViewByName@16

; 813  :    if ( vKZXMLPGO )

	cmp	DWORD PTR _vKZXMLPGO$[ebp], 0
	je	SHORT $L61106

; 815  :       if ( SetCursorFirstEntityByString( vKZXMLPGO, "DynamicBannerName", "DialogName",
; 816  :                                          cpcDialog, "" ) < zCURSOR_SET )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	edx, DWORD PTR _cpcDialog$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0L@IKFC@DialogName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BC@GCAG@DynamicBannerName?$AA@ ; `string'
	mov	eax, DWORD PTR _vKZXMLPGO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $L61107

; 818  :          CreateEntity( vKZXMLPGO, "DynamicBannerName", zPOS_FIRST );

	push	1
	push	OFFSET FLAT:??_C@_0BC@GCAG@DynamicBannerName?$AA@ ; `string'
	mov	edx, DWORD PTR _vKZXMLPGO$[ebp]
	push	edx
	call	_CreateEntity@12

; 819  :          SetAttributeFromString( vKZXMLPGO, "DynamicBannerName",
; 820  :                                  "DialogName", cpcDialog );

	mov	eax, DWORD PTR _cpcDialog$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@IKFC@DialogName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BC@GCAG@DynamicBannerName?$AA@ ; `string'
	mov	ecx, DWORD PTR _vKZXMLPGO$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$L61107:

; 822  : 
; 823  :       SetAttributeFromString( vKZXMLPGO, "DynamicBannerName", "BannerName", cpcBannerName );

	mov	edx, DWORD PTR _cpcBannerName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0L@PIKM@BannerName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BC@GCAG@DynamicBannerName?$AA@ ; `string'
	mov	eax, DWORD PTR _vKZXMLPGO$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 824  : 
; 825  :       return( 0 );

	xor	ax, ax
	jmp	SHORT $L61104
$L61106:

; 827  : 
; 828  :    return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
$L61104:

; 829  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysSetWebBannerName@12 ENDP
_TEXT	ENDS
PUBLIC	_SysGetWebBannerName@12
EXTRN	_GetStringFromAttribute@16:NEAR
_TEXT	SEGMENT
_v$ = 8
_cpcDialog$ = 12
_pchBannerName$ = 16
_vKZXMLPGO$ = -4
_SysGetWebBannerName@12 PROC NEAR

; 833  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 834  :    zVIEW      vKZXMLPGO;
; 835  : 
; 836  :    pchBannerName[ 0 ] = 0;

	mov	eax, DWORD PTR _pchBannerName$[ebp]
	mov	BYTE PTR [eax], 0

; 837  :    GetViewByName( &vKZXMLPGO, "KZXMLPGO", v, zLEVEL_TASK );

	push	2
	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_08GACC@KZXMLPGO?$AA@	; `string'
	lea	edx, DWORD PTR _vKZXMLPGO$[ebp]
	push	edx
	call	_GetViewByName@16

; 838  :    if ( vKZXMLPGO )

	cmp	DWORD PTR _vKZXMLPGO$[ebp], 0
	je	SHORT $L61119

; 840  :       if ( SetCursorFirstEntityByString( vKZXMLPGO, "DynamicBannerName", "DialogName",
; 841  :                                          cpcDialog, "" ) >= zCURSOR_SET )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	eax, DWORD PTR _cpcDialog$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@IKFC@DialogName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BC@GCAG@DynamicBannerName?$AA@ ; `string'
	mov	ecx, DWORD PTR _vKZXMLPGO$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByString@20
	movsx	edx, ax
	test	edx, edx
	jl	SHORT $L61120

; 843  :          GetStringFromAttribute( pchBannerName, vKZXMLPGO,
; 844  :                                  "DynamicBannerName", "DialogName" );

	push	OFFSET FLAT:??_C@_0L@IKFC@DialogName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BC@GCAG@DynamicBannerName?$AA@ ; `string'
	mov	eax, DWORD PTR _vKZXMLPGO$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBannerName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16
$L61120:

; 846  : 
; 847  :       return( 0 );

	xor	ax, ax
	jmp	SHORT $L61117
$L61119:

; 849  : 
; 850  :    return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
$L61117:

; 851  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysGetWebBannerName@12 ENDP
_TEXT	ENDS
PUBLIC	_SysSendOE_Message@8
PUBLIC	_RegisterZeidonApplication@28
PUBLIC	??_C@_0BH@IIPE@KZOENGWA?5?9?5Termination?$AA@	; `string'
PUBLIC	??_C@_0GN@DNGN@The?5Zeidon?5Object?5Engine?5hasn?8t?5@ ; `string'
PUBLIC	??_C@_0BG@KHAA@InitCriticalSection?3?5?$AA@	; `string'
PUBLIC	??_C@_0GC@PKCM@RegisterZeidonApplication?5?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0GH@BDLJ@RegisterZeidonApplication?5?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	_fnSysLockCoreMutex@4
PUBLIC	_fnSysUnlockCoreMutex@4
PUBLIC	_SysStartObjectServices
PUBLIC	_fnFreeSharedMemory@8
PUBLIC	_SysDescribeZeidonPageTable@4
EXTRN	_fnCreateTask:NEAR
EXTRN	_TraceLineS@8:NEAR
EXTRN	__imp__calloc:NEAR
EXTRN	_SetViewFlags@8:NEAR
EXTRN	__imp__InitializeCriticalSection@4:NEAR
EXTRN	_SfStartNetworks@8:NEAR
EXTRN	_ActivateViewObject@12:NEAR
EXTRN	__imp__OpenMutexA@12:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
EXTRN	_fnStoreStringInDataspace:NEAR
EXTRN	__imp__GetActiveWindow@0:NEAR
EXTRN	__imp__MessageBoxA@16:NEAR
EXTRN	_fnParseAppString:NEAR
EXTRN	_fnCreateApp:NEAR
EXTRN	_DeleteTask@4:NEAR
;	COMDAT ??_C@_0BH@IIPE@KZOENGWA?5?9?5Termination?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BH@IIPE@KZOENGWA?5?9?5Termination?$AA@ DB 'KZOENGWA - Termination', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0GN@DNGN@The?5Zeidon?5Object?5Engine?5hasn?8t?5@
_DATA	SEGMENT
??_C@_0GN@DNGN@The?5Zeidon?5Object?5Engine?5hasn?8t?5@ DB 'The Zeidon Obj'
	DB	'ect Engine hasn''t finished shutting down. Please wait for th'
	DB	'e engine to shut down and restart.', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@KHAA@InitCriticalSection?3?5?$AA@
_DATA	SEGMENT
??_C@_0BG@KHAA@InitCriticalSection?3?5?$AA@ DB 'InitCriticalSection: ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0GC@PKCM@RegisterZeidonApplication?5?$DN?$DN?$DN?$DN?$DN?$DN@
_DATA	SEGMENT
??_C@_0GC@PKCM@RegisterZeidonApplication?5?$DN?$DN?$DN?$DN?$DN?$DN@ DB 'R'
	DB	'egisterZeidonApplication ===============> %s   V/Task: 0x%08x'
	DB	' / 0x%08x  Process: %d   Thread: %d', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0GH@BDLJ@RegisterZeidonApplication?5?$DN?$DN?$DN?$DN?$DN?$DN@
_DATA	SEGMENT
??_C@_0GH@BDLJ@RegisterZeidonApplication?5?$DN?$DN?$DN?$DN?$DN?$DN@ DB 'R'
	DB	'egisterZeidonApplication ===============> %s   Process: %d   '
	DB	'Thread: %d   Memory: %s   Wnd: 0x%08x=%d', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pvSubtask$ = 8
_lSystemInstance$ = 12
_lMainWnd$ = 16
_lMsg$ = 20
_cpcAppString$ = 24
_cpcControlData$ = 28
_lControl$ = 32
_szTaskTitle$ = -588
_szAppName$ = -656
_szUserID$ = -328
_szDialog$ = -728
_szPassword$ = -800
_szCommand$ = -260
_lpApp$ = -664
_lpTask$ = -592
_hWndMain$ = -332
_hMutex$ = -736
_lProcessID$ = -4
_lThreadID$ = -660
_k$ = -732
_nRC$ = -264
_lpFirstSubtask$61160 = -804
_chWebTrace$61169 = -808
_RegisterZeidonApplication@28 PROC NEAR

; 922  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 808				; 00000328H

; 923  :    char   szTaskTitle[ 256 ];
; 924  :    char   szAppName[ 64 ];
; 925  :    char   szUserID[ 64 ];
; 926  :    char   szDialog[ 64 ];
; 927  :    char   szPassword[ 64 ];
; 928  :    char   szCommand[ 256 ];
; 929  :    LPAPP  lpApp;
; 930  :    LPTASK lpTask;
; 931  :    HWND   hWndMain = (HWND) lMainWnd;

	mov	eax, DWORD PTR _lMainWnd$[ebp]
	mov	DWORD PTR _hWndMain$[ebp], eax

; 932  :    HANDLE hMutex;
; 933  :    zLONG  lProcessID = 0;

	mov	DWORD PTR _lProcessID$[ebp], 0

; 934  :    zLONG  lThreadID = 0;

	mov	DWORD PTR _lThreadID$[ebp], 0

; 935  :    zSHORT k;
; 936  :    zSHORT nRC;
; 937  : 
; 938  :    SysDescribeZeidonPageTable( szTaskTitle );

	lea	ecx, DWORD PTR _szTaskTitle$[ebp]
	push	ecx
	call	_SysDescribeZeidonPageTable@4

; 939  : // SysMalloc( -2 );  // initialize memory usage (debug)
; 940  : 
; 941  :    // Check to see if the "termination" mutex is defined.  If it is then
; 942  :    // KZOENGWA.EXE is in the process of shutting down so fail the request.
; 943  :    if ( (hMutex = OpenMutex( MUTEX_ALL_ACCESS,
; 944  :                              FALSE, "KZOENGWA - Termination" )) != 0 )

	push	OFFSET FLAT:??_C@_0BH@IIPE@KZOENGWA?5?9?5Termination?$AA@ ; `string'
	push	0
	push	2031617					; 001f0001H
	call	DWORD PTR __imp__OpenMutexA@12
	mov	DWORD PTR _hMutex$[ebp], eax
	cmp	DWORD PTR _hMutex$[ebp], 0
	je	SHORT $L61151

; 946  :       // Close all the mutexes and get out.
; 947  :       CloseHandle( hMutex );

	mov	edx, DWORD PTR _hMutex$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 948  : 
; 949  :       MessageBox( GetActiveWindow( ),
; 950  :                   "The Zeidon Object Engine hasn't finished shutting down. "
; 951  :                   "Please wait for the engine to shut down and restart.",
; 952  :                   szlOE_SystemError, MB_ICONSTOP | MB_OK | MB_TASKMODAL );

	push	8208					; 00002010H
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	OFFSET FLAT:??_C@_0GN@DNGN@The?5Zeidon?5Object?5Engine?5hasn?8t?5@ ; `string'
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16

; 953  : 
; 954  :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L61135
$L61151:

; 956  : 
; 957  :    // Parse the Application string passed in from the client
; 958  :    fnParseAppString( szAppName, szDialog,
; 959  :                      szUserID,  szPassword,
; 960  :                      szCommand, cpcAppString );

	mov	ecx, DWORD PTR _cpcAppString$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szCommand$[ebp]
	push	edx
	lea	eax, DWORD PTR _szPassword$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szUserID$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDialog$[ebp]
	push	edx
	lea	eax, DWORD PTR _szAppName$[ebp]
	push	eax
	call	_fnParseAppString
	add	esp, 24					; 00000018H

; 961  : 
; 962  :    if ( szDialog[ 0 ] )

	movsx	ecx, BYTE PTR _szDialog$[ebp]
	test	ecx, ecx
	je	SHORT $L61154

; 963  :       zstrcpy( szTaskTitle, szDialog );

	lea	edx, DWORD PTR _szDialog$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTaskTitle$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 964  :    else

	jmp	SHORT $L61155
$L61154:

; 965  :       szTaskTitle[ 0 ] = 0;

	mov	BYTE PTR _szTaskTitle$[ebp], 0
$L61155:

; 966  : 
; 967  :    zLOCK_MUTEX( zMUTEX_INITTERM );

	push	0
	call	_fnSysLockCoreMutex@4

; 968  : 
; 969  :    // See if we can initialize OE.
; 970  :    k = SysStartObjectServices( lMsg, lMainWnd );

	mov	ecx, DWORD PTR _lMainWnd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lMsg$[ebp]
	push	edx
	call	_SysStartObjectServices
	add	esp, 8
	mov	WORD PTR _k$[ebp], ax

; 971  :    if ( k )

	movsx	eax, WORD PTR _k$[ebp]
	test	eax, eax
	je	SHORT $L61156

; 973  :       zUNLOCK_MUTEX( zMUTEX_INITTERM );

	push	0
	call	_fnSysUnlockCoreMutex@4

; 974  :       return( k );  // return if start not successful

	mov	ax, WORD PTR _k$[ebp]
	jmp	$L61135
$L61156:

; 976  : 
; 977  : #ifdef ALLOC_FREE_TRACE
; 978  :    AnchorBlock->bTraceMem = (zBOOL) SysSendOE_Message( IDM_GETMEMORYTRACE, 0 );
; 979  : #endif
; 980  : 
; 981  :    nRC = zCALL_ERROR;   // Default nRC to bad (zCALL_ERROR)

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 982  :    if ( (lpTask = fnCreateTask( lSystemInstance, (zLONG) hWndMain,
; 983  :                                 lMsg, szTaskTitle )) != 0 )

	lea	ecx, DWORD PTR _szTaskTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWndMain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lSystemInstance$[ebp]
	push	ecx
	call	_fnCreateTask
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$L61158

; 985  :       // Current process has performed RegisterZeidonApp( ) so ...
; 986  :       g_bProcessRegistered = TRUE;

	mov	BYTE PTR _g_bProcessRegistered, 1

; 987  :    // g_lpCurrentTask = lpTask;
; 988  : 
; 989  :       zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 990  : 
; 991  :       lpApp = fnCreateApp( lpTask, szAppName );

	lea	edx, DWORD PTR _szAppName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnCreateApp
	add	esp, 8
	mov	DWORD PTR _lpApp$[ebp], eax

; 992  :       if ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	$L61159

; 994  :          LPSUBTASK lpFirstSubtask = zGETPTR( lpTask->hFirstSubtask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstSubtask$61160[ebp], eax

; 995  : 
; 996  :          // Now point the application task to the application.
; 997  :          lpTask->hApp = zGETHNDL( lpApp );

	mov	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+10], eax

; 998  :          lpFirstSubtask->hApp = lpTask->hApp;

	mov	edx, DWORD PTR _lpFirstSubtask$61160[ebp]
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR [edx+10], ecx

; 999  : 
; 1000 :          if ( szDialog && szDialog[ 0 ] )

	lea	edx, DWORD PTR _szDialog$[ebp]
	test	edx, edx
	je	SHORT $L61163
	movsx	eax, BYTE PTR _szDialog$[ebp]
	test	eax, eax
	je	SHORT $L61163

; 1001 :             zstrcpy( lpTask->szDialog, szDialog );

	lea	ecx, DWORD PTR _szDialog$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	add	edx, 278				; 00000116H
	push	edx
	call	_strcpy
	add	esp, 8

; 1002 :          else

	jmp	SHORT $L61164
$L61163:

; 1003 :             zstrcpy( lpTask->szDialog, lpApp->szDefaultDialog );

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 39					; 00000027H
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 278				; 00000116H
	push	ecx
	call	_strcpy
	add	esp, 8
$L61164:

; 1004 : 
; 1005 :          if ( szCommand[ 0 ] )

	movsx	edx, BYTE PTR _szCommand$[ebp]
	test	edx, edx
	je	SHORT $L61165

; 1007 :             lpTask->hCommand =
; 1008 :                fnStoreStringInDataspace( (LPDATAHEADER) g_hAnchorBlock,
; 1009 :                                          szCommand );

	lea	eax, DWORD PTR _szCommand$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g_hAnchorBlock
	push	ecx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [edx+142], eax

; 1011 :          else

	jmp	SHORT $L61167
$L61165:

; 1012 :             lpTask->hCommand = 0;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [eax+142], 0
$L61167:

; 1013 : 
; 1014 :          // Task is now ready to go.
; 1015 : 
; 1016 :          if ( lControl & 0x00000001 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1
	test	ecx, ecx
	je	$L61175

; 1018 :             zCHAR  chWebTrace;
; 1019 : 
; 1020 :             lpTask->bTransientTask = TRUE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	or	ah, 4
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 1021 :             lProcessID = SysGetProcessID( &lThreadID );

	lea	edx, DWORD PTR _lThreadID$[ebp]
	push	edx
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 1022 : 
; 1023 :             TraceLineS( "InitCriticalSection: " , cpcControlData );

	mov	eax, DWORD PTR _cpcControlData$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BG@KHAA@InitCriticalSection?3?5?$AA@ ; `string'
	call	_TraceLineS@8

; 1024 : 
; 1025 :             lpTask->pcsCriticalSection = calloc( sizeof( CRITICAL_SECTION ), 1 );

	push	1
	push	24					; 00000018H
	call	DWORD PTR __imp__calloc
	add	esp, 8
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+439], eax

; 1026 :             InitializeCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+439]
	push	eax
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 1027 :             EnterCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+439]
	push	edx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 1028 :             chWebTrace = (zCHAR) SysSendOE_Message( IDM_GETWEBTRACE, 0 );

	push	0
	push	214					; 000000d6H
	call	_SysSendOE_Message@8
	mov	BYTE PTR _chWebTrace$61169[ebp], al

; 1029 :             if ( chWebTrace == 'Y' || chWebTrace == 'y' )

	movsx	eax, BYTE PTR _chWebTrace$61169[ebp]
	cmp	eax, 89					; 00000059H
	je	SHORT $L61176
	movsx	ecx, BYTE PTR _chWebTrace$61169[ebp]
	cmp	ecx, 121				; 00000079H
	jne	SHORT $L61175
$L61176:

; 1030 :                lpTask->bWebTrace = TRUE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	or	ah, 16					; 00000010H
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax
$L61175:

; 1032 : 
; 1033 :          lpTask->bDisable = FALSE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	and	al, -9					; fffffff7H
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 1034 : 
; 1035 :          ActivateViewObject( zGETPTR( lpTask->hFirstView ), szlMessageObject, 0 );

	push	0
	mov	edx, DWORD PTR _szlMessageObject
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_ActivateViewObject@12

; 1036 :          *pvSubtask = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _pvSubtask$[ebp]
	mov	DWORD PTR [ecx], eax

; 1037 : 
; 1038 :          if ( lControl & 0x00000001 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1
	test	edx, edx
	je	SHORT $L61179

; 1040 :             if ( cpcControlData && zstrlen( cpcControlData ) < sizeof( lpTask->szSessionId ) )

	cmp	DWORD PTR _cpcControlData$[ebp], 0
	je	SHORT $L61180
	mov	eax, DWORD PTR _cpcControlData$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 50					; 00000032H
	jae	SHORT $L61180

; 1042 :                zstrcpy( lpTask->szTaskTitle, cpcControlData );

	mov	ecx, DWORD PTR _cpcControlData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	add	edx, 311				; 00000137H
	push	edx
	call	_strcpy
	add	esp, 8

; 1043 :                zstrcpy( lpTask->szSessionId, cpcControlData );

	mov	eax, DWORD PTR _cpcControlData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 194				; 000000c2H
	push	ecx
	call	_strcpy
	add	esp, 8
$L61180:

; 1045 : 
; 1046 :             lpTask->vWebSubtask = *pvSubtask;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR _pvSubtask$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+28], ecx

; 1047 :             SysGetDateTime( lpTask->szTimeStamp );

	mov	edx, DWORD PTR _lpTask$[ebp]
	add	edx, 174				; 000000aeH
	push	edx
	call	_SysGetDateTime@4
$L61179:

; 1049 : 
; 1050 :          SetViewFlags( *pvSubtask, zVF_MESSAGEONDROP );

	push	1
	mov	eax, DWORD PTR _pvSubtask$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SetViewFlags@8

; 1051 : 
; 1052 :       // {
; 1053 :       //    zPVOID p = zGETHNDL( lpTask );
; 1054 :       //
; 1055 :       //    TraceLine( "RegisterZeidonApplication for Task: 0x%08x (%d)", p, p );
; 1056 :       // }
; 1057 : 
; 1058 :          nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 1060 :       else

	jmp	SHORT $L61181
$L61159:

; 1062 :          DeleteTask( lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_DeleteTask@4

; 1063 : 
; 1064 :          // Current process has performed RegisterZeidonApp( ) so ...
; 1065 :          g_bProcessRegistered = FALSE;

	mov	BYTE PTR _g_bProcessRegistered, 0
$L61181:

; 1068 : 
; 1069 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$L61158:

; 1071 : 
; 1072 :    // Check nRC and do a task release on anchor block if init failed.
; 1073 :    if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $L61182

; 1075 :       if ( g_hAnchorBlock )

	cmp	DWORD PTR _g_hAnchorBlock, 0
	je	SHORT $L61183

; 1076 :          fnFreeSharedMemory( 0, g_hAnchorBlock );

	mov	ecx, DWORD PTR _g_hAnchorBlock
	push	ecx
	push	0
	call	_fnFreeSharedMemory@8
$L61183:

; 1078 :    else

	jmp	SHORT $L61184
$L61182:

; 1079 : // if ( nRC == 0 )
; 1080 :       SfStartNetworks( *pvSubtask, 0 );

	push	0
	mov	edx, DWORD PTR _pvSubtask$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SfStartNetworks@8
$L61184:

; 1081 : 
; 1082 :    if ( lControl & 0x00000001 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L61186

; 1084 :       if ( lpTask->bWebTrace )

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	shr	eax, 12					; 0000000cH
	and	eax, 1
	test	eax, eax
	je	SHORT $L61186

; 1086 :          TraceLine( "RegisterZeidonApplication ===============> %s   V/Task: 0x%08x / 0x%08x  Process: %d   Thread: %d",
; 1087 :                     cpcAppString, *pvSubtask, (*pvSubtask)->hTask, lProcessID, lThreadID );

	mov	ecx, DWORD PTR _lThreadID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lProcessID$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvSubtask$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _pvSubtask$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _cpcAppString$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0GC@PKCM@RegisterZeidonApplication?5?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
	call	_TraceLine
	add	esp, 24					; 00000018H
$L61186:

; 1090 : 
; 1091 :    zUNLOCK_MUTEX( zMUTEX_INITTERM );

	push	0
	call	_fnSysUnlockCoreMutex@4

; 1092 : 
; 1093 :    TraceLine( "RegisterZeidonApplication ===============> %s   Process: %d   Thread: %d   Memory: %s   Wnd: 0x%08x=%d",
; 1094 :                cpcAppString, GetCurrentProcessId( ), GetCurrentThreadId( ), szTaskTitle, lMainWnd, lMainWnd );

	mov	eax, DWORD PTR _lMainWnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lMainWnd$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTaskTitle$[ebp]
	push	edx
	call	DWORD PTR __imp__GetCurrentThreadId@0
	push	eax
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	mov	eax, DWORD PTR _cpcAppString$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0GH@BDLJ@RegisterZeidonApplication?5?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
	call	_TraceLine
	add	esp, 28					; 0000001cH

; 1095 : 
; 1096 :    return( nRC );  // return the result

	mov	ax, WORD PTR _nRC$[ebp]
$L61135:

; 1097 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_RegisterZeidonApplication@28 ENDP
_TEXT	ENDS
PUBLIC	_UnregisterZeidonApplication@4
PUBLIC	??_C@_0FJ@COG@?$CIUnr?$CJ?5Cleaning?5up?5Registered?5S?1T@ ; `string'
EXTRN	__imp__free:NEAR
EXTRN	__imp__GetLastError@0:NEAR
EXTRN	__imp__DeleteCriticalSection@4:NEAR
EXTRN	__imp__PostMessageA@16:NEAR
EXTRN	__imp__UnregisterClassA@8:NEAR
;	COMDAT ??_C@_0FJ@COG@?$CIUnr?$CJ?5Cleaning?5up?5Registered?5S?1T@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0FJ@COG@?$CIUnr?$CJ?5Cleaning?5up?5Registered?5S?1T@ DB '(Unr) Clea'
	DB	'ning up Registered S/Task: 0x%08x / 0x%08x (%d)   Process: %d'
	DB	'   Thread: %d  %s', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vTaskView$ = 8
_dw$ = -20
_hMainWnd$ = -12
_hInstance$ = -4
_lpTask$ = -16
_nRC$ = -8
_lpSearchTask$61205 = -28
_lCount$61206 = -24
_UnregisterZeidonApplication@4 PROC NEAR

; 1119 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1120 :    DWORD     dw;
; 1121 :    HWND      hMainWnd;
; 1122 :    HINSTANCE hInstance;
; 1123 : 
; 1124 :    LPTASK lpTask;
; 1125 :    zSHORT nRC;
; 1126 : 
; 1127 :    lpTask = zGETPTR( vTaskView->hTask );

	mov	eax, DWORD PTR _vTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 1128 : 
; 1129 :    zLOCK_MUTEX( zMUTEX_INITTERM );

	push	0
	call	_fnSysLockCoreMutex@4

; 1130 : 
; 1131 :    hInstance = (HINSTANCE) lpTask->lHab;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _hInstance$[ebp], eax

; 1132 : 
; 1133 :    if ( lpTask->bTransientTask )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	test	edx, edx
	je	SHORT $L61199

; 1135 :       LeaveCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+439]
	push	ecx
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 1136 :       DeleteCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+439]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 1137 :       free( lpTask->pcsCriticalSection );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+439]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
$L61199:

; 1139 : 
; 1140 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L61202

; 1142 :       TraceLine( "(Unr) Cleaning up Registered S/Task: 0x%08x / 0x%08x (%d)   Process: %d   Thread: %d  %s",
; 1143 :                  vTaskView, vTaskView->hTask, lpTask, GetCurrentProcessId( ),
; 1144 :                  GetCurrentThreadId( ), lpTask->szSessionId );

	mov	edx, DWORD PTR _lpTask$[ebp]
	add	edx, 194				; 000000c2H
	push	edx
	call	DWORD PTR __imp__GetCurrentThreadId@0
	push	eax
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _vTaskView$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0FJ@COG@?$CIUnr?$CJ?5Cleaning?5up?5Registered?5S?1T@ ; `string'
	call	_TraceLine
	add	esp, 28					; 0000001cH
$L61202:

; 1157 : 
; 1158 :    // Check to see if we should drop the object engine if there are no other
; 1159 :    // tasks.  We'll do the check now because DeleteTask drops the AnchorBlock.
; 1160 :    hMainWnd = 0;

	mov	DWORD PTR _hMainWnd$[ebp], 0

; 1161 :    if ( AnchorBlock->bDropEngineIfNoTasks )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1495]
	shr	edx, 2
	and	edx, 1
	test	edx, edx
	je	SHORT $L61213

; 1163 :       LPTASK lpSearchTask;
; 1164 :       zLONG  lCount = 0;

	mov	DWORD PTR _lCount$61206[ebp], 0

; 1165 : 
; 1166 :       // Count the number of tasks.
; 1167 :       for ( lpSearchTask = zGETPTR( AnchorBlock->hFirstTask );
; 1168 :             lpSearchTask;
; 1169 :             lpSearchTask = zGETPTR( lpSearchTask->hNextTask ) )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$61205[ebp], eax
	jmp	SHORT $L61209
$L61210:
	mov	edx, DWORD PTR _lpSearchTask$61205[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$61205[ebp], eax
$L61209:
	cmp	DWORD PTR _lpSearchTask$61205[ebp], 0
	je	SHORT $L61211

; 1171 :          // We only care if there are 2 or fewer.
; 1172 :          if ( lCount++ > 1 )

	mov	ecx, DWORD PTR _lCount$61206[ebp]
	mov	edx, DWORD PTR _lCount$61206[ebp]
	add	edx, 1
	mov	DWORD PTR _lCount$61206[ebp], edx
	cmp	ecx, 1
	jle	SHORT $L61212

; 1173 :             break;

	jmp	SHORT $L61211
$L61212:

; 1174 :       }

	jmp	SHORT $L61210
$L61211:

; 1175 : 
; 1176 :       // If there are only 2 tasks that means only the current one and the
; 1177 :       // system task are running.  Set the HWND so we'll know to drop the
; 1178 :       // engine later.
; 1179 :       if ( lCount <= 2 )

	cmp	DWORD PTR _lCount$61206[ebp], 2
	jg	SHORT $L61213

; 1180 :          hMainWnd = (HWND) AnchorBlock->lOE_hMainWnd;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+94]
	mov	DWORD PTR _hMainWnd$[ebp], ecx
$L61213:

; 1182 : 
; 1183 :    nRC = DeleteTask( lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_DeleteTask@4
	mov	WORD PTR _nRC$[ebp], ax

; 1184 : 
; 1185 :    // If hMainWnd is not 0 then we need to drop the engine.
; 1186 :    if ( hMainWnd )

	cmp	DWORD PTR _hMainWnd$[ebp], 0
	je	SHORT $L61215

; 1187 :       PostMessage( hMainWnd, WM_CLOSE, 0, 0 );

	push	0
	push	0
	push	16					; 00000010H
	mov	eax, DWORD PTR _hMainWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__PostMessageA@16
$L61215:

; 1188 : 
; 1189 :    zUNLOCK_MUTEX( zMUTEX_INITTERM );

	push	0
	call	_fnSysUnlockCoreMutex@4

; 1190 : 
; 1191 :    if ( !UnregisterClass( szlNT_ThreadClassName, hInstance ) )

	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	push	OFFSET FLAT:_szlNT_ThreadClassName
	call	DWORD PTR __imp__UnregisterClassA@8
	test	eax, eax
	jne	SHORT $L61216

; 1192 :       dw = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dw$[ebp], eax
$L61216:

; 1193 : 
; 1194 :    // Current thread has performed UnregisterZeidonApp( ) so ...
; 1195 :    g_bProcessRegistered = FALSE;

	mov	BYTE PTR _g_bProcessRegistered, 0

; 1196 : // g_lpCurrentTask = 0;
; 1197 : 
; 1198 : // SysMalloc( -1 );  // report memory usage (debug)
; 1199 : 
; 1200 : #ifdef __MUTEX_DEBUG__
; 1201 :    if ( g_MutexInfoTable )
; 1202 :    {
; 1203 :       zLONG  lTaskID = SysGetProcessID( 0 );
; 1204 :       zSHORT k, j;
; 1205 : 
; 1206 :       for ( k = 0; k < zMUTEX_COUNT; k++ )
; 1207 :       {
; 1208 :          for ( j = 0; j < g_MutexInfoTable[ k ].lLastTaskIdx; j++ )
; 1209 :          {
; 1210 :             if ( g_MutexInfoTable[ k ].TaskInfo[ j ].lTaskID != lTaskID )
; 1211 :                continue;
; 1212 : 
; 1213 :             g_MutexInfoTable[ k ].TaskInfo[ j ].lTaskID = 0;
; 1214 :             break;
; 1215 :          }
; 1216 :       }
; 1217 :    }
; 1218 : #endif
; 1219 : 
; 1220 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 1221 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_UnregisterZeidonApplication@4 ENDP
_TEXT	ENDS
PUBLIC	_SysFreeInternational@4
EXTRN	_fnFreeDataspace:NEAR
_TEXT	SEGMENT
_lpInternational$ = 8
_SysFreeInternational@4 PROC NEAR

; 1232 : {

	push	ebp
	mov	ebp, esp

; 1233 :    if ( lpInternational &&
; 1234 :         lpInternational->nTableID == iInternational )

	cmp	DWORD PTR _lpInternational$[ebp], 0
	je	SHORT $L61220
	mov	eax, DWORD PTR _lpInternational$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, 10042				; 0000273aH
	jne	SHORT $L61220

; 1236 :       fnFreeDataspace( zGETPTR( lpInternational->hShortDate ) );

	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	eax, DWORD PTR [edx+98]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1237 :       fnFreeDataspace( zGETPTR( lpInternational->hLongDate ) );

	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	edx, DWORD PTR [ecx+102]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1238 :       fnFreeDataspace( zGETPTR( lpInternational->hTimeFmt ) );

	mov	eax, DWORD PTR _lpInternational$[ebp]
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1239 :       fnFreeDataspace( lpInternational );

	mov	edx, DWORD PTR _lpInternational$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
$L61220:

; 1241 : }

	pop	ebp
	ret	4
_SysFreeInternational@4 ENDP
_TEXT	ENDS
PUBLIC	_fnSysMessageBox@16
PUBLIC	_fnConvertToZeidonFormat
PUBLIC	??_C@_03DCGD@DDD?$AA@				; `string'
PUBLIC	??_C@_03PHAE@ddd?$AA@				; `string'
PUBLIC	??_C@_02PPJD@DD?$AA@				; `string'
PUBLIC	??_C@_03KNBB@MMM?$AA@				; `string'
PUBLIC	??_C@_03GIHG@mmm?$AA@				; `string'
PUBLIC	??_C@_02KCEC@MM?$AA@				; `string'
PUBLIC	??_C@_02CFPA@mm?$AA@				; `string'
PUBLIC	??_C@_03PHAO@YYY?$AA@				; `string'
PUBLIC	??_C@_04PJGI@YYYY?$AA@				; `string'
PUBLIC	??_C@_0BJ@BJED@Missing?5ending?5delimiter?$AA@	; `string'
PUBLIC	??_C@_0N@EEMD@Zeidon?5Error?$AA@		; `string'
EXTRN	_memcpy:NEAR
EXTRN	__imp___strnicmp:NEAR
;	COMDAT ??_C@_03DCGD@DDD?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_03DCGD@DDD?$AA@ DB 'DDD', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03PHAE@ddd?$AA@
_DATA	SEGMENT
??_C@_03PHAE@ddd?$AA@ DB 'ddd', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02PPJD@DD?$AA@
_DATA	SEGMENT
??_C@_02PPJD@DD?$AA@ DB 'DD', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03KNBB@MMM?$AA@
_DATA	SEGMENT
??_C@_03KNBB@MMM?$AA@ DB 'MMM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03GIHG@mmm?$AA@
_DATA	SEGMENT
??_C@_03GIHG@mmm?$AA@ DB 'mmm', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02KCEC@MM?$AA@
_DATA	SEGMENT
??_C@_02KCEC@MM?$AA@ DB 'MM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02CFPA@mm?$AA@
_DATA	SEGMENT
??_C@_02CFPA@mm?$AA@ DB 'mm', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03PHAO@YYY?$AA@
_DATA	SEGMENT
??_C@_03PHAO@YYY?$AA@ DB 'YYY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PJGI@YYYY?$AA@
_DATA	SEGMENT
??_C@_04PJGI@YYYY?$AA@ DB 'YYYY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@BJED@Missing?5ending?5delimiter?$AA@
_DATA	SEGMENT
??_C@_0BJ@BJED@Missing?5ending?5delimiter?$AA@ DB 'Missing ending delimit'
	DB	'er', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@EEMD@Zeidon?5Error?$AA@
_DATA	SEGMENT
??_C@_0N@EEMD@Zeidon?5Error?$AA@ DB 'Zeidon Error', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchFormat$ = 8
_pch1$ = -12
_pch2$ = -272
_sz$ = -268
_bError$ = -4
_bImbedding$ = -8
_cDelimiter$ = -276
_sz$61291 = -280
_fnConvertToZeidonFormat PROC NEAR

; 1255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH

; 1256 :    zPCHAR   pch1;
; 1257 :    zPCHAR   pch2;
; 1258 :    zCHAR    sz[ 256 ];
; 1259 :    zBOOL    bError = 0;

	mov	BYTE PTR _bError$[ebp], 0

; 1260 :    zBOOL    bImbedding = 0;

	mov	BYTE PTR _bImbedding$[ebp], 0

; 1261 :    zCHAR    cDelimiter = 0;

	mov	BYTE PTR _cDelimiter$[ebp], 0

; 1262 : 
; 1263 :    pch1 = pchFormat;

	mov	eax, DWORD PTR _pchFormat$[ebp]
	mov	DWORD PTR _pch1$[ebp], eax

; 1264 :    pch2 = sz;

	lea	ecx, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _pch2$[ebp], ecx
$L61235:

; 1265 : 
; 1266 :    while ( *pch1 )

	mov	edx, DWORD PTR _pch1$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$L61236

; 1268 :       if ( cDelimiter )

	movsx	ecx, BYTE PTR _cDelimiter$[ebp]
	test	ecx, ecx
	je	SHORT $L61237

; 1270 :          if ( *pch1 == cDelimiter )

	mov	edx, DWORD PTR _pch1$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR _cDelimiter$[ebp]
	cmp	eax, ecx
	jne	SHORT $L61238

; 1272 :             cDelimiter = 0;

	mov	BYTE PTR _cDelimiter$[ebp], 0

; 1273 :             *pch2++ = *pch1++;

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	eax, DWORD PTR _pch1$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx
	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch1$[ebp], eax

; 1275 :          else

	jmp	SHORT $L61239
$L61238:

; 1276 :             *pch2++ = *pch1++;

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	edx, DWORD PTR _pch1$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx
	mov	edx, DWORD PTR _pch1$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch1$[ebp], edx
$L61239:

; 1278 :       else

	jmp	$L61242
$L61237:

; 1279 :       switch ( *pch1 )
; 1280 :       {

	mov	eax, DWORD PTR _pch1$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR -284+[ebp], ecx
	mov	edx, DWORD PTR -284+[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR -284+[ebp], edx
	cmp	DWORD PTR -284+[ebp], 89		; 00000059H
	ja	$L61286
	mov	ecx, DWORD PTR -284+[ebp]
	xor	eax, eax
	mov	al, BYTE PTR $L64783[ecx]
	jmp	DWORD PTR $L64784[eax*4]
$L61245:

; 1281 :        case 'd':
; 1282 :        case 'D':
; 1283 :          if ( bImbedding )

	mov	edx, DWORD PTR _bImbedding$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L61246

; 1285 :             *pch2++ = '\"';

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 34			; 00000022H
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx

; 1286 :             bImbedding = 0;

	mov	BYTE PTR _bImbedding$[ebp], 0
$L61246:

; 1288 : 
; 1289 :          if ( zstrncmpi( (pch1 + 1), "DDD", 3 ) == 0 )

	push	3
	push	OFFSET FLAT:??_C@_03DCGD@DDD?$AA@	; `string'
	mov	edx, DWORD PTR _pch1$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L61247

; 1291 :             *pch2++ = 'D';

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 68			; 00000044H
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx

; 1292 :             zmemcpy( pch2, "ddd", 3 );

	push	3
	push	OFFSET FLAT:??_C@_03PHAE@ddd?$AA@	; `string'
	mov	edx, DWORD PTR _pch2$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1293 :             pch1 += 4;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 4
	mov	DWORD PTR _pch1$[ebp], eax

; 1294 :             pch2 += 3;

	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 3
	mov	DWORD PTR _pch2$[ebp], ecx

; 1296 :          else

	jmp	$L61256
$L61247:

; 1297 :          if ( zstrncmpi( (pch1 + 1), "DD", 2 ) == 0 )

	push	2
	push	OFFSET FLAT:??_C@_02PPJD@DD?$AA@	; `string'
	mov	edx, DWORD PTR _pch1$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L61251

; 1299 :             *pch2++ = 'D';

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 68			; 00000044H
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx

; 1300 :             *pch2++ = 'd';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 100			; 00000064H
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1301 :             *pch2++ = 'd';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 100			; 00000064H
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 1302 :             pch1 += 3;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 3
	mov	DWORD PTR _pch1$[ebp], eax

; 1304 :          else

	jmp	SHORT $L61256
$L61251:

; 1305 :          if ( *(pch1 + 1) == 'D' ||
; 1306 :               *(pch1 + 1) == 'd' )

	mov	ecx, DWORD PTR _pch1$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 68					; 00000044H
	je	SHORT $L61255
	mov	eax, DWORD PTR _pch1$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 100				; 00000064H
	jne	SHORT $L61254
$L61255:

; 1308 :             *pch2++ = 'D';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 68			; 00000044H
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1309 :             *pch2++ = 'd';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 100			; 00000064H
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 1310 :             pch1 += 2;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 2
	mov	DWORD PTR _pch1$[ebp], eax

; 1312 :          else

	jmp	SHORT $L61256
$L61254:

; 1314 :             *pch2++ = 'D';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 68			; 00000044H
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 1315 :             pch1++;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch1$[ebp], eax
$L61256:

; 1317 : 
; 1318 :          break;

	jmp	$L61242
$L61257:

; 1319 : 
; 1320 :        case 'm':
; 1321 :        case 'M':
; 1322 :          if ( bImbedding )

	mov	ecx, DWORD PTR _bImbedding$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L61258

; 1324 :             *pch2++ = '\"';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 34			; 00000022H
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1325 :             bImbedding = 0;

	mov	BYTE PTR _bImbedding$[ebp], 0
$L61258:

; 1327 : 
; 1328 :          if ( zstrncmpi( (pch1 + 1), "MMM", 3 ) == 0 )

	push	3
	push	OFFSET FLAT:??_C@_03KNBB@MMM?$AA@	; `string'
	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L61259

; 1330 :             *pch2++ = 'M';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 77			; 0000004dH
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1331 :             zmemcpy( pch2, "mmm", 3 );

	push	3
	push	OFFSET FLAT:??_C@_03GIHG@mmm?$AA@	; `string'
	mov	ecx, DWORD PTR _pch2$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1332 :             pch2 += 3;

	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 3
	mov	DWORD PTR _pch2$[ebp], edx

; 1333 :             pch1 += 4;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 4
	mov	DWORD PTR _pch1$[ebp], eax

; 1335 :          else

	jmp	$L61269
$L61259:

; 1336 :          if ( zstrncmpi( (pch1 + 1), "MM", 2 ) == 0 )

	push	2
	push	OFFSET FLAT:??_C@_02KCEC@MM?$AA@	; `string'
	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L61263

; 1338 :             *pch2++ = 'M';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 77			; 0000004dH
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1339 :             zmemcpy( pch2, "mm", 2 );

	push	2
	push	OFFSET FLAT:??_C@_02CFPA@mm?$AA@	; `string'
	mov	ecx, DWORD PTR _pch2$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1340 :             pch2 += 2;

	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 2
	mov	DWORD PTR _pch2$[ebp], edx

; 1341 :             pch1 += 3;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 3
	mov	DWORD PTR _pch1$[ebp], eax

; 1343 :          else

	jmp	SHORT $L61269
$L61263:

; 1344 :          if ( *(pch1 + 1) == 'M' ||
; 1345 :               *(pch1 + 1) == 'm' )

	mov	ecx, DWORD PTR _pch1$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 77					; 0000004dH
	je	SHORT $L61268
	mov	eax, DWORD PTR _pch1$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 109				; 0000006dH
	jne	SHORT $L61267
$L61268:

; 1347 :             *pch2++ = 'M';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 77			; 0000004dH
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1348 :             *pch2++ = 'm';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 109			; 0000006dH
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 1349 :             pch1 +=2;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 2
	mov	DWORD PTR _pch1$[ebp], eax

; 1351 :          else

	jmp	SHORT $L61269
$L61267:

; 1353 :             *pch2++ = 'M';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 77			; 0000004dH
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 1354 :             pch1++;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch1$[ebp], eax
$L61269:

; 1356 : 
; 1357 :          break;

	jmp	$L61242
$L61270:

; 1358 : 
; 1359 :        case 'y':
; 1360 :        case 'Y':
; 1361 :          if ( zstrncmpi( (pch1 + 1), "YYY", 3 ) == 0 )

	push	3
	push	OFFSET FLAT:??_C@_03PHAO@YYY?$AA@	; `string'
	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L61271

; 1363 :             if ( bImbedding )

	mov	edx, DWORD PTR _bImbedding$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L61273

; 1365 :                *pch2++ = '\"';

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 34			; 00000022H
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx

; 1366 :                bImbedding = 0;

	mov	BYTE PTR _bImbedding$[ebp], 0
$L61273:

; 1368 : 
; 1369 :             zmemcpy( pch2, "YYYY", 4 );

	push	4
	push	OFFSET FLAT:??_C@_04PJGI@YYYY?$AA@	; `string'
	mov	edx, DWORD PTR _pch2$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1370 :             pch2 += 4;

	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 4
	mov	DWORD PTR _pch2$[ebp], eax

; 1371 :             pch1 += 4;

	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pch1$[ebp], ecx

; 1373 :          else

	jmp	$L61281
$L61271:

; 1374 :          if ( *(pch1 + 1) == 'Y' || *(pch1 + 1) == 'y' )

	mov	edx, DWORD PTR _pch1$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 89					; 00000059H
	je	SHORT $L61277
	mov	ecx, DWORD PTR _pch1$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 121				; 00000079H
	jne	SHORT $L61276
$L61277:

; 1376 :             if ( bImbedding )

	mov	eax, DWORD PTR _bImbedding$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L61278

; 1378 :                *pch2++ = '\"';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 34			; 00000022H
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 1379 :                bImbedding = 0;

	mov	BYTE PTR _bImbedding$[ebp], 0
$L61278:

; 1381 : 
; 1382 :             *pch2++ = 'Y';

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 89			; 00000059H
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx

; 1383 :             *pch2++ = 'Y';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 89			; 00000059H
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1384 :             pch1 += 2;

	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pch1$[ebp], ecx

; 1386 :          else

	jmp	SHORT $L61281
$L61276:

; 1387 :          if ( bImbedding )

	mov	edx, DWORD PTR _bImbedding$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L61280

; 1388 :             *pch2++ = *pch1++;

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	ecx, DWORD PTR _pch1$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax
	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch1$[ebp], ecx

; 1389 :          else

	jmp	SHORT $L61281
$L61280:

; 1390 :             bError = 1;

	mov	BYTE PTR _bError$[ebp], 1
$L61281:

; 1391 : 
; 1392 :          break;

	jmp	$L61242
$L61282:

; 1393 : 
; 1394 :        case '\"':  // quote
; 1395 :          if ( bImbedding )

	mov	edx, DWORD PTR _bImbedding$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L61283

; 1397 :             bImbedding = 0;

	mov	BYTE PTR _bImbedding$[ebp], 0

; 1398 :             cDelimiter = *pch1++;

	mov	eax, DWORD PTR _pch1$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cDelimiter$[ebp], cl
	mov	edx, DWORD PTR _pch1$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch1$[ebp], edx

; 1399 :             break;

	jmp	$L61242
$L61283:

; 1401 : 
; 1402 :        case '\'':  // apostrophe
; 1403 :          cDelimiter = *pch1;

	mov	eax, DWORD PTR _pch1$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cDelimiter$[ebp], cl

; 1404 :          *pch2++ = *pch1++;

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	eax, DWORD PTR _pch1$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx
	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch1$[ebp], eax

; 1405 :          break;

	jmp	SHORT $L61242
$L61285:

; 1406 : 
; 1407 :        case '(':   // left paren
; 1408 :        case ')':   // right paren
; 1409 :        case ':':   // colon
; 1410 :        case ',':   // comma
; 1411 :        case '-':   // dash
; 1412 :        case '/':   // slash
; 1413 :        case '.':   // period
; 1414 :        case ' ':   // space
; 1415 :          *pch2++ = *pch1++;

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	edx, DWORD PTR _pch1$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx
	mov	edx, DWORD PTR _pch1$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch1$[ebp], edx

; 1416 :          break;

	jmp	SHORT $L61242
$L61286:

; 1417 : 
; 1418 :        default:
; 1419 :          if ( !bImbedding )

	mov	eax, DWORD PTR _bImbedding$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L61287

; 1421 :             bImbedding = 1;

	mov	BYTE PTR _bImbedding$[ebp], 1

; 1422 :             *pch2++ = '\"';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 34			; 00000022H
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx
$L61287:

; 1424 : 
; 1425 :          *pch2++ = *pch1++;

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	ecx, DWORD PTR _pch1$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax
	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch1$[ebp], ecx
$L61242:

; 1427 : 
; 1428 :       if ( bError )

	mov	edx, DWORD PTR _bError$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L61288

; 1429 :          break;

	jmp	SHORT $L61236
$L61288:

; 1430 :    }

	jmp	$L61235
$L61236:

; 1431 : 
; 1432 :    *pch2 = 0; // terminate the string.

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 0

; 1433 : 
; 1434 :    if ( bError == FALSE )

	mov	ecx, DWORD PTR _bError$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L61289

; 1435 :       zstrcpy( pchFormat, sz );   // return the zeidon format

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchFormat$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L61289:

; 1436 : 
; 1437 :    if ( cDelimiter && bError == FALSE )

	movsx	ecx, BYTE PTR _cDelimiter$[ebp]
	test	ecx, ecx
	je	SHORT $L61290
	mov	edx, DWORD PTR _bError$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L61290

; 1439 :       zCHAR sz[ 2 ];
; 1440 : 
; 1441 :       sz[ 0 ] = cDelimiter;

	mov	al, BYTE PTR _cDelimiter$[ebp]
	mov	BYTE PTR _sz$61291[ebp], al

; 1442 :       sz[ 1 ] = 0;

	mov	BYTE PTR _sz$61291[ebp+1], 0

; 1443 : 
; 1444 :       // "KZOEE360 - Missing ending delimiter "
; 1445 :       fnSysMessageBox( 0, "Zeidon Error", "Missing ending delimiter", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BJ@BJED@Missing?5ending?5delimiter?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@EEMD@Zeidon?5Error?$AA@ ; `string'
	push	0
	call	_fnSysMessageBox@16
$L61290:

; 1448 : 
; 1449 :    return( bError );

	mov	al, BYTE PTR _bError$[ebp]

; 1450 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$L64784:
	DD	$L61285
	DD	$L61282
	DD	$L61283
	DD	$L61245
	DD	$L61257
	DD	$L61270
	DD	$L61286
$L64783:
	DB	0
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	0
	DB	0
	DB	6
	DB	6
	DB	0
	DB	0
	DB	0
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
_fnConvertToZeidonFormat ENDP
_TEXT	ENDS
PUBLIC	_SysCreateInternational@0
PUBLIC	??_C@_03PLJD@ENU?$AA@				; `string'
PUBLIC	??_C@_03CHCO@DEU?$AA@				; `string'
PUBLIC	??_C@_03NOPN@FRC?$AA@				; `string'
PUBLIC	??_C@_03IDPK@POR?$AA@				; `string'
PUBLIC	??_C@_03JNKA@SPA?$AA@				; `string'
PUBLIC	??_C@_01KMAE@?0?$AA@				; `string'
PUBLIC	??_C@_01PKAG@?3?$AA@				; `string'
PUBLIC	??_C@_02ENLM@AM?$AA@				; `string'
PUBLIC	??_C@_02DBLP@PM?$AA@				; `string'
PUBLIC	??_C@_08NNHK@mm?1dd?1yy?$AA@			; `string'
PUBLIC	??_C@_0N@CFAC@mmm?5dd?0?5yyyy?$AA@		; `string'
PUBLIC	??_C@_01PILM@$?$AA@				; `string'
PUBLIC	??_C@_01PJCK@?4?$AA@				; `string'
PUBLIC	??_C@_02OOIJ@HH?$AA@				; `string'
PUBLIC	??_C@_01PBHI@H?$AA@				; `string'
PUBLIC	??_C@_01HMO@?$CC?$AA@				; `string'
PUBLIC	??_C@_02IBO@MI?$AA@				; `string'
PUBLIC	??_C@_03PGJ@?5AM?$AA@				; `string'
EXTRN	_fnAllocDataspace:NEAR
EXTRN	__imp___stricmp:NEAR
EXTRN	__imp__GetProfileIntA@12:NEAR
EXTRN	__imp__GetProfileStringA@20:NEAR
;	COMDAT ??_C@_03PLJD@ENU?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_03PLJD@ENU?$AA@ DB 'ENU', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03CHCO@DEU?$AA@
_DATA	SEGMENT
??_C@_03CHCO@DEU?$AA@ DB 'DEU', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03NOPN@FRC?$AA@
_DATA	SEGMENT
??_C@_03NOPN@FRC?$AA@ DB 'FRC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IDPK@POR?$AA@
_DATA	SEGMENT
??_C@_03IDPK@POR?$AA@ DB 'POR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03JNKA@SPA?$AA@
_DATA	SEGMENT
??_C@_03JNKA@SPA?$AA@ DB 'SPA', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01KMAE@?0?$AA@
_DATA	SEGMENT
??_C@_01KMAE@?0?$AA@ DB ',', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PKAG@?3?$AA@
_DATA	SEGMENT
??_C@_01PKAG@?3?$AA@ DB ':', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02ENLM@AM?$AA@
_DATA	SEGMENT
??_C@_02ENLM@AM?$AA@ DB 'AM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02DBLP@PM?$AA@
_DATA	SEGMENT
??_C@_02DBLP@PM?$AA@ DB 'PM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08NNHK@mm?1dd?1yy?$AA@
_DATA	SEGMENT
??_C@_08NNHK@mm?1dd?1yy?$AA@ DB 'mm/dd/yy', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@CFAC@mmm?5dd?0?5yyyy?$AA@
_DATA	SEGMENT
??_C@_0N@CFAC@mmm?5dd?0?5yyyy?$AA@ DB 'mmm dd, yyyy', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PILM@$?$AA@
_DATA	SEGMENT
??_C@_01PILM@$?$AA@ DB '$', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PJCK@?4?$AA@
_DATA	SEGMENT
??_C@_01PJCK@?4?$AA@ DB '.', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02OOIJ@HH?$AA@
_DATA	SEGMENT
??_C@_02OOIJ@HH?$AA@ DB 'HH', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PBHI@H?$AA@
_DATA	SEGMENT
??_C@_01PBHI@H?$AA@ DB 'H', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_01HMO@?$CC?$AA@
_DATA	SEGMENT
??_C@_01HMO@?$CC?$AA@ DB '"', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02IBO@MI?$AA@
_DATA	SEGMENT
??_C@_02IBO@MI?$AA@ DB 'MI', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03PGJ@?5AM?$AA@
_DATA	SEGMENT
??_C@_03PGJ@?5AM?$AA@ DB ' AM', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpInternational$ = -4
_hInternational$ = -520
_sz$ = -516
_SysCreateInternational@0 PROC NEAR

; 1643 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 520				; 00000208H

; 1644 :    LPINTERNATIONAL   lpInternational;
; 1645 :    zPVOID            hInternational;
; 1646 :    zCHAR             sz[ 512 ];
; 1647 : 
; 1648 :    hInternational =
; 1649 :       fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,
; 1650 :                         sizeof( InternationalRecord ), 1, 0, iInternational );

	push	10042					; 0000273aH
	push	0
	push	1
	push	140					; 0000008cH
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hInternational$[ebp], eax

; 1651 :    if ( hInternational == 0 )

	cmp	DWORD PTR _hInternational$[ebp], 0
	jne	SHORT $L61300

; 1652 :       return( 0 );

	xor	eax, eax
	jmp	$L61295
$L61300:

; 1653 : 
; 1654 :    lpInternational = zGETPTR( hInternational );

	mov	edx, DWORD PTR _hInternational$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$[ebp], eax

; 1655 : 
; 1656 :    // Get country code, default to US
; 1657 :    lpInternational->nCountry = GetProfileInt( szlINTL, szlICOUNTRY, 1 );

	push	1
	mov	eax, DWORD PTR _szlICOUNTRY
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+2], ax

; 1658 : 
; 1659 :    // Selected country name, no default
; 1660 :    GetProfileString( szlINTL, szlSCOUNTRY, szNullS, sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szNullS
	push	ecx
	mov	edx, DWORD PTR _szlSCOUNTRY
	push	edx
	mov	eax, DWORD PTR _szlINTL
	push	eax
	call	DWORD PTR __imp__GetProfileStringA@20

; 1661 : 
; 1662 :    zstrcpy( lpInternational->szCountry, sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInternational$[ebp]
	add	edx, 4
	push	edx
	call	_strcpy
	add	esp, 8

; 1663 : 
; 1664 :    // Get selected language code, default U.S. English
; 1665 :    GetProfileString( szlINTL, szlSLANGUAGE, "ENU", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_03PLJD@ENU?$AA@	; `string'
	mov	ecx, DWORD PTR _szlSLANGUAGE
	push	ecx
	mov	edx, DWORD PTR _szlINTL
	push	edx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1666 : 
; 1667 :    zstrcpy( lpInternational->szLanguage, sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	add	ecx, 37					; 00000025H
	push	ecx
	call	_strcpy
	add	esp, 8

; 1668 : 
; 1669 :    // DGC: ????????????????? OS/2 ?????????? DKS 2/21/96 ?????????
; 1670 :    // Hard code the language code from the language string.
; 1671 :    // 0 - No default defined.
; 1672 :    if ( zstrcmpi( sz, "ENU" ) == 0 )

	push	OFFSET FLAT:??_C@_03PLJD@ENU?$AA@	; `string'
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L61303

; 1673 :       lpInternational->nLanguage = 1;

	mov	eax, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [eax+70], 1

; 1674 :    else

	jmp	$L61316
$L61303:

; 1675 :    if ( zstrcmpi( sz, "DEU" ) == 0 )

	push	OFFSET FLAT:??_C@_03CHCO@DEU?$AA@	; `string'
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L61305

; 1676 :       lpInternational->nLanguage = 49;

	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+70], 49			; 00000031H

; 1677 :    else

	jmp	SHORT $L61316
$L61305:

; 1678 :    if ( zstrcmpi( sz, "FRC" ) == 0 )

	push	OFFSET FLAT:??_C@_03NOPN@FRC?$AA@	; `string'
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L61308

; 1679 :       lpInternational->nLanguage = 2;

	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [ecx+70], 2

; 1680 :    else

	jmp	SHORT $L61316
$L61308:

; 1681 :    if ( zstrcmpi( sz, "POR" ) == 0 ) // Portuguese 351

	push	OFFSET FLAT:??_C@_03IDPK@POR?$AA@	; `string'
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L61311

; 1682 :       lpInternational->nLanguage = 351;

	mov	eax, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [eax+70], 351			; 0000015fH

; 1683 :    else

	jmp	SHORT $L61316
$L61311:

; 1684 :    if ( zstrcmpi( sz, "SPA" ) == 0 ) // Spanish 34

	push	OFFSET FLAT:??_C@_03JNKA@SPA?$AA@	; `string'
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L61314

; 1685 :       lpInternational->nLanguage = 34;

	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+70], 34			; 00000022H

; 1686 :    else

	jmp	SHORT $L61316
$L61314:

; 1687 :       lpInternational->nLanguage = 1; // lpInternational->nLanguage = 0;

	mov	eax, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [eax+70], 1
$L61316:

; 1688 : 
; 1689 :    // List separator, default comma
; 1690 :    GetProfileString( szlINTL, szlSLIST, ",", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_01KMAE@?0?$AA@	; `string'
	mov	edx, DWORD PTR _szlSLIST
	push	edx
	mov	eax, DWORD PTR _szlINTL
	push	eax
	call	DWORD PTR __imp__GetProfileStringA@20

; 1691 : 
; 1692 :    zstrcpy( lpInternational->szList, sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInternational$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	call	_strcpy
	add	esp, 8

; 1693 : 
; 1694 :    // Measurement system, default English
; 1695 :    // Time format, default 12 hour
; 1696 :    // Time Separator, default ":"
; 1697 :    lpInternational->nMeasure = GetProfileInt( szlINTL, szlIMEASURE, 1 );

	push	1
	mov	eax, DWORD PTR _szlIMEASURE
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+77], ax

; 1698 :    lpInternational->nTime = GetProfileInt( szlINTL, szlITIME, 0 );

	push	0
	mov	eax, DWORD PTR _szlITIME
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+79], ax

; 1699 :    GetProfileString( szlINTL, szlSTIME, ":", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_01PKAG@?3?$AA@	; `string'
	mov	ecx, DWORD PTR _szlSTIME
	push	ecx
	mov	edx, DWORD PTR _szlINTL
	push	edx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1700 : 
; 1701 :    zstrcpy( lpInternational->szTime, sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	add	ecx, 81					; 00000051H
	push	ecx
	call	_strcpy
	add	esp, 8

; 1702 : 
; 1703 :    // Trailing string for AM, default "AM"
; 1704 :    GetProfileString( szlINTL, szlS1159, "AM", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_02ENLM@AM?$AA@	; `string'
	mov	eax, DWORD PTR _szlS1159
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1705 : 
; 1706 :    zstrcpy( lpInternational->sz1159, sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInternational$[ebp]
	add	eax, 86					; 00000056H
	push	eax
	call	_strcpy
	add	esp, 8

; 1707 : 
; 1708 :    // Trailing string for PM, default "PM"
; 1709 :    GetProfileString( szlINTL, szlS2359, "PM", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_02DBLP@PM?$AA@	; `string'
	mov	edx, DWORD PTR _szlS2359
	push	edx
	mov	eax, DWORD PTR _szlINTL
	push	eax
	call	DWORD PTR __imp__GetProfileStringA@20

; 1710 : 
; 1711 :    zstrcpy( lpInternational->sz2359, sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInternational$[ebp]
	add	edx, 91					; 0000005bH
	push	edx
	call	_strcpy
	add	esp, 8

; 1712 : 
; 1713 :    // Time leading zeros for hours, default yes
; 1714 :    // Picture for short date, default "mm/dd/yy"
; 1715 :    lpInternational->nTLZero = GetProfileInt( szlINTL, szlITLZERO, 1 );

	push	1
	mov	eax, DWORD PTR _szlITLZERO
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+96], ax

; 1716 :    GetProfileString( szlINTL, szlSSHORTDATE, "mm/dd/yy",
; 1717 :                      sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08NNHK@mm?1dd?1yy?$AA@ ; `string'
	mov	ecx, DWORD PTR _szlSSHORTDATE
	push	ecx
	mov	edx, DWORD PTR _szlINTL
	push	edx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1718 : 
; 1719 :    fnConvertToZeidonFormat( sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_fnConvertToZeidonFormat
	add	esp, 4

; 1720 :    lpInternational->hShortDate =
; 1721 :       fnStoreStringInDataspace( AnchorBlock->hMainFirstDataHeader, sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	DWORD PTR [ecx+98], eax

; 1722 : 
; 1723 :    // Picture for long date, default "mmm dd, yyyy"
; 1724 :    GetProfileString( szlINTL, szlSLONGDATE, "mmm dd, yyyy",
; 1725 :                      sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0N@CFAC@mmm?5dd?0?5yyyy?$AA@ ; `string'
	mov	eax, DWORD PTR _szlSLONGDATE
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1726 : 
; 1727 :    fnConvertToZeidonFormat( sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_fnConvertToZeidonFormat
	add	esp, 4

; 1728 :    lpInternational->hLongDate =
; 1729 :       fnStoreStringInDataspace( AnchorBlock->hMainFirstDataHeader, sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	DWORD PTR [ecx+102], eax

; 1730 : 
; 1731 :    // Currency symbol, default "$"
; 1732 :    GetProfileString( szlINTL, szlSCURRENCY, "$", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_01PILM@$?$AA@		; `string'
	mov	eax, DWORD PTR _szlSCURRENCY
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1733 : 
; 1734 :    zstrcpy( lpInternational->szCurrency, sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInternational$[ebp]
	add	eax, 110				; 0000006eH
	push	eax
	call	_strcpy
	add	esp, 8

; 1735 : 
; 1736 :    // Current code format, default 0
; 1737 :    //
; 1738 :    // 0 - Currency symbol prefix with no separation ( $1 )
; 1739 :    // 1 - Currency symbol suffix with no separation ( 1$ )
; 1740 :    // 2 - Currency symbol prefix with one character separation ( $ 1 )
; 1741 :    // 3 - Currency symbol suffix with one character separation ( 1 $ )
; 1742 :    //
; 1743 : 
; 1744 :    // Number of digits used for the fractional part of a currency amount,
; 1745 :    // default 2.
; 1746 : 
; 1747 :    // Negative currency format code default 0
; 1748 :    //
; 1749 :    // 0  ($1)
; 1750 :    // 1  -$1
; 1751 :    // 2  $-1
; 1752 :    // 3  $1-
; 1753 :    // 4  (1$)
; 1754 :    // 5  -1$
; 1755 :    // 6  1-$
; 1756 :    // 7  1$-
; 1757 :    // 8  -1 $
; 1758 :    // 9  -$ 1
; 1759 :    // 10 $ 1-
; 1760 :    //
; 1761 : 
; 1762 :    // Symbol used to separate thousands in numbers with more than 3 digits,
; 1763 :    // default ","
; 1764 :    lpInternational->nCurrency = GetProfileInt( szlINTL, szlICURRENCY, 0 );

	push	0
	mov	ecx, DWORD PTR _szlICURRENCY
	push	ecx
	mov	edx, DWORD PTR _szlINTL
	push	edx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [ecx+120], ax

; 1765 :    lpInternational->nCurrDigits = GetProfileInt( szlINTL, szlICURRDIGITS, 2 );

	push	2
	mov	edx, DWORD PTR _szlICURRDIGITS
	push	edx
	mov	eax, DWORD PTR _szlINTL
	push	eax
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [ecx+122], ax

; 1766 :    lpInternational->nNegCurr = GetProfileInt( szlINTL, szlINEGCURR, 0 );

	push	0
	mov	edx, DWORD PTR _szlINEGCURR
	push	edx
	mov	eax, DWORD PTR _szlINTL
	push	eax
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [ecx+124], ax

; 1767 :    GetProfileString( szlINTL, szlSTHOUSAND, ",", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_01KMAE@?0?$AA@	; `string'
	mov	eax, DWORD PTR _szlSTHOUSAND
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1768 : 
; 1769 :    zstrcpy( lpInternational->szThousand, sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInternational$[ebp]
	add	eax, 126				; 0000007eH
	push	eax
	call	_strcpy
	add	esp, 8

; 1770 : 
; 1771 :    // Symbol used to separate the integer part from the fractional part
; 1772 :    // of a number, default "."
; 1773 :    GetProfileString( szlINTL, szlSDECIMAL, ".", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	mov	edx, DWORD PTR _szlSDECIMAL
	push	edx
	mov	eax, DWORD PTR _szlINTL
	push	eax
	call	DWORD PTR __imp__GetProfileStringA@20

; 1774 : 
; 1775 :    zstrcpy( lpInternational->szDecimal, sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInternational$[ebp]
	add	edx, 131				; 00000083H
	push	edx
	call	_strcpy
	add	esp, 8

; 1776 : 
; 1777 :    // Value defining the number of decimal digits that should be used in a
; 1778 :    // number, default 2
; 1779 : 
; 1780 :    // Value specifying whether a decimal value less than 1.0 (and greater
; 1781 :    // than -1.0) should contain a leading zero, as follows:
; 1782 :    //
; 1783 :    //  0    Do not use a leading zero (.7)
; 1784 :    //  1    Use a leading zero (0.7)
; 1785 :    //
; 1786 :    // Default is 1.
; 1787 :    lpInternational->nDigits = GetProfileInt( szlINTL, szlIDIGITS, 2 );

	push	2
	mov	eax, DWORD PTR _szlIDIGITS
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+136], ax

; 1788 :    lpInternational->nLZero = GetProfileInt( szlINTL, szlILZERO, 1 );

	push	1
	mov	eax, DWORD PTR _szlILZERO
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+138], ax

; 1789 : 
; 1790 :    // construct zeidon intl time format from the other indicators
; 1791 :    if ( lpInternational->nTLZero )

	mov	eax, DWORD PTR _lpInternational$[ebp]
	movsx	ecx, WORD PTR [eax+96]
	test	ecx, ecx
	je	SHORT $L61325

; 1792 :       zstrcpy( sz, "HH" );

	push	OFFSET FLAT:??_C@_02OOIJ@HH?$AA@	; `string'
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1793 :    else

	jmp	SHORT $L61327
$L61325:

; 1794 :       zstrcpy( sz, "H" );

	push	OFFSET FLAT:??_C@_01PBHI@H?$AA@		; `string'
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L61327:

; 1795 : 
; 1796 :    zstrcat( sz, "\"" );

	push	OFFSET FLAT:??_C@_01HMO@?$CC?$AA@	; `string'
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1797 :    zstrcat( sz, lpInternational->szTime );

	mov	edx, DWORD PTR _lpInternational$[ebp]
	add	edx, 81					; 00000051H
	push	edx
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1798 :    zstrcat( sz, "\"" );

	push	OFFSET FLAT:??_C@_01HMO@?$CC?$AA@	; `string'
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1799 :    zstrcat( sz, "MI" );

	push	OFFSET FLAT:??_C@_02IBO@MI?$AA@		; `string'
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1800 :    if ( lpInternational->nTime == 0 )

	mov	eax, DWORD PTR _lpInternational$[ebp]
	movsx	ecx, WORD PTR [eax+79]
	test	ecx, ecx
	jne	SHORT $L61331

; 1801 :       zstrcat( sz, " AM" );

	push	OFFSET FLAT:??_C@_03PGJ@?5AM?$AA@	; `string'
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$L61331:

; 1802 : 
; 1803 :    lpInternational->hTimeFmt =
; 1804 :       fnStoreStringInDataspace( AnchorBlock->hMainFirstDataHeader, sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	DWORD PTR [ecx+106], eax

; 1805 : 
; 1806 :    return( hInternational );

	mov	eax, DWORD PTR _hInternational$[ebp]
$L61295:

; 1807 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SysCreateInternational@0 ENDP
_TEXT	ENDS
PUBLIC	_SysGetLanguageCode@4
_TEXT	SEGMENT
_lpnLanguageCode$ = 8
_lpInternational$ = -4
_SysGetLanguageCode@4 PROC NEAR

; 1818 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1819 :    LPINTERNATIONAL   lpInternational;
; 1820 : 
; 1821 :    // Follow the chain from the AnchorBlock to the International Language
; 1822 :    // pointer to the International Language Code.  Then return the Code.
; 1823 : 
; 1824 :    lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2515]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$[ebp], eax

; 1825 :    *lpnLanguageCode = lpInternational->nLanguage;

	mov	edx, DWORD PTR _lpnLanguageCode$[ebp]
	mov	eax, DWORD PTR _lpInternational$[ebp]
	mov	cx, WORD PTR [eax+70]
	mov	WORD PTR [edx], cx

; 1826 : 
; 1827 :    return( 0 );

	xor	ax, ax

; 1828 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetLanguageCode@4 ENDP
_TEXT	ENDS
PUBLIC	_SysSetLanguageCode@4
_TEXT	SEGMENT
_nLanguageCode$ = 8
_lpInternational$ = -4
_SysSetLanguageCode@4 PROC NEAR

; 1839 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1840 :    LPINTERNATIONAL lpInternational;
; 1841 : 
; 1842 :    lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2515]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$[ebp], eax

; 1843 :    lpInternational->nLanguage = nLanguageCode;

	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	ax, WORD PTR _nLanguageCode$[ebp]
	mov	WORD PTR [edx+70], ax

; 1844 : 
; 1845 :    return( 0 );

	xor	ax, ax

; 1846 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysSetLanguageCode@4 ENDP
_TEXT	ENDS
PUBLIC	_SysGetNumberFormat@12
_TEXT	SEGMENT
_pchReturnThou$ = 8
_pchReturnDecPt$ = 12
_plPrecision$ = 16
_lpInternational$61351 = -4
_SysGetNumberFormat@12 PROC NEAR

; 1852 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1853 :    if ( AnchorBlock && AnchorBlock->hInternational )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $L61350
	mov	eax, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [eax+2515], 0
	je	SHORT $L61350

; 1855 :       LPINTERNATIONAL lpInternational;
; 1856 : 
; 1857 :       lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2515]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$61351[ebp], eax

; 1858 :       zstrcpy( pchReturnThou, lpInternational->szThousand );

	mov	eax, DWORD PTR _lpInternational$61351[ebp]
	add	eax, 126				; 0000007eH
	push	eax
	mov	ecx, DWORD PTR _pchReturnThou$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1859 :       zstrcpy( pchReturnDecPt, lpInternational->szDecimal );

	mov	edx, DWORD PTR _lpInternational$61351[ebp]
	add	edx, 131				; 00000083H
	push	edx
	mov	eax, DWORD PTR _pchReturnDecPt$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1860 :       *plPrecision = (zLONG) lpInternational->nDigits;

	mov	ecx, DWORD PTR _lpInternational$61351[ebp]
	movsx	edx, WORD PTR [ecx+136]
	mov	eax, DWORD PTR _plPrecision$[ebp]
	mov	DWORD PTR [eax], edx

; 1861 :       return( 0 );

	xor	ax, ax
	jmp	SHORT $L61354
$L61350:

; 1863 :    else
; 1864 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
$L61354:

; 1865 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysGetNumberFormat@12 ENDP
_TEXT	ENDS
PUBLIC	_SysGetTimeFormat@4
_TEXT	SEGMENT
_pchReturnString$ = 8
_lpInternational$61359 = -4
_SysGetTimeFormat@4 PROC NEAR

; 1869 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1870 :    *pchReturnString = 0;

	mov	eax, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [eax], 0

; 1871 : 
; 1872 :    if ( AnchorBlock && AnchorBlock->hInternational )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $L61361
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [ecx+2515], 0
	je	SHORT $L61361

; 1874 :       LPINTERNATIONAL lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2515]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$61359[ebp], eax

; 1875 : 
; 1876 :       if ( lpInternational->hTimeFmt )

	mov	ecx, DWORD PTR _lpInternational$61359[ebp]
	cmp	DWORD PTR [ecx+106], 0
	je	SHORT $L61361

; 1877 :          zstrcpy( pchReturnString, zGETPTR( lpInternational->hTimeFmt ) );

	mov	edx, DWORD PTR _lpInternational$61359[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$L61361:

; 1879 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetTimeFormat@4 ENDP
_TEXT	ENDS
PUBLIC	_SysGetLongDateFormat@4
_TEXT	SEGMENT
_pchReturnString$ = 8
_lpInternational$61367 = -4
_SysGetLongDateFormat@4 PROC NEAR

; 1883 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1884 :    *pchReturnString = 0;

	mov	eax, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [eax], 0

; 1885 : 
; 1886 :    if ( AnchorBlock && AnchorBlock->hInternational )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $L61369
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [ecx+2515], 0
	je	SHORT $L61369

; 1888 :       LPINTERNATIONAL lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2515]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$61367[ebp], eax

; 1889 : 
; 1890 :       if ( lpInternational->hLongDate )

	mov	ecx, DWORD PTR _lpInternational$61367[ebp]
	cmp	DWORD PTR [ecx+102], 0
	je	SHORT $L61369

; 1891 :          zstrcpy( pchReturnString, zGETPTR( lpInternational->hLongDate ) );

	mov	edx, DWORD PTR _lpInternational$61367[ebp]
	mov	eax, DWORD PTR [edx+102]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$L61369:

; 1893 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetLongDateFormat@4 ENDP
_TEXT	ENDS
PUBLIC	_SysGetShortDateFormat@4
_TEXT	SEGMENT
_pchReturnString$ = 8
_lpInternational$61375 = -4
_SysGetShortDateFormat@4 PROC NEAR

; 1897 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1898 :    *pchReturnString = 0;

	mov	eax, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [eax], 0

; 1899 : 
; 1900 :    if ( AnchorBlock && AnchorBlock->hInternational )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $L61377
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [ecx+2515], 0
	je	SHORT $L61377

; 1902 :       LPINTERNATIONAL lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2515]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$61375[ebp], eax

; 1903 : 
; 1904 :       if ( lpInternational->hShortDate )

	mov	ecx, DWORD PTR _lpInternational$61375[ebp]
	cmp	DWORD PTR [ecx+98], 0
	je	SHORT $L61377

; 1905 :          zstrcpy( pchReturnString, zGETPTR( lpInternational->hShortDate ) );

	mov	edx, DWORD PTR _lpInternational$61375[ebp]
	mov	eax, DWORD PTR [edx+98]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$L61377:

; 1907 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetShortDateFormat@4 ENDP
_TEXT	ENDS
PUBLIC	_fnConvertEnvironmentString@8
PUBLIC	_SysGetEnvVar@12
PUBLIC	??_C@_0CB@BDDO@No?5terminating?5?8?$CF?8?5in?5ZEIDON?4APP@ ; `string'
;	COMDAT ??_C@_0CB@BDDO@No?5terminating?5?8?$CF?8?5in?5ZEIDON?4APP@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CB@BDDO@No?5terminating?5?8?$CF?8?5in?5ZEIDON?4APP@ DB 'No termina'
	DB	'ting ''%'' in ZEIDON.APP', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchTarget$ = 8
_pchSource$ = 12
_pch$ = -4
_fnConvertEnvironmentString@8 PROC NEAR

; 1914 : {

	push	ebp
	mov	ebp, esp
	push	ecx
$L61386:

; 1915 :    zPCHAR pch;
; 1916 : 
; 1917 :    while ( *pchSource )

	mov	eax, DWORD PTR _pchSource$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$L61387

; 1919 :       // If char is not % then just copy it to target string and continue.
; 1920 :       if ( *pchSource != '%' )

	mov	edx, DWORD PTR _pchSource$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 37					; 00000025H
	je	SHORT $L61388

; 1922 :          *pchTarget++ = *pchSource++;

	mov	ecx, DWORD PTR _pchTarget$[ebp]
	mov	edx, DWORD PTR _pchSource$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchTarget$[ebp], ecx
	mov	edx, DWORD PTR _pchSource$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSource$[ebp], edx

; 1923 :          continue;

	jmp	SHORT $L61386
$L61388:

; 1925 : 
; 1926 :       // Bump up pchSource to skip past %.
; 1927 :       pchSource++;

	mov	eax, DWORD PTR _pchSource$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchSource$[ebp], eax

; 1928 : 
; 1929 :       // Look for final %.
; 1930 :       for ( pch = pchSource; *pch && *pch != '%'; pch++ )

	mov	ecx, DWORD PTR _pchSource$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx
	jmp	SHORT $L61389
$L61390:
	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
$L61389:
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L61391
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 37					; 00000025H
	je	SHORT $L61391

; 1931 :          ; // Nothing needs to be done here.

	jmp	SHORT $L61390
$L61391:

; 1932 : 
; 1933 :       if ( *pch == 0 )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L61392

; 1935 :          // Error -- no terminating %.
; 1936 :          SysMessageBox( 0, szlOE_SystemError,
; 1937 :                         "No terminating '%' in ZEIDON.APP", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0CB@BDDO@No?5terminating?5?8?$CF?8?5in?5ZEIDON?4APP@ ; `string'
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 1938 : 
; 1939 :          // Try to get out as gracefully as possible.
; 1940 :          *pchTarget++ = '%';

	mov	ecx, DWORD PTR _pchTarget$[ebp]
	mov	BYTE PTR [ecx], 37			; 00000025H
	mov	edx, DWORD PTR _pchTarget$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchTarget$[ebp], edx

; 1941 :          zstrcpy( pchTarget, pchSource );

	mov	eax, DWORD PTR _pchSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1942 :          return;

	jmp	SHORT $L61383
$L61392:

; 1944 : 
; 1945 :       // Temporarily change '%' to null-terminator.
; 1946 :       *pch = 0;

	mov	edx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [edx], 0

; 1947 : 
; 1948 :       // Expand env var in the target string.
; 1949 :       SysGetEnvVar( pchTarget, pchSource, zMAX_FILENAME_LTH );

	push	256					; 00000100H
	mov	eax, DWORD PTR _pchSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	push	ecx
	call	_SysGetEnvVar@12

; 1950 : 
; 1951 :       // Change null-terminator back to '%'.
; 1952 :       *pch = '%';

	mov	edx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [edx], 37			; 00000025H
$L61395:

; 1953 : 
; 1954 :       // Move pchTarget to point to null-terminator.
; 1955 :       while ( *pchTarget )

	mov	eax, DWORD PTR _pchTarget$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L61396

; 1956 :          pchTarget++;

	mov	edx, DWORD PTR _pchTarget$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchTarget$[ebp], edx
	jmp	SHORT $L61395
$L61396:

; 1957 : 
; 1958 :       pchSource = pch + 1;

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchSource$[ebp], eax

; 1959 : 
; 1960 :    } // while ( *pchSource )...

	jmp	$L61386
$L61387:

; 1961 : 
; 1962 :    // Terminate result.
; 1963 :    *pchTarget = 0;

	mov	ecx, DWORD PTR _pchTarget$[ebp]
	mov	BYTE PTR [ecx], 0
$L61383:

; 1964 : 
; 1965 : } // fnConvertEnvironmentString

	mov	esp, ebp
	pop	ebp
	ret	8
_fnConvertEnvironmentString@8 ENDP
_TEXT	ENDS
PUBLIC	_SysConvertEnvironmentString@8
_TEXT	SEGMENT
_pchTarget$ = 8
_pchSource$ = 12
_SysConvertEnvironmentString@8 PROC NEAR

; 1969 : {

	push	ebp
	mov	ebp, esp

; 1970 :    fnConvertEnvironmentString( pchTarget, pchSource );

	mov	eax, DWORD PTR _pchSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	push	ecx
	call	_fnConvertEnvironmentString@8

; 1971 : }

	pop	ebp
	ret	8
_SysConvertEnvironmentString@8 ENDP
_TEXT	ENDS
PUBLIC	_fnBuildZeidonIni
PUBLIC	??_C@_0L@PEHO@zeidon?4ini?$AA@			; `string'
;	COMDAT ??_C@_0L@PEHO@zeidon?4ini?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0L@PEHO@zeidon?4ini?$AA@ DB 'zeidon.ini', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchFileName$ = 8
_nMaxLth$ = 12
_nLth$ = -4
_fnBuildZeidonIni PROC NEAR

; 1975 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1976 :    zSHORT nLth;
; 1977 : 
; 1978 :    SysGetEnvVar( pchFileName, szlZEIDON, nMaxLth );

	movsx	eax, WORD PTR _nMaxLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlZEIDON
	push	ecx
	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	call	_SysGetEnvVar@12

; 1979 :    if ( pchFileName[ 0 ] )

	mov	eax, DWORD PTR _pchFileName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L61409

; 1981 :       SysAppendcDirSep( pchFileName );

	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 1982 :       nLth = zstrlen( pchFileName );

	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$[ebp], ax

; 1983 :       zstrcpy( pchFileName + nLth, "zeidon.ini" );

	push	OFFSET FLAT:??_C@_0L@PEHO@zeidon?4ini?$AA@ ; `string'
	movsx	ecx, WORD PTR _nLth$[ebp]
	mov	edx, DWORD PTR _pchFileName$[ebp]
	add	edx, ecx
	push	edx
	call	_strcpy
	add	esp, 8

; 1985 :    else

	jmp	SHORT $L61411
$L61409:

; 1986 :       nLth = 0;

	mov	WORD PTR _nLth$[ebp], 0
$L61411:

; 1987 : 
; 1988 :    return( nLth );

	mov	ax, WORD PTR _nLth$[ebp]

; 1989 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnBuildZeidonIni ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DBJB@InitAnchor?$AA@			; `string'
PUBLIC	??_C@_02NCFH@?5?8?$AA@				; `string'
PUBLIC	??_C@_01HAF@?8?$AA@				; `string'
PUBLIC	_fnSysOpenFile@12
PUBLIC	_SysParseLine@12
PUBLIC	??_C@_02GIEM@?0?5?$AA@				; `string'
PUBLIC	??_C@_04FEEL@TEMP?$AA@				; `string'
PUBLIC	??_C@_03LDNL@TMP?$AA@				; `string'
PUBLIC	??_C@_0BF@IKIP@MemoryTraceThreshold?$AA@	; `string'
PUBLIC	??_C@_0P@CGC@?$FLObjectEngine?$FN?$AA@		; `string'
PUBLIC	??_C@_0O@CGLF@MemoryCeiling?$AA@		; `string'
PUBLIC	??_C@_0CL@NLJM@Object?5Services?5Initialization?5c@ ; `string'
PUBLIC	??_C@_0CK@EGPN@Object?5Services?5Running?5in?5Serve@ ; `string'
PUBLIC	??_C@_0CK@LCNC@Object?5Services?5Running?5in?5Share@ ; `string'
PUBLIC	_fnSysReadLine@16
PUBLIC	_fnSysCloseFile@12
PUBLIC	_InitializeAnchorBlock@16
PUBLIC	_SysGetBaseMessage@12
PUBLIC	??_C@_09ODBK@AllocSize?$AA@			; `string'
PUBLIC	??_C@_09CJOG@OE?5Anchor?$AA@			; `string'
EXTRN	__imp__GetPrivateProfileIntA@16:NEAR
EXTRN	__imp__atoi:NEAR
EXTRN	_fnTraceCompileTime@0:NEAR
EXTRN	_fnInitializeDataspace:NEAR
EXTRN	__imp__GetWindowTextA@12:NEAR
EXTRN	__imp__SendMessageA@16:NEAR
EXTRN	_MiListOE_Memory@8:NEAR
EXTRN	_memset:NEAR
EXTRN	__imp__strncmp:NEAR
;	COMDAT ??_C@_09ODBK@AllocSize?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_09ODBK@AllocSize?$AA@ DB 'AllocSize', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09CJOG@OE?5Anchor?$AA@
_DATA	SEGMENT
??_C@_09CJOG@OE?5Anchor?$AA@ DB 'OE Anchor', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DBJB@InitAnchor?$AA@
_DATA	SEGMENT
??_C@_0L@DBJB@InitAnchor?$AA@ DB 'InitAnchor', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_02NCFH@?5?8?$AA@
_DATA	SEGMENT
??_C@_02NCFH@?5?8?$AA@ DB ' ''', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01HAF@?8?$AA@
_DATA	SEGMENT
??_C@_01HAF@?8?$AA@ DB '''', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02GIEM@?0?5?$AA@
_DATA	SEGMENT
??_C@_02GIEM@?0?5?$AA@ DB ', ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04FEEL@TEMP?$AA@
_DATA	SEGMENT
??_C@_04FEEL@TEMP?$AA@ DB 'TEMP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03LDNL@TMP?$AA@
_DATA	SEGMENT
??_C@_03LDNL@TMP?$AA@ DB 'TMP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@IKIP@MemoryTraceThreshold?$AA@
_DATA	SEGMENT
??_C@_0BF@IKIP@MemoryTraceThreshold?$AA@ DB 'MemoryTraceThreshold', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@CGC@?$FLObjectEngine?$FN?$AA@
_DATA	SEGMENT
??_C@_0P@CGC@?$FLObjectEngine?$FN?$AA@ DB '[ObjectEngine]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@CGLF@MemoryCeiling?$AA@
_DATA	SEGMENT
??_C@_0O@CGLF@MemoryCeiling?$AA@ DB 'MemoryCeiling', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@NLJM@Object?5Services?5Initialization?5c@
_DATA	SEGMENT
??_C@_0CL@NLJM@Object?5Services?5Initialization?5c@ DB 'Object Services I'
	DB	'nitialization complete...', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CK@EGPN@Object?5Services?5Running?5in?5Serve@
_DATA	SEGMENT
??_C@_0CK@EGPN@Object?5Services?5Running?5in?5Serve@ DB 'Object Services '
	DB	'Running in Server Mode...', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CK@LCNC@Object?5Services?5Running?5in?5Share@
_DATA	SEGMENT
??_C@_0CK@LCNC@Object?5Services?5Running?5in?5Share@ DB 'Object Services '
	DB	'Running in Shared Mode...', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpProcessList$61446 = -1312
_lpFirstSubtask$61447 = -1308
_pchLine$61448 = -1304
_hFile$61449 = -1320
_nEOF$61450 = -1316
_szMessage$61454 = -1576
_szMessage$61494 = -1832
_lpApp$61497 = -1836
_sz$61504 = -2096
_cd$61511 = -2108
_OE_AnchorBlock$ = 8
_lOE_hMainWnd$ = 12
_lOE_hListWnd$ = 16
_lOE_Msg$ = 20
_pvFile$ = -524
_szTaskTitle$ = -520
_szZeidonEnv$ = -780
_szSize$ = -264
_lpMainTask$ = -8
_lTaskAllocSize$ = -784
_lSize$ = -4
_szMessage$61429 = -1040
_szFileName$61431 = -1300
_InitializeAnchorBlock@16 PROC NEAR

; 2014 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2124				; 0000084cH

; 2015 :    zPVOID pvFile;
; 2016 :    char   szTaskTitle[ 256 ];
; 2017 :    char   szZeidonEnv[ 256 ];
; 2018 :    char   szSize[ 256 ];
; 2019 :    LPTASK lpMainTask;
; 2020 :    zLONG  lTaskAllocSize = zSHARED_ALLOC;

	mov	DWORD PTR _lTaskAllocSize$[ebp], 4000000 ; 003d0900H

; 2021 :    zLONG  lSize = 16384;

	mov	DWORD PTR _lSize$[ebp], 16384		; 00004000H

; 2022 : 
; 2023 :    zmemset( szZeidonEnv, 0, sizeof( szZeidonEnv ) );

	push	256					; 00000100H
	push	0
	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2024 : 
; 2025 :    // Validate that environment variable ZEIDON set, NOTE: This
; 2026 :    // is done both here and in SysStartObjectServices on purpose
; 2027 :    // because ObjectServices can be started either alone or by
; 2028 :    // a client's RegisterZeidonApplication call.
; 2029 : 
; 2030 :    // Validate that environment variable ZEIDON set, NOTE: This
; 2031 :    // is done both here and in SysStartObjectServices on purpose
; 2032 :    // because ObjectServices can be started either alone or by
; 2033 :    // a client's RegisterZeidonApplication call.
; 2034 :    SysGetEnvVar( szZeidonEnv, szlZEIDON, sizeof( szZeidonEnv ) );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _szlZEIDON
	push	ecx
	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	call	_SysGetEnvVar@12

; 2035 :    if ( szZeidonEnv[ 0 ] == 0 )

	movsx	eax, BYTE PTR _szZeidonEnv$[ebp]
	test	eax, eax
	jne	SHORT $L61428

; 2037 :       char szMessage[ 256 ];
; 2038 : 
; 2039 :       // {2,"KZOEE002 - ZEIDON environment variable not set"},
; 2040 :       SysGetBaseMessage( szMessage, KZOEE002, sizeof( szMessage ) );

	push	256					; 00000100H
	push	2
	lea	ecx, DWORD PTR _szMessage$61429[ebp]
	push	ecx
	call	_SysGetBaseMessage@12

; 2041 :       SysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	edx, DWORD PTR _szMessage$61429[ebp]
	push	edx
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 2042 : 
; 2043 :       return( (LPANCHOR) zCALL_ERROR );   // Error initializing anchor

	mov	eax, -16				; fffffff0H
	jmp	$L61420
$L61428:

; 2047 :       zCHAR szFileName[ zMAX_FILENAME_LTH + 1 ];
; 2048 : 
; 2049 :       fnBuildZeidonIni( szFileName, sizeof( szFileName ) );

	push	257					; 00000101H
	lea	ecx, DWORD PTR _szFileName$61431[ebp]
	push	ecx
	call	_fnBuildZeidonIni
	add	esp, 8

; 2050 :       lTaskAllocSize = GetPrivateProfileInt( "Zeidon", "AllocSize",
; 2051 :                                              lTaskAllocSize, szFileName );

	lea	edx, DWORD PTR _szFileName$61431[ebp]
	push	edx
	mov	eax, DWORD PTR _lTaskAllocSize$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_09ODBK@AllocSize?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06BADI@Zeidon?$AA@	; `string'
	call	DWORD PTR __imp__GetPrivateProfileIntA@16
	mov	DWORD PTR _lTaskAllocSize$[ebp], eax

; 2052 : 
; 2053 :       // Make sure size is at leask 64K
; 2054 :       if ( lTaskAllocSize < 64000 )

	cmp	DWORD PTR _lTaskAllocSize$[ebp], 64000	; 0000fa00H
	jge	SHORT $L61433

; 2055 :          lTaskAllocSize = zSHARED_ALLOC; // 4000000L or old one 262000L

	mov	DWORD PTR _lTaskAllocSize$[ebp], 4000000 ; 003d0900H
$L61433:

; 2057 : 
; 2058 :    // Edit the zeidon environment and make sure it ends with a
; 2059 :    // directory separator.
; 2060 :    SysAppendcDirSep( szZeidonEnv );

	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 2061 : 
; 2062 :    zLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysLockCoreMutex@4

; 2063 : 
; 2064 :    // Allocate the main shared table space for the Anchor Block
; 2065 : #ifdef ALLOC_FREE_TRACE
; 2066 :    lSize += 3 * ALLOC_FREE_TRACE * sizeof( zPVOID );
; 2067 : #endif
; 2068 : 
; 2069 :    g_hAnchorBlock = fnInitializeDataspace( 0, (zCOREMEM) &AnchorBlock,
; 2070 :                                            iAnchor, "OE Anchor",
; 2071 :                                            lSize - sizeof( DataHeaderRecord ),
; 2072 :                                            szlShareSeg );

	mov	edx, DWORD PTR _szlShareSeg
	push	edx
	mov	eax, DWORD PTR _lSize$[ebp]
	sub	eax, 64					; 00000040H
	push	eax
	push	OFFSET FLAT:??_C@_09CJOG@OE?5Anchor?$AA@ ; `string'
	push	10001					; 00002711H
	push	OFFSET FLAT:_AnchorBlock
	push	0
	call	_fnInitializeDataspace
	add	esp, 24					; 00000018H
	mov	DWORD PTR _g_hAnchorBlock, eax

; 2081 :       fnAllocDataspace( (LPDATAHEADER) g_hAnchorBlock,
; 2082 :                         sizeof( AnchorRecord ) - (sizeof( DataHeaderRecord ) +
; 2083 :                                   sizeof( FreespaceRecord )),
; 2084 :                         1, 0, iAnchor );

	push	10001					; 00002711H
	push	0
	push	1
	push	2449					; 00000991H
	mov	ecx, DWORD PTR _g_hAnchorBlock
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H

; 2086 : 
; 2087 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $L61441

; 2089 :       zUNLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysUnlockCoreMutex@4

; 2090 :       return( 0 );

	xor	eax, eax
	jmp	$L61420
$L61441:

; 2092 : 
; 2093 :    AnchorBlock->nStatus          = AnchorUninitialized;  // Init is pending

	mov	edx, DWORD PTR _AnchorBlock
	mov	WORD PTR [edx+84], 0

; 2094 : // AnchorBlock->lMainTaskID      = 0; // SysGetTaskID( );
; 2095 : 
; 2096 : #ifdef ALLOC_FREE_TRACE
; 2097 :    AnchorBlock->bTraceMem = (zBOOL) SysSendOE_Message( IDM_GETMEMORYTRACE, 0 );
; 2098 : #endif
; 2099 : 
; 2100 :    AnchorBlock->lTaskAllocSize   = lTaskAllocSize - sizeof( DataHeaderRecord );

	mov	eax, DWORD PTR _lTaskAllocSize$[ebp]
	sub	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+86], eax

; 2101 :    AnchorBlock->lHab             = OE_AnchorBlock;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _OE_AnchorBlock$[ebp]
	mov	DWORD PTR [edx+90], eax

; 2102 :    AnchorBlock->lOE_hMainWnd     = lOE_hMainWnd;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _lOE_hMainWnd$[ebp]
	mov	DWORD PTR [ecx+94], edx

; 2103 :    AnchorBlock->lOE_hListWnd     = lOE_hListWnd;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _lOE_hListWnd$[ebp]
	mov	DWORD PTR [eax+98], ecx

; 2104 :    AnchorBlock->lOE_Msg          = lOE_Msg;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _lOE_Msg$[ebp]
	mov	DWORD PTR [edx+102], eax

; 2105 :    AnchorBlock->hFirstTask       = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+130], 0

; 2106 :    AnchorBlock->hMainTask        = 0;

	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+106], 0

; 2107 :    AnchorBlock->hSystemApp       = 0;

	mov	eax, DWORD PTR _AnchorBlock
	mov	DWORD PTR [eax+110], 0

; 2108 :    AnchorBlock->hMainFirstDataHeader = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+114], 0

; 2109 :    AnchorBlock->hFirstApp        = 0;

	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+126], 0

; 2110 :    AnchorBlock->hFirstTask       = 0;

	mov	eax, DWORD PTR _AnchorBlock
	mov	DWORD PTR [eax+130], 0

; 2111 : // AnchorBlock->hFirstOpenFile   = 0; moved to Task
; 2112 : // AnchorBlock->hFirstProcLib    = 0; moved to Task
; 2113 :    zstrcpy( AnchorBlock->szZeidonLocal, szZeidonEnv );

	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 138				; 0000008aH
	push	edx
	call	_strcpy
	add	esp, 8

; 2114 :    AnchorBlock->szZeidonBin[ 0 ] = 0;

	mov	eax, DWORD PTR _AnchorBlock
	mov	BYTE PTR [eax+395], 0

; 2115 :    AnchorBlock->szZeidonSys[ 0 ] = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	BYTE PTR [ecx+652], 0

; 2116 :    AnchorBlock->szZeidonLoc[ 0 ] = 0;

	mov	edx, DWORD PTR _AnchorBlock
	mov	BYTE PTR [edx+909], 0

; 2117 :    AnchorBlock->szZeidonShr[ 0 ] = 0;

	mov	eax, DWORD PTR _AnchorBlock
	mov	BYTE PTR [eax+1166], 0

; 2118 :    AnchorBlock->szUserID[ 0 ]    = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	BYTE PTR [ecx+1423], 0

; 2119 :    AnchorBlock->szPassword[ 0 ]  = 0;

	mov	edx, DWORD PTR _AnchorBlock
	mov	BYTE PTR [edx+1456], 0

; 2120 :    AnchorBlock->hFirstViewName   = 0;

	mov	eax, DWORD PTR _AnchorBlock
	mov	DWORD PTR [eax+1489], 0

; 2121 :    AnchorBlock->nBrowseTaskListCounter = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	WORD PTR [ecx+1493], 0

; 2122 :    AnchorBlock->bShowTaskID      = FALSE;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1495]
	and	al, -2					; fffffffeH
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+1495], eax

; 2123 :    AnchorBlock->bTraceCnt        = TRUE;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1495]
	or	al, 2
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+1495], eax

; 2124 :    AnchorBlock->bDropEngineIfNoTasks = FALSE;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1495]
	and	al, -5					; fffffffbH
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+1495], eax

; 2125 :    AnchorBlock->bDeleteTaskInProgress = FALSE;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1495]
	and	al, -17					; ffffffefH
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+1495], eax

; 2126 :    AnchorBlock->lpParentTask     = 0;

	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+2511], 0

; 2127 :    AnchorBlock->hInternational   = 0;

	mov	eax, DWORD PTR _AnchorBlock
	mov	DWORD PTR [eax+2515], 0

; 2128 :    AnchorBlock->hFirstSysMutex   = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+2519], 0

; 2129 :    AnchorBlock->hFirstDebugChange = 0;

	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+2523], 0

; 2130 : // AnchorBlock->TraceFlags       = 0;
; 2131 :    AnchorBlock->nMemoryTraceThreshold = 0;

	mov	eax, DWORD PTR _AnchorBlock
	mov	WORD PTR [eax+134], 0

; 2132 :    AnchorBlock->nMemoryCeiling   = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	WORD PTR [ecx+136], 0

; 2133 : 
; 2134 :    // Get Title of Main Task.
; 2135 :    GetWindowText( (HWND) lOE_hMainWnd, szTaskTitle, sizeof( szTaskTitle ) - 1 );

	push	255					; 000000ffH
	lea	edx, DWORD PTR _szTaskTitle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lOE_hMainWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetWindowTextA@12

; 2136 : 
; 2137 :    lpMainTask = fnCreateTask( OE_AnchorBlock, lOE_hMainWnd,
; 2138 :                               lOE_Msg, szTaskTitle );

	lea	ecx, DWORD PTR _szTaskTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lOE_Msg$[ebp]
	push	edx
	mov	eax, DWORD PTR _lOE_hMainWnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _OE_AnchorBlock$[ebp]
	push	ecx
	call	_fnCreateTask
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpMainTask$[ebp], eax

; 2139 : 
; 2140 :    // Task is now ready to go.
; 2141 :    lpMainTask->bDisable = FALSE;

	mov	edx, DWORD PTR _lpMainTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	and	al, -9					; fffffff7H
	mov	ecx, DWORD PTR _lpMainTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 2142 : 
; 2143 : // g_lpCurrentTask = lpMainTask;
; 2144 : 
; 2145 :    AnchorBlock->hMainFirstDataHeader = lpMainTask->hFirstDataHeader;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _lpMainTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	mov	DWORD PTR [edx+114], ecx

; 2146 :    AnchorBlock->hMainTask = zGETHNDL( lpMainTask );

	mov	edx, DWORD PTR _lpMainTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+106], eax

; 2147 :    if ( AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [edx+106], 0
	je	$L61445

; 2149 :       LPPROCESSLIST lpProcessList;
; 2150 :       LPSUBTASK lpFirstSubtask;
; 2151 :       zPCHAR    pchLine;
; 2152 :       zLONG     hFile;
; 2153 :       int       nEOF;
; 2154 : 
; 2155 :       // Now that we have allocated the AnchorBlock's memory, we can
; 2156 :       // set the process index for the main task.
; 2157 :       fnSetProcessIdx( "InitAnchor", &lpProcessList );

	lea	eax, DWORD PTR _lpProcessList$61446[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@DBJB@InitAnchor?$AA@ ; `string'
	call	_fnSetProcessIdx
	add	esp, 8

; 2158 :       lpProcessList->uAppOE_Msg = (zUSHORT) lOE_Msg;

	mov	ecx, DWORD PTR _lpProcessList$61446[ebp]
	mov	dx, WORD PTR _lOE_Msg$[ebp]
	mov	WORD PTR [ecx+2], dx

; 2159 :       lpProcessList->hWndAppOE_Msg = lOE_hMainWnd;

	mov	eax, DWORD PTR _lpProcessList$61446[ebp]
	mov	ecx, DWORD PTR _lOE_hMainWnd$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2160 : 
; 2161 :       // Now that we have created the main task, see if we can open
; 2162 :       // the zeidon applications file and get the directory pointers
; 2163 :       // for the zeidon exe directory and the zeidon system directory.
; 2164 :       zstrcat( szZeidonEnv, szlAppFile );

	mov	edx, DWORD PTR _szlAppFile
	push	edx
	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2165 :       hFile = fnSysOpenFile( lpMainTask, szZeidonEnv, COREFILE_READ );

	push	128					; 00000080H
	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMainTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFile$61449[ebp], eax

; 2166 :       if ( hFile == -1 )

	cmp	DWORD PTR _hFile$61449[ebp], -1
	jne	$L61453

; 2168 :          char szMessage[ 256 ];
; 2169 : 
; 2170 :          // {9,"KZOEE009 - Error opening application definition file"},
; 2171 :          SysGetBaseMessage( szMessage, KZOEE009, 255 );

	push	255					; 000000ffH
	push	9
	lea	eax, DWORD PTR _szMessage$61454[ebp]
	push	eax
	call	_SysGetBaseMessage@12

; 2172 :          zstrcat( szMessage, " '" );

	push	OFFSET FLAT:??_C@_02NCFH@?5?8?$AA@	; `string'
	lea	ecx, DWORD PTR _szMessage$61454[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2173 :          zstrcat( szMessage, szZeidonEnv );

	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	lea	eax, DWORD PTR _szMessage$61454[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2174 :          zstrcat( szMessage, "'" );

	push	OFFSET FLAT:??_C@_01HAF@?8?$AA@		; `string'
	lea	ecx, DWORD PTR _szMessage$61454[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2175 : 
; 2176 :          // Free the shared segment for KZOENGWA
; 2177 :          AnchorBlock->nStatus = AnchorCorrupt; // mark AnchorBlock as no good

	mov	edx, DWORD PTR _AnchorBlock
	mov	WORD PTR [edx+84], 20			; 00000014H

; 2178 :          fnFreeSharedMemory( lpMainTask, g_hAnchorBlock ); // free for KZOENGAA.DLL

	mov	eax, DWORD PTR _g_hAnchorBlock
	push	eax
	mov	ecx, DWORD PTR _lpMainTask$[ebp]
	push	ecx
	call	_fnFreeSharedMemory@8

; 2179 : 
; 2180 :          // NULL AnchorBlock handle and pointer
; 2181 :          g_hAnchorBlock = 0;

	mov	DWORD PTR _g_hAnchorBlock, 0

; 2182 :          AnchorBlock  = 0;

	mov	DWORD PTR _AnchorBlock, 0

; 2183 :          g_lProcessIdx = -1;

	mov	DWORD PTR _g_lProcessIdx, -1

; 2184 : 
; 2185 :          fnSysMessageBox( lpMainTask, szlOE_SystemError, szMessage, 1 );

	push	1
	lea	edx, DWORD PTR _szMessage$61454[ebp]
	push	edx
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpMainTask$[ebp]
	push	ecx
	call	_fnSysMessageBox@16

; 2186 :          zUNLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysUnlockCoreMutex@4

; 2187 :          return( 0 );

	xor	eax, eax
	jmp	$L61420
$L61453:

; 2189 : 
; 2190 :       pvFile = 0;

	mov	DWORD PTR _pvFile$[ebp], 0

; 2191 :       nEOF = fnSysReadLine( lpMainTask, &pchLine, hFile, &pvFile );

	lea	edx, DWORD PTR _pvFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFile$61449[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$61448[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMainTask$[ebp]
	push	edx
	call	_fnSysReadLine@16
	mov	DWORD PTR _nEOF$61450[ebp], eax
$L61458:

; 2192 :       while ( nEOF > 0 )

	cmp	DWORD PTR _nEOF$61450[ebp], 0
	jle	$L61459

; 2194 :          SysParseLine( szZeidonEnv, &pchLine, pchLine + 1 );

	mov	eax, DWORD PTR _pchLine$61448[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _pchLine$61448[ebp]
	push	ecx
	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	call	_SysParseLine@12

; 2195 :          if ( zstrcmp( szZeidonEnv, szlZEIDON_BIN ) == 0 )

	movsx	eax, BYTE PTR _szZeidonEnv$[ebp]
	mov	ecx, DWORD PTR _szlZEIDON_BIN
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $L64796
	mov	eax, DWORD PTR _szlZEIDON_BIN
	push	eax
	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -2112+[ebp], eax
	jmp	SHORT $L64797
$L64796:
	movsx	edx, BYTE PTR _szZeidonEnv$[ebp]
	mov	eax, DWORD PTR _szlZEIDON_BIN
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	xor	eax, eax
	test	edx, edx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -2112+[ebp], eax
$L64797:
	cmp	DWORD PTR -2112+[ebp], 0
	jne	SHORT $L61466

; 2197 :             fnConvertEnvironmentString( szZeidonEnv, pchLine );

	mov	ecx, DWORD PTR _pchLine$61448[ebp]
	push	ecx
	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	call	_fnConvertEnvironmentString@8

; 2198 :             SysAppendcDirSep( szZeidonEnv );

	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 2199 :             zstrcpy( AnchorBlock->szZeidonBin, szZeidonEnv );

	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 395				; 0000018bH
	push	edx
	call	_strcpy
	add	esp, 8

; 2201 :          else

	jmp	$L61490
$L61466:

; 2202 :          if ( zstrcmp( szZeidonEnv, szlZEIDON_SYS ) == 0 )

	movsx	eax, BYTE PTR _szZeidonEnv$[ebp]
	mov	ecx, DWORD PTR _szlZEIDON_SYS
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $L64798
	mov	eax, DWORD PTR _szlZEIDON_SYS
	push	eax
	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -2116+[ebp], eax
	jmp	SHORT $L64799
$L64798:
	movsx	edx, BYTE PTR _szZeidonEnv$[ebp]
	mov	eax, DWORD PTR _szlZEIDON_SYS
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	xor	eax, eax
	test	edx, edx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -2116+[ebp], eax
$L64799:
	cmp	DWORD PTR -2116+[ebp], 0
	jne	SHORT $L61474

; 2204 :             fnConvertEnvironmentString( szZeidonEnv, pchLine );

	mov	ecx, DWORD PTR _pchLine$61448[ebp]
	push	ecx
	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	call	_fnConvertEnvironmentString@8

; 2205 :             SysAppendcDirSep( szZeidonEnv );

	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 2206 :             zstrcpy( AnchorBlock->szZeidonSys, szZeidonEnv );

	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 652				; 0000028cH
	push	edx
	call	_strcpy
	add	esp, 8

; 2208 :          else

	jmp	$L61490
$L61474:

; 2209 :          if ( zstrcmp( szZeidonEnv, szlZEIDON_LOC ) == 0 )

	movsx	eax, BYTE PTR _szZeidonEnv$[ebp]
	mov	ecx, DWORD PTR _szlZEIDON_LOC
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $L64800
	mov	eax, DWORD PTR _szlZEIDON_LOC
	push	eax
	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -2120+[ebp], eax
	jmp	SHORT $L64801
$L64800:
	movsx	edx, BYTE PTR _szZeidonEnv$[ebp]
	mov	eax, DWORD PTR _szlZEIDON_LOC
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	xor	eax, eax
	test	edx, edx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -2120+[ebp], eax
$L64801:
	cmp	DWORD PTR -2120+[ebp], 0
	jne	SHORT $L61482

; 2211 :             fnConvertEnvironmentString( szZeidonEnv, pchLine );

	mov	ecx, DWORD PTR _pchLine$61448[ebp]
	push	ecx
	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	call	_fnConvertEnvironmentString@8

; 2212 :             SysAppendcDirSep( szZeidonEnv );

	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 2213 :             zstrcpy( AnchorBlock->szZeidonLoc, szZeidonEnv );

	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 909				; 0000038dH
	push	edx
	call	_strcpy
	add	esp, 8

; 2215 :          else

	jmp	$L61490
$L61482:

; 2216 :          if ( zstrcmp( szZeidonEnv, szlZEIDON_SHR ) == 0 )

	movsx	eax, BYTE PTR _szZeidonEnv$[ebp]
	mov	ecx, DWORD PTR _szlZEIDON_SHR
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $L64802
	mov	eax, DWORD PTR _szlZEIDON_SHR
	push	eax
	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -2124+[ebp], eax
	jmp	SHORT $L64803
$L64802:
	movsx	edx, BYTE PTR _szZeidonEnv$[ebp]
	mov	eax, DWORD PTR _szlZEIDON_SHR
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	xor	eax, eax
	test	edx, edx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -2124+[ebp], eax
$L64803:
	cmp	DWORD PTR -2124+[ebp], 0
	jne	SHORT $L61490

; 2218 :             fnConvertEnvironmentString( szZeidonEnv, pchLine );

	mov	ecx, DWORD PTR _pchLine$61448[ebp]
	push	ecx
	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	call	_fnConvertEnvironmentString@8

; 2219 :             SysAppendcDirSep( szZeidonEnv );

	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 2220 :             zstrcpy( AnchorBlock->szZeidonShr, szZeidonEnv );

	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 1166				; 0000048eH
	push	edx
	call	_strcpy
	add	esp, 8
$L61490:

; 2222 : 
; 2223 :          nEOF = fnSysReadLine( lpMainTask, &pchLine, hFile, &pvFile );

	lea	eax, DWORD PTR _pvFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$61449[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$61448[ebp]
	push	edx
	mov	eax, DWORD PTR _lpMainTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _nEOF$61450[ebp], eax

; 2224 :          if ( zstrncmp( pchLine + 1, szlAPPLICATION,
; 2225 :                         zstrlen( szlAPPLICATION ) ) == 0 )

	mov	ecx, DWORD PTR _szlAPPLICATION
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _szlAPPLICATION
	push	edx
	mov	eax, DWORD PTR _pchLine$61448[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L61491

; 2227 :             break;

	jmp	SHORT $L61459
$L61491:

; 2229 :       }

	jmp	$L61458
$L61459:

; 2230 : 
; 2231 :       fnSysCloseFile( lpMainTask, hFile, 0 );

	push	0
	mov	ecx, DWORD PTR _hFile$61449[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMainTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 2232 :       if ( AnchorBlock->szZeidonBin[ 0 ] == 0 || AnchorBlock->szZeidonSys[ 0 ] == 0 )

	mov	eax, DWORD PTR _AnchorBlock
	movsx	ecx, BYTE PTR [eax+395]
	test	ecx, ecx
	je	SHORT $L61493
	mov	edx, DWORD PTR _AnchorBlock
	movsx	eax, BYTE PTR [edx+652]
	test	eax, eax
	jne	SHORT $L61492
$L61493:

; 2234 :          char szMessage[ 256 ];
; 2235 : 
; 2236 :          // {8,"KZOEE008 - Application definition file missing ZEIDON_BIN or ZEIDON_SYS"},
; 2237 :          SysGetBaseMessage( szMessage, KZOEE008, 255 );

	push	255					; 000000ffH
	push	8
	lea	ecx, DWORD PTR _szMessage$61494[ebp]
	push	ecx
	call	_SysGetBaseMessage@12

; 2238 :          zstrcat( szMessage, ", " );

	push	OFFSET FLAT:??_C@_02GIEM@?0?5?$AA@	; `string'
	lea	edx, DWORD PTR _szMessage$61494[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 2239 :          zstrcat( szMessage, AnchorBlock->szZeidonLocal );

	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 138				; 0000008aH
	push	eax
	lea	ecx, DWORD PTR _szMessage$61494[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2240 :          zstrcat( szMessage, szlAppFile );

	mov	edx, DWORD PTR _szlAppFile
	push	edx
	lea	eax, DWORD PTR _szMessage$61494[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2241 :          fnSysMessageBox( lpMainTask, szlOE_SystemError, szMessage, 1 );

	push	1
	lea	ecx, DWORD PTR _szMessage$61494[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	mov	eax, DWORD PTR _lpMainTask$[ebp]
	push	eax
	call	_fnSysMessageBox@16

; 2243 :       else

	jmp	SHORT $L61496
$L61492:

; 2245 :          LPAPP lpApp = fnCreateApp( lpMainTask, 0 );  // Create sys app

	push	0
	mov	ecx, DWORD PTR _lpMainTask$[ebp]
	push	ecx
	call	_fnCreateApp
	add	esp, 8
	mov	DWORD PTR _lpApp$61497[ebp], eax

; 2246 :          AnchorBlock->hSystemApp = zGETHNDL( lpApp );

	mov	edx, DWORD PTR _lpApp$61497[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+110], eax
$L61496:

; 2248 : 
; 2249 :       if ( AnchorBlock->szZeidonLoc[ 0 ] == 0 )

	mov	edx, DWORD PTR _AnchorBlock
	movsx	eax, BYTE PTR [edx+909]
	test	eax, eax
	jne	SHORT $L61503

; 2251 :          SysGetEnvVar( szZeidonEnv, "TEMP", sizeof( szZeidonEnv ) );

	push	256					; 00000100H
	push	OFFSET FLAT:??_C@_04FEEL@TEMP?$AA@	; `string'
	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	call	_SysGetEnvVar@12

; 2252 :          if ( szZeidonEnv[ 0 ] == 0 )

	movsx	edx, BYTE PTR _szZeidonEnv$[ebp]
	test	edx, edx
	jne	SHORT $L61501

; 2253 :             SysGetEnvVar( szZeidonEnv, "TMP", sizeof( szZeidonEnv ) );

	push	256					; 00000100H
	push	OFFSET FLAT:??_C@_03LDNL@TMP?$AA@	; `string'
	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_SysGetEnvVar@12
$L61501:

; 2254 : 
; 2255 :          if ( szZeidonEnv[ 0 ] )

	movsx	ecx, BYTE PTR _szZeidonEnv$[ebp]
	test	ecx, ecx
	je	SHORT $L61503

; 2257 :             zCHAR sz[ zMAX_FILENAME_LTH + 1 ];
; 2258 : 
; 2259 :             fnConvertEnvironmentString( sz, szZeidonEnv );

	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	lea	eax, DWORD PTR _sz$61504[ebp]
	push	eax
	call	_fnConvertEnvironmentString@8

; 2260 :             SysAppendcDirSep( sz );

	lea	ecx, DWORD PTR _sz$61504[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 2261 :             zstrcpy( AnchorBlock->szZeidonLoc, sz );

	lea	edx, DWORD PTR _sz$61504[ebp]
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 909				; 0000038dH
	push	eax
	call	_strcpy
	add	esp, 8
$L61503:

; 2264 : 
; 2265 :       lpMainTask->hApp = AnchorBlock->hSystemApp;

	mov	ecx, DWORD PTR _lpMainTask$[ebp]
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+110]
	mov	DWORD PTR [ecx+10], eax

; 2266 :       lpFirstSubtask = zGETPTR( lpMainTask->hFirstSubtask );

	mov	ecx, DWORD PTR _lpMainTask$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstSubtask$61447[ebp], eax

; 2267 :       lpFirstSubtask->hApp = AnchorBlock->hSystemApp;

	mov	eax, DWORD PTR _lpFirstSubtask$61447[ebp]
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+110]
	mov	DWORD PTR [eax+10], edx
$L61445:

; 2269 : 
; 2270 :    // If First task initialization failed, issue error and leave
; 2271 :    if ( !AnchorBlock->hMainTask || !AnchorBlock->hSystemApp )

	mov	eax, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [eax+106], 0
	je	SHORT $L61507
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [ecx+110], 0
	jne	SHORT $L61506
$L61507:

; 2273 :       // Free the shared segment for KZOENGWA
; 2274 :       AnchorBlock->nStatus = AnchorCorrupt;  // mark AnchorBlock as no good

	mov	edx, DWORD PTR _AnchorBlock
	mov	WORD PTR [edx+84], 20			; 00000014H

; 2275 :       fnFreeSharedMemory( lpMainTask, g_hAnchorBlock ); // free for KZOENGAA.DLL

	mov	eax, DWORD PTR _g_hAnchorBlock
	push	eax
	mov	ecx, DWORD PTR _lpMainTask$[ebp]
	push	ecx
	call	_fnFreeSharedMemory@8

; 2276 : 
; 2277 :       // NULL AnchorBlock handle and pointer
; 2278 :       g_hAnchorBlock = 0;

	mov	DWORD PTR _g_hAnchorBlock, 0

; 2279 :       AnchorBlock    = 0;

	mov	DWORD PTR _AnchorBlock, 0

; 2280 :       g_lProcessIdx  = -1;

	mov	DWORD PTR _g_lProcessIdx, -1

; 2281 : 
; 2282 :       zUNLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysUnlockCoreMutex@4

; 2283 :       return( 0 );

	xor	eax, eax
	jmp	$L61420
$L61506:

; 2285 : 
; 2286 :    // create international info from win.ini
; 2287 :    AnchorBlock->hInternational = SysCreateInternational( );

	call	_SysCreateInternational@0
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+2515], eax

; 2288 : 
; 2289 :    SysReadZeidonIni( -1, "[ObjectEngine]", "MemoryTraceThreshold", szSize );

	lea	eax, DWORD PTR _szSize$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@IKIP@MemoryTraceThreshold?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@CGC@?$FLObjectEngine?$FN?$AA@ ; `string'
	push	-1
	call	_SysReadZeidonIni@16

; 2290 :    AnchorBlock->nMemoryTraceThreshold = atoi( szSize );

	lea	ecx, DWORD PTR _szSize$[ebp]
	push	ecx
	call	DWORD PTR __imp__atoi
	add	esp, 4
	mov	edx, DWORD PTR _AnchorBlock
	mov	WORD PTR [edx+134], ax

; 2291 :    SysReadZeidonIni( -1, "[ObjectEngine]", "MemoryCeiling", szSize );

	lea	eax, DWORD PTR _szSize$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0O@CGLF@MemoryCeiling?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@CGC@?$FLObjectEngine?$FN?$AA@ ; `string'
	push	-1
	call	_SysReadZeidonIni@16

; 2292 :    AnchorBlock->nMemoryCeiling = atoi( szSize );

	lea	ecx, DWORD PTR _szSize$[ebp]
	push	ecx
	call	DWORD PTR __imp__atoi
	add	esp, 4
	mov	edx, DWORD PTR _AnchorBlock
	mov	WORD PTR [edx+136], ax

; 2293 : 
; 2294 :    zUNLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysUnlockCoreMutex@4

; 2302 : 
; 2303 :    COPYDATASTRUCT cd;
; 2304 : 
; 2305 :    cd.dwData = LB_ADDSTRING;

	mov	DWORD PTR _cd$61511[ebp], 384		; 00000180H

; 2306 :    cd.lpData = "Object Services Initialization complete...";

	mov	DWORD PTR _cd$61511[ebp+8], OFFSET FLAT:??_C@_0CL@NLJM@Object?5Services?5Initialization?5c@ ; `string'

; 2307 :    cd.cbData = zstrlen( (zPCHAR) cd.lpData ) + 1;

	mov	eax, DWORD PTR _cd$61511[ebp+8]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _cd$61511[ebp+4], eax

; 2308 : 
; 2309 :    // Use WM_COPYDATA to send the message so we don't have any memory leaks.
; 2310 :    SendMessage( (HWND) AnchorBlock->lOE_hListWnd,
; 2311 :                 WM_COPYDATA, 0, (LPARAM) &cd );

	lea	ecx, DWORD PTR _cd$61511[ebp]
	push	ecx
	push	0
	push	74					; 0000004aH
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+98]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16

; 2312 :    if ( g_bServerMode )

	xor	ecx, ecx
	mov	cl, BYTE PTR _g_bServerMode
	test	ecx, ecx
	je	SHORT $L61516

; 2313 :       cd.lpData = "Object Services Running in Server Mode...";

	mov	DWORD PTR _cd$61511[ebp+8], OFFSET FLAT:??_C@_0CK@EGPN@Object?5Services?5Running?5in?5Serve@ ; `string'

; 2314 :    else

	jmp	SHORT $L61518
$L61516:

; 2315 :       cd.lpData = "Object Services Running in Shared Mode...";

	mov	DWORD PTR _cd$61511[ebp+8], OFFSET FLAT:??_C@_0CK@LCNC@Object?5Services?5Running?5in?5Share@ ; `string'
$L61518:

; 2316 : 
; 2317 :    cd.cbData = zstrlen( (zPCHAR) cd.lpData ) + 1;

	mov	edx, DWORD PTR _cd$61511[ebp+8]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _cd$61511[ebp+4], eax

; 2318 :    SendMessage( (HWND) AnchorBlock->lOE_hListWnd,
; 2319 :                 WM_COPYDATA, 0, (LPARAM) &cd );

	lea	eax, DWORD PTR _cd$61511[ebp]
	push	eax
	push	0
	push	74					; 0000004aH
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+98]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16

; 2321 : 
; 2322 : #ifdef __MUTEX_DEBUG__
; 2323 :    // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 2324 :    fnPrintMutexInfo( 'S', zMUTEX_COUNT, __FILE__, __LINE__ );
; 2325 : #endif
; 2326 : 
; 2327 :    fnTraceCompileTime( );

	call	_fnTraceCompileTime@0

; 2328 :    MiListOE_Memory( 0, -1 );

	push	-1
	push	0
	call	_MiListOE_Memory@8

; 2329 :    return( AnchorBlock );

	mov	eax, DWORD PTR _AnchorBlock
$L61420:

; 2330 : 
; 2331 : }   // End of InitializeAnchorBlock

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_InitializeAnchorBlock@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FE@PDLP@fnFreeLocalAnchorBlock?5Page?5Tabl@ ; `string'
PUBLIC	_fnFreeLocalAnchorBlock@4
PUBLIC	_SysFree@4
EXTRN	__imp__UnmapViewOfFile@4:NEAR
;	COMDAT ??_C@_0FE@PDLP@fnFreeLocalAnchorBlock?5Page?5Tabl@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0FE@PDLP@fnFreeLocalAnchorBlock?5Page?5Tabl@ DB 'fnFreeLocalAnchorB'
	DB	'lock Page Table UNmapping at Index: %x   0x%08x   Process: 0x'
	DB	'%08x', 00H					; `string'
_DATA	ENDS
_TEXT	SEGMENT
_bWebTask$ = 8
_lPageTableIndex$ = -4
_fnFreeLocalAnchorBlock@4 PROC NEAR

; 2337 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2338 :    zLONG lPageTableIndex;
; 2339 : 
; 2340 :    // If we're in Server Mode or a Web Task, then there's no anchor block
; 2341 :    // to free.
; 2342 :    if ( g_bServerMode || bWebTask )

	xor	eax, eax
	mov	al, BYTE PTR _g_bServerMode
	test	eax, eax
	jne	SHORT $L61528
	mov	ecx, DWORD PTR _bWebTask$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	je	SHORT $L61527
$L61528:

; 2344 :       SysFree( AnchorBlock );

	mov	edx, DWORD PTR _AnchorBlock
	push	edx
	call	_SysFree@4

; 2345 :       return;

	jmp	$L61525
$L61527:

; 2349 :       if ( g_bWin95 )

	xor	eax, eax
	mov	al, BYTE PTR _g_bWin95
	test	eax, eax
	je	SHORT $L61530

; 2350 :          lPageTableIndex = 1;

	mov	DWORD PTR _lPageTableIndex$[ebp], 1

; 2351 :       else

	jmp	SHORT $L61531
$L61530:

; 2352 : #ifdef DEBUG_PAGETABLE
; 2353 :          lPageTableIndex = 128;

	mov	DWORD PTR _lPageTableIndex$[ebp], 128	; 00000080H
$L61531:

; 2354 : #else
; 2355 :          lPageTableIndex = 1;
; 2356 : #endif
; 2357 : 
; 2358 : #ifdef SHARED_MEM_TRACE
; 2359 :       fnTraceSharedMemory( "Unmapping anchor block" );
; 2360 : #endif
; 2361 : 
; 2362 :       TraceLine( "fnFreeLocalAnchorBlock Page Table UNmapping at Index: %x   0x%08x   Process: 0x%08x",
; 2363 :                  lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );

	push	0
	call	_SysGetProcessID@4
	push	eax
	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	mov	edx, DWORD PTR _g_ZeidonPageTable[ecx*4]
	push	edx
	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0FE@PDLP@fnFreeLocalAnchorBlock?5Page?5Tabl@ ; `string'
	call	_TraceLine
	add	esp, 16					; 00000010H

; 2364 : 
; 2365 :       UnmapViewOfFile( g_ZeidonPageTable[ lPageTableIndex ] );

	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	mov	edx, DWORD PTR _g_ZeidonPageTable[ecx*4]
	push	edx
	call	DWORD PTR __imp__UnmapViewOfFile@4

; 2366 :       CloseHandle( (HANDLE) g_FileMappingHandles[ lPageTableIndex ] );

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	ecx, DWORD PTR _g_FileMappingHandles[eax*4]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 2367 :       g_ZeidonPageTable[ lPageTableIndex ] = 0;

	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[edx*4], 0

; 2368 :       g_FileMappingHandles[ lPageTableIndex ] = 0;

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR _g_FileMappingHandles[eax*4], 0

; 2370 : 
; 2371 :    g_hAnchorBlock = 0;

	mov	DWORD PTR _g_hAnchorBlock, 0

; 2372 :    AnchorBlock    = 0;

	mov	DWORD PTR _AnchorBlock, 0

; 2373 :    g_lProcessIdx  = -1;

	mov	DWORD PTR _g_lProcessIdx, -1
$L61525:

; 2374 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnFreeLocalAnchorBlock@4 ENDP
_TEXT	ENDS
PUBLIC	_FreeAnchorBlock@4
EXTRN	_g_pProbeArea:DWORD
_TEXT	SEGMENT
_lpTask$ = 8
_FreeAnchorBlock@4 PROC NEAR

; 2392 : {

	push	ebp
	mov	ebp, esp

; 2393 :    // free Probe Area
; 2394 :    if ( g_pProbeArea )

	cmp	DWORD PTR _g_pProbeArea, 0
	je	SHORT $L61537

; 2395 :       SysFree( g_pProbeArea );

	mov	eax, DWORD PTR _g_pProbeArea
	push	eax
	call	_SysFree@4
$L61537:

; 2396 : 
; 2397 : // TraceLineX( "FreeAnchorBlock AnchorBlock ", g_hAnchorBlock );
; 2398 :    // if AnchorBlock not initialized, return zCALL_ERROR.
; 2399 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $L61538

; 2400 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L61536
$L61538:

; 2401 : 
; 2402 :    // If the caller is not the main task, return zCALL_ERROR.
; 2403 :    if ( lpTask == 0 ||
; 2404 :         zGETHNDL( lpTask ) != AnchorBlock->hMainTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $L61541
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _AnchorBlock
	cmp	eax, DWORD PTR [edx+106]
	je	SHORT $L61540
$L61541:

; 2406 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L61536
$L61540:

; 2408 : 
; 2409 :    // Delete the main Task.
; 2410 :    if ( lpTask->bOE_TaskShutdown == FALSE )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 15					; 0000000fH
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L61542

; 2411 :       DeleteTask( lpTask );  // dks 2006.09.18 error while cleaning up client OE

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_DeleteTask@4
$L61542:

; 2412 : 
; 2413 :    // Current process has performed RegisterZeidonApp( ) so ...
; 2414 :    g_bProcessRegistered = FALSE;

	mov	BYTE PTR _g_bProcessRegistered, 0

; 2415 : // g_lpCurrentTask = 0;
; 2416 : 
; 2417 :    // Free the shared segment for KZOENGWA
; 2418 :    AnchorBlock->nStatus = AnchorCorrupt;     // mark AnchorBlock as no good

	mov	eax, DWORD PTR _AnchorBlock
	mov	WORD PTR [eax+84], 20			; 00000014H

; 2419 :    if ( g_bServerMode )

	xor	ecx, ecx
	mov	cl, BYTE PTR _g_bServerMode
	test	ecx, ecx
	je	SHORT $L61543

; 2421 :       SysFree( AnchorBlock );

	mov	edx, DWORD PTR _AnchorBlock
	push	edx
	call	_SysFree@4
$L61543:

; 2423 : // else
; 2424 : //    fnFreeSharedMemory( lpTask, g_hAnchorBlock ); // free for KZOENGAA.DLL
; 2425 : 
; 2426 :    // NULL AnchorBlock handle and pointer
; 2427 :    g_hAnchorBlock = 0;

	mov	DWORD PTR _g_hAnchorBlock, 0

; 2428 :    AnchorBlock = 0;

	mov	DWORD PTR _AnchorBlock, 0

; 2429 :    g_lProcessIdx = -1;

	mov	DWORD PTR _g_lProcessIdx, -1

; 2430 : 
; 2431 :    return( 0 );

	xor	ax, ax
$L61536:

; 2432 : 
; 2433 : }   // End of FreeAnchorBlock

	pop	ebp
	ret	4
_FreeAnchorBlock@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@MHCA@Received?5a?5message?5while?5in?5Serv@ ; `string'
PUBLIC	??_C@_0CK@MMNK@Internal?5Error?5?9?5lpRequestProces@ ; `string'
PUBLIC	??_C@_0BF@INJH@Zeidon?5Object?5Engine?$AA@	; `string'
PUBLIC	??_C@_0BL@LLDD@?$CIsy?$CJ?5DuplicateHandle?5RC?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0BO@MJGK@?$CIsy?$CJ?5DuplicateHandle?5Failed?3?5?$AA@ ; `string'
PUBLIC	??_C@_0CK@JGNK@Internal?5error?5?9?9?5DuplicateHandl@ ; `string'
PUBLIC	??_C@_0BL@LBEN@Error?5destroying?5mutex?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BA@KLMC@Unknown?5message?$AA@		; `string'
PUBLIC	_fnMapFile@16
PUBLIC	_ProcessZeidonMessage@8
EXTRN	_TraceLineI@8:NEAR
EXTRN	__imp__OpenProcess@12:NEAR
EXTRN	__imp__GetCurrentProcess@0:NEAR
EXTRN	__imp__DuplicateHandle@28:NEAR
EXTRN	__imp__GetHandleInformation@8:NEAR
EXTRN	__imp__FreeLibrary@4:NEAR
EXTRN	__imp__LocalFree@4:NEAR
EXTRN	__imp__FormatMessageA@28:NEAR
;	COMDAT ??_C@_0CI@MHCA@Received?5a?5message?5while?5in?5Serv@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CI@MHCA@Received?5a?5message?5while?5in?5Serv@ DB 'Received a mess'
	DB	'age while in Server Mode', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CK@MMNK@Internal?5Error?5?9?5lpRequestProces@
_DATA	SEGMENT
??_C@_0CK@MMNK@Internal?5Error?5?9?5lpRequestProces@ DB 'Internal Error -'
	DB	' lpRequestProcess is null', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@INJH@Zeidon?5Object?5Engine?$AA@
_DATA	SEGMENT
??_C@_0BF@INJH@Zeidon?5Object?5Engine?$AA@ DB 'Zeidon Object Engine', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@LLDD@?$CIsy?$CJ?5DuplicateHandle?5RC?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BL@LLDD@?$CIsy?$CJ?5DuplicateHandle?5RC?5?$DN?5?$AA@ DB '(sy) Dupl'
	DB	'icateHandle RC = ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@MJGK@?$CIsy?$CJ?5DuplicateHandle?5Failed?3?5?$AA@
_DATA	SEGMENT
??_C@_0BO@MJGK@?$CIsy?$CJ?5DuplicateHandle?5Failed?3?5?$AA@ DB '(sy) Dupl'
	DB	'icateHandle Failed: ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CK@JGNK@Internal?5error?5?9?9?5DuplicateHandl@
_DATA	SEGMENT
??_C@_0CK@JGNK@Internal?5error?5?9?9?5DuplicateHandl@ DB 'Internal error '
	DB	'-- DuplicateHandle failed!', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@LBEN@Error?5destroying?5mutex?3?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BL@LBEN@Error?5destroying?5mutex?3?5?$CFs?$AA@ DB 'Error destroyin'
	DB	'g mutex: %s', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@KLMC@Unknown?5message?$AA@
_DATA	SEGMENT
??_C@_0BA@KLMC@Unknown?5message?$AA@ DB 'Unknown message', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_wParam$ = 8
_lParam$ = 12
_lpRequestProcess$ = -16
_lpTask$ = -12
_lProcessIdx$ = -8
_dwCurrentProcess$ = -4
_nRequest$ = -20
_hOwnerTask$61575 = -40
_hOwnerMem$61576 = -32
_hCurrentMem$61578 = -36
_hCurrentProcess$61579 = -28
_lPageTableIndex$61580 = -24
_lRC$61582 = -44
_lRC2$61584 = -52
_lpMsg$61585 = -48
_dw$61586 = -56
_lpSearchTask$61600 = -60
_lpDataHeader$61607 = -64
_lPageTableIndex$61619 = -68
_lPageTableIndex$61630 = -72
_lPageTableIndex$61639 = -76
_lpLibrary$61642 = -80
_lpMutex$61646 = -84
_szMsg$61650 = -184
_ProcessZeidonMessage@8 PROC NEAR

; 2487 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH

; 2488 :    LPPROCESSLIST lpRequestProcess;
; 2489 :    LPTASK        lpTask = 0;

	mov	DWORD PTR _lpTask$[ebp], 0

; 2490 :    zLONG         lProcessIdx = lParam;

	mov	eax, DWORD PTR _lParam$[ebp]
	mov	DWORD PTR _lProcessIdx$[ebp], eax

; 2491 :    DWORD         dwCurrentProcess = GetCurrentProcessId( );

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	DWORD PTR _dwCurrentProcess$[ebp], eax

; 2492 :    zSHORT        nRequest;
; 2493 : 
; 2494 : //#ifdef DEBUG
; 2495 :    if ( g_bServerMode )

	xor	ecx, ecx
	mov	cl, BYTE PTR _g_bServerMode
	test	ecx, ecx
	je	SHORT $L61554

; 2497 :       SysMessageBox( (zVIEW) wParam, szlOE_SystemError,
; 2498 :                      "Received a message while in Server Mode", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0CI@MHCA@Received?5a?5message?5while?5in?5Serv@ ; `string'
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	call	_SysMessageBox@16

; 2499 :       return( 0 );

	xor	ax, ax
	jmp	$L61548
$L61554:

; 2501 : //#endif
; 2502 : 
; 2503 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $L61557

; 2504 :       return( zCALL_ERROR );  // failure ... get out!

	mov	ax, -16					; fffffff0H
	jmp	$L61548
$L61557:

; 2505 : 
; 2506 :    // Get address of requesting process.
; 2507 :    if ( lProcessIdx == -1 )

	cmp	DWORD PTR _lProcessIdx$[ebp], -1
	jne	SHORT $L61558

; 2509 :       nRequest = TASKREQ_FREEALL;

	mov	WORD PTR _nRequest$[ebp], 5

; 2510 :       lpTask = zGETPTR( wParam );

	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 2511 :       lpRequestProcess = 0;

	mov	DWORD PTR _lpRequestProcess$[ebp], 0

; 2513 :    else

	jmp	SHORT $L61560
$L61558:

; 2515 :       lpRequestProcess = &AnchorBlock->OS_Data.ProcessList[ lProcessIdx ];

	mov	edx, DWORD PTR _lProcessIdx$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _AnchorBlock
	lea	ecx, DWORD PTR [eax+edx+1511]
	mov	DWORD PTR _lpRequestProcess$[ebp], ecx

; 2516 :       if ( lpRequestProcess == 0 )

	cmp	DWORD PTR _lpRequestProcess$[ebp], 0
	jne	SHORT $L61561

; 2518 :          SysMessageBox( (zVIEW) wParam, "Zeidon Object Engine",
; 2519 :                         "Internal Error - lpRequestProcess is null", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0CK@MMNK@Internal?5Error?5?9?5lpRequestProces@ ; `string'
	push	OFFSET FLAT:??_C@_0BF@INJH@Zeidon?5Object?5Engine?$AA@ ; `string'
	mov	edx, DWORD PTR _wParam$[ebp]
	push	edx
	call	_SysMessageBox@16

; 2520 :          return( zCALL_ERROR );  // Failure get out

	mov	ax, -16					; fffffff0H
	jmp	$L61548
$L61561:

; 2522 : 
; 2523 :       nRequest = lpRequestProcess->nOE_Request;

	mov	eax, DWORD PTR _lpRequestProcess$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _nRequest$[ebp], cx
$L61560:

; 2533 : 
; 2534 :    // The requesting task is valid, process the message.
; 2535 :    switch ( nRequest )
; 2536 :    {

	movsx	edx, WORD PTR _nRequest$[ebp]
	mov	DWORD PTR -188+[ebp], edx
	mov	eax, DWORD PTR -188+[ebp]
	sub	eax, 1
	mov	DWORD PTR -188+[ebp], eax
	cmp	DWORD PTR -188+[ebp], 6
	ja	$L61652
	mov	ecx, DWORD PTR -188+[ebp]
	jmp	DWORD PTR $L64807[ecx*4]
$L61569:

; 2540 :          // Share a single block of the requesting task's memory.
; 2541 : 
; 2542 :          // We should only get this message for the main task.  Another task
; 2543 :          // has just started and needs to share all file mappings.  Go
; 2544 :          // through the table of file mappings and return some info.
; 2545 :          // lParam contains the last index into the process table with which
; 2546 :          // the calling process has shared memory.
; 2547 : 
; 2548 :          // OK to lose original ProcessID.
; 2549 :          lpRequestProcess->lProcessID = dwCurrentProcess;

	mov	edx, DWORD PTR _lpRequestProcess$[ebp]
	mov	eax, DWORD PTR _dwCurrentProcess$[ebp]
	mov	DWORD PTR [edx+16], eax

; 2550 :          lpRequestProcess->lPageTableIndex++;

	mov	ecx, DWORD PTR _lpRequestProcess$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _lpRequestProcess$[ebp]
	mov	DWORD PTR [eax+8], edx

; 2551 :          lpRequestProcess->hMemHandle = 0;  // no more blocks to share

	mov	ecx, DWORD PTR _lpRequestProcess$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L61571:

; 2552 : 
; 2553 : #ifdef SHARED_MEM_TRACE
; 2554 :          TraceLine( "TASKREQ_SHARE Process: 0x%08x   PageTableIndex: %d",
; 2555 :                     lpRequestProcess->lProcessID, lpRequestProcess->lPageTableIndex );
; 2556 : #endif
; 2557 : 
; 2558 :          while ( lpRequestProcess->lPageTableIndex < zSHR_MAX_PAGES )

	mov	edx, DWORD PTR _lpRequestProcess$[ebp]
	cmp	DWORD PTR [edx+8], 256			; 00000100H
	jae	SHORT $L61572

; 2560 :             if ( g_ZeidonPageTable[ lpRequestProcess->lPageTableIndex ] )

	mov	eax, DWORD PTR _lpRequestProcess$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR _g_ZeidonPageTable[ecx*4], 0
	je	SHORT $L61573

; 2562 :                // We found a used file mapping.  Copy the handle to parm2 and break loop.
; 2563 :                lpRequestProcess->hMemHandle = g_FileMappingHandles[ lpRequestProcess->lPageTableIndex ];

	mov	edx, DWORD PTR _lpRequestProcess$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _lpRequestProcess$[ebp]
	mov	edx, DWORD PTR _g_FileMappingHandles[eax*4]
	mov	DWORD PTR [ecx+12], edx

; 2564 :                break;

	jmp	SHORT $L61572
$L61573:

; 2566 : 
; 2567 :             lpRequestProcess->lPageTableIndex++;

	mov	eax, DWORD PTR _lpRequestProcess$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _lpRequestProcess$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 2568 :          }

	jmp	SHORT $L61571
$L61572:

; 2569 : 
; 2570 :          break;

	jmp	$L61566
$L61574:

; 2575 :          // Allocate shared memory.
; 2576 :          // Some other task wants to allocate shared memory and has already
; 2577 :          // created a file mapping.  Open a view to that file mapping.
; 2578 :          HANDLE hOwnerTask;
; 2579 :          HANDLE hOwnerMem  = (HANDLE) lpRequestProcess->hMemHandle;

	mov	eax, DWORD PTR _lpRequestProcess$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _hOwnerMem$61576[ebp], ecx

; 2580 :          HANDLE hCurrentMem;
; 2581 :          HANDLE hCurrentProcess = GetCurrentProcess( );  // intentionally

	call	DWORD PTR __imp__GetCurrentProcess@0
	mov	DWORD PTR _hCurrentProcess$61579[ebp], eax

; 2582 :          zLONG  lPageTableIndex = lpRequestProcess->lPageTableIndex;

	mov	edx, DWORD PTR _lpRequestProcess$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _lPageTableIndex$61580[ebp], eax

; 2583 : 
; 2584 : #ifdef SHARED_MEM_TRACE
; 2585 :          TraceLine( "TASKREQ_ALLOC Page Table mapping at Index: %x   0x%08x   Process: (%d) %d",
; 2586 :                     lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], hCurrentProcess, GetCurrentProcessId( ) );
; 2587 : #endif
; 2588 : 
; 2589 :          // Creates a windows object handle from the current process to the
; 2590 :          // process specified by lpRequestProcess->lProcessID.
; 2591 :          hOwnerTask = OpenProcess( PROCESS_ALL_ACCESS, 0,
; 2592 :                                    lpRequestProcess->lProcessID );

	mov	ecx, DWORD PTR _lpRequestProcess$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	push	0
	push	2035711					; 001f0fffH
	call	DWORD PTR __imp__OpenProcess@12
	mov	DWORD PTR _hOwnerTask$61575[ebp], eax

; 2593 : 
; 2594 :          if ( !DuplicateHandle( hOwnerTask, hOwnerMem, hCurrentProcess,
; 2595 :                                 &hCurrentMem, 0, TRUE, DUPLICATE_SAME_ACCESS ) )

	push	2
	push	1
	push	0
	lea	eax, DWORD PTR _hCurrentMem$61578[ebp]
	push	eax
	mov	ecx, DWORD PTR _hCurrentProcess$61579[ebp]
	push	ecx
	mov	edx, DWORD PTR _hOwnerMem$61576[ebp]
	push	edx
	mov	eax, DWORD PTR _hOwnerTask$61575[ebp]
	push	eax
	call	DWORD PTR __imp__DuplicateHandle@28
	test	eax, eax
	jne	$L61581

; 2597 :             zLONG  lRC = (zLONG) GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lRC$61582[ebp], eax

; 2598 :             zLONG  lRC2;
; 2599 :             zPCHAR lpMsg;
; 2600 :             DWORD  dw;
; 2601 : 
; 2602 :             if ( !GetHandleInformation( hOwnerTask, &dw ) )

	lea	ecx, DWORD PTR _dw$61586[ebp]
	push	ecx
	mov	edx, DWORD PTR _hOwnerTask$61575[ebp]
	push	edx
	call	DWORD PTR __imp__GetHandleInformation@8
	test	eax, eax
	jne	SHORT $L61587

; 2603 :                lRC2 = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lRC2$61584[ebp], eax
$L61587:

; 2604 : 
; 2605 :             if ( !GetHandleInformation( hOwnerMem, &dw ) )

	lea	eax, DWORD PTR _dw$61586[ebp]
	push	eax
	mov	ecx, DWORD PTR _hOwnerMem$61576[ebp]
	push	ecx
	call	DWORD PTR __imp__GetHandleInformation@8
	test	eax, eax
	jne	SHORT $L61588

; 2606 :                lRC2 = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lRC2$61584[ebp], eax
$L61588:

; 2607 : 
; 2608 :             if ( !GetHandleInformation( hCurrentProcess, &dw ) )

	lea	edx, DWORD PTR _dw$61586[ebp]
	push	edx
	mov	eax, DWORD PTR _hCurrentProcess$61579[ebp]
	push	eax
	call	DWORD PTR __imp__GetHandleInformation@8
	test	eax, eax
	jne	SHORT $L61589

; 2609 :                lRC2 = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lRC2$61584[ebp], eax
$L61589:

; 2610 : 
; 2611 :             FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
; 2612 :                            NULL, lRC, MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT),
; 2613 :                            (LPTSTR) &lpMsg, 0, NULL );

	push	0
	push	0
	lea	ecx, DWORD PTR _lpMsg$61585[ebp]
	push	ecx
	push	1024					; 00000400H
	mov	edx, DWORD PTR _lRC$61582[ebp]
	push	edx
	push	0
	push	4352					; 00001100H
	call	DWORD PTR __imp__FormatMessageA@28

; 2614 : 
; 2615 :             TraceLineI( "(sy) DuplicateHandle RC = ", lRC );

	mov	eax, DWORD PTR _lRC$61582[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BL@LLDD@?$CIsy?$CJ?5DuplicateHandle?5RC?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8

; 2616 :             TraceLineS( "(sy) DuplicateHandle Failed: ", lpMsg );

	mov	ecx, DWORD PTR _lpMsg$61585[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BO@MJGK@?$CIsy?$CJ?5DuplicateHandle?5Failed?3?5?$AA@ ; `string'
	call	_TraceLineS@8

; 2617 :             SysMessageBox( 0, szlOE_SystemError,
; 2618 :                            "Internal error -- DuplicateHandle failed!", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0CK@JGNK@Internal?5error?5?9?9?5DuplicateHandl@ ; `string'
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 2619 :             CloseHandle( hOwnerTask );

	mov	eax, DWORD PTR _hOwnerTask$61575[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 2620 :             LocalFree( (LPVOID) lpMsg );

	mov	ecx, DWORD PTR _lpMsg$61585[ebp]
	push	ecx
	call	DWORD PTR __imp__LocalFree@4

; 2621 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L61548
$L61581:

; 2623 : 
; 2624 :          fnMapFile( &hCurrentMem, 0, &lPageTableIndex, 0 );

	push	0
	lea	edx, DWORD PTR _lPageTableIndex$61580[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _hCurrentMem$61578[ebp]
	push	eax
	call	_fnMapFile@16

; 2625 :          CloseHandle( hOwnerTask );

	mov	ecx, DWORD PTR _hOwnerTask$61575[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 2626 :          break;

	jmp	$L61566
$L61599:

; 2631 :          LPTASK lpSearchTask;
; 2632 : 
; 2633 :          // The task is shutting down ... free requesting task's hold on
; 2634 :          // all memory "owned" by other tasks.
; 2635 : 
; 2636 :          // If the task is a thread task then we don't need to free memory --
; 2637 :          // it will be handled by the process task.
; 2638 :          if ( lpTask->bThreadTask )

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	shr	eax, 7
	and	eax, 1
	test	eax, eax
	je	SHORT $L61601

; 2639 :             break;

	jmp	$L61566
$L61601:

; 2640 : 
; 2641 :          // Make sure nobody is currently deleting a task.
; 2642 :          fnStartBrowseOfTaskList( lpTask, FALSE );

	push	0
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnStartBrowseOfTaskList@8

; 2643 : 
; 2644 :          for ( lpSearchTask = zGETPTR( AnchorBlock->hFirstTask );
; 2645 :                lpSearchTask;
; 2646 :                lpSearchTask = zGETPTR( lpSearchTask->hNextTask ) )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+130]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$61600[ebp], eax
	jmp	SHORT $L61604
$L61605:
	mov	ecx, DWORD PTR _lpSearchTask$61600[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$61600[ebp], eax
$L61604:
	cmp	DWORD PTR _lpSearchTask$61600[ebp], 0
	je	$L61606

; 2648 :             LPDATAHEADER lpDataHeader;
; 2649 : 
; 2650 :             // Don't bother for the current task.
; 2651 :             if ( lpSearchTask == lpTask )

	mov	eax, DWORD PTR _lpSearchTask$61600[ebp]
	cmp	eax, DWORD PTR _lpTask$[ebp]
	jne	SHORT $L61608

; 2652 :                continue;

	jmp	SHORT $L61605
$L61608:

; 2653 : 
; 2654 :             // Free all memory allocated for the task.
; 2655 :             lpDataHeader = zGETPTR( lpSearchTask->hFirstDataHeader );

	mov	ecx, DWORD PTR _lpSearchTask$61600[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$61607[ebp], eax

; 2656 :             if ( lpDataHeader )

	cmp	DWORD PTR _lpDataHeader$61607[ebp], 0
	je	$L61617
$L61612:

; 2658 :                while ( lpDataHeader->hNextDataHeader )

	mov	eax, DWORD PTR _lpDataHeader$61607[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	SHORT $L61613

; 2659 :                   lpDataHeader = zGETPTR( lpDataHeader->hNextDataHeader );

	mov	ecx, DWORD PTR _lpDataHeader$61607[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$61607[ebp], eax
	jmp	SHORT $L61612
$L61613:

; 2660 : 
; 2661 :                while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	$L61617

; 2663 :                   if ( lpDataHeader->lNextDataHandle )

	mov	ecx, DWORD PTR _lpDataHeader$61607[ebp]
	cmp	DWORD PTR [ecx+34], 0
	je	SHORT $L61618

; 2665 :                      zLONG lPageTableIndex;
; 2666 : 
; 2667 :                      if ( g_bWin95 )

	xor	edx, edx
	mov	dl, BYTE PTR _g_bWin95
	test	edx, edx
	je	SHORT $L61620

; 2668 :                         lPageTableIndex = (zLONG) *((zPLONG) lpDataHeader->lNextDataHandle - 1);

	mov	eax, DWORD PTR _lpDataHeader$61607[ebp]
	mov	ecx, DWORD PTR [eax+34]
	mov	edx, DWORD PTR [ecx-4]
	mov	DWORD PTR _lPageTableIndex$61619[ebp], edx

; 2669 :                      else

	jmp	SHORT $L61623
$L61620:

; 2670 :                         lPageTableIndex = (zLONG) ((zULONG) lpDataHeader->lNextDataHandle >> 24);

	mov	eax, DWORD PTR _lpDataHeader$61607[ebp]
	mov	ecx, DWORD PTR [eax+34]
	shr	ecx, 24					; 00000018H
	mov	DWORD PTR _lPageTableIndex$61619[ebp], ecx
$L61623:

; 2671 : 
; 2672 : #ifdef SHARED_MEM_TRACE
; 2673 :                      fnTraceSharedMemory( "TASKREQ_FREEALL: freeing memory owned by other tasks." );
; 2674 : #endif
; 2675 : 
; 2676 :                   // if ( lPageTableIndex == 134 )
; 2677 :                   // {
; 2678 :                   //    TraceLine( "UnmapViewOfFile1 Page Table at Index: %x   0x%08x   Process: 0x%08x",
; 2679 :                   //               lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 2680 :                   // }
; 2681 : 
; 2682 :                      UnmapViewOfFile( g_ZeidonPageTable[ lPageTableIndex ] );

	mov	edx, DWORD PTR _lPageTableIndex$61619[ebp]
	mov	eax, DWORD PTR _g_ZeidonPageTable[edx*4]
	push	eax
	call	DWORD PTR __imp__UnmapViewOfFile@4

; 2683 :                      CloseHandle( (HANDLE) g_FileMappingHandles[ lPageTableIndex ] );

	mov	ecx, DWORD PTR _lPageTableIndex$61619[ebp]
	mov	edx, DWORD PTR _g_FileMappingHandles[ecx*4]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 2684 :                      g_ZeidonPageTable[ lPageTableIndex ] = 0;

	mov	eax, DWORD PTR _lPageTableIndex$61619[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[eax*4], 0

; 2685 :                      g_FileMappingHandles[ lPageTableIndex ] = 0;

	mov	ecx, DWORD PTR _lPageTableIndex$61619[ebp]
	mov	DWORD PTR _g_FileMappingHandles[ecx*4], 0
$L61618:

; 2687 : 
; 2688 :                   lpDataHeader = zGETPTR( lpDataHeader->hPrevDataHeader );

	mov	edx, DWORD PTR _lpDataHeader$61607[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$61607[ebp], eax

; 2689 :                   if ( lpDataHeader == 0 )

	cmp	DWORD PTR _lpDataHeader$61607[ebp], 0
	jne	SHORT $L61628

; 2690 :                      break;

	jmp	SHORT $L61617
$L61628:

; 2691 :                }

	jmp	$L61613
$L61617:

; 2693 : 
; 2694 :             if ( lpSearchTask->hFirstDataHandle )

	mov	ecx, DWORD PTR _lpSearchTask$61600[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $L61629

; 2696 :                zLONG lPageTableIndex;
; 2697 : 
; 2698 :                if ( g_bWin95 )

	xor	edx, edx
	mov	dl, BYTE PTR _g_bWin95
	test	edx, edx
	je	SHORT $L61631

; 2699 :                   lPageTableIndex = (zLONG) *((zPLONG) lpSearchTask->hFirstDataHandle - 1);

	mov	eax, DWORD PTR _lpSearchTask$61600[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx-4]
	mov	DWORD PTR _lPageTableIndex$61630[ebp], edx

; 2700 :                else

	jmp	SHORT $L61634
$L61631:

; 2701 :                   lPageTableIndex = (zLONG) ((zULONG) lpSearchTask->hFirstDataHandle >> 24);

	mov	eax, DWORD PTR _lpSearchTask$61600[ebp]
	mov	ecx, DWORD PTR [eax+52]
	shr	ecx, 24					; 00000018H
	mov	DWORD PTR _lPageTableIndex$61630[ebp], ecx
$L61634:

; 2702 : 
; 2703 : #ifdef SHARED_MEM_TRACE
; 2704 :                fnTraceSharedMemory( "TASKREQ_FREEALL: Freeing last page table." );
; 2705 : #endif
; 2706 : 
; 2707 :             // if ( lPageTableIndex == 134 )
; 2708 :             // {
; 2709 :             //    TraceLine( "UnmapViewOfFile2 Page Table at Index: %x   0x%08x   Process: 0x%08x",
; 2710 :             //               lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 2711 :             // }
; 2712 : 
; 2713 :                UnmapViewOfFile( g_ZeidonPageTable[ lPageTableIndex ] );

	mov	edx, DWORD PTR _lPageTableIndex$61630[ebp]
	mov	eax, DWORD PTR _g_ZeidonPageTable[edx*4]
	push	eax
	call	DWORD PTR __imp__UnmapViewOfFile@4

; 2714 :                CloseHandle( (HANDLE) g_FileMappingHandles[ lPageTableIndex ] );

	mov	ecx, DWORD PTR _lPageTableIndex$61630[ebp]
	mov	edx, DWORD PTR _g_FileMappingHandles[ecx*4]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 2715 :                g_ZeidonPageTable[ lPageTableIndex ] = 0;

	mov	eax, DWORD PTR _lPageTableIndex$61630[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[eax*4], 0

; 2716 :                g_FileMappingHandles[ lPageTableIndex ] = 0;

	mov	ecx, DWORD PTR _lPageTableIndex$61630[ebp]
	mov	DWORD PTR _g_FileMappingHandles[ecx*4], 0
$L61629:

; 2718 :          }

	jmp	$L61605
$L61606:

; 2719 : 
; 2720 :          fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 2721 :          break;

	jmp	$L61566
$L61638:

; 2727 :          // Free a particular chunk of memory.
; 2728 : 
; 2729 :          zLONG lPageTableIndex = lpRequestProcess->lPageTableIndex;

	mov	edx, DWORD PTR _lpRequestProcess$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _lPageTableIndex$61639[ebp], eax

; 2730 : 
; 2731 : #ifdef SHARED_MEM_TRACE
; 2732 :          fnTraceSharedMemory( "TASKREQ_FREE:  Freeing a current page." );
; 2733 :          TraceLine( "TASKREQ_FREE Page Table UNmapping at Index: %x   0x%08x   Process: %d",
; 2734 :                     lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 2735 : #endif
; 2736 : 
; 2737 :       // if ( lPageTableIndex == 134 )
; 2738 :       // {
; 2739 :       //    TraceLine( "UnmapViewOfFile3 Page Table at Index: %x   0x%08x   Process: 0x%08x",
; 2740 :       //               lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 2741 :       // }
; 2742 : 
; 2743 :          UnmapViewOfFile( g_ZeidonPageTable[ lPageTableIndex ] );

	mov	ecx, DWORD PTR _lPageTableIndex$61639[ebp]
	mov	edx, DWORD PTR _g_ZeidonPageTable[ecx*4]
	push	edx
	call	DWORD PTR __imp__UnmapViewOfFile@4

; 2744 :          CloseHandle( (HANDLE) g_FileMappingHandles[ lPageTableIndex ] );

	mov	eax, DWORD PTR _lPageTableIndex$61639[ebp]
	mov	ecx, DWORD PTR _g_FileMappingHandles[eax*4]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 2745 :          g_ZeidonPageTable[ lPageTableIndex ] = 0;

	mov	edx, DWORD PTR _lPageTableIndex$61639[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[edx*4], 0

; 2746 :          g_FileMappingHandles[ lPageTableIndex ] = 0;

	mov	eax, DWORD PTR _lPageTableIndex$61639[ebp]
	mov	DWORD PTR _g_FileMappingHandles[eax*4], 0

; 2747 :          break;

	jmp	$L61566
$L61641:

; 2752 :          LPLIBRARY lpLibrary = zGETPTR( lpRequestProcess->hMemHandle );

	mov	ecx, DWORD PTR _lpRequestProcess$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$61642[ebp], eax

; 2753 :       // TraceLineS( "(sy) TASKREQ_FREELIB: freeing library ",
; 2754 :       //             lpLibrary->szName );
; 2755 :       // fnTraceLibrary( lpLibrary, 0 );
; 2756 :          FreeLibrary( (HMODULE) lpLibrary->hLibrary );

	mov	eax, DWORD PTR _lpLibrary$61642[ebp]
	mov	ecx, DWORD PTR [eax+263]
	push	ecx
	call	DWORD PTR __imp__FreeLibrary@4

; 2757 :          break;

	jmp	$L61566
$L61645:

; 2762 :          LPMUTEX lpMutex = zGETPTR( lpRequestProcess->hMemHandle );

	mov	edx, DWORD PTR _lpRequestProcess$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$61646[ebp], eax

; 2763 :          if ( CloseHandle( (HANDLE) lpMutex->Info.hMutexOS ) == 0 )

	mov	ecx, DWORD PTR _lpMutex$61646[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	jne	SHORT $L61649

; 2765 :             char szMsg[ 100 ];
; 2766 : 
; 2767 :             zsprintf( szMsg, "Error destroying mutex: %s", lpMutex->szName );

	mov	eax, DWORD PTR _lpMutex$61646[ebp]
	add	eax, 6
	push	eax
	push	OFFSET FLAT:??_C@_0BL@LBEN@Error?5destroying?5mutex?3?5?$CFs?$AA@ ; `string'
	lea	ecx, DWORD PTR _szMsg$61650[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 2768 :             TraceLineS( szMsg, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	edx, DWORD PTR _szMsg$61650[ebp]
	push	edx
	call	_TraceLineS@8

; 2769 :             fnSysMessageBox( lpTask, szlOE_SystemError, szMsg, 1 );

	push	1
	lea	eax, DWORD PTR _szMsg$61650[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysMessageBox@16
$L61649:

; 2771 : 
; 2772 :          break;

	jmp	SHORT $L61566
$L61652:

; 2777 :          SysMessageBox( (zVIEW) wParam, "Zeidon Object Engine", "Unknown message", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0BA@KLMC@Unknown?5message?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BF@INJH@Zeidon?5Object?5Engine?$AA@ ; `string'
	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	call	_SysMessageBox@16

; 2778 :          return( zCALL_ERROR ); // Failure

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L61548
$L61566:

; 2781 : 
; 2782 :    return( 0 );  // ok ... get out

	xor	ax, ax
$L61548:

; 2783 : 
; 2784 : } // end of:  ProcessZeidonMessage

	mov	esp, ebp
	pop	ebp
	ret	8
$L64807:
	DD	$L61574
	DD	$L61569
	DD	$L61652
	DD	$L61638
	DD	$L61599
	DD	$L61641
	DD	$L61645
_ProcessZeidonMessage@8 ENDP
_TEXT	ENDS
PUBLIC	_SysMalloc@4
PUBLIC	??_C@_0M@EGB@AllocShared?$AA@			; `string'
PUBLIC	??_C@_0BG@OOBG@Zeidon?5Internal?5Error?$AA@	; `string'
PUBLIC	??_C@_0BJ@LNJI@Error?5Calling?5SendMsg?$CI?5?$CJ?$AA@ ; `string'
PUBLIC	_fnAllocSharedMemory@16
EXTRN	__imp__IsWindow@4:NEAR
;	COMDAT ??_C@_0M@EGB@AllocShared?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0M@EGB@AllocShared?$AA@ DB 'AllocShared', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@OOBG@Zeidon?5Internal?5Error?$AA@
_DATA	SEGMENT
??_C@_0BG@OOBG@Zeidon?5Internal?5Error?$AA@ DB 'Zeidon Internal Error', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@LNJI@Error?5Calling?5SendMsg?$CI?5?$CJ?$AA@
_DATA	SEGMENT
??_C@_0BJ@LNJI@Error?5Calling?5SendMsg?$CI?5?$CJ?$AA@ DB 'Error Calling S'
	DB	'endMsg( )', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_ppvMemory$ = 8
_lBytes$ = 16
_cpcShareName$ = 20
_hMemory$ = -4
_lPageTableIndex$ = -8
_lpProcessList$61670 = -16
_k$61671 = -20
_lRC$61672 = -12
_fnAllocSharedMemory@16 PROC NEAR

; 2844 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2845 :    HANDLE hMemory = 0;

	mov	DWORD PTR _hMemory$[ebp], 0

; 2846 :    zLONG  lPageTableIndex = 0;

	mov	DWORD PTR _lPageTableIndex$[ebp], 0

; 2847 : 
; 2848 :    *ppvMemory = 0;

	mov	eax, DWORD PTR _ppvMemory$[ebp]
	mov	DWORD PTR [eax], 0

; 2849 : 
; 2850 :    // If more space is requested than is available, return error.
; 2851 :    if ( lBytes <= 0 )

	cmp	DWORD PTR _lBytes$[ebp], 0
	jg	SHORT $L61666

; 2852 :       return( 0 );

	xor	eax, eax
	jmp	$L61663
$L61666:

; 2853 : 
; 2854 :    if ( g_bServerMode )

	xor	ecx, ecx
	mov	cl, BYTE PTR _g_bServerMode
	test	ecx, ecx
	je	SHORT $L61667

; 2856 :       *ppvMemory = SysMalloc( lBytes );

	mov	edx, DWORD PTR _lBytes$[ebp]
	push	edx
	call	_SysMalloc@4
	mov	ecx, DWORD PTR _ppvMemory$[ebp]
	mov	DWORD PTR [ecx], eax

; 2857 :       return (zLONG) *ppvMemory;

	mov	edx, DWORD PTR _ppvMemory$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	$L61663
$L61667:

; 2859 : 
; 2860 : // TraceLine( "fnAllocSharedMemory1   Process: 0x%08x", SysGetProcessID( 0 ) );
; 2861 : 
; 2862 :    zLOCK_MUTEX( zMUTEX_SHAREDMEM );

	push	4
	call	_fnSysLockCoreMutex@4

; 2863 : 
; 2864 :    // If the memory is shared, then we must send a message to each
; 2865 :    // registered zeidon application.
; 2866 :    //
; 2867 :    // If AnchorBlock is zero then we haven't finished initialization yet so
; 2868 :    // there are no messages to send.
; 2869 : 
; 2870 :    if ( AnchorBlock && AnchorBlock->hMainTask )

	cmp	DWORD PTR _AnchorBlock, 0
	je	$L61669
	mov	eax, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [eax+106], 0
	je	$L61669

; 2872 :       LPPROCESSLIST lpProcessList;
; 2873 :       zLONG     k;
; 2874 :       zLONG     lRC;
; 2875 : 
; 2876 :       // Create a new file mapping.
; 2877 :       *ppvMemory = fnMapFile( &hMemory, lBytes, &lPageTableIndex, 0 );

	push	0
	lea	ecx, DWORD PTR _lPageTableIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lBytes$[ebp]
	push	edx
	lea	eax, DWORD PTR _hMemory$[ebp]
	push	eax
	call	_fnMapFile@16
	mov	ecx, DWORD PTR _ppvMemory$[ebp]
	mov	DWORD PTR [ecx], eax

; 2878 :       if ( hMemory == 0 )

	cmp	DWORD PTR _hMemory$[ebp], 0
	jne	SHORT $L61673

; 2880 :          zUNLOCK_MUTEX( zMUTEX_SHAREDMEM );

	push	4
	call	_fnSysUnlockCoreMutex@4

; 2881 :          return( 0 );

	xor	eax, eax
	jmp	$L61663
$L61673:

; 2883 : 
; 2884 :       fnSetProcessIdx( "AllocShared", &lpProcessList );

	lea	edx, DWORD PTR _lpProcessList$61670[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0M@EGB@AllocShared?$AA@ ; `string'
	call	_fnSetProcessIdx
	add	esp, 8

; 2885 :       lpProcessList->nOE_Request     = TASKREQ_ALLOC; // tell OE to share Memory

	mov	eax, DWORD PTR _lpProcessList$61670[ebp]
	mov	WORD PTR [eax], 1

; 2886 :       lpProcessList->lPageTableIndex = lPageTableIndex;

	mov	ecx, DWORD PTR _lpProcessList$61670[ebp]
	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 2887 :       lpProcessList->hMemHandle      = (zLONG) g_FileMappingHandles[ lPageTableIndex ];

	mov	eax, DWORD PTR _lpProcessList$61670[ebp]
	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	mov	edx, DWORD PTR _g_FileMappingHandles[ecx*4]
	mov	DWORD PTR [eax+12], edx

; 2888 : 
; 2889 :       // Send each task a message to open the same file mapping.
; 2890 :       k = AnchorBlock->OS_Data.lProcessCount;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1507]
	mov	DWORD PTR _k$61671[ebp], ecx
$L61677:

; 2891 :    // TraceLine( "fnAllocSharedMemory should SendMessage from ProcessIndex: %d  to %d processes", g_lProcessIdx, k );
; 2892 :       while ( k > 0 )

	cmp	DWORD PTR _k$61671[ebp], 0
	jle	$L61678

; 2894 :          k--;

	mov	edx, DWORD PTR _k$61671[ebp]
	sub	edx, 1
	mov	DWORD PTR _k$61671[ebp], edx

; 2895 :          lpProcessList = &AnchorBlock->OS_Data.ProcessList[ k ];

	mov	eax, DWORD PTR _k$61671[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _AnchorBlock
	lea	edx, DWORD PTR [ecx+eax+1511]
	mov	DWORD PTR _lpProcessList$61670[ebp], edx

; 2896 :       // TraceLine( "fnAllocSharedMemory SendMessage ALLOC %x Wnd: 0x%08x  Handle: 0x%08x  ProcessIdx: %d  Process: %d",
; 2897 :       //            lPageTableIndex, lpProcessList->hWndAppOE_Msg, lpProcessList->hMemHandle, k, lpProcessList->lProcessID );
; 2898 : 
; 2899 :          if ( k == g_lProcessIdx )

	mov	eax, DWORD PTR _k$61671[ebp]
	cmp	eax, DWORD PTR _g_lProcessIdx
	jne	SHORT $L61679

; 2900 :             continue;  // don't bother sending a message to ourselves

	jmp	SHORT $L61677
$L61679:

; 2901 : 
; 2902 :          if ( IsWindow( (HWND) lpProcessList->hWndAppOE_Msg ) == 0 )

	mov	ecx, DWORD PTR _lpProcessList$61670[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__IsWindow@4
	test	eax, eax
	jne	SHORT $L61681

; 2903 :             continue;

	jmp	SHORT $L61677
$L61681:

; 2904 : 
; 2905 :          lRC = SendMessage( (HWND) lpProcessList->hWndAppOE_Msg,
; 2906 :                             lpProcessList->uAppOE_Msg, 0, g_lProcessIdx );

	mov	eax, DWORD PTR _g_lProcessIdx
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpProcessList$61670[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _lpProcessList$61670[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16
	mov	DWORD PTR _lRC$61672[ebp], eax

; 2907 :       // TraceLine( "fnAllocSharedMemory SendMessage ****** %s ****** Wnd: 0x%08x  ProcessIdx: %d",
; 2908 :       //            lRC ? "Failure" : "Success" , lpProcessList->hWndAppOE_Msg, g_lProcessIdx );
; 2909 :          if ( lRC )

	cmp	DWORD PTR _lRC$61672[ebp], 0
	je	SHORT $L61683

; 2911 :             MessageBox( GetActiveWindow( ), "Error Calling SendMsg( )",
; 2912 :                         "Zeidon Internal Error",
; 2913 :                         MB_ICONSTOP | MB_OK | MB_TASKMODAL );

	push	8208					; 00002010H
	push	OFFSET FLAT:??_C@_0BG@OOBG@Zeidon?5Internal?5Error?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BJ@LNJI@Error?5Calling?5SendMsg?$CI?5?$CJ?$AA@ ; `string'
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
$L61683:

; 2915 :       }

	jmp	$L61677
$L61678:

; 2917 :    else

	jmp	SHORT $L61686
$L61669:

; 2919 :       // Create a new file mapping.
; 2920 :       *ppvMemory = fnMapFile( &hMemory, lBytes, &lPageTableIndex, cpcShareName );

	mov	edx, DWORD PTR _cpcShareName$[ebp]
	push	edx
	lea	eax, DWORD PTR _lPageTableIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lBytes$[ebp]
	push	ecx
	lea	edx, DWORD PTR _hMemory$[ebp]
	push	edx
	call	_fnMapFile@16
	mov	ecx, DWORD PTR _ppvMemory$[ebp]
	mov	DWORD PTR [ecx], eax
$L61686:

; 2922 : 
; 2923 :    zUNLOCK_MUTEX( zMUTEX_SHAREDMEM );

	push	4
	call	_fnSysUnlockCoreMutex@4

; 2924 : 
; 2925 : #ifdef SHARED_MEM_TRACE
; 2926 :    TraceLine( "fnAllocSharedMemory (Task: 0x%08x) at Index: %x   0x%08x   Process: 0x%08x",
; 2927 :               zGETHNDL( lpTask ), lPageTableIndex,
; 2928 :               g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 2929 : #endif
; 2930 : 
; 2931 :    return( (zLONG) hMemory );

	mov	eax, DWORD PTR _hMemory$[ebp]
$L61663:

; 2932 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnAllocSharedMemory@16 ENDP
_TEXT	ENDS
PUBLIC	_CheckPointer
PUBLIC	??_C@_07OCOK@No?5view?$AA@			; `string'
PUBLIC	??_C@_0DJ@NCNE@Check?5Pointer?5Error?5for?5TableInd@ ; `string'
PUBLIC	??_C@_0CE@PGOJ@Check?5Pointer?5Error?5for?5TableInd@ ; `string'
PUBLIC	??_C@_0M@MIHA@Zeidon?5Core?$AA@			; `string'
;	COMDAT ??_C@_07OCOK@No?5view?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_07OCOK@No?5view?$AA@ DB 'No view', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DJ@NCNE@Check?5Pointer?5Error?5for?5TableInd@
_DATA	SEGMENT
??_C@_0DJ@NCNE@Check?5Pointer?5Error?5for?5TableInd@ DB 'Check Pointer Er'
	DB	'ror for TableIndex: %d   ViewOD Name: %s', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CE@PGOJ@Check?5Pointer?5Error?5for?5TableInd@
_DATA	SEGMENT
??_C@_0CE@PGOJ@Check?5Pointer?5Error?5for?5TableInd@ DB 'Check Pointer Er'
	DB	'ror for TableIndex!', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@MIHA@Zeidon?5Core?$AA@
_DATA	SEGMENT
??_C@_0M@MIHA@Zeidon?5Core?$AA@ DB 'Zeidon Core', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_lPageTableIndex$ = 12
_pHandle$ = 16
_k$ = -4
_lpViewOD$61700 = -8
_CheckPointer PROC NEAR

; 2936 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2937 :    // Get high order byte from handle.
; 2938 :    zLONG  k = (zLONG) ((zULONG) pHandle >> 24);

	mov	eax, DWORD PTR _pHandle$[ebp]
	shr	eax, 24					; 00000018H
	mov	DWORD PTR _k$[ebp], eax

; 2939 :    if ( k == lPageTableIndex )

	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _lPageTableIndex$[ebp]
	jne	SHORT $L61699

; 2941 :       LPVIEWOD lpViewOD;
; 2942 : 
; 2943 :       if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $L61701

; 2944 :          lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$61700[ebp], eax

; 2945 :       else

	jmp	SHORT $L61703
$L61701:

; 2946 :          lpViewOD = 0;

	mov	DWORD PTR _lpViewOD$61700[ebp], 0
$L61703:

; 2947 : 
; 2948 :       TraceLine( "Check Pointer Error for TableIndex: %d   ViewOD Name: %s",
; 2949 :                  lPageTableIndex, lpViewOD ? lpViewOD->szName : "No view" );

	cmp	DWORD PTR _lpViewOD$61700[ebp], 0
	je	SHORT $L64810
	mov	ecx, DWORD PTR _lpViewOD$61700[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR -12+[ebp], ecx
	jmp	SHORT $L64811
$L64810:
	mov	DWORD PTR -12+[ebp], OFFSET FLAT:??_C@_07OCOK@No?5view?$AA@ ; `string'
$L64811:
	mov	edx, DWORD PTR -12+[ebp]
	push	edx
	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0DJ@NCNE@Check?5Pointer?5Error?5for?5TableInd@ ; `string'
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 2950 :       SysMessageBox( 0, "Zeidon Core",
; 2951 :                      "Check Pointer Error for TableIndex!", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0CE@PGOJ@Check?5Pointer?5Error?5for?5TableInd@ ; `string'
	push	OFFSET FLAT:??_C@_0M@MIHA@Zeidon?5Core?$AA@ ; `string'
	push	0
	call	_SysMessageBox@16
$L61699:

; 2953 : 
; 2954 :    return( zGETPTR( pHandle ) );

	mov	ecx, DWORD PTR _pHandle$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr

; 2955 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CheckPointer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@JMDM@Invalid?5pointer?5handle?5for?5free?3@ ; `string'
;	COMDAT ??_C@_0DI@JMDM@Invalid?5pointer?5handle?5for?5free?3@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0DI@JMDM@Invalid?5pointer?5handle?5for?5free?3@ DB 'Invalid pointer'
	DB	' handle for free: hi-bit not set: 0x%08x', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_hMemory$ = 12
_lpProcessList$ = -4
_lpTgtProcess$ = -16
_lPageTableIndex$ = -8
_k$ = -12
_szMessage$61722 = -272
_fnFreeSharedMemory@8 PROC NEAR

; 3032 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H

; 3033 :    LPPROCESSLIST lpProcessList;
; 3034 :    LPPROCESSLIST lpTgtProcess;
; 3035 :    zLONG         lPageTableIndex;
; 3036 :    zLONG         k;
; 3037 : 
; 3038 :    if ( g_bServerMode )

	xor	eax, eax
	mov	al, BYTE PTR _g_bServerMode
	test	eax, eax
	je	SHORT $L61718

; 3040 :       SysFree( (zPVOID) hMemory );

	mov	ecx, DWORD PTR _hMemory$[ebp]
	push	ecx
	call	_SysFree@4

; 3041 :       return( 0 );

	xor	eax, eax
	jmp	$L61713
$L61718:

; 3043 : 
; 3044 : #ifdef DEBUG_PAGETABLE
; 3045 :    // Make sure that the highest bit is set.
; 3046 :    if ( ((zLONG) hMemory & 0x80000000) == 0 )

	mov	edx, DWORD PTR _hMemory$[ebp]
	and	edx, -2147483648			; 80000000H
	test	edx, edx
	jne	SHORT $L61721

; 3048 :       char szMessage[ 256 ];
; 3049 :    // k = 0;
; 3050 :       zsprintf( szMessage, "Invalid pointer handle for free: hi-bit not set: 0x%08x", hMemory );

	mov	eax, DWORD PTR _hMemory$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0DI@JMDM@Invalid?5pointer?5handle?5for?5free?3@ ; `string'
	lea	ecx, DWORD PTR _szMessage$61722[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 3051 :       TraceLineS( szMessage, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	edx, DWORD PTR _szMessage$61722[ebp]
	push	edx
	call	_TraceLineS@8

; 3052 :       SysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	eax, DWORD PTR _szMessage$61722[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 3053 : #if 0
; 3054 :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );
; 3055 :       if ( szMessage[ 0 ] == 'Y' )
; 3056 :          k /= k;
; 3057 : #endif
; 3058 :       return( hMemory );

	mov	eax, DWORD PTR _hMemory$[ebp]
	jmp	$L61713
$L61721:

; 3060 : #endif
; 3061 : 
; 3062 :    if ( g_bWin95 )

	xor	edx, edx
	mov	dl, BYTE PTR _g_bWin95
	test	edx, edx
	je	SHORT $L61724

; 3063 :       lPageTableIndex = (zLONG) *((zPLONG) hMemory - 1);

	mov	eax, DWORD PTR _hMemory$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	mov	DWORD PTR _lPageTableIndex$[ebp], ecx

; 3064 :    else

	jmp	SHORT $L61727
$L61724:

; 3065 :       lPageTableIndex = (zLONG) ((zULONG) hMemory >> 24);

	mov	edx, DWORD PTR _hMemory$[ebp]
	shr	edx, 24					; 00000018H
	mov	DWORD PTR _lPageTableIndex$[ebp], edx
$L61727:

; 3066 : 
; 3067 : // TraceLine( "fnFreeSharedMemory at Index: %x   0x%08x   Process: 0x%08x",
; 3068 : //            lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 3069 : 
; 3070 :    // Make sure we have a valid task.  If not then we should be freeing the
; 3071 :    // anchor block so do it.
; 3072 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L61730

; 3074 : #if defined SHARED_MEM_TRACE
; 3075 :       fnTraceSharedMemory( "fnFreeSharedMemory" );
; 3076 : #endif
; 3077 : 
; 3078 :    // if ( lPageTableIndex == 134 )
; 3079 :    // {
; 3080 :    //    TraceLine( "fnFreeSharedMemory1 Page Table at Index: %x   0x%08x   Process: 0x%08x",
; 3081 :    //               lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 3082 :    // }
; 3083 : 
; 3084 :       UnmapViewOfFile( g_ZeidonPageTable[ lPageTableIndex ] );

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonPageTable[eax*4]
	push	ecx
	call	DWORD PTR __imp__UnmapViewOfFile@4

; 3085 :       CloseHandle( (HANDLE) g_FileMappingHandles[ lPageTableIndex ] );

	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	eax, DWORD PTR _g_FileMappingHandles[edx*4]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 3086 :       g_ZeidonPageTable[ lPageTableIndex ] = 0;

	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[ecx*4], 0

; 3087 :       g_FileMappingHandles[ lPageTableIndex ] = 0;

	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR _g_FileMappingHandles[edx*4], 0

; 3088 :       return( 0 );

	xor	eax, eax
	jmp	$L61713
$L61730:

; 3090 : 
; 3091 :    zLOCK_MUTEX( zMUTEX_SHAREDMEM );

	push	4
	call	_fnSysLockCoreMutex@4

; 3092 : 
; 3093 : #ifdef CHECK_MEMORY // check for memory references that will soon become invalid
; 3094 :    CheckMemory( lPageTableIndex );
; 3095 : #endif
; 3096 : 
; 3097 :    lpProcessList = &AnchorBlock->OS_Data.ProcessList[ g_lProcessIdx ];

	mov	eax, DWORD PTR _g_lProcessIdx
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _AnchorBlock
	lea	edx, DWORD PTR [ecx+eax+1511]
	mov	DWORD PTR _lpProcessList$[ebp], edx

; 3098 :    lpProcessList->nOE_Request     = TASKREQ_FREE;  // tell OE to do free

	mov	eax, DWORD PTR _lpProcessList$[ebp]
	mov	WORD PTR [eax], 4

; 3099 :    lpProcessList->lPageTableIndex = lPageTableIndex;

	mov	ecx, DWORD PTR _lpProcessList$[ebp]
	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 3100 : 
; 3101 :    // Make sure nobody is currently deleting a task.
; 3102 :    fnStartBrowseOfTaskList( lpTask, FALSE );

	push	0
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnStartBrowseOfTaskList@8

; 3103 : 
; 3104 :    // Use SysSendTaskMsg to send a message to all tasks to free the memory.
; 3105 :    // We do this in reverse order so as not to blow out the anchor block ???
; 3106 :    // before we're finished with it.                                     ???
; 3107 :    k = AnchorBlock->OS_Data.lProcessCount;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1507]
	mov	DWORD PTR _k$[ebp], edx
$L61733:

; 3108 : // TraceLineI( "fnFreeSharedMemory should SendMessage to process count: ", k );
; 3109 :    while ( k > 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jle	SHORT $L61734

; 3111 :       k--;

	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 3112 :       lpTgtProcess = &AnchorBlock->OS_Data.ProcessList[ k ];

	mov	ecx, DWORD PTR _k$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _AnchorBlock
	lea	eax, DWORD PTR [edx+ecx+1511]
	mov	DWORD PTR _lpTgtProcess$[ebp], eax

; 3113 : 
; 3114 :       if ( lpTgtProcess->hWndAppOE_Msg &&
; 3115 :            IsWindow( (HWND) lpTgtProcess->hWndAppOE_Msg ) )

	mov	ecx, DWORD PTR _lpTgtProcess$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L61736
	mov	edx, DWORD PTR _lpTgtProcess$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__IsWindow@4
	test	eax, eax
	je	SHORT $L61736

; 3117 :          SendMessage( (HWND) lpTgtProcess->hWndAppOE_Msg,
; 3118 :                       lpTgtProcess->uAppOE_Msg, 0, g_lProcessIdx );

	mov	ecx, DWORD PTR _g_lProcessIdx
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpTgtProcess$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _lpTgtProcess$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16
$L61736:

; 3120 :    // SysSendTaskMsg( lpCurrentTask, lpTask );
; 3121 :    }

	jmp	SHORT $L61733
$L61734:

; 3122 : 
; 3123 :    if ( hMemory != g_hAnchorBlock )

	mov	eax, DWORD PTR _hMemory$[ebp]
	cmp	eax, DWORD PTR _g_hAnchorBlock
	je	SHORT $L61738

; 3125 :    // if ( lPageTableIndex == 134 )
; 3126 :    // {
; 3127 :    //    TraceLine( "fnFreeSharedMemory2 Page Table at Index: %x   0x%08x   Process: 0x%08x",
; 3128 :    //               lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 3129 :    // }
; 3130 : 
; 3131 :       UnmapViewOfFile( g_ZeidonPageTable[ lPageTableIndex ] );

	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	mov	edx, DWORD PTR _g_ZeidonPageTable[ecx*4]
	push	edx
	call	DWORD PTR __imp__UnmapViewOfFile@4

; 3132 :       CloseHandle( (HANDLE) g_FileMappingHandles[ lPageTableIndex ] );

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	ecx, DWORD PTR _g_FileMappingHandles[eax*4]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 3133 :       g_ZeidonPageTable[ lPageTableIndex ] = 0;

	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[edx*4], 0

; 3134 :       g_FileMappingHandles[ lPageTableIndex ] = 0;

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR _g_FileMappingHandles[eax*4], 0
$L61738:

; 3139 : 
; 3140 :    fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 3141 : 
; 3142 :    zUNLOCK_MUTEX( zMUTEX_SHAREDMEM );

	push	4
	call	_fnSysUnlockCoreMutex@4

; 3143 : 
; 3144 :    return( 0 );

	xor	eax, eax
$L61713:

; 3145 : 
; 3146 : } // end of:  fnFreeSharedMemory.

	mov	esp, ebp
	pop	ebp
	ret	8
_fnFreeSharedMemory@8 ENDP
_lSize$ = 8
_pvMemory$ = -4
_SysMalloc@4 PROC NEAR

; 3167 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3168 :    zPVOID pvMemory;
; 3169 : 
; 3170 : #ifdef DEBUG_MALLOC
; 3171 :    zLONG  k;
; 3172 : 
; 3173 :    if ( lSize <= -2 )
; 3174 :    {
; 3175 :       TraceLine( "SysMalloc Initializing Memory Usage ===============================> Size: %d", lSize );
; 3176 :       g_lHighWaterMark = -1;
; 3177 :    }
; 3178 : 
; 3179 :    if ( g_lHighWaterMark == -1 )
; 3180 :    {
; 3181 :       for ( k = 0; k < zMAX_ALLOC_TEST; k++ )
; 3182 :          g_pvAlloc[ k ] = 0;
; 3183 :    }
; 3184 : 
; 3185 :    if ( lSize <= 0 )
; 3186 :    {
; 3187 :       TraceLine( "SysMalloc Reporting Memory Usage ===============================> High Water Mark: %d", g_lHighWaterMark );
; 3188 :       for ( k = 0; k < g_lHighWaterMark; k += 2 )
; 3189 :       {
; 3190 :          if ( g_pvAlloc[ k ] )
; 3191 :          {
; 3192 :             TraceLine( "== %06d ============> Mem: 0x%08x  Size: %d",
; 3193 :                        k, g_pvAlloc[ k ], g_pvAlloc[ k + 1 ] );
; 3194 :          }
; 3195 :       }
; 3196 : 
; 3197 :    // g_lHighWaterMark = -1;
; 3198 :       return( 0 );
; 3199 :    }
; 3200 : 
; 3201 :    for ( k = 0; k < zMAX_ALLOC_TEST; k += 2 )
; 3202 :    {
; 3203 :       if ( g_pvAlloc[ k ] == 0 )
; 3204 :          break;
; 3205 :    }
; 3206 : 
; 3207 : #endif
; 3208 : 
; 3209 :    pvMemory = calloc( lSize, 1 );  // allocate the memory!!!

	push	1
	mov	eax, DWORD PTR _lSize$[ebp]
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	mov	DWORD PTR _pvMemory$[ebp], eax

; 3210 : 
; 3211 : #ifdef DEBUG_MALLOC
; 3212 : 
; 3213 :    if ( lSize == 262000 )
; 3214 :       TraceLine( "SysMalloc Size: %d   Mem: 0x%08x", lSize, pvMemory );
; 3215 : 
; 3216 :    if ( k == 18 || k == 12 || k == 14 || k == 16 )
; 3217 :       TraceLine( "SysMalloc (%d) Size: %d   Mem: 0x%08x", k, lSize, pvMemory );
; 3218 : 
; 3219 :    if ( k >= zMAX_ALLOC_TEST )
; 3220 :       MessageBox( 0, "SysMalloc Error", "Memory Test Error", MB_OK );
; 3221 :    else
; 3222 :    {
; 3223 :       if ( g_lHighWaterMark < k )
; 3224 :          g_lHighWaterMark = k;
; 3225 : 
; 3226 :       g_pvAlloc[ k ] = pvMemory;
; 3227 :       g_pvAlloc[ k + 1 ] = (HANDLE) lSize;
; 3228 :    }
; 3229 : 
; 3230 : #endif
; 3231 : 
; 3232 :    return( pvMemory );

	mov	eax, DWORD PTR _pvMemory$[ebp]

; 3233 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysMalloc@4 ENDP
_pvMemory$ = 8
_SysFree@4 PROC NEAR

; 3254 : {

	push	ebp
	mov	ebp, esp

; 3255 : #ifdef DEBUG_MALLOC
; 3256 :    zLONG  k;
; 3257 : 
; 3258 : // TraceLine( "SysFree Mem: 0x%08x", pvMemory );
; 3259 : #endif
; 3260 : 
; 3261 :    if ( pvMemory )

	cmp	DWORD PTR _pvMemory$[ebp], 0
	je	SHORT $L61747

; 3263 : 
; 3264 : #ifdef DEBUG_MALLOC
; 3265 :       for ( k = 0; k < zMAX_ALLOC_TEST; k += 2 )
; 3266 :       {
; 3267 :          if ( g_pvAlloc[ k ] == pvMemory )
; 3268 :          {
; 3269 :             g_pvAlloc[ k ] = 0;
; 3270 :             g_pvAlloc[ k + 1 ] = 0;
; 3271 :             break;
; 3272 :          }
; 3273 :       }
; 3274 : 
; 3275 :       if ( k >= zMAX_ALLOC_TEST )
; 3276 :       {
; 3277 :          TraceLine( "SysFree Error ... Memory Not Found: 0x%08x", pvMemory );
; 3278 :       // MessageBox( 0, "SysFree Error", "Memory Not Found", MB_OK );
; 3279 :       }
; 3280 : #endif
; 3281 : 
; 3282 :       free( pvMemory );

	mov	eax, DWORD PTR _pvMemory$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$L61747:

; 3284 : }

	pop	ebp
	ret	4
_SysFree@4 ENDP
_TEXT	ENDS
PUBLIC	_SysMemSize@4
EXTRN	__imp___msize:NEAR
_TEXT	SEGMENT
_pMemory$ = 8
_SysMemSize@4 PROC NEAR

; 3305 : {

	push	ebp
	mov	ebp, esp

; 3306 :    return( (zULONG) _msize( pMemory ) );

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	DWORD PTR __imp___msize
	add	esp, 4

; 3307 : }

	pop	ebp
	ret	4
_SysMemSize@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@HMMO@KZOE0012?5?9?5Error?5allocating?5memo@ ; `string'
PUBLIC	_SysAllocMemory@20
;	COMDAT ??_C@_0CP@HMMO@KZOE0012?5?9?5Error?5allocating?5memo@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CP@HMMO@KZOE0012?5?9?5Error?5allocating?5memo@ DB 'KZOE0012 - Erro'
	DB	'r allocating memory for length ', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_ppvMemory$ = 8
_lBytes$ = 12
_hMemory$ = 16
_szMsg$61765 = -60
_SysAllocMemory@20 PROC NEAR

; 3365 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 3366 :    *ppvMemory = SysMalloc( lBytes );

	mov	eax, DWORD PTR _lBytes$[ebp]
	push	eax
	call	_SysMalloc@4
	mov	ecx, DWORD PTR _ppvMemory$[ebp]
	mov	DWORD PTR [ecx], eax

; 3367 :    hMemory = (zLONG) *ppvMemory;

	mov	edx, DWORD PTR _ppvMemory$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _hMemory$[ebp], eax

; 3368 : 
; 3369 :    // If an error occurred, tell operator about it, NOTE we do not call
; 3370 :    // fnIssueCoreError because out of memory is a very delicate situation
; 3371 :    // to be in!!.
; 3372 :    if ( hMemory == 0 )

	cmp	DWORD PTR _hMemory$[ebp], 0
	jne	SHORT $L61764

; 3374 :       char szMsg[ 60 ];
; 3375 : 
; 3376 :       // offset ...... 1234567890123456789212345678931234567894123456
; 3377 :       zstrcpy( szMsg, "KZOE0012 - Error allocating memory for length " );

	push	OFFSET FLAT:??_C@_0CP@HMMO@KZOE0012?5?9?5Error?5allocating?5memo@ ; `string'
	lea	ecx, DWORD PTR _szMsg$61765[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 3378 :       zltoa( lBytes, szMsg + 46 );

	push	10					; 0000000aH
	lea	edx, DWORD PTR _szMsg$61765[ebp+46]
	push	edx
	mov	eax, DWORD PTR _lBytes$[ebp]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 3379 :       SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMsg$61765[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16
$L61764:

; 3381 : 
; 3382 :    // Return the handle to the memory allocated.
; 3383 :    return( hMemory );

	mov	eax, DWORD PTR _hMemory$[ebp]

; 3384 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SysAllocMemory@20 ENDP
_TEXT	ENDS
PUBLIC	_SysFreeMemory@4
_TEXT	SEGMENT
_hMemory$ = 8
_SysFreeMemory@4 PROC NEAR

; 3415 : {

	push	ebp
	mov	ebp, esp

; 3416 :    if ( hMemory == 0 )

	cmp	DWORD PTR _hMemory$[ebp], 0
	jne	SHORT $L61770

; 3417 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $L61769
$L61770:

; 3418 : 
; 3419 :    SysFree( (zPVOID) hMemory );

	mov	eax, DWORD PTR _hMemory$[ebp]
	push	eax
	call	_SysFree@4

; 3420 :    return( 0 );

	xor	eax, eax
$L61769:

; 3421 : }

	pop	ebp
	ret	4
_SysFreeMemory@4 ENDP
_TEXT	ENDS
PUBLIC	_SysAddressMemory@4
_TEXT	SEGMENT
_hMemory$ = 8
_SysAddressMemory@4 PROC NEAR

; 3439 : {

	push	ebp
	mov	ebp, esp

; 3440 :    if ( hMemory == g_hAnchorBlock )  // we share the anchor block by name

	mov	eax, DWORD PTR _hMemory$[ebp]
	cmp	eax, DWORD PTR _g_hAnchorBlock
	jne	SHORT $L61775

; 3442 : //    TraceLineX( "SysAddressMemory hAnchorBlock ", (zLONG) hMemory );
; 3443 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $L61774
$L61775:

; 3445 : 
; 3446 :    // Do nothing for addressing since GlobalLock does not seem to
; 3447 :    // increment the memory lock count and all memory is shareable in
; 3448 :    // windows. Therefore, we never attempt to increase the lock count
; 3449 :    // and also never free memory unless the main task requests the free
; 3450 :    // (see SysFreeMemory).
; 3451 :    return( 0 );

	xor	eax, eax
$L61774:

; 3452 : }

	pop	ebp
	ret	4
_SysAddressMemory@4 ENDP
_TEXT	ENDS
PUBLIC	_SysValidAddress@12
EXTRN	__imp__IsBadReadPtr@8:NEAR
EXTRN	__imp__IsBadWritePtr@8:NEAR
_TEXT	SEGMENT
_lpAddress$ = 8
_lLth$ = 12
_bWrite$ = 16
_SysValidAddress@12 PROC NEAR

; 3474 : {

	push	ebp
	mov	ebp, esp

; 3475 :    if ( bWrite )

	mov	eax, DWORD PTR _bWrite$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L61783

; 3476 :       return( !(IsBadWritePtr( lpAddress, (zUSHORT) lLth )) );

	mov	ecx, DWORD PTR _lLth$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	edx, DWORD PTR _lpAddress$[ebp]
	push	edx
	call	DWORD PTR __imp__IsBadWritePtr@8
	neg	eax
	sbb	eax, eax
	inc	eax
	jmp	SHORT $L61785
$L61783:

; 3477 :    else
; 3478 :       return( !(IsBadReadPtr( lpAddress, (zUSHORT) lLth )) );

	mov	eax, DWORD PTR _lLth$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _lpAddress$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsBadReadPtr@8
	neg	eax
	sbb	eax, eax
	inc	eax
$L61785:

; 3479 : }

	pop	ebp
	ret	12					; 0000000cH
_SysValidAddress@12 ENDP
_TEXT	ENDS
PUBLIC	_SysCheckTaskMemory@0
_TEXT	SEGMENT
_SysCheckTaskMemory@0 PROC NEAR

; 3496 : {

	push	ebp
	mov	ebp, esp

; 3497 :    return( 0 );

	xor	eax, eax

; 3498 : }

	pop	ebp
	ret	0
_SysCheckTaskMemory@0 ENDP
_TEXT	ENDS
PUBLIC	_fnGetAnchorBlock@8
PUBLIC	??_C@_0EM@LLEE@fnGetAnchorBlock?5Page?5Table?5mapp@ ; `string'
PUBLIC	??_C@_0BE@LDJC@g_lProcessIdx?5?$CB?$DN?5?91?$AA@ ; `string'
PUBLIC	??_C@_03FMHJ@DGC?$AA@				; `string'
PUBLIC	??_C@_09MIBB@GetAnchor?$AA@			; `string'
EXTRN	__imp__OpenFileMappingA@12:NEAR
EXTRN	__imp__MapViewOfFile@20:NEAR
;	COMDAT ??_C@_0EM@LLEE@fnGetAnchorBlock?5Page?5Table?5mapp@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0EM@LLEE@fnGetAnchorBlock?5Page?5Table?5mapp@ DB 'fnGetAnchorBlock '
	DB	'Page Table mapping at Index: %x   0x%08x   Process: 0x%08x', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@LDJC@g_lProcessIdx?5?$CB?$DN?5?91?$AA@
_DATA	SEGMENT
??_C@_0BE@LDJC@g_lProcessIdx?5?$CB?$DN?5?91?$AA@ DB 'g_lProcessIdx != -1', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_03FMHJ@DGC?$AA@
_DATA	SEGMENT
??_C@_03FMHJ@DGC?$AA@ DB 'DGC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09MIBB@GetAnchor?$AA@
_DATA	SEGMENT
??_C@_09MIBB@GetAnchor?$AA@ DB 'GetAnchor', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lAppOE_Msg$ = 8
_hWndAppOE$ = 12
_lpProcessList$ = -4
_lPageTableIndex$ = -8
_hSaveAnchorBlock$ = -16
_bValidWindow$ = -12
_fnGetAnchorBlock@8 PROC NEAR

; 3508 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3509 :    LPPROCESSLIST lpProcessList;
; 3510 :    zLONG  lPageTableIndex;
; 3511 :    zLONG  hSaveAnchorBlock;
; 3512 :    zBOOL  bValidWindow;
; 3513 : 
; 3514 :    // In server mode, the anchor block has been allocated using local memory
; 3515 :    // so we don't need to do anything.
; 3516 :    if ( g_bServerMode || AnchorBlock )

	xor	eax, eax
	mov	al, BYTE PTR _g_bServerMode
	test	eax, eax
	jne	SHORT $L61800
	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $L61799
$L61800:

; 3517 :       return( 0 );

	xor	ax, ax
	jmp	$L61794
$L61799:

; 3518 : 
; 3519 :    if ( g_bWin95 )

	xor	ecx, ecx
	mov	cl, BYTE PTR _g_bWin95
	test	ecx, ecx
	je	SHORT $L61801

; 3520 :       lPageTableIndex = 1;

	mov	DWORD PTR _lPageTableIndex$[ebp], 1

; 3521 :    else

	jmp	SHORT $L61802
$L61801:

; 3522 : #ifdef DEBUG_PAGETABLE
; 3523 :       // When we are debugging we start with page 128 so that the high bit in
; 3524 :       // the resulting handle will always be set.
; 3525 :       lPageTableIndex = 128;

	mov	DWORD PTR _lPageTableIndex$[ebp], 128	; 00000080H
$L61802:

; 3526 : #else
; 3527 :       // We start with page one (instead of zero) so that a handle will always
; 3528 :       // be non-zero.
; 3529 :       lPageTableIndex = 1;
; 3530 : #endif
; 3531 : 
; 3532 :    // Here is where the current task gets addressability to the AnchorBlock
; 3533 :    // by opening a view to the (named) shared memory mapping file.
; 3534 :    g_hAnchorBlock = (zLONG) OpenFileMapping( FILE_MAP_ALL_ACCESS,
; 3535 :                                              FALSE, szlShareSeg );

	mov	edx, DWORD PTR _szlShareSeg
	push	edx
	push	0
	push	983071					; 000f001fH
	call	DWORD PTR __imp__OpenFileMappingA@12
	mov	DWORD PTR _g_hAnchorBlock, eax

; 3536 :    if ( g_hAnchorBlock == 0 )

	cmp	DWORD PTR _g_hAnchorBlock, 0
	jne	SHORT $L61804

; 3537 :       return( 0 );

	xor	ax, ax
	jmp	$L61794
$L61804:

; 3538 : 
; 3539 :    // We found the anchor block!  Now map it.
; 3540 : #ifdef SHARED_MEM_TRACE
; 3541 :    fnTraceSharedMemory( "Mapping view of anchor block" );
; 3542 : #endif
; 3543 :    AnchorBlock = MapViewOfFile( (HANDLE) g_hAnchorBlock,
; 3544 :                                 FILE_MAP_ALL_ACCESS, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	983071					; 000f001fH
	mov	eax, DWORD PTR _g_hAnchorBlock
	push	eax
	call	DWORD PTR __imp__MapViewOfFile@20
	mov	DWORD PTR _AnchorBlock, eax

; 3545 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $L61806

; 3546 :       return( -1 );

	or	ax, -1
	jmp	$L61794
$L61806:

; 3547 : 
; 3548 :    // We successfully gained addressability to the AnchorBlock!
; 3549 : 
; 3550 :    // Lock the anchor init mutex.  Once we get it we know that the anchor
; 3551 :    // has finished initializing so we can unlock it and go on our merry way.
; 3552 :    zLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysLockCoreMutex@4

; 3553 :    zUNLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysUnlockCoreMutex@4

; 3554 : 
; 3555 :    // We now have the anchor block but we still need to set the global
; 3556 :    // paging table values.  Note that the page table index had better
; 3557 :    // be the first one.
; 3558 :    g_ZeidonPageTable[ lPageTableIndex ] = AnchorBlock;

	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR _g_ZeidonPageTable[ecx*4], edx

; 3559 :    g_FileMappingHandles[ lPageTableIndex ] = (zLONG) g_hAnchorBlock;

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	ecx, DWORD PTR _g_hAnchorBlock
	mov	DWORD PTR _g_FileMappingHandles[eax*4], ecx

; 3560 : 
; 3561 :    TraceLine( "fnGetAnchorBlock Page Table mapping at Index: %x   0x%08x   Process: 0x%08x",
; 3562 :               lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );

	push	0
	call	_SysGetProcessID@4
	push	eax
	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	eax, DWORD PTR _g_ZeidonPageTable[edx*4]
	push	eax
	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0EM@LLEE@fnGetAnchorBlock?5Page?5Table?5mapp@ ; `string'
	call	_TraceLine
	add	esp, 16					; 00000010H

; 3563 : 
; 3564 : //#ifdef DEBUG
; 3565 :    if ( g_lProcessIdx != -1 )

	cmp	DWORD PTR _g_lProcessIdx, -1
	je	SHORT $L61809

; 3567 :       SysMessageBox( 0, "DGC", "g_lProcessIdx != -1", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0BE@LDJC@g_lProcessIdx?5?$CB?$DN?5?91?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_03FMHJ@DGC?$AA@	; `string'
	push	0
	call	_SysMessageBox@16

; 3568 :       return( 0 );

	xor	ax, ax
	jmp	$L61794
$L61809:

; 3570 : //#endif
; 3571 : 
; 3572 :    // Point to the correct structure in the AnchorBlock's ProcessList and set
; 3573 :    // g_lProcessIdx and the CurrentProcessId data element at the same time.
; 3574 :    fnSetProcessIdx( "GetAnchor", &lpProcessList );

	lea	edx, DWORD PTR _lpProcessList$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_09MIBB@GetAnchor?$AA@	; `string'
	call	_fnSetProcessIdx
	add	esp, 8

; 3575 :    lpProcessList->uAppOE_Msg = (zUSHORT) lAppOE_Msg;

	mov	eax, DWORD PTR _lpProcessList$[ebp]
	mov	cx, WORD PTR _lAppOE_Msg$[ebp]
	mov	WORD PTR [eax+2], cx

; 3576 :    lpProcessList->hWndAppOE_Msg = hWndAppOE;

	mov	edx, DWORD PTR _lpProcessList$[ebp]
	mov	eax, DWORD PTR _hWndAppOE$[ebp]
	mov	DWORD PTR [edx+4], eax

; 3577 : 
; 3578 :    if ( g_bWin95 )

	xor	ecx, ecx
	mov	cl, BYTE PTR _g_bWin95
	test	ecx, ecx
	je	SHORT $L61814

; 3580 :       // To mirror what happens in fnAllocSharedMemory we have to store the
; 3581 :       // index of g_hAnchorBlock in the first few bytes of the memory.
; 3582 :       *((zPLONG) AnchorBlock)++ = lPageTableIndex;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 4
	mov	DWORD PTR _AnchorBlock, ecx

; 3583 :       hSaveAnchorBlock = (zLONG) AnchorBlock;

	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR _hSaveAnchorBlock$[ebp], edx

; 3585 :    else

	jmp	SHORT $L61817
$L61814:

; 3586 :       hSaveAnchorBlock = (zLONG) ((zULONG) lPageTableIndex << 24);

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	shl	eax, 24					; 00000018H
	mov	DWORD PTR _hSaveAnchorBlock$[ebp], eax
$L61817:

; 3587 : 
; 3588 :    // For the moment we'll change g_hAnchorBlock to be zero.  This will keep
; 3589 :    // some things (for example TraceLineX) from doing something it shouldn't.
; 3590 :    g_hAnchorBlock = 0;

	mov	DWORD PTR _g_hAnchorBlock, 0

; 3591 : 
; 3592 : // TraceLineI( "Register AnchorBlock = ", (zLONG) AnchorBlock );
; 3593 : 
; 3594 :    // We now have to open views to all shared mapping files created by other
; 3595 :    // tasks.  To do this we will send a message to the main task and ask for
; 3596 :    // the handle of each shared mapping file.  When the returned handle is
; 3597 :    // zero, then there are no more mapping files.
; 3598 : 
; 3599 :    // Init to first PageTable entry ... used in inter-process communication
; 3600 :    // to permit each shared mapping handle to be processed.
; 3601 :    lpProcessList->lPageTableIndex = lPageTableIndex;

	mov	ecx, DWORD PTR _lpProcessList$[ebp]
	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 3602 : 
; 3603 :    if ( IsWindow( (HWND) AnchorBlock->OS_Data.hMainWindow ) )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1503]
	push	ecx
	call	DWORD PTR __imp__IsWindow@4
	test	eax, eax
	je	SHORT $L61821

; 3604 :       bValidWindow = TRUE;

	mov	BYTE PTR _bValidWindow$[ebp], 1

; 3605 :    else

	jmp	SHORT $L61822
$L61821:

; 3606 :       bValidWindow = FALSE;

	mov	BYTE PTR _bValidWindow$[ebp], 0
$L61822:

; 3607 : 
; 3608 :    while ( bValidWindow )

	mov	edx, DWORD PTR _bValidWindow$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L61825

; 3610 :       lpProcessList->nOE_Request = TASKREQ_SHARE;  // we want to share handles

	mov	eax, DWORD PTR _lpProcessList$[ebp]
	mov	WORD PTR [eax], 2

; 3611 : 
; 3612 : #ifdef __MUTEX_DEBUG__
; 3613 :       // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 3614 :       fnPrintMutexInfo( 's', zMUTEX_COUNT, __FILE__, __LINE__ );
; 3615 : #endif
; 3616 : 
; 3617 :       SendMessage( (HWND) AnchorBlock->OS_Data.hMainWindow,
; 3618 :                    g_wOENG_Message, 0, g_lProcessIdx );

	mov	ecx, DWORD PTR _g_lProcessIdx
	push	ecx
	push	0
	mov	edx, DWORD PTR _g_wOENG_Message
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1503]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 3619 : 
; 3620 : #ifdef __MUTEX_DEBUG__
; 3621 :       // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 3622 :       fnPrintMutexInfo( 'S', zMUTEX_COUNT, __FILE__, __LINE__ );
; 3623 : #endif
; 3624 : 
; 3625 :       // Check the returned handle.  If it's zero, then there are no more file mappings.
; 3626 :       if ( lpProcessList->hMemHandle == 0 )

	mov	edx, DWORD PTR _lpProcessList$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $L61827

; 3627 :          break;

	jmp	SHORT $L61825
$L61827:

; 3628 : 
; 3629 :       // Now call ProcessZeidonMessage to take the handle returned from the
; 3630 :       // system task and open it for the current task.
; 3631 :       lpProcessList->nOE_Request = TASKREQ_ALLOC; // we want to open a file mapping

	mov	eax, DWORD PTR _lpProcessList$[ebp]
	mov	WORD PTR [eax], 1

; 3632 :       ProcessZeidonMessage( 0, g_lProcessIdx );

	mov	ecx, DWORD PTR _g_lProcessIdx
	push	ecx
	push	0
	call	_ProcessZeidonMessage@8

; 3633 :    }

	jmp	SHORT $L61822
$L61825:

; 3634 : 
; 3635 :    // Last thing is to change g_hAnchorBlock from zero to a Zeidon handle.
; 3636 :    g_hAnchorBlock = hSaveAnchorBlock;

	mov	edx, DWORD PTR _hSaveAnchorBlock$[ebp]
	mov	DWORD PTR _g_hAnchorBlock, edx

; 3637 :    return( 0 );

	xor	ax, ax
$L61794:

; 3638 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnGetAnchorBlock@8 ENDP
_TEXT	ENDS
PUBLIC	_SysGetAnchorBlock@0
_TEXT	SEGMENT
_SysGetAnchorBlock@0 PROC NEAR

; 3653 : {

	push	ebp
	mov	ebp, esp

; 3654 :    return( AnchorBlock );

	mov	eax, DWORD PTR _AnchorBlock

; 3655 : }

	pop	ebp
	ret	0
_SysGetAnchorBlock@0 ENDP
_TEXT	ENDS
PUBLIC	_SysGetAnchorBlockData@4
_TEXT	SEGMENT
_lFlag$ = 8
_SysGetAnchorBlockData@4 PROC NEAR

; 3673 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3674 :    if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	$L61835

; 3676 :       switch ( lFlag & 0x0FFFFFFF )
; 3677 :       {

	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR -4+[ebp], eax
	mov	ecx, DWORD PTR -4+[ebp]
	sub	ecx, 1
	mov	DWORD PTR -4+[ebp], ecx
	cmp	DWORD PTR -4+[ebp], 3
	ja	SHORT $L61835
	mov	edx, DWORD PTR -4+[ebp]
	jmp	DWORD PTR $L64824[edx*4]
$L61838:

; 3678 :          case 1:
; 3679 :             if ( lFlag & 0x80000000 )

	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	je	SHORT $L61839

; 3680 :                return( zGETPTR( AnchorBlock->hSystemApp ) );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	jmp	SHORT $L61832
$L61839:

; 3681 :             else
; 3682 :                return( AnchorBlock->hSystemApp );

	mov	eax, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [eax+110]
	jmp	SHORT $L61832
$L61841:

; 3683 : 
; 3684 :          case 2:
; 3685 :             if ( lFlag & 0x80000000 )

	mov	ecx, DWORD PTR _lFlag$[ebp]
	and	ecx, -2147483648			; 80000000H
	test	ecx, ecx
	je	SHORT $L61843

; 3686 :                return( zGETPTR( AnchorBlock->hMainTask ) );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	jmp	SHORT $L61832
$L61843:

; 3687 :             else
; 3688 :                return( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [ecx+106]
	jmp	SHORT $L61832
$L61845:

; 3689 : 
; 3690 :          case 3:
; 3691 :             return( (zPVOID) AnchorBlock->lOE_hMainWnd );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+94]
	jmp	SHORT $L61832
$L61848:

; 3692 : 
; 3693 :          case 4:
; 3694 :             return( (zPVOID) AnchorBlock->lOE_hListWnd );

	mov	eax, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [eax+98]
	jmp	SHORT $L61832
$L61835:

; 3697 : 
; 3698 :    return( 0 );

	xor	eax, eax
$L61832:

; 3699 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$L64824:
	DD	$L61838
	DD	$L61841
	DD	$L61845
	DD	$L61848
_SysGetAnchorBlockData@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@JNJD@Couldn?8t?5find?5ZEIDON_BIN?5specifi@ ; `string'
PUBLIC	??_C@_0BO@GCKC@Zeidon?5?9?5Object?5Services?5Init?$AA@ ; `string'
PUBLIC	??_C@_03DMDD@?5?9?5?$AA@			; `string'
PUBLIC	??_C@_0P@FAPI@MS?5Windows?53?4x?$AA@		; `string'
PUBLIC	??_C@_0BB@FLLN@MS?5Windows?595?198?$AA@		; `string'
PUBLIC	??_C@_0BB@CFLM@MS?5Windows?5NT?1XP?$AA@		; `string'
PUBLIC	??_C@_08IBID@IBM?5OS?12?$AA@			; `string'
PUBLIC	??_C@_0CJ@LGIB@?$CIsy?$CJ?5SysStartObjectServices?5star@ ; `string'
PUBLIC	_SysGetOS_Info@4
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	__imp__CreateFileA@28:NEAR
EXTRN	__imp__CreateEventA@16:NEAR
EXTRN	__imp__ReadFile@20:NEAR
EXTRN	__imp__CreateProcessA@40:NEAR
EXTRN	__imp__strstr:NEAR
;	COMDAT ??_C@_0CI@JNJD@Couldn?8t?5find?5ZEIDON_BIN?5specifi@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CI@JNJD@Couldn?8t?5find?5ZEIDON_BIN?5specifi@ DB 'Couldn''t find Z'
	DB	'EIDON_BIN specification.', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@GCKC@Zeidon?5?9?5Object?5Services?5Init?$AA@
_DATA	SEGMENT
??_C@_0BO@GCKC@Zeidon?5?9?5Object?5Services?5Init?$AA@ DB 'Zeidon - Objec'
	DB	't Services Init', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03DMDD@?5?9?5?$AA@
_DATA	SEGMENT
??_C@_03DMDD@?5?9?5?$AA@ DB ' - ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@FAPI@MS?5Windows?53?4x?$AA@
_DATA	SEGMENT
??_C@_0P@FAPI@MS?5Windows?53?4x?$AA@ DB 'MS Windows 3.x', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@FLLN@MS?5Windows?595?198?$AA@
_DATA	SEGMENT
??_C@_0BB@FLLN@MS?5Windows?595?198?$AA@ DB 'MS Windows 95/98', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@CFLM@MS?5Windows?5NT?1XP?$AA@
_DATA	SEGMENT
??_C@_0BB@CFLM@MS?5Windows?5NT?1XP?$AA@ DB 'MS Windows NT/XP', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IBID@IBM?5OS?12?$AA@
_DATA	SEGMENT
??_C@_08IBID@IBM?5OS?12?$AA@ DB 'IBM OS/2', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@LGIB@?$CIsy?$CJ?5SysStartObjectServices?5star@
_DATA	SEGMENT
??_C@_0CJ@LGIB@?$CIsy?$CJ?5SysStartObjectServices?5star@ DB '(sy) SysStar'
	DB	'tObjectServices started for ', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lAppOE_Msg$ = 8
_hWndAppOE$ = 12
_szProgramName$ = -516
_szTemp$ = -1036
_pchOS_Name$ = -520
_szMessage$61859 = -1292
_hFile$61862 = -2376
_szLine$61863 = -2364
_pchPtr$61864 = -1364
_k$61865 = -2368
_hServicesStarted$61866 = -2372
_Startup$61867 = -1360
_PInfo$61868 = -2392
_szMessage$61871 = -2648
_ulBytes$61872 = -2652
_szMessage$61886 = -2908
_l$61887 = -2912
_szMessage$61900 = -3168
_SysStartObjectServices PROC NEAR

; 3719 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3172				; 00000c64H

; 3720 :    char szProgramName[ zMAX_FILESPEC_LTH + 1 ];  // prevent overflow in
; 3721 :    char szTemp[ zMAX_FILESPEC_LTH + 1 ];         // fnConvertEnvironnentString
; 3722 :    zPCHAR pchOS_Name;
; 3723 : 
; 3724 :    // Validate that environment variable ZEIDON set
; 3725 :    SysGetEnvVar( szProgramName, szlZEIDON, sizeof( szProgramName ) - 1 );

	push	512					; 00000200H
	mov	eax, DWORD PTR _szlZEIDON
	push	eax
	lea	ecx, DWORD PTR _szProgramName$[ebp]
	push	ecx
	call	_SysGetEnvVar@12

; 3726 :    if ( szProgramName[ 0 ] == 0 )

	movsx	edx, BYTE PTR _szProgramName$[ebp]
	test	edx, edx
	jne	SHORT $L61858

; 3728 :       char szMessage[ 256 ];
; 3729 : 
; 3730 :       // {2,"KZOEE002 - ZEIDON environment variable not set"},
; 3731 :       SysGetBaseMessage( szMessage, KZOEE002, 255 );

	push	255					; 000000ffH
	push	2
	lea	eax, DWORD PTR _szMessage$61859[ebp]
	push	eax
	call	_SysGetBaseMessage@12

; 3732 :       SysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMessage$61859[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 3733 :       return( -1 );

	or	ax, -1
	jmp	$L61854
$L61858:

; 3735 : 
; 3736 :    // Let's see if the anchor block is already initialized.  If it is then
; 3737 :    // some other process has created shared memory and named it.  Look for it.
; 3738 :    if ( g_hAnchorBlock == 0 && fnGetAnchorBlock( lAppOE_Msg, hWndAppOE ) == -1 )

	cmp	DWORD PTR _g_hAnchorBlock, 0
	jne	SHORT $L61860
	mov	eax, DWORD PTR _hWndAppOE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lAppOE_Msg$[ebp]
	push	ecx
	call	_fnGetAnchorBlock@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $L61860

; 3739 :       return( -1 );

	or	ax, -1
	jmp	$L61854
$L61860:

; 3740 : 
; 3741 :    // Build qualified program name.
; 3742 :    // The ZEIDON environment variable must point to a directory
; 3743 :    // containing the ZEIDON.APP file.  From there we retrieve the
; 3744 :    // name of the Zeidon executable directory.
; 3745 :    if ( AnchorBlock == 0 && g_bServerMode == FALSE )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	$L61861
	xor	eax, eax
	mov	al, BYTE PTR _g_bServerMode
	test	eax, eax
	jne	$L61861

; 3747 :       zLONG               hFile;
; 3748 :       zCHAR               szLine[ 1000 ];
; 3749 :       zPCHAR              pchPtr;
; 3750 :       int                 k;
; 3751 :       HANDLE              hServicesStarted;
; 3752 :       STARTUPINFO         Startup;
; 3753 :       PROCESS_INFORMATION PInfo;
; 3754 : 
; 3755 :       // See if we can open the zeidon applications file.
; 3756 :       SysAppendcDirSep( szProgramName );

	lea	ecx, DWORD PTR _szProgramName$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 3757 :       zstrcat( szProgramName, szlAppFile );

	mov	edx, DWORD PTR _szlAppFile
	push	edx
	lea	eax, DWORD PTR _szProgramName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3758 : 
; 3759 :       hFile = (zLONG) CreateFile( szProgramName, GENERIC_READ,
; 3760 :                                   FILE_SHARE_READ, 0,
; 3761 :                                   OPEN_EXISTING,
; 3762 :                                   FILE_ATTRIBUTE_NORMAL, 0 );

	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	lea	ecx, DWORD PTR _szProgramName$[ebp]
	push	ecx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$61862[ebp], eax

; 3763 : 
; 3764 :       if ( hFile == -1 )

	cmp	DWORD PTR _hFile$61862[ebp], -1
	jne	SHORT $L61870

; 3766 :          char szMessage[ 256 ];
; 3767 : 
; 3768 :          // {9,"KZOEE009 - Error opening application definition file"},
; 3769 :          SysGetBaseMessage( szMessage, KZOEE009, 255 );

	push	255					; 000000ffH
	push	9
	lea	edx, DWORD PTR _szMessage$61871[ebp]
	push	edx
	call	_SysGetBaseMessage@12

; 3770 :          zstrcat( szMessage, " '" );

	push	OFFSET FLAT:??_C@_02NCFH@?5?8?$AA@	; `string'
	lea	eax, DWORD PTR _szMessage$61871[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3771 :          zstrcat( szMessage, szProgramName );

	lea	ecx, DWORD PTR _szProgramName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szMessage$61871[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3772 :          zstrcat( szMessage, "'" );

	push	OFFSET FLAT:??_C@_01HAF@?8?$AA@		; `string'
	lea	eax, DWORD PTR _szMessage$61871[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3773 :       // SysMessageBox( 0, szlOE_SystemError, szMessage, -1 );  causes bomb if called
; 3774 :          fnSysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMessage$61871[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_fnSysMessageBox@16

; 3775 : 
; 3776 :          return( -1 );

	or	ax, -1
	jmp	$L61854
$L61870:

; 3782 :          ULONG ulBytes;
; 3783 : 
; 3784 :          ReadFile( (HANDLE) hFile, szLine, sizeof( szLine ), &ulBytes, 0 );

	push	0
	lea	eax, DWORD PTR _ulBytes$61872[ebp]
	push	eax
	push	1000					; 000003e8H
	lea	ecx, DWORD PTR _szLine$61863[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFile$61862[ebp]
	push	edx
	call	DWORD PTR __imp__ReadFile@20

; 3785 :          CloseHandle( (HANDLE) hFile );

	mov	eax, DWORD PTR _hFile$61862[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 3787 : 
; 3788 :       szLine[ sizeof( szLine ) - 1 ] = 0;    // ensure buffer is terminated

	mov	BYTE PTR _szLine$61863[ebp+999], 0

; 3789 :       pchPtr = zstrstr( szLine, szlZEIDON_BIN );

	mov	ecx, DWORD PTR _szlZEIDON_BIN
	push	ecx
	lea	edx, DWORD PTR _szLine$61863[ebp]
	push	edx
	call	DWORD PTR __imp__strstr
	add	esp, 8
	mov	DWORD PTR _pchPtr$61864[ebp], eax

; 3790 :       if ( !pchPtr )

	cmp	DWORD PTR _pchPtr$61864[ebp], 0
	jne	SHORT $L61875

; 3792 :          fnSysMessageBox( 0, szlOE_SystemError,
; 3793 :                           "Couldn't find ZEIDON_BIN specification.", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0CI@JNJD@Couldn?8t?5find?5ZEIDON_BIN?5specifi@ ; `string'
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_fnSysMessageBox@16

; 3794 :          return( -1 );

	or	ax, -1
	jmp	$L61854
$L61875:

; 3796 : 
; 3797 :       // We found the zeidon bin specification.  Now bump up pchPtr to point
; 3798 :       // to the first non-blank char after zeidon bin.
; 3799 :       pchPtr += strlen( szlZEIDON_BIN );

	mov	ecx, DWORD PTR _szlZEIDON_BIN
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _pchPtr$61864[ebp]
	add	edx, eax
	mov	DWORD PTR _pchPtr$61864[ebp], edx
$L61878:

; 3800 :       while ( *pchPtr == ' ' )

	mov	eax, DWORD PTR _pchPtr$61864[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $L61879

; 3801 :          pchPtr++;

	mov	edx, DWORD PTR _pchPtr$61864[ebp]
	add	edx, 1
	mov	DWORD PTR _pchPtr$61864[ebp], edx
	jmp	SHORT $L61878
$L61879:

; 3802 : 
; 3803 :       // Copy directory to szProgramName up to the line terminator.
; 3804 :       k = 0;

	mov	DWORD PTR _k$61865[ebp], 0
$L61881:

; 3805 :       while ( *pchPtr >= ' ' )

	mov	eax, DWORD PTR _pchPtr$61864[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $L61882

; 3806 :          szTemp[ k++ ] = *pchPtr++;

	mov	edx, DWORD PTR _k$61865[ebp]
	mov	eax, DWORD PTR _pchPtr$61864[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szTemp$[ebp+edx], cl
	mov	edx, DWORD PTR _k$61865[ebp]
	add	edx, 1
	mov	DWORD PTR _k$61865[ebp], edx
	mov	eax, DWORD PTR _pchPtr$61864[ebp]
	add	eax, 1
	mov	DWORD PTR _pchPtr$61864[ebp], eax
	jmp	SHORT $L61881
$L61882:

; 3807 : 
; 3808 :       szTemp[ k ] = 0;

	mov	ecx, DWORD PTR _k$61865[ebp]
	mov	BYTE PTR _szTemp$[ebp+ecx], 0

; 3809 : 
; 3810 :       // Convert name using environment vars.
; 3811 :       fnConvertEnvironmentString( szProgramName, szTemp );

	lea	edx, DWORD PTR _szTemp$[ebp]
	push	edx
	lea	eax, DWORD PTR _szProgramName$[ebp]
	push	eax
	call	_fnConvertEnvironmentString@8

; 3812 : 
; 3813 :       // Create a Win32 event so we'll know when OE is up.
; 3814 :       hServicesStarted = CreateEvent( NULL, TRUE, FALSE,
; 3815 :                                       "Zeidon - Object Services Init" );

	push	OFFSET FLAT:??_C@_0BO@GCKC@Zeidon?5?9?5Object?5Services?5Init?$AA@ ; `string'
	push	0
	push	1
	push	0
	call	DWORD PTR __imp__CreateEventA@16
	mov	DWORD PTR _hServicesStarted$61866[ebp], eax

; 3816 : 
; 3817 :       // Start Object Services program asynchronously
; 3818 :       SysAppendcDirSep( szProgramName );

	lea	ecx, DWORD PTR _szProgramName$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 3819 :       zstrcat( szProgramName, szObjectEngineName );

	mov	edx, DWORD PTR _szObjectEngineName
	push	edx
	lea	eax, DWORD PTR _szProgramName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3820 : 
; 3821 :       zmemset( &PInfo, 0, sizeof( PInfo ) );

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _PInfo$61868[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 3822 :       zmemset( &Startup, 0, sizeof( Startup ) );

	push	68					; 00000044H
	push	0
	lea	edx, DWORD PTR _Startup$61867[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 3823 :       Startup.cb          = sizeof( Startup );

	mov	DWORD PTR _Startup$61867[ebp], 68	; 00000044H

; 3824 :       Startup.dwFlags     = STARTF_USESHOWWINDOW;

	mov	DWORD PTR _Startup$61867[ebp+44], 1

; 3825 :       Startup.wShowWindow = SW_MINIMIZE;

	mov	WORD PTR _Startup$61867[ebp+48], 6

; 3826 :       if ( CreateProcess( szProgramName, 0, 0, 0, 0, 0, 0,
; 3827 :                           0, &Startup, &PInfo ) == 0 )

	lea	eax, DWORD PTR _PInfo$61868[ebp]
	push	eax
	lea	ecx, DWORD PTR _Startup$61867[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _szProgramName$[ebp]
	push	edx
	call	DWORD PTR __imp__CreateProcessA@40
	test	eax, eax
	jne	SHORT $L61885

; 3829 :          char  szMessage[ 256 ];
; 3830 :          DWORD l = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _l$61887[ebp], eax

; 3831 : 
; 3832 :          // {3,"KZOEE003 - Error starting Object Services"},
; 3833 :          SysGetBaseMessage( szMessage, KZOEE003, 255 );

	push	255					; 000000ffH
	push	3
	lea	eax, DWORD PTR _szMessage$61886[ebp]
	push	eax
	call	_SysGetBaseMessage@12

; 3834 :          zstrcat( szMessage, " - " );

	push	OFFSET FLAT:??_C@_03DMDD@?5?9?5?$AA@	; `string'
	lea	ecx, DWORD PTR _szMessage$61886[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3835 :          zstrcat( szMessage, szProgramName );

	lea	edx, DWORD PTR _szProgramName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szMessage$61886[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3836 :          fnSysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMessage$61886[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_fnSysMessageBox@16

; 3837 :          return( -1 );

	or	ax, -1
	jmp	$L61854
$L61885:

; 3839 : 
; 3840 :       // Wait for the services to start.
; 3841 :       WaitForSingleObject( hServicesStarted, INFINITE );

	push	-1
	mov	eax, DWORD PTR _hServicesStarted$61866[ebp]
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 3842 :       CloseHandle( hServicesStarted );

	mov	ecx, DWORD PTR _hServicesStarted$61866[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 3843 :       if ( fnGetAnchorBlock( lAppOE_Msg, hWndAppOE ) == -1 )

	mov	edx, DWORD PTR _hWndAppOE$[ebp]
	push	edx
	mov	eax, DWORD PTR _lAppOE_Msg$[ebp]
	push	eax
	call	_fnGetAnchorBlock@8
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $L61889

; 3844 :          return( -1 );

	or	ax, -1
	jmp	$L61854
$L61889:

; 3846 :    else

	jmp	$L61898
$L61861:

; 3847 :    if ( AnchorBlock == 0 && g_bServerMode )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $L61891
	xor	edx, edx
	mov	dl, BYTE PTR _g_bServerMode
	test	edx, edx
	je	SHORT $L61891

; 3849 :       AnchorBlock = InitializeAnchorBlock( (zLONG) g_hInstance,
; 3850 :                                            (zLONG) 0,
; 3851 :                                            (zLONG) 0,
; 3852 :                                            (zLONG) 0 );

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _g_hInstance
	push	eax
	call	_InitializeAnchorBlock@16
	mov	DWORD PTR _AnchorBlock, eax

; 3854 :    else

	jmp	$L61898
$L61891:

; 3856 :       // If AnchorBlock is corrupt, free it and issue a bad RC
; 3857 :       if ( AnchorBlock->nStatus  == AnchorCorrupt ||
; 3858 :            AnchorBlock->nTableID != iAnchor ||
; 3859 :            !IsWindow( (HWND) AnchorBlock->lOE_hMainWnd ) )

	mov	ecx, DWORD PTR _AnchorBlock
	movsx	edx, WORD PTR [ecx+84]
	cmp	edx, 20					; 00000014H
	je	SHORT $L61899
	mov	eax, DWORD PTR _AnchorBlock
	movsx	ecx, WORD PTR [eax+82]
	cmp	ecx, 10001				; 00002711H
	jne	SHORT $L61899
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	DWORD PTR __imp__IsWindow@4
	test	eax, eax
	jne	SHORT $L61898
$L61899:

; 3861 :          char szMessage[ 256 ];
; 3862 : 
; 3863 :          // {7,"KZOEE007 - Internal Anchor block error, system restart recommended"},
; 3864 :          SysGetBaseMessage( szMessage, KZOEE007, 255 );

	push	255					; 000000ffH
	push	7
	lea	ecx, DWORD PTR _szMessage$61900[ebp]
	push	ecx
	call	_SysGetBaseMessage@12

; 3865 :          fnSysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	edx, DWORD PTR _szMessage$61900[ebp]
	push	edx
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_fnSysMessageBox@16

; 3866 : 
; 3867 :          fnFreeSharedMemory( 0, g_hAnchorBlock );

	mov	ecx, DWORD PTR _g_hAnchorBlock
	push	ecx
	push	0
	call	_fnFreeSharedMemory@8

; 3868 :          g_hAnchorBlock = 0;

	mov	DWORD PTR _g_hAnchorBlock, 0

; 3869 :          AnchorBlock  = 0;

	mov	DWORD PTR _AnchorBlock, 0

; 3870 :          g_lProcessIdx = -1;

	mov	DWORD PTR _g_lProcessIdx, -1

; 3871 :          return( -1 );

	or	ax, -1
	jmp	SHORT $L61854
$L61898:

; 3874 : 
; 3875 :    switch ( SysGetOS_Info( 0 ) )
; 3876 :    {

	push	0
	call	_SysGetOS_Info@4
	mov	DWORD PTR -3172+[ebp], eax
	mov	edx, DWORD PTR -3172+[ebp]
	sub	edx, 1
	mov	DWORD PTR -3172+[ebp], edx
	cmp	DWORD PTR -3172+[ebp], 3
	ja	SHORT $L61902
	mov	eax, DWORD PTR -3172+[ebp]
	jmp	DWORD PTR $L64826[eax*4]
$L61905:

; 3877 :       case zOS_WINDOWS:
; 3878 :          pchOS_Name = "MS Windows 3.x";

	mov	DWORD PTR _pchOS_Name$[ebp], OFFSET FLAT:??_C@_0P@FAPI@MS?5Windows?53?4x?$AA@ ; `string'

; 3879 :          break;

	jmp	SHORT $L61902
$L61907:

; 3880 : 
; 3881 :       case zOS_WINDOWS95:
; 3882 :          pchOS_Name = "MS Windows 95/98";

	mov	DWORD PTR _pchOS_Name$[ebp], OFFSET FLAT:??_C@_0BB@FLLN@MS?5Windows?595?198?$AA@ ; `string'

; 3883 :          break;

	jmp	SHORT $L61902
$L61909:

; 3884 : 
; 3885 :       case zOS_WINDOWSNT:
; 3886 :          pchOS_Name = "MS Windows NT/XP";

	mov	DWORD PTR _pchOS_Name$[ebp], OFFSET FLAT:??_C@_0BB@CFLM@MS?5Windows?5NT?1XP?$AA@ ; `string'

; 3887 :          break;

	jmp	SHORT $L61902
$L61911:

; 3888 : 
; 3889 :       case zOS_OS2:
; 3890 :          pchOS_Name = "IBM OS/2";

	mov	DWORD PTR _pchOS_Name$[ebp], OFFSET FLAT:??_C@_08IBID@IBM?5OS?12?$AA@ ; `string'
$L61902:

; 3893 : 
; 3894 :    // If we get here, we must have been successful.
; 3895 :    TraceLineS( "(sy) SysStartObjectServices started for ", pchOS_Name );

	mov	ecx, DWORD PTR _pchOS_Name$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CJ@LGIB@?$CIsy?$CJ?5SysStartObjectServices?5star@ ; `string'
	call	_TraceLineS@8

; 3896 :    return( 0 );

	xor	ax, ax
$L61854:

; 3897 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$L64826:
	DD	$L61905
	DD	$L61907
	DD	$L61909
	DD	$L61911
_SysStartObjectServices ENDP
_TEXT	ENDS
PUBLIC	_fnSysGetPointerFromHandleServerMode@4
_TEXT	SEGMENT
_pHandle$ = 8
_fnSysGetPointerFromHandleServerMode@4 PROC NEAR

; 4052 : {

	push	ebp
	mov	ebp, esp

; 4053 :    return( pHandle );

	mov	eax, DWORD PTR _pHandle$[ebp]

; 4054 : }

	pop	ebp
	ret	4
_fnSysGetPointerFromHandleServerMode@4 ENDP
_TEXT	ENDS
PUBLIC	_fnSysGetPointerFromHandleShared@4
PUBLIC	??_C@_0DG@KGPA@Invalid?5pointer?5handle?5?$CIget?$CJ?5?3?5h@ ; `string'
PUBLIC	??_C@_0DO@NGGI@Invalid?5pointer?5handle?5?$CInull?$CJ?5at@ ; `string'
;	COMDAT ??_C@_0DG@KGPA@Invalid?5pointer?5handle?5?$CIget?$CJ?5?3?5h@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0DG@KGPA@Invalid?5pointer?5handle?5?$CIget?$CJ?5?3?5h@ DB 'Invalid '
	DB	'pointer handle (get) : hi-bit not set: 0x%08x', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DO@NGGI@Invalid?5pointer?5handle?5?$CInull?$CJ?5at@
_DATA	SEGMENT
??_C@_0DO@NGGI@Invalid?5pointer?5handle?5?$CInull?$CJ?5at@ DB 'Invalid po'
	DB	'inter handle (null) at Index: %x for pointer 0x%08x', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pHandle$ = 8
_k$ = -8
_lOffset$ = -4
_szMessage$61930 = -264
_szMessage$61936 = -520
_fnSysGetPointerFromHandleShared@4 PROC NEAR

; 4058 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 520				; 00000208H

; 4059 :    zBYTE  k;
; 4060 :    zLONG  lOffset;
; 4061 : 
; 4062 :    if ( pHandle == 0 )

	cmp	DWORD PTR _pHandle$[ebp], 0
	jne	SHORT $L61924

; 4063 :       return( 0 );

	xor	eax, eax
	jmp	$L61921
$L61924:

; 4064 : 
; 4065 :    // Following is for Instance handles.  Instance handles can be:
; 4066 :    // zero (no instance), one (unset cursor), or a valid handle.
; 4067 :    if ( pHandle == (zPVOID) 1 )

	cmp	DWORD PTR _pHandle$[ebp], 1
	jne	SHORT $L61926

; 4068 :       return( (zPVOID) 1 );

	mov	eax, 1
	jmp	$L61921
$L61926:

; 4069 : 
; 4070 : #ifdef DEBUG_PAGETABLE
; 4071 :    // Make sure that the highest bit is set.
; 4072 :    if ( ((zLONG) pHandle & 0x80000000) == 0 )

	mov	eax, DWORD PTR _pHandle$[ebp]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	jne	SHORT $L61929

; 4074 :       char szMessage[ 256 ];
; 4075 : 
; 4076 :       zsprintf( szMessage, "Invalid pointer handle (get) : hi-bit not set: 0x%08x", pHandle );

	mov	ecx, DWORD PTR _pHandle$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DG@KGPA@Invalid?5pointer?5handle?5?$CIget?$CJ?5?3?5h@ ; `string'
	lea	edx, DWORD PTR _szMessage$61930[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 4077 :       TraceLineS( szMessage, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	eax, DWORD PTR _szMessage$61930[ebp]
	push	eax
	call	_TraceLineS@8

; 4078 :       if ( AnchorBlock->bDebugLeak == FALSE )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1495]
	shr	edx, 3
	and	edx, 1
	test	edx, edx
	jne	SHORT $L61932

; 4080 :          MessageBox( GetActiveWindow( ), szMessage,
; 4081 :                      szlOE_SystemError, MB_ICONSTOP | MB_OK | MB_TASKMODAL );

	push	8208					; 00002010H
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	lea	ecx, DWORD PTR _szMessage$61930[ebp]
	push	ecx
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
$L61932:

; 4083 : #if 0
; 4084 :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );
; 4085 :       if ( szMessage[ 0 ] == 'Y' )
; 4086 :       {
; 4087 :          k = 0;
; 4088 :          k /= k;
; 4089 :       }
; 4090 : #endif
; 4091 :       return( 0 );

	xor	eax, eax
	jmp	$L61921
$L61929:

; 4093 : #endif
; 4094 : 
; 4095 :    // Get high order byte from handle.
; 4096 :    k = (zBYTE) ((zULONG) pHandle >> 24);

	mov	edx, DWORD PTR _pHandle$[ebp]
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _k$[ebp], dl

; 4097 : 
; 4098 :    if ( g_ZeidonPageTable[ k ] == 0 )

	mov	eax, DWORD PTR _k$[ebp]
	and	eax, 255				; 000000ffH
	cmp	DWORD PTR _g_ZeidonPageTable[eax*4], 0
	jne	SHORT $L61935

; 4100 :       char szMessage[ 256 ];  // dks 2006.09.18 error while cleaning up client OE (k=134)
; 4101 : 
; 4102 :       zsprintf( szMessage, "Invalid pointer handle (null) at Index: %x for pointer 0x%08x", k, pHandle );

	mov	ecx, DWORD PTR _pHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	and	edx, 255				; 000000ffH
	push	edx
	push	OFFSET FLAT:??_C@_0DO@NGGI@Invalid?5pointer?5handle?5?$CInull?$CJ?5at@ ; `string'
	lea	eax, DWORD PTR _szMessage$61936[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4103 :       TraceLineS( szMessage, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szMessage$61936[ebp]
	push	ecx
	call	_TraceLineS@8

; 4104 :       if ( AnchorBlock->bDebugLeak == FALSE )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1495]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	jne	SHORT $L61938

; 4106 :          MessageBox( GetActiveWindow( ), szMessage,
; 4107 :                      szlOE_SystemError, MB_ICONSTOP | MB_OK | MB_TASKMODAL );

	push	8208					; 00002010H
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	lea	edx, DWORD PTR _szMessage$61936[ebp]
	push	edx
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
$L61938:

; 4109 : #if 0
; 4110 :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );
; 4111 :       if ( szMessage[ 0 ] == 'Y' )
; 4112 :       {
; 4113 :          k /= k - k;
; 4114 :       }
; 4115 : #endif
; 4116 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $L61921
$L61935:

; 4118 : 
; 4119 :    // Get page offset from 3 low-order bytes.
; 4120 :    lOffset = (zLONG) pHandle & 0x00FFFFFF;

	mov	eax, DWORD PTR _pHandle$[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _lOffset$[ebp], eax

; 4121 : 
; 4122 :    // Get pointer value by adding offset to page table address.
; 4123 :    pHandle = (zPVOID) ((zLONG) g_ZeidonPageTable[ k ] + lOffset);

	mov	ecx, DWORD PTR _k$[ebp]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _g_ZeidonPageTable[ecx*4]
	add	edx, DWORD PTR _lOffset$[ebp]
	mov	DWORD PTR _pHandle$[ebp], edx

; 4124 :    return( pHandle );

	mov	eax, DWORD PTR _pHandle$[ebp]
$L61921:

; 4125 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnSysGetPointerFromHandleShared@4 ENDP
_TEXT	ENDS
PUBLIC	_SysGetPointerFromHandle@4
_TEXT	SEGMENT
_pHandle$ = 8
_SysGetPointerFromHandle@4 PROC NEAR

; 4129 : {

	push	ebp
	mov	ebp, esp

; 4130 :    return( (*g_pfnGetPtr)( pHandle ) );

	mov	eax, DWORD PTR _pHandle$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr

; 4131 : }

	pop	ebp
	ret	4
_SysGetPointerFromHandle@4 ENDP
_TEXT	ENDS
PUBLIC	_fnSysGetHandleFromPointerServerMode@4
_TEXT	SEGMENT
_pPointer$ = 8
_fnSysGetHandleFromPointerServerMode@4 PROC NEAR

; 4135 : {

	push	ebp
	mov	ebp, esp

; 4136 :    return( pPointer );

	mov	eax, DWORD PTR _pPointer$[ebp]

; 4137 : }

	pop	ebp
	ret	4
_fnSysGetHandleFromPointerServerMode@4 ENDP
_TEXT	ENDS
PUBLIC	_fnSysGetHandleFromPointerShared@4
PUBLIC	??_C@_0BO@IFBI@Invalid?5pointer?3?5hi?9bit?5set?$CB?$CB?$AA@ ; `string'
;	COMDAT ??_C@_0BO@IFBI@Invalid?5pointer?3?5hi?9bit?5set?$CB?$CB?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BO@IFBI@Invalid?5pointer?3?5hi?9bit?5set?$CB?$CB?$AA@ DB 'Invalid '
	DB	'pointer: hi-bit set!!', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pPointer$ = 8
_lpFreespace$ = -4
_fnSysGetHandleFromPointerShared@4 PROC NEAR

; 4141 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4142 :    LPFREESPACE lpFreespace;
; 4143 : 
; 4144 :    if ( pPointer == 0 )

	cmp	DWORD PTR _pPointer$[ebp], 0
	jne	SHORT $L61954

; 4145 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $L61952
$L61954:

; 4146 : 
; 4147 : #ifdef DEBUG_PAGETABLE
; 4148 :    // Make sure that the highest bit is NOT set (this means it's a handle).
; 4149 :    if ( ((zLONG) pPointer & 0x80000000) != 0 )

	mov	eax, DWORD PTR _pPointer$[ebp]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	je	SHORT $L61956

; 4151 :    // char szMessage[ 16 ];
; 4152 :    // int k = 0;
; 4153 :       MessageBox( GetActiveWindow( ), "Invalid pointer: hi-bit set!!",
; 4154 :                   szlOE_SystemError, MB_ICONSTOP | MB_OK | MB_TASKMODAL );

	push	8208					; 00002010H
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	OFFSET FLAT:??_C@_0BO@IFBI@Invalid?5pointer?3?5hi?9bit?5set?$CB?$CB?$AA@ ; `string'
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16

; 4155 : #if 0
; 4156 :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );
; 4157 :       if ( szMessage[ 0 ] == 'Y' )
; 4158 :          k /= k;
; 4159 : #endif
; 4160 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $L61952
$L61956:

; 4162 : #endif
; 4163 : 
; 4164 :    lpFreespace = (LPFREESPACE) pPointer;

	mov	edx, DWORD PTR _pPointer$[ebp]
	mov	DWORD PTR _lpFreespace$[ebp], edx

; 4165 :    lpFreespace--;

	mov	eax, DWORD PTR _lpFreespace$[ebp]
	sub	eax, 18					; 00000012H
	mov	DWORD PTR _lpFreespace$[ebp], eax

; 4166 : 
; 4167 :    return( lpFreespace->hFreespace );

	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	mov	eax, DWORD PTR [ecx+10]
$L61952:

; 4168 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnSysGetHandleFromPointerShared@4 ENDP
_TEXT	ENDS
PUBLIC	_SysGetHandleFromPointer@4
_TEXT	SEGMENT
_pPointer$ = 8
_SysGetHandleFromPointer@4 PROC NEAR

; 4172 : {

	push	ebp
	mov	ebp, esp

; 4173 :    return( (*g_pfnGetHndl)( pPointer ) );

	mov	eax, DWORD PTR _pPointer$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl

; 4174 : }

	pop	ebp
	ret	4
_SysGetHandleFromPointer@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@EPII@Invalid?5pointer?3?5hi?9bit?5not?5set?$CB@ ; `string'
PUBLIC	_fnSysCreateHandle@8
;	COMDAT ??_C@_0CC@EPII@Invalid?5pointer?3?5hi?9bit?5not?5set?$CB@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CC@EPII@Invalid?5pointer?3?5hi?9bit?5not?5set?$CB@ DB 'Invalid poi'
	DB	'nter: hi-bit not set!!', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpDataHeader$ = 8
_pPointer$ = 12
_pbBase$ = -8
_lOffset$ = -4
_fnSysCreateHandle@8 PROC NEAR

; 4179 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4180 :    zPBYTE pbBase;
; 4181 :    zLONG  lOffset;
; 4182 : 
; 4183 :    // For Win95 apps we just return the pointer back.
; 4184 :    if ( g_bWin95 )

	xor	eax, eax
	mov	al, BYTE PTR _g_bWin95
	test	eax, eax
	je	SHORT $L61969

; 4185 :       return( pPointer );

	mov	eax, DWORD PTR _pPointer$[ebp]
	jmp	SHORT $L61966
$L61969:

; 4186 : 
; 4187 : #ifdef DEBUG_PAGETABLE
; 4188 :    // Make sure that the highest bit is NOT set (this means it's a handle).
; 4189 :    if ( ((zLONG) pPointer & 0x80000000) != 0 )

	mov	ecx, DWORD PTR _pPointer$[ebp]
	and	ecx, -2147483648			; 80000000H
	test	ecx, ecx
	je	SHORT $L61971

; 4191 :    // char szMessage[ 16 ];
; 4192 :    // int k = 0;
; 4193 :       MessageBox( GetActiveWindow( ), "Invalid pointer: hi-bit not set!!",
; 4194 :                   szlOE_SystemError, MB_ICONSTOP | MB_OK | MB_TASKMODAL );

	push	8208					; 00002010H
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	OFFSET FLAT:??_C@_0CC@EPII@Invalid?5pointer?3?5hi?9bit?5not?5set?$CB@ ; `string'
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16

; 4195 : #if 0
; 4196 :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );
; 4197 :       if ( szMessage[ 0 ] == 'Y' )
; 4198 :          k /= k;
; 4199 : #endif
; 4200 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $L61966
$L61971:

; 4202 : #endif
; 4203 : 
; 4204 :    // Get base address of dataspace.
; 4205 :    pbBase = zGETPTR( (zPVOID) lpDataHeader->hDataHandle );

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pbBase$[ebp], eax

; 4206 : 
; 4207 :    // Compute the offset of the pointer from the base address.
; 4208 :    lOffset = (zLONG) pPointer - (zLONG) pbBase;

	mov	edx, DWORD PTR _pPointer$[ebp]
	sub	edx, DWORD PTR _pbBase$[ebp]
	mov	DWORD PTR _lOffset$[ebp], edx

; 4209 : 
; 4210 :    // New handle consists of the handle of the dataspace (first byte of lHandle)
; 4211 :    // and the offset in the last three bytes.
; 4212 :    pPointer = (zPVOID) (lpDataHeader->hDataHandle | lOffset);

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, DWORD PTR _lOffset$[ebp]
	mov	DWORD PTR _pPointer$[ebp], ecx

; 4213 :    return( pPointer );

	mov	eax, DWORD PTR _pPointer$[ebp]
$L61966:

; 4214 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnSysCreateHandle@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@NNIF@Out?5of?5memory?5pages?$CB?$AA@	; `string'
PUBLIC	??_C@_0EC@HOEL@fnMapFile?5Page?5Table?5conflict?5at@ ; `string'
EXTRN	__imp__CreateFileMappingA@24:NEAR
;	COMDAT ??_C@_0BF@NNIF@Out?5of?5memory?5pages?$CB?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BF@NNIF@Out?5of?5memory?5pages?$CB?$AA@ DB 'Out of memory pages!', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EC@HOEL@fnMapFile?5Page?5Table?5conflict?5at@
_DATA	SEGMENT
??_C@_0EC@HOEL@fnMapFile?5Page?5Table?5conflict?5at@ DB 'fnMapFile Page T'
	DB	'able conflict at Index: %x   0x%08x   Process: %d', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_phHandle$ = 8
_lBytes$ = 12
_plPageTableIndex$ = 16
_cpcShareName$ = 20
_pv$ = -4
_k$61989 = -12
_lStartIdx$61990 = -8
_fnMapFile@16 PROC NEAR

; 4221 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 4222 :    zPVOID pv;
; 4223 : 
; 4224 :    // If the handle is zero then we need to create one.
; 4225 :    if ( *phHandle == 0 )

	mov	eax, DWORD PTR _phHandle$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$L61988

; 4227 :       zLONG  k;
; 4228 :       zLONG  lStartIdx;
; 4229 : 
; 4230 :       // Start off by finding an empty (or open) page table entry.
; 4231 : 
; 4232 :       if ( g_bWin95 )

	xor	ecx, ecx
	mov	cl, BYTE PTR _g_bWin95
	test	ecx, ecx
	je	SHORT $L61991

; 4233 :          lStartIdx = 1;

	mov	DWORD PTR _lStartIdx$61990[ebp], 1

; 4234 :       else

	jmp	SHORT $L61992
$L61991:

; 4236 : #ifdef DEBUG_PAGETABLE
; 4237 :          // When we are debugging we start with page 128 so that the high bit
; 4238 :          // in the resulting handle will always be set.
; 4239 :          lStartIdx = 128;

	mov	DWORD PTR _lStartIdx$61990[ebp], 128	; 00000080H
$L61992:

; 4246 : 
; 4247 :       for ( k = lStartIdx; k < zSHR_MAX_PAGES; k++ )

	mov	edx, DWORD PTR _lStartIdx$61990[ebp]
	mov	DWORD PTR _k$61989[ebp], edx
	jmp	SHORT $L61993
$L61994:
	mov	eax, DWORD PTR _k$61989[ebp]
	add	eax, 1
	mov	DWORD PTR _k$61989[ebp], eax
$L61993:
	cmp	DWORD PTR _k$61989[ebp], 256		; 00000100H
	jge	SHORT $L61995

; 4249 :          // If we find an empty page break loop.
; 4250 :          if ( g_ZeidonPageTable[ k ] == 0 )

	mov	ecx, DWORD PTR _k$61989[ebp]
	cmp	DWORD PTR _g_ZeidonPageTable[ecx*4], 0
	jne	SHORT $L61996

; 4251 :             break;

	jmp	SHORT $L61995
$L61996:

; 4252 :       }

	jmp	SHORT $L61994
$L61995:

; 4253 : 
; 4254 :       if ( k >= zSHR_MAX_PAGES )

	cmp	DWORD PTR _k$61989[ebp], 256		; 00000100H
	jl	SHORT $L61997

; 4256 :          SysMessageBox( 0, szlOE_SystemError, "Out of memory pages!", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0BF@NNIF@Out?5of?5memory?5pages?$CB?$AA@ ; `string'
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 4257 :          return( 0 );

	xor	eax, eax
	jmp	$L61986
$L61997:

; 4259 : 
; 4260 :       if ( g_bWin95 )

	xor	eax, eax
	mov	al, BYTE PTR _g_bWin95
	test	eax, eax
	je	SHORT $L61999

; 4262 :          // Take into account that we have to store the index of the currently
; 4263 :          // allocated block of memory in the first few bytes of the memory.
; 4264 :          lBytes += sizeof( zLONG );

	mov	ecx, DWORD PTR _lBytes$[ebp]
	add	ecx, 4
	mov	DWORD PTR _lBytes$[ebp], ecx
$L61999:

; 4266 : 
; 4267 :       *plPageTableIndex = k;

	mov	edx, DWORD PTR _plPageTableIndex$[ebp]
	mov	eax, DWORD PTR _k$61989[ebp]
	mov	DWORD PTR [edx], eax

; 4268 : 
; 4269 :    // TraceLine( "fnMapFile Page Table mapped at Index: %x   0x%08x   Process: %d",
; 4270 :    //            *plPageTableIndex, g_ZeidonPageTable[ *plPageTableIndex ], SysGetProcessID( 0 ) );
; 4271 : 
; 4272 :       *phHandle = CreateFileMapping( (HANDLE) -1, NULL, PAGE_READWRITE,
; 4273 :                                      0, lBytes, cpcShareName );

	mov	ecx, DWORD PTR _cpcShareName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lBytes$[ebp]
	push	edx
	push	0
	push	4
	push	0
	push	-1
	call	DWORD PTR __imp__CreateFileMappingA@24
	mov	ecx, DWORD PTR _phHandle$[ebp]
	mov	DWORD PTR [ecx], eax

; 4274 :       if ( *phHandle == 0 )

	mov	edx, DWORD PTR _phHandle$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L62003

; 4275 :          return( 0 );

	xor	eax, eax
	jmp	$L61986
$L62003:

; 4277 :    else

	jmp	SHORT $L62005
$L61988:

; 4279 :       if ( g_ZeidonPageTable[ *plPageTableIndex ] )

	mov	eax, DWORD PTR _plPageTableIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR _g_ZeidonPageTable[ecx*4], 0
	je	SHORT $L62005

; 4281 :          TraceLine( "fnMapFile Page Table conflict at Index: %x   0x%08x   Process: %d",
; 4282 :                     *plPageTableIndex, g_ZeidonPageTable[ *plPageTableIndex ], SysGetProcessID( 0 ) );

	push	0
	call	_SysGetProcessID@4
	push	eax
	mov	edx, DWORD PTR _plPageTableIndex$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _g_ZeidonPageTable[eax*4]
	push	ecx
	mov	edx, DWORD PTR _plPageTableIndex$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_0EC@HOEL@fnMapFile?5Page?5Table?5conflict?5at@ ; `string'
	call	_TraceLine
	add	esp, 16					; 00000010H

; 4283 :       // SysMessageBox( 0, szlOE_SystemError, "Page Table conflict!", -1 );
; 4284 :          return( 0 );

	xor	eax, eax
	jmp	$L61986
$L62005:

; 4287 : 
; 4288 : #ifdef SHARED_MEM_TRACE
; 4289 :    fnTraceSharedMemory( "fnMapFile" );
; 4290 : #endif
; 4291 :    pv = MapViewOfFile( *phHandle, FILE_MAP_WRITE, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	2
	mov	ecx, DWORD PTR _phHandle$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__MapViewOfFile@20
	mov	DWORD PTR _pv$[ebp], eax

; 4292 : 
; 4293 :    g_ZeidonPageTable[ *plPageTableIndex ] = pv;

	mov	eax, DWORD PTR _plPageTableIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[ecx*4], edx

; 4294 :    g_FileMappingHandles[ *plPageTableIndex ] = (zLONG) *phHandle;

	mov	eax, DWORD PTR _plPageTableIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _phHandle$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _g_FileMappingHandles[ecx*4], eax

; 4295 : 
; 4296 : #ifdef SHARED_MEM_TRACE
; 4297 :    TraceLine( "fnMapFile Page Table mapped at Index: %x   0x%08x   Process: %d",
; 4298 :               *plPageTableIndex, g_ZeidonPageTable[ *plPageTableIndex ], SysGetProcessID( 0 ) );
; 4299 : #endif
; 4300 : 
; 4301 :    // Create a handle.
; 4302 :    if ( g_bWin95 )

	xor	ecx, ecx
	mov	cl, BYTE PTR _g_bWin95
	test	ecx, ecx
	je	SHORT $L62008

; 4304 :       // Store the index of the shared memory in the first couple of bytes of
; 4305 :       // the shared memory.
; 4306 :       *((zPLONG) pv)++ = *plPageTableIndex;

	mov	edx, DWORD PTR _pv$[ebp]
	mov	eax, DWORD PTR _plPageTableIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR _pv$[ebp]
	add	edx, 4
	mov	DWORD PTR _pv$[ebp], edx

; 4307 :       *phHandle = (HANDLE) pv;

	mov	eax, DWORD PTR _phHandle$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [eax], ecx

; 4309 :    else

	jmp	SHORT $L62014
$L62008:

; 4311 :       if ( g_bWin95 )

	xor	edx, edx
	mov	dl, BYTE PTR _g_bWin95
	test	edx, edx
	je	SHORT $L62012

; 4312 :          *phHandle = (HANDLE) g_ZeidonPageTable[ *plPageTableIndex ];

	mov	eax, DWORD PTR _plPageTableIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _phHandle$[ebp]
	mov	eax, DWORD PTR _g_ZeidonPageTable[ecx*4]
	mov	DWORD PTR [edx], eax

; 4313 :       else

	jmp	SHORT $L62014
$L62012:

; 4314 :          *phHandle = (HANDLE) ((zULONG) *plPageTableIndex << 24);

	mov	ecx, DWORD PTR _plPageTableIndex$[ebp]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 24					; 00000018H
	mov	eax, DWORD PTR _phHandle$[ebp]
	mov	DWORD PTR [eax], edx
$L62014:

; 4316 : 
; 4317 :    return( pv );

	mov	eax, DWORD PTR _pv$[ebp]
$L61986:

; 4318 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnMapFile@16 ENDP
_TEXT	ENDS
EXTRN	__imp__GetEnvironmentVariableA@12:NEAR
_TEXT	SEGMENT
_pchReturnEnv$ = 8
_cpcEnvName$ = 12
_nMaxLth$ = 16
_SysGetEnvVar@12 PROC NEAR

; 4345 : {

	push	ebp
	mov	ebp, esp

; 4346 :    *pchReturnEnv = 0;

	mov	eax, DWORD PTR _pchReturnEnv$[ebp]
	mov	BYTE PTR [eax], 0

; 4347 : 
; 4348 :    if ( GetEnvironmentVariable( cpcEnvName, pchReturnEnv, nMaxLth ) == 0 )

	mov	ecx, DWORD PTR _nMaxLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnEnv$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEnvName$[ebp]
	push	eax
	call	DWORD PTR __imp__GetEnvironmentVariableA@12
	test	eax, eax
	jne	SHORT $L62024

; 4349 :       return( 1 );

	mov	ax, 1
	jmp	SHORT $L62025
$L62024:

; 4350 :    else
; 4351 :       return( 0 );

	xor	ax, ax
$L62025:

; 4352 : }

	pop	ebp
	ret	12					; 0000000cH
_SysGetEnvVar@12 ENDP
_TEXT	ENDS
PUBLIC	_SysWait@4
EXTRN	__imp__Sleep@4:NEAR
_TEXT	SEGMENT
_uMilliseconds$ = 8
_SysWait@4 PROC NEAR

; 4367 : {

	push	ebp
	mov	ebp, esp

; 4368 :    Sleep( (DWORD) uMilliseconds );

	mov	eax, DWORD PTR _uMilliseconds$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	call	DWORD PTR __imp__Sleep@4

; 4369 : }

	pop	ebp
	ret	4
_SysWait@4 ENDP
_TEXT	ENDS
PUBLIC	_SysMessageList@4
PUBLIC	??_C@_0L@OCNM@Diagnostic?$AA@			; `string'
PUBLIC	??_C@_07FGLN@?$FLDebug?$FN?$AA@			; `string'
PUBLIC	_SysDiagnosticMessage@16
;	COMDAT ??_C@_0L@OCNM@Diagnostic?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0L@OCNM@Diagnostic?$AA@ DB 'Diagnostic', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FGLN@?$FLDebug?$FN?$AA@
_DATA	SEGMENT
??_C@_07FGLN@?$FLDebug?$FN?$AA@ DB '[Debug]', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTaskView$ = 8
_cpcTitle$ = 12
_cpcMessage$ = 16
_nBeep$ = 20
_szDiagnostic$ = -4
_SysDiagnosticMessage@16 PROC NEAR

; 4390 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4391 :    char szDiagnostic[ 2 ];
; 4392 : 
; 4393 :    SysReadZeidonIni( -1, "[Debug]", "Diagnostic", szDiagnostic );

	lea	eax, DWORD PTR _szDiagnostic$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@OCNM@Diagnostic?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_07FGLN@?$FLDebug?$FN?$AA@ ; `string'
	push	-1
	call	_SysReadZeidonIni@16

; 4394 :    if ( szDiagnostic[ 0 ] != 'N' && szDiagnostic[ 0 ] != 'n' )

	movsx	ecx, BYTE PTR _szDiagnostic$[ebp]
	cmp	ecx, 78					; 0000004eH
	je	SHORT $L62042
	movsx	edx, BYTE PTR _szDiagnostic$[ebp]
	cmp	edx, 110				; 0000006eH
	je	SHORT $L62042

; 4395 :       return( SysMessageBox( lpTaskView, cpcTitle, cpcMessage, nBeep ) );

	mov	eax, DWORD PTR _nBeep$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcTitle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysMessageBox@16
	jmp	SHORT $L62038
$L62042:

; 4396 : 
; 4397 :    SysMessageList( cpcMessage );

	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	push	ecx
	call	_SysMessageList@4

; 4398 :    return( 0 );

	xor	eax, eax
$L62038:

; 4399 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysDiagnosticMessage@16 ENDP
_TEXT	ENDS
PUBLIC	_fnSysWriteLine@16
PUBLIC	??_C@_0M@NKGM@ServerDebug?$AA@			; `string'
PUBLIC	??_C@_0DM@OLK@Message?5Handler?5Error?5opening?5lo@ ; `string'
;	COMDAT ??_C@_0M@NKGM@ServerDebug?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0M@NKGM@ServerDebug?$AA@ DB 'ServerDebug', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DM@OLK@Message?5Handler?5Error?5opening?5lo@
_DATA	SEGMENT
??_C@_0DM@OLK@Message?5Handler?5Error?5opening?5lo@ DB 'Message Handler E'
	DB	'rror opening log file (%s) for message: %s', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_cpcTitle$ = 12
_cpcMessage$ = 16
_nBeep$ = 20
_uRC$ = -4
_sz$62061 = -260
_szLogFileName$62068 = -520
_hLogFile$62069 = -264
_fnSysMessageBox@16 PROC NEAR

; 4425 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 520				; 00000208H

; 4426 :    unsigned uRC;
; 4427 :    static zCHAR cShowPopup = ' ';
; 4428 : 
; 4429 :    // If we are connected to OE, print in message list.
; 4430 :    if ( AnchorBlock && AnchorBlock->lOE_hListWnd )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $L62055
	mov	eax, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [eax+98], 0
	je	SHORT $L62055

; 4431 :       SysMessageList( cpcMessage );

	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	push	ecx
	call	_SysMessageList@4
$L62055:

; 4432 : 
; 4433 :    // If we are a server app then we don't wan't to actually pop up a message.
; 4434 :    if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	$L62074

; 4436 :       if ( cShowPopup == ' ' )

	movsx	edx, BYTE PTR _?cShowPopup@?1??fnSysMessageBox@@9@9
	cmp	edx, 32					; 00000020H
	jne	$L62073

; 4438 :          if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L62058

; 4439 :             lpTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$L62058:

; 4440 : 
; 4441 :       // if ( lpTask && lpTask->bServer )  don't care if server or not
; 4442 :          if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$L62060

; 4444 :             zCHAR sz[ zMAX_FILENAME_LTH ];
; 4445 : 
; 4446 :             // Check a flag in the Zeidon INI to see if we should pop up the msg.
; 4447 :             SysReadZeidonIni( -1, "[Debug]", "ServerDebug", sz );

	lea	edx, DWORD PTR _sz$62061[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0M@NKGM@ServerDebug?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_07FGLN@?$FLDebug?$FN?$AA@ ; `string'
	push	-1
	call	_SysReadZeidonIni@16

; 4448 :             if ( *sz == 0 ||
; 4449 :                  ((*sz && *(sz + 1) == 0) &&
; 4450 :                   (*sz == 'Y' || *sz == 'y' || *sz == '1')) )

	movsx	eax, BYTE PTR _sz$62061[ebp]
	test	eax, eax
	je	SHORT $L62065
	movsx	ecx, BYTE PTR _sz$62061[ebp]
	test	ecx, ecx
	je	SHORT $L62063
	movsx	edx, BYTE PTR _sz$62061[ebp+1]
	test	edx, edx
	jne	SHORT $L62063
	movsx	eax, BYTE PTR _sz$62061[ebp]
	cmp	eax, 89					; 00000059H
	je	SHORT $L62065
	movsx	ecx, BYTE PTR _sz$62061[ebp]
	cmp	ecx, 121				; 00000079H
	je	SHORT $L62065
	movsx	edx, BYTE PTR _sz$62061[ebp]
	cmp	edx, 49					; 00000031H
	jne	SHORT $L62063
$L62065:

; 4452 :                cShowPopup = 'Y';

	mov	BYTE PTR _?cShowPopup@?1??fnSysMessageBox@@9@9, 89 ; 00000059H

; 4454 :             else

	jmp	$L62071
$L62063:

; 4456 :                cShowPopup = 'N';

	mov	BYTE PTR _?cShowPopup@?1??fnSysMessageBox@@9@9, 78 ; 0000004eH

; 4457 :                if ( *sz && *(sz + 1) )  // assume log file name

	movsx	eax, BYTE PTR _sz$62061[ebp]
	test	eax, eax
	je	$L62071
	movsx	ecx, BYTE PTR _sz$62061[ebp+1]
	test	ecx, ecx
	je	SHORT $L62071

; 4459 :                   zCHAR szLogFileName[ zMAX_FILENAME_LTH ];
; 4460 :                   zLONG hLogFile;
; 4461 : 
; 4462 :                   SysConvertEnvironmentString( szLogFileName, sz );

	lea	edx, DWORD PTR _sz$62061[ebp]
	push	edx
	lea	eax, DWORD PTR _szLogFileName$62068[ebp]
	push	eax
	call	_SysConvertEnvironmentString@8

; 4463 :                   if ( (hLogFile = fnSysOpenFile( lpTask, szLogFileName,
; 4464 :                                                   COREFILE_APPEND )) != -1 )

	push	448					; 000001c0H
	lea	ecx, DWORD PTR _szLogFileName$62068[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hLogFile$62069[ebp], eax
	cmp	DWORD PTR _hLogFile$62069[ebp], -1
	je	SHORT $L62070

; 4466 :                      fnSysWriteLine( lpTask, hLogFile, 0, cpcMessage );

	mov	eax, DWORD PTR _cpcMessage$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _hLogFile$62069[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 4467 :                      fnSysCloseFile( lpTask, hLogFile, 0 );

	push	0
	mov	eax, DWORD PTR _hLogFile$62069[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysCloseFile@12

; 4469 :                   else

	jmp	SHORT $L62071
$L62070:

; 4471 :                      TraceLine( "Message Handler Error opening log file (%s) for message: %s",
; 4472 :                                 szLogFileName, cpcMessage );

	mov	edx, DWORD PTR _cpcMessage$[ebp]
	push	edx
	lea	eax, DWORD PTR _szLogFileName$62068[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0DM@OLK@Message?5Handler?5Error?5opening?5lo@ ; `string'
	call	_TraceLine
	add	esp, 12					; 0000000cH
$L62071:

; 4477 :          else

	jmp	SHORT $L62073
$L62060:

; 4478 :             cShowPopup = 'Y';

	mov	BYTE PTR _?cShowPopup@?1??fnSysMessageBox@@9@9, 89 ; 00000059H
$L62073:

; 4480 : 
; 4481 :       if ( cShowPopup == 'N' )

	movsx	ecx, BYTE PTR _?cShowPopup@?1??fnSysMessageBox@@9@9
	cmp	ecx, 78					; 0000004eH
	jne	SHORT $L62074

; 4482 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $L62051
$L62074:

; 4484 : 
; 4485 : // if ( nBeep )                   the beep is generated by MB_ICONSTOP in the
; 4486 : //    MessageBeep( MB_ICONSTOP ); call to MessageBox below ... dks 2005.04.28
; 4487 : 
; 4488 :    if ( nBeep <= 1 || nBeep > 6 )

	cmp	DWORD PTR _nBeep$[ebp], 1
	jle	SHORT $L62076
	cmp	DWORD PTR _nBeep$[ebp], 6
	jle	SHORT $L62075
$L62076:

; 4489 :       nBeep = 0;

	mov	DWORD PTR _nBeep$[ebp], 0

; 4490 :    else

	jmp	SHORT $L62078
$L62075:

; 4491 :    if ( nBeep == 6 )

	cmp	DWORD PTR _nBeep$[ebp], 6
	jne	SHORT $L62078

; 4492 :       nBeep = 1;

	mov	DWORD PTR _nBeep$[ebp], 1
$L62078:

; 4493 : 
; 4494 :    uRC = MessageBox( GetActiveWindow( ), cpcMessage, cpcTitle,
; 4495 :                      MB_ICONSTOP | MB_OK | MB_TASKMODAL | nBeep );

	mov	edx, DWORD PTR _nBeep$[ebp]
	or	edx, 8208				; 00002010H
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
	mov	DWORD PTR _uRC$[ebp], eax

; 4496 :    return( uRC );

	mov	eax, DWORD PTR _uRC$[ebp]
$L62051:

; 4497 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysMessageBox@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@BDGH@WebUserErrorMessages?$AA@	; `string'
PUBLIC	??_C@_0CE@OFLB@SysMessageBox?5Title?3?5?$CFs?5?5?5Error?3@ ; `string'
;	COMDAT ??_C@_0BF@BDGH@WebUserErrorMessages?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BF@BDGH@WebUserErrorMessages?$AA@ DB 'WebUserErrorMessages', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CE@OFLB@SysMessageBox?5Title?3?5?$CFs?5?5?5Error?3@
_DATA	SEGMENT
??_C@_0CE@OFLB@SysMessageBox?5Title?3?5?$CFs?5?5?5Error?3@ DB 'SysMessage'
	DB	'Box Title: %s   Error: %s', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTaskView$ = 8
_cpcTitle$ = 12
_cpcMessage$ = 16
_nBeep$ = 20
_sz$ = -12
_lpTask$62096 = -16
_SysMessageBox@16 PROC NEAR

; 4502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 4503 :    zCHAR  sz[ 10 ];
; 4504 : 
; 4505 :    SysReadZeidonIni( -1, "[ObjectEngine]", "WebUserErrorMessages", sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@BDGH@WebUserErrorMessages?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@CGC@?$FLObjectEngine?$FN?$AA@ ; `string'
	push	-1
	call	_SysReadZeidonIni@16

; 4506 :    if ( sz[ 0 ] == 'Y' || sz[ 0 ] == 'y' )

	movsx	ecx, BYTE PTR _sz$[ebp]
	cmp	ecx, 89					; 00000059H
	je	SHORT $L62091
	movsx	edx, BYTE PTR _sz$[ebp]
	cmp	edx, 121				; 00000079H
	jne	SHORT $L62090
$L62091:

; 4508 :       TraceLine( "SysMessageBox Title: %s   Error: %s",
; 4509 :                  cpcTitle, cpcMessage );

	mov	eax, DWORD PTR _cpcMessage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTitle$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CE@OFLB@SysMessageBox?5Title?3?5?$CFs?5?5?5Error?3@ ; `string'
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 4510 :       return( -1 );

	or	eax, -1
	jmp	SHORT $L62095
$L62090:

; 4514 :       if ( nBeep == -1 )  // no valid tasks/view exist

	cmp	DWORD PTR _nBeep$[ebp], -1
	jne	SHORT $L62094

; 4516 :          MessageBox( GetActiveWindow( ), cpcMessage, cpcTitle,
; 4517 :                      MB_ICONSTOP | MB_OK | MB_TASKMODAL );

	push	8208					; 00002010H
	mov	edx, DWORD PTR _cpcTitle$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMessage$[ebp]
	push	eax
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16

; 4518 :          return( MB_OK );

	xor	eax, eax
	jmp	SHORT $L62095
$L62094:

; 4522 :          LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64840
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -20+[ebp], eax
	jmp	SHORT $L64841
$L64840:
	mov	DWORD PTR -20+[ebp], 0
$L64841:
	mov	eax, DWORD PTR -20+[ebp]
	mov	DWORD PTR _lpTask$62096[ebp], eax

; 4523 : 
; 4524 :          return( fnSysMessageBox( lpTask, cpcTitle, cpcMessage, nBeep ) );

	mov	ecx, DWORD PTR _nBeep$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcMessage$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$62096[ebp]
	push	ecx
	call	_fnSysMessageBox@16
$L62095:

; 4527 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysMessageBox@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FMCK@HH?3MI?3SS?4999?$AA@		; `string'
PUBLIC	??_C@_0BI@FAGA@YYYY?9MM?9DD?5HH?3MI?3SS?4999?$AA@ ; `string'
PUBLIC	??_C@_0P@EADK@?$CFs?5Task?$CI?$CFx?$CJ?5?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BF@FCLN@OE?5Trace?5Unavailable?$AA@	; `string'
EXTRN	_GetDefaultViewForActiveTask@0:NEAR
EXTRN	__chkstk:NEAR
EXTRN	_UfFormatDateTime@12:NEAR
EXTRN	__imp__strncat:NEAR
;	COMDAT ??_C@_0N@FMCK@HH?3MI?3SS?4999?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0N@FMCK@HH?3MI?3SS?4999?$AA@ DB 'HH:MI:SS.999', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@FAGA@YYYY?9MM?9DD?5HH?3MI?3SS?4999?$AA@
_DATA	SEGMENT
??_C@_0BI@FAGA@YYYY?9MM?9DD?5HH?3MI?3SS?4999?$AA@ DB 'YYYY-MM-DD HH:MI:SS'
	DB	'.999', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@EADK@?$CFs?5Task?$CI?$CFx?$CJ?5?3?5?$AA@
_DATA	SEGMENT
??_C@_0P@EADK@?$CFs?5Task?$CI?$CFx?$CJ?5?3?5?$AA@ DB '%s Task(%x) : ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@FCLN@OE?5Trace?5Unavailable?$AA@
_DATA	SEGMENT
??_C@_0BF@FCLN@OE?5Trace?5Unavailable?$AA@ DB 'OE Trace Unavailable', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_cpcMessage$ = 8
_nRC$ = -8
_pchMsg$ = -4
_g_szMessage$ = -65544
_szCurrentDateTime$62108 = -65564
_szFormattedDateTime$62109 = -65604
_hTask$62110 = -65572
_v$62111 = -65568
_cd$62125 = -65616
_SysMessageList@4 PROC NEAR

; 4548 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 65616				; 00010050H
	call	__chkstk

; 4549 :    int    nRC = zCALL_ERROR;  // Default rc to zCALL_ERROR

	mov	DWORD PTR _nRC$[ebp], -16		; fffffff0H

; 4550 :    zPCHAR pchMsg;
; 4551 : 
; 4552 : #define zTRACE_LTH  65535
; 4553 :    char g_szMessage[ zTRACE_LTH + 1 ];  // SysMessageList
; 4554 : 
; 4555 :    if ( AnchorBlock && AnchorBlock->bTraceCnt == FALSE )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $L62104
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	shr	ecx, 1
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L62104

; 4556 :       return( 0 );

	xor	eax, eax
	jmp	$L62100
$L62104:

; 4557 : 
; 4558 :    pchMsg = g_szMessage;

	lea	edx, DWORD PTR _g_szMessage$[ebp]
	mov	DWORD PTR _pchMsg$[ebp], edx

; 4559 :    *pchMsg = *cpcMessage;

	mov	eax, DWORD PTR _pchMsg$[ebp]
	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 4560 : 
; 4561 :    pchMsg[ 1 ] = 0;  // force null termination of message

	mov	eax, DWORD PTR _pchMsg$[ebp]
	mov	BYTE PTR [eax+1], 0

; 4562 :    if ( AnchorBlock && AnchorBlock->bShowTaskID )

	cmp	DWORD PTR _AnchorBlock, 0
	je	$L62105
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1495]
	and	edx, 1
	test	edx, edx
	je	$L62105

; 4564 :       static zCHAR szLastDateTime[ 20 ] = "";
; 4565 :       zCHAR szCurrentDateTime[ 20 ];
; 4566 :       zCHAR szFormattedDateTime[ 30 ];
; 4567 :       zLONG hTask = 0;

	mov	DWORD PTR _hTask$62110[ebp], 0

; 4568 :       zVIEW v = GetDefaultViewForActiveTask( );

	call	_GetDefaultViewForActiveTask@0
	mov	DWORD PTR _v$62111[ebp], eax

; 4569 : 
; 4570 :       if ( v )

	cmp	DWORD PTR _v$62111[ebp], 0
	je	SHORT $L62112

; 4571 :          hTask = (zLONG) v->hTask;

	mov	eax, DWORD PTR _v$62111[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hTask$62110[ebp], ecx
$L62112:

; 4572 : 
; 4573 :       if ( hTask == 0 )

	cmp	DWORD PTR _hTask$62110[ebp], 0
	jne	SHORT $L62114

; 4574 :          hTask = (zLONG) AnchorBlock->hMainTask;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	mov	DWORD PTR _hTask$62110[ebp], eax
$L62114:

; 4575 : 
; 4576 :       SysGetDateTime( szCurrentDateTime );

	lea	ecx, DWORD PTR _szCurrentDateTime$62108[ebp]
	push	ecx
	call	_SysGetDateTime@4

; 4577 :       if ( zstrncmp( szLastDateTime, szCurrentDateTime, 6 ) == 0 )

	push	6
	lea	edx, DWORD PTR _szCurrentDateTime$62108[ebp]
	push	edx
	push	OFFSET FLAT:_?szLastDateTime@?2??SysMessageList@@9@9
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L62116

; 4579 :          // Current date matches last date so we'll just display the time.
; 4580 :          UfFormatDateTime( szFormattedDateTime, szCurrentDateTime,
; 4581 :                            "HH:MI:SS.999" );

	push	OFFSET FLAT:??_C@_0N@FMCK@HH?3MI?3SS?4999?$AA@ ; `string'
	lea	eax, DWORD PTR _szCurrentDateTime$62108[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFormattedDateTime$62109[ebp]
	push	ecx
	call	_UfFormatDateTime@12

; 4583 :       else

	jmp	SHORT $L62118
$L62116:

; 4585 :          // Current date is different from the date of the last message.
; 4586 :          // Print the date and time.
; 4587 :          UfFormatDateTime( szFormattedDateTime, szCurrentDateTime,
; 4588 :                            "YYYY-MM-DD HH:MI:SS.999" );

	push	OFFSET FLAT:??_C@_0BI@FAGA@YYYY?9MM?9DD?5HH?3MI?3SS?4999?$AA@ ; `string'
	lea	edx, DWORD PTR _szCurrentDateTime$62108[ebp]
	push	edx
	lea	eax, DWORD PTR _szFormattedDateTime$62109[ebp]
	push	eax
	call	_UfFormatDateTime@12

; 4589 :          zstrcpy( szLastDateTime, szCurrentDateTime );

	lea	ecx, DWORD PTR _szCurrentDateTime$62108[ebp]
	push	ecx
	push	OFFSET FLAT:_?szLastDateTime@?2??SysMessageList@@9@9
	call	_strcpy
	add	esp, 8
$L62118:

; 4591 : 
; 4592 :       zsprintf( pchMsg, "%s Task(%x) : ", szFormattedDateTime, hTask );

	mov	edx, DWORD PTR _hTask$62110[ebp]
	push	edx
	lea	eax, DWORD PTR _szFormattedDateTime$62109[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0P@EADK@?$CFs?5Task?$CI?$CFx?$CJ?5?3?5?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchMsg$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4593 :       zstrncat( pchMsg, (zPCHAR) cpcMessage, zTRACE_LTH - zstrlen( pchMsg ) );

	mov	edx, DWORD PTR _pchMsg$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, 65535				; 0000ffffH
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _cpcMessage$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchMsg$[ebp]
	push	eax
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH

; 4595 :    else

	jmp	SHORT $L62123
$L62105:

; 4596 :    if ( *cpcMessage )

	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L62123

; 4598 :       zstrncat( pchMsg + 1, cpcMessage + 1, zTRACE_LTH - 1 );

	push	65534					; 0000fffeH
	mov	eax, DWORD PTR _cpcMessage$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pchMsg$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH
$L62123:

; 4600 : 
; 4601 :    if ( AnchorBlock && AnchorBlock->lOE_hListWnd )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $L62124
	mov	edx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [edx+98], 0
	je	SHORT $L62124

; 4603 :       COPYDATASTRUCT cd;
; 4604 : 
; 4605 :       cd.dwData = LB_ADDSTRING;

	mov	DWORD PTR _cd$62125[ebp], 384		; 00000180H

; 4606 :       cd.lpData = pchMsg;

	mov	eax, DWORD PTR _pchMsg$[ebp]
	mov	DWORD PTR _cd$62125[ebp+8], eax

; 4607 :       cd.cbData = zstrlen( (zPCHAR) cd.lpData ) + 1;

	mov	ecx, DWORD PTR _cd$62125[ebp+8]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _cd$62125[ebp+4], eax

; 4608 : 
; 4609 : #ifdef __MUTEX_DEBUG__
; 4610 :       // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 4611 :    // fnPrintMutexInfo( 's', zMUTEX_COUNT, __FILE__, __LINE__ ); recursion
; 4612 : #endif
; 4613 : 
; 4614 :       // Use WM_COPYDATA to send the message so we don't have any memory leaks.
; 4615 :       SendMessage( (HWND) AnchorBlock->lOE_hListWnd,
; 4616 :                    WM_COPYDATA, 0, (LPARAM) &cd );

	lea	edx, DWORD PTR _cd$62125[ebp]
	push	edx
	push	0
	push	74					; 0000004aH
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+98]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 4617 : 
; 4618 : #ifdef __MUTEX_DEBUG__
; 4619 :       // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 4620 :      // fnPrintMutexInfo( 'S', zMUTEX_COUNT, __FILE__, __LINE__ ); recursion
; 4621 : #endif
; 4622 : 
; 4623 :       nRC = 0;

	mov	DWORD PTR _nRC$[ebp], 0

; 4625 :    else

	jmp	SHORT $L62129
$L62124:

; 4626 :       SysMessageBox( 0, "OE Trace Unavailable", pchMsg, -1 );

	push	-1
	mov	edx, DWORD PTR _pchMsg$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BF@FCLN@OE?5Trace?5Unavailable?$AA@ ; `string'
	push	0
	call	_SysMessageBox@16
$L62129:

; 4627 : 
; 4628 :    return( nRC );

	mov	eax, DWORD PTR _nRC$[ebp]
$L62100:

; 4629 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysMessageList@4 ENDP
_TEXT	ENDS
PUBLIC	_SysSetUserID@12
PUBLIC	??_C@_0BD@FBHK@?$CIsy?$CJ?5Logon?5Userid?$DN?$AA@ ; `string'
;	COMDAT ??_C@_0BD@FBHK@?$CIsy?$CJ?5Logon?5Userid?$DN?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BD@FBHK@?$CIsy?$CJ?5Logon?5Userid?$DN?$AA@ DB '(sy) Logon Userid=', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_cpcUserID$ = 12
_cpcPassword$ = 16
_szMsg$ = -60
_SysSetUserID@12 PROC NEAR

; 4651 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 4652 :    char szMsg[ 60 ];
; 4653 : 
; 4654 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $L62139

; 4655 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L62137
$L62139:

; 4656 : 
; 4657 :    if ( lpTask && zGETHNDL( lpTask ) != AnchorBlock->hMainTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$L62141
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	eax, DWORD PTR [ecx+106]
	je	$L62141

; 4659 :       lpTask->hUserID = fnFreeDataspace( zGETPTR( lpTask->hUserID ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 4660 :       lpTask->hPassword = fnFreeDataspace( zGETPTR( lpTask->hPassword ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 4661 :       if ( cpcUserID[ 0 ] )

	mov	edx, DWORD PTR _cpcUserID$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L62144

; 4663 :          lpTask->hUserID =
; 4664 :           fnStoreStringInDataspace( (LPDATAHEADER) g_hAnchorBlock, cpcUserID );

	mov	ecx, DWORD PTR _cpcUserID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_hAnchorBlock
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+32], eax
$L62144:

; 4666 : 
; 4667 :       if ( cpcPassword[ 0 ] )

	mov	edx, DWORD PTR _cpcPassword$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L62146

; 4669 :          lpTask->hPassword =
; 4670 :          fnStoreStringInDataspace( (LPDATAHEADER) g_hAnchorBlock, cpcPassword );

	mov	ecx, DWORD PTR _cpcPassword$[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_hAnchorBlock
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+36], eax
$L62146:

; 4673 :    else

	jmp	$L62150
$L62141:

; 4675 :       zstrcpy( AnchorBlock->szUserID, AnchorBlock->szUserID );

	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 1423				; 0000058fH
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 1423				; 0000058fH
	push	eax
	call	_strcpy
	add	esp, 8

; 4676 :       zstrcpy( AnchorBlock->szPassword, AnchorBlock->szPassword );

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 1456				; 000005b0H
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 1456				; 000005b0H
	push	edx
	call	_strcpy
	add	esp, 8

; 4677 :       if ( cpcUserID[ 0 ] )

	mov	eax, DWORD PTR _cpcUserID$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L62149

; 4678 :          zstrcpy( AnchorBlock->szUserID, cpcUserID );

	mov	edx, DWORD PTR _cpcUserID$[ebp]
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 1423				; 0000058fH
	push	eax
	call	_strcpy
	add	esp, 8
$L62149:

; 4679 : 
; 4680 :       if ( cpcPassword[ 0 ] )

	mov	ecx, DWORD PTR _cpcPassword$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L62150

; 4681 :          zstrcpy( AnchorBlock->szPassword, cpcPassword );

	mov	eax, DWORD PTR _cpcPassword$[ebp]
	push	eax
	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 1456				; 000005b0H
	push	ecx
	call	_strcpy
	add	esp, 8
$L62150:

; 4683 : 
; 4684 :    // Send UserID to list box
; 4685 :    zstrcpy( szMsg, "(sy) Logon Userid=" );

	push	OFFSET FLAT:??_C@_0BD@FBHK@?$CIsy?$CJ?5Logon?5Userid?$DN?$AA@ ; `string'
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 4686 :    zstrcat( szMsg, (zPCHAR) cpcUserID );

	mov	eax, DWORD PTR _cpcUserID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4687 :    SysMessageList( szMsg );

	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_SysMessageList@4

; 4688 :    return( 0 );

	xor	eax, eax
$L62137:

; 4689 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysSetUserID@12 ENDP
_TEXT	ENDS
PUBLIC	_SysSetDB_UserID@12
_TEXT	SEGMENT
_lpView$ = 8
_cpcUserID$ = 12
_cpcPassword$ = 16
_lpTask$ = -4
_SysSetDB_UserID@12 PROC NEAR

; 4710 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4711 :    LPTASK lpTask;
; 4712 : 
; 4713 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $L62161

; 4714 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L62159
$L62161:

; 4715 : 
; 4716 :    lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 4717 :    if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $L62168

; 4719 :       lpTask->hDBUserID = fnFreeDataspace( zGETPTR( lpTask->hDBUserID ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 4720 :       lpTask->hDBPassword = fnFreeDataspace( zGETPTR( lpTask->hDBPassword ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 4721 :       if ( cpcUserID[ 0 ] )

	mov	edx, DWORD PTR _cpcUserID$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L62166

; 4723 :          lpTask->hDBUserID =
; 4724 :            fnStoreStringInDataspace( (LPDATAHEADER) g_hAnchorBlock, cpcUserID );

	mov	ecx, DWORD PTR _cpcUserID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_hAnchorBlock
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+40], eax
$L62166:

; 4726 : 
; 4727 :       if ( cpcPassword[ 0 ] )

	mov	edx, DWORD PTR _cpcPassword$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L62168

; 4729 :          lpTask->hDBPassword =
; 4730 :          fnStoreStringInDataspace( (LPDATAHEADER) g_hAnchorBlock, cpcPassword );

	mov	ecx, DWORD PTR _cpcPassword$[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_hAnchorBlock
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+44], eax
$L62168:

; 4733 : 
; 4734 :    return( 0 );

	xor	eax, eax
$L62159:

; 4735 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysSetDB_UserID@12 ENDP
_TEXT	ENDS
PUBLIC	_SysGetUserID@12
_TEXT	SEGMENT
_lpView$ = 8
_pchUserID$ = 12
_pchPassword$ = 16
_lpTask$ = -4
_SysGetUserID@12 PROC NEAR

; 4757 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4758 :    LPTASK lpTask;
; 4759 : 
; 4760 :    // Initialize in case of early errors.
; 4761 :    pchUserID[ 0 ] = 0;

	mov	eax, DWORD PTR _pchUserID$[ebp]
	mov	BYTE PTR [eax], 0

; 4762 :    pchPassword[ 0 ] = 0;

	mov	ecx, DWORD PTR _pchPassword$[ebp]
	mov	BYTE PTR [ecx], 0

; 4763 : 
; 4764 :    // OE not up, get out.
; 4765 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $L62178

; 4766 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L62176
$L62178:

; 4767 : 
; 4768 :    if ( lpView == 0 )

	cmp	DWORD PTR _lpView$[ebp], 0
	jne	SHORT $L62179

; 4769 :       lpTask = zGETPTR( AnchorBlock->hMainTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 4770 :    else

	jmp	SHORT $L62181
$L62179:

; 4771 :       lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$L62181:

; 4772 : 
; 4773 :    // No task for this caller, gonzo.
; 4774 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L62183

; 4775 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L62176
$L62183:

; 4776 : 
; 4777 :    // first check for a userid at the task level.
; 4778 :    if ( zGETHNDL( lpTask ) != AnchorBlock->hMainTask && lpTask->hUserID )

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	eax, DWORD PTR [ecx+106]
	je	SHORT $L62185
	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $L62185

; 4780 :       // return the userid
; 4781 :       zstrcpy( pchUserID, zGETPTR( lpTask->hUserID ) );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _pchUserID$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 4782 : 
; 4783 :       // return password, if present.
; 4784 :       if ( lpTask->hPassword )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $L62187

; 4785 :          zstrcpy( pchPassword, zGETPTR( lpTask->hPassword ) );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _pchPassword$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L62187:

; 4787 :    else

	jmp	SHORT $L62191
$L62185:

; 4789 :       // Next, check the system level for a userid
; 4790 :       if ( *AnchorBlock->szUserID )

	mov	ecx, DWORD PTR _AnchorBlock
	movsx	edx, BYTE PTR [ecx+1423]
	test	edx, edx
	je	SHORT $L62191

; 4792 :          // return the system userid
; 4793 :          zstrcpy( pchUserID, AnchorBlock->szUserID );

	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 1423				; 0000058fH
	push	eax
	mov	ecx, DWORD PTR _pchUserID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 4794 : 
; 4795 :          // return the system password
; 4796 :          if ( *AnchorBlock->szPassword )

	mov	edx, DWORD PTR _AnchorBlock
	movsx	eax, BYTE PTR [edx+1456]
	test	eax, eax
	je	SHORT $L62191

; 4797 :             zstrcpy( pchPassword, AnchorBlock->szPassword );

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 1456				; 000005b0H
	push	ecx
	mov	edx, DWORD PTR _pchPassword$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L62191:

; 4800 : 
; 4801 :    return( 0 );

	xor	eax, eax
$L62176:

; 4802 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysGetUserID@12 ENDP
_TEXT	ENDS
PUBLIC	_SysGetDB_UserID@12
_TEXT	SEGMENT
_lpView$ = 8
_pchUserID$ = 12
_pchPassword$ = 16
_lpTask$ = -4
_SysGetDB_UserID@12 PROC NEAR

; 4824 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4825 :    LPTASK lpTask;
; 4826 : 
; 4827 :    // Initialize in case of early errors.
; 4828 :    pchUserID[ 0 ] = 0;

	mov	eax, DWORD PTR _pchUserID$[ebp]
	mov	BYTE PTR [eax], 0

; 4829 :    pchPassword[ 0 ] = 0;

	mov	ecx, DWORD PTR _pchPassword$[ebp]
	mov	BYTE PTR [ecx], 0

; 4830 : 
; 4831 :    // OE not up, get out.
; 4832 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $L62200

; 4833 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $L62198
$L62200:

; 4834 : 
; 4835 :    lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 4836 : 
; 4837 :    // No task for this caller, gonzo.
; 4838 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L62202

; 4839 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $L62198
$L62202:

; 4840 : 
; 4841 :    // first check for a userid at the task level.
; 4842 :    if ( lpTask->hDBUserID )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $L62203

; 4844 :       // return the userid
; 4845 :       zstrcpy( pchUserID, zGETPTR( lpTask->hDBUserID ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _pchUserID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 4846 : 
; 4847 :       // return password, if present.
; 4848 :       if ( lpTask->hDBPassword )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $L62205

; 4849 :          zstrcpy( pchPassword, zGETPTR( lpTask->hDBPassword ) );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _pchPassword$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L62205:

; 4851 :    else

	jmp	SHORT $L62207
$L62203:

; 4853 :       SysGetUserID( lpView, pchUserID, pchPassword );

	mov	eax, DWORD PTR _pchPassword$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchUserID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysGetUserID@12
$L62207:

; 4855 : 
; 4856 :    return( 0 );

	xor	eax, eax
$L62198:

; 4857 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysGetDB_UserID@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@GEKD@?$CFsZTF_?$CFlx_?$CFlx?4TMP?$AA@	; `string'
PUBLIC	_SysCreateTempFileName@4
PUBLIC	_SysGetTickCount@0
;	COMDAT ??_C@_0BC@GEKD@?$CFsZTF_?$CFlx_?$CFlx?4TMP?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BC@GEKD@?$CFsZTF_?$CFlx_?$CFlx?4TMP?$AA@ DB '%sZTF_%lx_%lx.TMP', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchTargetName$ = 8
_lTime$ = -4
_ulTask$ = -8
_SysCreateTempFileName@4 PROC NEAR

; 4880 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4881 :    zLONG  lTime;
; 4882 :    zULONG ulTask;
; 4883 :    *pchTargetName = 0;

	mov	eax, DWORD PTR _pchTargetName$[ebp]
	mov	BYTE PTR [eax], 0

; 4884 : 
; 4885 :    ulTask = (zULONG) GetCurrentProcessId( );

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	DWORD PTR _ulTask$[ebp], eax

; 4886 :    lTime = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTime$[ebp], eax

; 4887 :    zsprintf( pchTargetName, "%sZTF_%lx_%lx.TMP",
; 4888 :              AnchorBlock->szZeidonLoc, ulTask, lTime );

	mov	ecx, DWORD PTR _lTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 909				; 0000038dH
	push	eax
	push	OFFSET FLAT:??_C@_0BC@GEKD@?$CFsZTF_?$CFlx_?$CFlx?4TMP?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchTargetName$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 4889 :    return( 0 );

	xor	ax, ax

; 4890 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysCreateTempFileName@4 ENDP
_TEXT	ENDS
PUBLIC	_fnSysReadFile@16
PUBLIC	_fnSysWriteFile@16
PUBLIC	_fnSysCopyFile@16
_TEXT	SEGMENT
_lpTask$ = 8
_cpcFileSpecFrom$ = 12
_cpcFileSpecTo$ = 16
_bOverwrite$ = 20
_hFileTo$ = -12
_hFileFrom$ = -20
_k$ = -16
_hMem$ = -4
_pchBuffer$ = -8
_fnSysCopyFile@16 PROC NEAR

; 4920 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 4921 :    zLONG    hFileTo;
; 4922 :    zLONG    hFileFrom;
; 4923 :    zSHORT   k;
; 4924 :    zLONG    hMem = 0;

	mov	DWORD PTR _hMem$[ebp], 0

; 4925 :    zPCHAR   pchBuffer;
; 4926 : 
; 4927 :    if ( bOverwrite == FALSE &&
; 4928 :         fnSysOpenFile( lpTask, cpcFileSpecTo, COREFILE_EXIST ) == 0 )

	mov	eax, DWORD PTR _bOverwrite$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L62229
	push	4
	mov	ecx, DWORD PTR _cpcFileSpecTo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12
	test	eax, eax
	jne	SHORT $L62229

; 4930 :       return( -1 );

	or	ax, -1
	jmp	$L62223
$L62229:

; 4932 : 
; 4933 :    hFileFrom = fnSysOpenFile( lpTask, cpcFileSpecFrom, COREFILE_READ );

	push	128					; 00000080H
	mov	eax, DWORD PTR _cpcFileSpecFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFileFrom$[ebp], eax

; 4934 :    if ( hFileFrom <= 0 )

	cmp	DWORD PTR _hFileFrom$[ebp], 0
	jg	SHORT $L62230

; 4935 :       return( -2 );

	mov	ax, -2					; fffffffeH
	jmp	$L62223
$L62230:

; 4936 : 
; 4937 :    hFileTo = fnSysOpenFile( lpTask, cpcFileSpecTo, COREFILE_WRITE );

	push	64					; 00000040H
	mov	edx, DWORD PTR _cpcFileSpecTo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFileTo$[ebp], eax

; 4938 :    if ( hFileTo <= 0 )

	cmp	DWORD PTR _hFileTo$[ebp], 0
	jg	SHORT $L62231

; 4940 :       fnSysCloseFile( lpTask, hFileFrom, 0 );

	push	0
	mov	ecx, DWORD PTR _hFileFrom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 4941 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L62223
$L62231:

; 4943 : 
; 4944 :    hMem = SysAllocMemory( &pchBuffer, COPY_BUFFER_LTH, 0, zCOREMEM_ALLOC, 0 );

	push	0
	push	32768					; 00008000H
	push	0
	push	10000					; 00002710H
	lea	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	_SysAllocMemory@20
	mov	DWORD PTR _hMem$[ebp], eax

; 4945 :    if ( pchBuffer == 0 )

	cmp	DWORD PTR _pchBuffer$[ebp], 0
	jne	SHORT $L62232

; 4947 :       fnSysCloseFile( lpTask, hFileFrom, 0 );

	push	0
	mov	ecx, DWORD PTR _hFileFrom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 4948 :       fnSysCloseFile( lpTask, hFileTo, 0 );

	push	0
	mov	eax, DWORD PTR _hFileTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysCloseFile@12

; 4949 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L62223
$L62232:

; 4954 :       k = fnSysReadFile( lpTask, hFileFrom, pchBuffer, COPY_BUFFER_LTH );

	push	10000					; 00002710H
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFileFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadFile@16
	mov	WORD PTR _k$[ebp], ax

; 4955 :       if ( k > 0 )

	movsx	edx, WORD PTR _k$[ebp]
	test	edx, edx
	jle	SHORT $L62236

; 4956 :          fnSysWriteFile( lpTask, hFileTo, pchBuffer, k );

	movsx	eax, WORD PTR _k$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFileTo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteFile@16

; 4957 :       else

	jmp	SHORT $L62237
$L62236:

; 4958 :          break;

	jmp	SHORT $L62235
$L62237:

; 4959 :    }

	jmp	SHORT $L62232
$L62235:

; 4960 : 
; 4961 :    SysFreeMemory( hMem );

	mov	ecx, DWORD PTR _hMem$[ebp]
	push	ecx
	call	_SysFreeMemory@4

; 4962 :    fnSysCloseFile( lpTask, hFileFrom, 0 );

	push	0
	mov	edx, DWORD PTR _hFileFrom$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFile@12

; 4963 :    fnSysCloseFile( lpTask, hFileTo, 0 );

	push	0
	mov	ecx, DWORD PTR _hFileTo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 4964 :    return( 1 );

	mov	ax, 1
$L62223:

; 4965 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysCopyFile@16 ENDP
_TEXT	ENDS
PUBLIC	_SysCopyFile@16
_TEXT	SEGMENT
_lpTaskView$ = 8
_cpcFileSpecFrom$ = 12
_cpcFileSpecTo$ = 16
_bOverwrite$ = 20
_lpTask$ = -4
_SysCopyFile@16 PROC NEAR

; 4972 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4973 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64851
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64852
$L64851:
	mov	DWORD PTR -8+[ebp], 0
$L64852:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 4974 : 
; 4975 :    return( fnSysCopyFile( lpTask, cpcFileSpecFrom,
; 4976 :                           cpcFileSpecTo, bOverwrite ) );

	mov	al, BYTE PTR _bOverwrite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcFileSpecTo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcFileSpecFrom$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCopyFile@16

; 4977 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysCopyFile@16 ENDP
_TEXT	ENDS
PUBLIC	_fnSysRenameFile@16
PUBLIC	??_C@_0EP@BOCM@SysRenameFile?5MoveFile?5RC?3?5?$CFld?5?5@ ; `string'
PUBLIC	??_C@_0BG@OCKP@Zeidon?5MoveFile?5Error?$AA@	; `string'
EXTRN	__imp__MoveFileA@8:NEAR
;	COMDAT ??_C@_0EP@BOCM@SysRenameFile?5MoveFile?5RC?3?5?$CFld?5?5@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0EP@BOCM@SysRenameFile?5MoveFile?5RC?3?5?$CFld?5?5@ DB 'SysRenameFi'
	DB	'le MoveFile RC: %ld   FileSpecFrom: %s   FileSpecTo: %s   Err'
	DB	'or: %s', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@OCKP@Zeidon?5MoveFile?5Error?$AA@
_DATA	SEGMENT
??_C@_0BG@OCKP@Zeidon?5MoveFile?5Error?$AA@ DB 'Zeidon MoveFile Error', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_pchFileSpecFrom$ = 12
_pchFileSpecTo$ = 16
_bOverwrite$ = 20
_pchMsg$62263 = -4
_dw$62264 = -8
_fnSysRenameFile@16 PROC NEAR

; 5005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5006 :    if ( fnSysOpenFile( lpTask, pchFileSpecFrom, COREFILE_EXIST ) < 0 )

	push	4
	mov	eax, DWORD PTR _pchFileSpecFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysOpenFile@12
	test	eax, eax
	jge	SHORT $L62258

; 5007 :       return( -1 );

	or	ax, -1
	jmp	$L62257
$L62258:

; 5008 : 
; 5009 :    if ( fnSysOpenFile( lpTask, pchFileSpecTo, COREFILE_EXIST ) >= 0 )

	push	4
	mov	edx, DWORD PTR _pchFileSpecTo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysOpenFile@12
	test	eax, eax
	jl	SHORT $L62261

; 5011 :       if ( bOverwrite == FALSE )

	mov	ecx, DWORD PTR _bOverwrite$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L62260

; 5012 :          return( -1 );

	or	ax, -1
	jmp	$L62257
$L62260:

; 5013 : 
; 5014 :       // Delete the new name if it already exists.
; 5015 :    // if ( fnSysOpenFile( lpTask, pchFileSpecTo, COREFILE_DELETE ) == -1 )
; 5016 :       if ( fnSysOpenFile( lpTask, pchFileSpecTo, COREFILE_DELETE ) == zCALL_ERROR )

	push	8
	mov	edx, DWORD PTR _pchFileSpecTo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysOpenFile@12
	cmp	eax, -16				; fffffff0H
	jne	SHORT $L62261

; 5017 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L62257
$L62261:

; 5019 : 
; 5020 :    if ( !MoveFile( pchFileSpecFrom, pchFileSpecTo ) )

	mov	ecx, DWORD PTR _pchFileSpecTo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchFileSpecFrom$[ebp]
	push	edx
	call	DWORD PTR __imp__MoveFileA@8
	test	eax, eax
	jne	SHORT $L62262

; 5022 :       zPCHAR pchMsg;
; 5023 :       DWORD dw = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dw$62264[ebp], eax

; 5024 : 
; 5025 :       FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
; 5026 :                      0, dw, MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
; 5027 :                      (zPCHAR) &pchMsg, 0, 0 );

	push	0
	push	0
	lea	eax, DWORD PTR _pchMsg$62263[ebp]
	push	eax
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _dw$62264[ebp]
	push	ecx
	push	0
	push	4352					; 00001100H
	call	DWORD PTR __imp__FormatMessageA@28

; 5028 :       TraceLine( "SysRenameFile MoveFile RC: %ld   FileSpecFrom: %s   "
; 5029 :                    "FileSpecTo: %s   Error: %s",
; 5030 :                  dw, pchFileSpecFrom, pchFileSpecTo, pchMsg );

	mov	edx, DWORD PTR _pchMsg$62263[ebp]
	push	edx
	mov	eax, DWORD PTR _pchFileSpecTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchFileSpecFrom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dw$62264[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0EP@BOCM@SysRenameFile?5MoveFile?5RC?3?5?$CFld?5?5@ ; `string'
	call	_TraceLine
	add	esp, 20					; 00000014H

; 5031 :       fnSysMessageBox( lpTask, "Zeidon MoveFile Error", pchMsg, 1 );

	push	1
	mov	eax, DWORD PTR _pchMsg$62263[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BG@OCKP@Zeidon?5MoveFile?5Error?$AA@ ; `string'
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysMessageBox@16

; 5032 : 
; 5033 :       LocalFree( pchMsg ); // free the buffer

	mov	edx, DWORD PTR _pchMsg$62263[ebp]
	push	edx
	call	DWORD PTR __imp__LocalFree@4

; 5034 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L62257
$L62262:

; 5036 : 
; 5037 :    return( 1 );

	mov	ax, 1
$L62257:

; 5038 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysRenameFile@16 ENDP
_TEXT	ENDS
PUBLIC	_SysRenameFile@16
_TEXT	SEGMENT
_lpTaskView$ = 8
_pchFileSpecFrom$ = 12
_pchFileSpecTo$ = 16
_bOverwrite$ = 20
_lpTask$ = -4
_SysRenameFile@16 PROC NEAR

; 5045 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5046 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64855
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64856
$L64855:
	mov	DWORD PTR -8+[ebp], 0
$L64856:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 5047 : 
; 5048 :    return( fnSysRenameFile( lpTask, pchFileSpecFrom,
; 5049 :                             pchFileSpecTo, bOverwrite ) );

	mov	al, BYTE PTR _bOverwrite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchFileSpecTo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchFileSpecFrom$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysRenameFile@16

; 5050 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysRenameFile@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EA@ECMJ@SysOpenFile?5for?5file?3?5?$CFs?5failed?5@ ; `string'
PUBLIC	??_C@_08IHCD@0x?$CF08x?$CFs?$AA@		; `string'
PUBLIC	??_C@_0CM@PPJA@SysDeleteFile?5Error?3?5?$CFs?5?5?5File?3?5@ ; `string'
PUBLIC	??_C@_0BL@LAPP@?$CIsy?$CJ?5Could?5not?5open?5file?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BE@CEDG@?$CIsy?$CJ?5Reason?5code?5?$DN?5?$AA@ ; `string'
EXTRN	__imp__DeleteFileA@4:NEAR
EXTRN	__imp__SearchPathA@24:NEAR
EXTRN	__imp__SetFilePointer@16:NEAR
;	COMDAT ??_C@_0EA@ECMJ@SysOpenFile?5for?5file?3?5?$CFs?5failed?5@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0EA@ECMJ@SysOpenFile?5for?5file?3?5?$CFs?5failed?5@ DB 'SysOpenFile'
	DB	' for file: %s failed due to invalid view (null task)', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IHCD@0x?$CF08x?$CFs?$AA@
_DATA	SEGMENT
??_C@_08IHCD@0x?$CF08x?$CFs?$AA@ DB '0x%08x%s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@PPJA@SysDeleteFile?5Error?3?5?$CFs?5?5?5File?3?5@
_DATA	SEGMENT
??_C@_0CM@PPJA@SysDeleteFile?5Error?3?5?$CFs?5?5?5File?3?5@ DB 'SysDelete'
	DB	'File Error: %s   File: %s   RC: %d', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@LAPP@?$CIsy?$CJ?5Could?5not?5open?5file?3?5?$AA@
_DATA	SEGMENT
??_C@_0BL@LAPP@?$CIsy?$CJ?5Could?5not?5open?5file?3?5?$AA@ DB '(sy) Could'
	DB	' not open file: ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@CEDG@?$CIsy?$CJ?5Reason?5code?5?$DN?5?$AA@
_DATA	SEGMENT
??_C@_0BE@CEDG@?$CIsy?$CJ?5Reason?5code?5?$DN?5?$AA@ DB '(sy) Reason code'
	DB	' = ', 00H					; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_cpcFileName$ = 12
_nFlags$ = 16
_szTempFileName$ = -1036
_hFile$ = -1044
_lpOpenFile$ = -1040
_lpMainTask$ = -8
_nTrys$ = -4
_szExtension$62303 = -1060
_pch$62304 = -1048
_szPath$62331 = -2092
_szFN$62332 = -3132
_szResult$62333 = -2104
_pch$62334 = -1064
_lRC$62342 = -3136
_pchMsg$62344 = -3140
_dw$62345 = -3144
_pchNew$62353 = -3148
_hOpenFile$62360 = -3152
_lProcessID$62363 = -3156
_bMutexLocked$62364 = -3160
_fnSysOpenFile@12 PROC NEAR

; 5090 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3160				; 00000c58H

; 5091 :    zCHAR      szTempFileName[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 5092 :    HANDLE     hFile = (HANDLE) -1;

	mov	DWORD PTR _hFile$[ebp], -1

; 5093 :    LPOPENFILE lpOpenFile;
; 5094 :    LPTASK     lpMainTask;
; 5095 :    zSHORT     nTrys = 0;

	mov	WORD PTR _nTrys$[ebp], 0
$L62296:

; 5096 : 
; 5097 : // TraceLine( "fnSysOpenFile %s  Task: 0x%08x   Process: 0x%08x",
; 5098 : //            cpcFileName, lpTask, lProcessID );
; 5099 : 
; 5100 :    while ( (lpMainTask = zGETPTR( AnchorBlock->hMainTask )) == 0 && nTrys < 100 )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMainTask$[ebp], eax
	cmp	DWORD PTR _lpMainTask$[ebp], 0
	jne	SHORT $L62297
	movsx	edx, WORD PTR _nTrys$[ebp]
	cmp	edx, 100				; 00000064H
	jge	SHORT $L62297

; 5102 :       SysWait( 100 );

	push	100					; 00000064H
	call	_SysWait@4

; 5103 :       nTrys++;

	mov	ax, WORD PTR _nTrys$[ebp]
	add	ax, 1
	mov	WORD PTR _nTrys$[ebp], ax

; 5104 :    }

	jmp	SHORT $L62296
$L62297:

; 5105 : 
; 5106 :    if ( lpMainTask == 0 || lpTask == 0 )

	cmp	DWORD PTR _lpMainTask$[ebp], 0
	je	SHORT $L62299
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L62298
$L62299:

; 5108 :       if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L62300

; 5110 :          TraceLine( "SysOpenFile for file: %s failed due to invalid view (null task)",
; 5111 :                     cpcFileName );

	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0EA@ECMJ@SysOpenFile?5for?5file?3?5?$CFs?5failed?5@ ; `string'
	call	_TraceLine
	add	esp, 8
$L62300:

; 5113 : 
; 5114 :       return( -1 );

	or	eax, -1
	jmp	$L62287
$L62298:

; 5116 : 
; 5117 :    zstrcpy( szTempFileName, cpcFileName );

	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTempFileName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 5118 : 
; 5119 :    // Check to see if we are going to write the file to a backup file first.
; 5120 :    if ( nFlags & COREFILE_BACKUP )

	mov	ecx, DWORD PTR _nFlags$[ebp]
	and	ecx, 4096				; 00001000H
	test	ecx, ecx
	je	$L62302

; 5122 :       zCHAR  szExtension[ 10 ];
; 5123 :       zPCHAR pch = &szTempFileName[ zstrlen( szTempFileName ) - 1 ];

	lea	edx, DWORD PTR _szTempFileName$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	lea	eax, DWORD PTR _szTempFileName$[ebp+eax-1]
	mov	DWORD PTR _pch$62304[ebp], eax
$L62306:

; 5124 : 
; 5125 :       // Backup until we find the period.
; 5126 :       while ( pch > szTempFileName && *pch != '.' )

	mov	ecx, DWORD PTR _pch$62304[ebp]
	lea	edx, DWORD PTR _szTempFileName$[ebp]
	cmp	ecx, edx
	jbe	SHORT $L62307
	mov	eax, DWORD PTR _pch$62304[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	je	SHORT $L62307

; 5127 :          pch--;

	mov	edx, DWORD PTR _pch$62304[ebp]
	sub	edx, 1
	mov	DWORD PTR _pch$62304[ebp], edx
	jmp	SHORT $L62306
$L62307:

; 5128 : 
; 5129 :       // Save the extension for later use.
; 5130 :       if ( pch > szTempFileName )

	mov	eax, DWORD PTR _pch$62304[ebp]
	lea	ecx, DWORD PTR _szTempFileName$[ebp]
	cmp	eax, ecx
	jbe	SHORT $L62308

; 5131 :          zstrcpy( szExtension, pch );

	mov	edx, DWORD PTR _pch$62304[ebp]
	push	edx
	lea	eax, DWORD PTR _szExtension$62303[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L62308:

; 5132 : 
; 5133 :       // Backup until we find the first directory separator.
; 5134 :       while ( pch > szTempFileName && *pch != cDirSep )

	mov	ecx, DWORD PTR _pch$62304[ebp]
	lea	edx, DWORD PTR _szTempFileName$[ebp]
	cmp	ecx, edx
	jbe	SHORT $L62311
	mov	eax, DWORD PTR _pch$62304[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR _cDirSep
	cmp	ecx, edx
	je	SHORT $L62311

; 5135 :          pch--;

	mov	eax, DWORD PTR _pch$62304[ebp]
	sub	eax, 1
	mov	DWORD PTR _pch$62304[ebp], eax
	jmp	SHORT $L62308
$L62311:

; 5136 : 
; 5137 :       // Make sure we don't lose the dir separator.
; 5138 :       if ( *pch == cDirSep )

	mov	ecx, DWORD PTR _pch$62304[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR _cDirSep
	cmp	edx, eax
	jne	SHORT $L62312

; 5139 :          pch++;

	mov	ecx, DWORD PTR _pch$62304[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$62304[ebp], ecx
$L62312:

; 5140 : 
; 5141 :       // Create a temp file name using the current task ID.
; 5142 :       zsprintf( pch, "0x%08x%s", zGETHNDL( lpTask ), szExtension );

	lea	edx, DWORD PTR _szExtension$62303[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET FLAT:??_C@_08IHCD@0x?$CF08x?$CFs?$AA@ ; `string'
	mov	ecx, DWORD PTR _pch$62304[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
$L62302:

; 5144 : 
; 5145 :    if ( nFlags & COREFILE_READ )

	mov	edx, DWORD PTR _nFlags$[ebp]
	and	edx, 128				; 00000080H
	test	edx, edx
	je	$L62315

; 5147 :       if ( nFlags & COREFILE_WRITE )

	mov	eax, DWORD PTR _nFlags$[ebp]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $L62316

; 5149 :          hFile = CreateFile( szTempFileName, GENERIC_WRITE | GENERIC_READ,
; 5150 :                              FILE_SHARE_READ, 0, OPEN_ALWAYS,
; 5151 :                              FILE_ATTRIBUTE_NORMAL, 0 );

	push	0
	push	128					; 00000080H
	push	4
	push	0
	push	1
	push	-1073741824				; c0000000H
	lea	ecx, DWORD PTR _szTempFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$[ebp], eax

; 5152 :          if ( hFile == INVALID_HANDLE_VALUE )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $L62318

; 5153 :             hFile = (HANDLE) -1;

	mov	DWORD PTR _hFile$[ebp], -1
$L62318:

; 5154 : 
; 5155 :          if ( (zLONG) hFile != -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	je	SHORT $L62322

; 5157 :             if ( (nFlags & COREFILE_APPEND) == COREFILE_APPEND )

	mov	edx, DWORD PTR _nFlags$[ebp]
	and	edx, 448				; 000001c0H
	cmp	edx, 448				; 000001c0H
	jne	SHORT $L62322

; 5159 :                SetFilePointer( hFile, 0, 0, FILE_END );

	push	2
	push	0
	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	DWORD PTR __imp__SetFilePointer@16
$L62322:

; 5163 :       else

	jmp	SHORT $L62323
$L62316:

; 5165 :          hFile = CreateFile( szTempFileName, GENERIC_READ,
; 5166 :                              FILE_SHARE_READ, 0, OPEN_EXISTING,
; 5167 :                              FILE_ATTRIBUTE_NORMAL, 0 );

	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	lea	ecx, DWORD PTR _szTempFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$[ebp], eax
$L62323:

; 5170 :    else

	jmp	$L62352
$L62315:

; 5171 :    if ( (nFlags & COREFILE_WRITE) || (nFlags & COREFILE_CREATE) )

	mov	edx, DWORD PTR _nFlags$[ebp]
	and	edx, 64					; 00000040H
	test	edx, edx
	jne	SHORT $L62326
	mov	eax, DWORD PTR _nFlags$[ebp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $L62325
$L62326:

; 5173 :       if ( (nFlags & COREFILE_CREATE_NEW) == COREFILE_CREATE_NEW )

	mov	ecx, DWORD PTR _nFlags$[ebp]
	and	ecx, 544				; 00000220H
	cmp	ecx, 544				; 00000220H
	jne	SHORT $L62327

; 5174 :          hFile = CreateFile( szTempFileName, GENERIC_WRITE,
; 5175 :                              FILE_SHARE_READ, 0, CREATE_NEW,
; 5176 :                              FILE_ATTRIBUTE_NORMAL, 0 );

	push	0
	push	128					; 00000080H
	push	1
	push	0
	push	1
	push	1073741824				; 40000000H
	lea	edx, DWORD PTR _szTempFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$[ebp], eax

; 5177 :       else

	jmp	SHORT $L62328
$L62327:

; 5178 :          hFile = CreateFile( szTempFileName, GENERIC_WRITE,
; 5179 :                              FILE_SHARE_READ, 0, CREATE_ALWAYS,
; 5180 :                              FILE_ATTRIBUTE_NORMAL, 0 );

	push	0
	push	128					; 00000080H
	push	2
	push	0
	push	1
	push	1073741824				; 40000000H
	lea	eax, DWORD PTR _szTempFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$[ebp], eax
$L62328:

; 5182 :    else

	jmp	$L62352
$L62325:

; 5183 :    if ( nFlags & COREFILE_EXIST )

	mov	ecx, DWORD PTR _nFlags$[ebp]
	and	ecx, 4
	test	ecx, ecx
	je	$L62330

; 5185 :       zCHAR  szPath[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 5186 :       zCHAR  szFN[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 5187 :       zCHAR  szResult[ 10 ];
; 5188 :       zPCHAR pch;
; 5189 : 
; 5190 :       // Find the last directory separator.
; 5191 :       zstrcpy( szPath, szTempFileName );

	lea	edx, DWORD PTR _szTempFileName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szPath$62331[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 5192 :       pch = &szPath[ zstrlen( szPath ) - 1 ];

	lea	ecx, DWORD PTR _szPath$62331[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	lea	edx, DWORD PTR _szPath$62331[ebp+eax-1]
	mov	DWORD PTR _pch$62334[ebp], edx
$L62336:

; 5193 :       while ( pch >= szPath && *pch != cDirSep && *pch != ':' )

	mov	eax, DWORD PTR _pch$62334[ebp]
	lea	ecx, DWORD PTR _szPath$62331[ebp]
	cmp	eax, ecx
	jb	SHORT $L62337
	mov	edx, DWORD PTR _pch$62334[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR _cDirSep
	cmp	eax, ecx
	je	SHORT $L62337
	mov	edx, DWORD PTR _pch$62334[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	je	SHORT $L62337

; 5194 :          pch--;

	mov	ecx, DWORD PTR _pch$62334[ebp]
	sub	ecx, 1
	mov	DWORD PTR _pch$62334[ebp], ecx
	jmp	SHORT $L62336
$L62337:

; 5195 : 
; 5196 :       // Copy the filename and extension.
; 5197 :       zstrcpy( szFN, pch + 1 );

	mov	edx, DWORD PTR _pch$62334[ebp]
	add	edx, 1
	push	edx
	lea	eax, DWORD PTR _szFN$62332[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 5198 : 
; 5199 :       // Set null terminator in szPath to remove filename and extension.
; 5200 :       pch[ 1 ] = 0;

	mov	ecx, DWORD PTR _pch$62334[ebp]
	mov	BYTE PTR [ecx+1], 0

; 5201 : 
; 5202 :       // Note that the " 9, szResult, &pch" arguments are really dummy args.
; 5203 :       if ( SearchPath( szPath, szFN, 0, 9, szResult, &pch ) > 0 )

	lea	edx, DWORD PTR _pch$62334[ebp]
	push	edx
	lea	eax, DWORD PTR _szResult$62333[ebp]
	push	eax
	push	9
	push	0
	lea	ecx, DWORD PTR _szFN$62332[ebp]
	push	ecx
	lea	edx, DWORD PTR _szPath$62331[ebp]
	push	edx
	call	DWORD PTR __imp__SearchPathA@24
	test	eax, eax
	jbe	SHORT $L62338

; 5204 :          return( 1 ); // File exists.

	mov	eax, 1
	jmp	$L62287
$L62338:

; 5205 :       else
; 5206 :          return( -1 );

	or	eax, -1
	jmp	$L62287
$L62330:

; 5208 :    else
; 5209 :    if ( nFlags & COREFILE_DELETE )

	mov	eax, DWORD PTR _nFlags$[ebp]
	and	eax, 8
	test	eax, eax
	je	$L62341

; 5211 :       zLONG lRC = DeleteFile( szTempFileName );

	lea	ecx, DWORD PTR _szTempFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__DeleteFileA@4
	mov	DWORD PTR _lRC$62342[ebp], eax

; 5212 :       if ( lRC == 0 )

	cmp	DWORD PTR _lRC$62342[ebp], 0
	jne	SHORT $L62343

; 5214 :          zPCHAR pchMsg;
; 5215 :          DWORD  dw = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dw$62345[ebp], eax

; 5216 : 
; 5217 :          FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
; 5218 :                         0, dw, MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
; 5219 :                         (zPCHAR) &pchMsg, 0, 0 );

	push	0
	push	0
	lea	edx, DWORD PTR _pchMsg$62344[ebp]
	push	edx
	push	1024					; 00000400H
	mov	eax, DWORD PTR _dw$62345[ebp]
	push	eax
	push	0
	push	4352					; 00001100H
	call	DWORD PTR __imp__FormatMessageA@28

; 5220 :          TraceLine( "SysDeleteFile Error: %s   File: %s   RC: %d",
; 5221 :                     pchMsg, szTempFileName, dw );

	mov	ecx, DWORD PTR _dw$62345[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTempFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchMsg$62344[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CM@PPJA@SysDeleteFile?5Error?3?5?$CFs?5?5?5File?3?5@ ; `string'
	call	_TraceLine
	add	esp, 16					; 00000010H

; 5222 :       // fnSysMessageBox( lpTask, "Zeidon DeleteFile Error", pchMsg, 1 );
; 5223 :          LocalFree( pchMsg ); // free the buffer

	mov	ecx, DWORD PTR _pchMsg$62344[ebp]
	push	ecx
	call	DWORD PTR __imp__LocalFree@4

; 5224 :          return( -1 );

	or	eax, -1
	jmp	$L62287
$L62343:

; 5226 :       else
; 5227 :          return( 0 );

	xor	eax, eax
	jmp	$L62287
$L62341:

; 5229 :    else
; 5230 :    if ( nFlags & COREFILE_RENAME )

	mov	edx, DWORD PTR _nFlags$[ebp]
	and	edx, 16					; 00000010H
	test	edx, edx
	je	SHORT $L62352

; 5232 :       zPCHAR pchNew = (zPCHAR) &cpcFileName[ zstrlen( cpcFileName ) + 1 ];

	mov	eax, DWORD PTR _cpcFileName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchNew$62353[ebp], edx

; 5233 : 
; 5234 :       // Call fnSysRenameFile.
; 5235 :       return( fnSysRenameFile( lpTask, (zPCHAR) cpcFileName, pchNew, TRUE ) );

	push	1
	mov	eax, DWORD PTR _pchNew$62353[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysRenameFile@16
	movsx	eax, ax
	jmp	$L62287
$L62352:

; 5237 : 
; 5238 :    if ( hFile == (HANDLE) -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $L62357

; 5240 :       // The following statement was added and the lines
; 5241 :       // above commented out because getcwd was abending.
; 5242 :       // This should be reversed when getcwd is ok.
; 5243 :       TraceLineS( "(sy) Could not open file: ", szTempFileName );

	lea	eax, DWORD PTR _szTempFileName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BL@LAPP@?$CIsy?$CJ?5Could?5not?5open?5file?3?5?$AA@ ; `string'
	call	_TraceLineS@8

; 5244 :       TraceLineI( "(sy) Reason code = ", GetLastError( ) );

	call	DWORD PTR __imp__GetLastError@0
	push	eax
	push	OFFSET FLAT:??_C@_0BE@CEDG@?$CIsy?$CJ?5Reason?5code?5?$DN?5?$AA@ ; `string'
	call	_TraceLineI@8

; 5245 :       return( -1 );

	or	eax, -1
	jmp	$L62287
$L62357:

; 5251 :       zPVOID hOpenFile;
; 5252 : 
; 5253 :       // We need to allocate and initialize an OpenFile record and then
; 5254 :       // chain it to the task block.
; 5255 :       hOpenFile = fnAllocDataspace( lpTask->hFirstDataHeader,
; 5256 :                                     sizeof( OpenFileRecord ), 1, 0, iOpenFile );

	push	10028					; 0000272cH
	push	0
	push	1
	push	558					; 0000022eH
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hOpenFile$62360[ebp], eax

; 5257 :       if ( hOpenFile )

	cmp	DWORD PTR _hOpenFile$62360[ebp], 0
	je	$L62370

; 5259 :          zLONG lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$62363[ebp], eax

; 5260 :          zBOOL bMutexLocked;
; 5261 : 
; 5262 :          lpOpenFile = zGETPTR( hOpenFile );

	mov	eax, DWORD PTR _hOpenFile$62360[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 5263 : 
; 5264 :          if ( zGETHNDL( lpTask ) == AnchorBlock->hMainTask )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _AnchorBlock
	cmp	eax, DWORD PTR [edx+106]
	jne	SHORT $L62367

; 5266 :             bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$62364[ebp], 1

; 5267 :             zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 5269 :          else

	jmp	SHORT $L62368
$L62367:

; 5270 :             bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$62364[ebp], 0
$L62368:

; 5271 : 
; 5272 :          // Now chain the OpenFile record to the task block.
; 5273 :          lpOpenFile->hNextOpenFile = lpTask->hFirstOpenFile;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+118]
	mov	DWORD PTR [eax+6], edx

; 5274 :          lpTask->hFirstOpenFile    = hOpenFile;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR _hOpenFile$62360[ebp]
	mov	DWORD PTR [eax+118], ecx

; 5275 :          lpOpenFile->lProcessID    = lProcessID;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lProcessID$62363[ebp]
	mov	DWORD PTR [edx+2], eax

; 5276 :          lpOpenFile->nFlags        = nFlags;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	dx, WORD PTR _nFlags$[ebp]
	mov	WORD PTR [ecx+10], dx

; 5277 :          lpOpenFile->lFileHandle   = (zLONG) hFile;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _hFile$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 5278 :          zstrcpy( lpOpenFile->szFileName, cpcFileName );

	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_strcpy
	add	esp, 8

; 5279 :          zstrcpy( lpOpenFile->szTempFileName, szTempFileName );

	lea	ecx, DWORD PTR _szTempFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	add	edx, 273				; 00000111H
	push	edx
	call	_strcpy
	add	esp, 8

; 5280 : 
; 5281 :          if ( bMutexLocked )

	mov	eax, DWORD PTR _bMutexLocked$62364[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L62370

; 5282 :             zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$L62370:

; 5285 : 
; 5286 : // TraceLine( "fnSysOpenFile %s   Handle: 0x%08x   Task: 0x%08x",
; 5287 : //            cpcFileName, hFile, lpTask );
; 5288 : 
; 5289 :    return( (zLONG) hFile );  // return the handle to the file

	mov	eax, DWORD PTR _hFile$[ebp]
$L62287:

; 5290 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSysOpenFile@12 ENDP
_TEXT	ENDS
PUBLIC	_SysOpenFile@12
_TEXT	SEGMENT
_lpTaskView$ = 8
_cpcFileName$ = 12
_nFlags$ = 16
_lpTask$ = -4
_SysOpenFile@12 PROC NEAR

; 5294 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5295 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64859
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64860
$L64859:
	mov	DWORD PTR -8+[ebp], 0
$L64860:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 5296 : 
; 5297 :    return( fnSysOpenFile( lpTask, cpcFileName, nFlags ) );

	mov	eax, DWORD PTR _nFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12

; 5298 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysOpenFile@12 ENDP
_lFileHandle$ = 12
_pchBuffer$ = 16
_ulMaxLth$ = 20
_ulBytes$ = -4
_fnSysReadFile@16 PROC NEAR

; 5453 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5454 :    ULONG ulBytes;
; 5455 : 
; 5456 :    if ( ReadFile( (HANDLE) lFileHandle, pchBuffer, ulMaxLth, &ulBytes, 0 ) )

	push	0
	lea	eax, DWORD PTR _ulBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulMaxLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	call	DWORD PTR __imp__ReadFile@20
	test	eax, eax
	je	SHORT $L62392

; 5457 :       return( ulBytes );

	mov	eax, DWORD PTR _ulBytes$[ebp]
	jmp	SHORT $L62393
$L62392:

; 5458 :    else
; 5459 :       return( 0 );

	xor	eax, eax
$L62393:

; 5460 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysReadFile@16 ENDP
_TEXT	ENDS
PUBLIC	_SysReadFile@16
_TEXT	SEGMENT
_lpTaskView$ = 8
_lFileHandle$ = 12
_pchBuffer$ = 16
_ulMaxLth$ = 20
_lpTask$ = -4
_SysReadFile@16 PROC NEAR

; 5467 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5468 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64863
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64864
$L64863:
	mov	DWORD PTR -8+[ebp], 0
$L64864:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 5469 : 
; 5470 :    return( fnSysReadFile( lpTask, lFileHandle, pchBuffer, ulMaxLth ) );

	mov	eax, DWORD PTR _ulMaxLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lFileHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadFile@16

; 5471 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysReadFile@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@NLFO@SysReadLine?5null?5OpenFile?$AA@	; `string'
PUBLIC	??_C@_0BO@JEGM@SysReadLine?5?4?4?4?5no?5open?5files?$AA@ ; `string'
PUBLIC	??_C@_0CL@CHJM@SysReadLine?5?4?4?4?5buffer?5acquisiti@ ; `string'
EXTRN	_DisplayOpenFiles@8:NEAR
EXTRN	_IssueError@16:NEAR
;	COMDAT ??_C@_0BK@NLFO@SysReadLine?5null?5OpenFile?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BK@NLFO@SysReadLine?5null?5OpenFile?$AA@ DB 'SysReadLine null Open'
	DB	'File', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@JEGM@SysReadLine?5?4?4?4?5no?5open?5files?$AA@
_DATA	SEGMENT
??_C@_0BO@JEGM@SysReadLine?5?4?4?4?5no?5open?5files?$AA@ DB 'SysReadLine '
	DB	'... no open files', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CL@CHJM@SysReadLine?5?4?4?4?5buffer?5acquisiti@
_DATA	SEGMENT
??_C@_0CL@CHJM@SysReadLine?5?4?4?4?5buffer?5acquisiti@ DB 'SysReadLine ..'
	DB	'. buffer acquisition failure', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_lpReturnLine$ = 12
_lFileHandle$ = 16
_ppvFile$ = 20
_uPos$ = -16
_uEnd$ = -4
_lpOpenFile$ = -12
_lpBuffer$ = -8
_vTask$62429 = -20
_vTask$62442 = -24
_fnSysReadLine@16 PROC NEAR

; 5496 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 5497 :    unsigned int  uPos;
; 5498 :    unsigned int  uEnd;
; 5499 :    LPOPENFILE lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0

; 5500 :    zPCHAR   lpBuffer;
; 5501 : 
; 5502 :    *lpReturnLine = 0;

	mov	eax, DWORD PTR _lpReturnLine$[ebp]
	mov	DWORD PTR [eax], 0

; 5503 :    if ( ppvFile && *ppvFile )

	cmp	DWORD PTR _ppvFile$[ebp], 0
	je	SHORT $L62420
	mov	ecx, DWORD PTR _ppvFile$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L62420

; 5505 :       lpOpenFile = (LPOPENFILE) *ppvFile;

	mov	edx, DWORD PTR _ppvFile$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 5506 :       if ( lpOpenFile->lFileHandle != lFileHandle )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _lFileHandle$[ebp]
	je	SHORT $L62420

; 5508 :          lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0
$L62420:

; 5511 : 
; 5512 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $L62425

; 5514 :       lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+118]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
$L62424:

; 5515 :       while ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	je	SHORT $L62425

; 5517 :          if ( lpOpenFile->lFileHandle == lFileHandle )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _lFileHandle$[ebp]
	jne	SHORT $L62426

; 5518 :             break;

	jmp	SHORT $L62425
$L62426:

; 5519 : 
; 5520 :          lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 5521 :       }

	jmp	SHORT $L62424
$L62425:

; 5523 : 
; 5524 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $L62428

; 5526 :       zVIEW vTask = zGETPTR( lpTask->hFirstView );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vTask$62429[ebp], eax

; 5527 : 
; 5528 :       fnStartBrowseOfTaskList( zGETHNDL( lpTask ), FALSE );

	push	0
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	_fnStartBrowseOfTaskList@8

; 5529 :       DisplayOpenFiles( "SysReadLine null OpenFile", zGETHNDL( lpTask ) );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET FLAT:??_C@_0BK@NLFO@SysReadLine?5null?5OpenFile?$AA@ ; `string'
	call	_DisplayOpenFiles@8

; 5530 :       fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 5531 :       IssueError( vTask, 0, 0, "SysReadLine ... no open files" );

	push	OFFSET FLAT:??_C@_0BO@JEGM@SysReadLine?5?4?4?4?5no?5open?5files?$AA@ ; `string'
	push	0
	push	0
	mov	ecx, DWORD PTR _vTask$62429[ebp]
	push	ecx
	call	_IssueError@16

; 5532 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L62413
$L62428:

; 5534 : 
; 5535 :    // File found ... get a file read buffer if necessary.
; 5536 :    if ( ppvFile )

	cmp	DWORD PTR _ppvFile$[ebp], 0
	je	SHORT $L62435

; 5537 :       *ppvFile = lpOpenFile;

	mov	edx, DWORD PTR _ppvFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx], eax
$L62435:

; 5538 : 
; 5539 :    if ( lpOpenFile->uReadBufferSize == 0 )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [ecx+530], 0
	jne	$L62436

; 5541 :       lpOpenFile->uReadBufferSize = 32770;   // 32768 + 2;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+530], 32770		; 00008002H
$L62438:

; 5542 :       while ( lpOpenFile->uReadBufferSize > 1026 )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+530], 1026		; 00000402H
	jbe	SHORT $L62439

; 5544 :          lpOpenFile->hReadBuffer = fnAllocDataspace( lpTask->hFirstDataHeader,
; 5545 :                                                      lpOpenFile->uReadBufferSize, 0, 0, 0 );

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+530]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+542], eax

; 5546 :          if ( lpOpenFile->hReadBuffer )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+542], 0
	je	SHORT $L62440

; 5547 :             break;

	jmp	SHORT $L62439
$L62440:

; 5548 : 
; 5549 :          lpOpenFile->uReadBufferSize -= 1024;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+530]
	sub	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+530], edx

; 5550 :       }

	jmp	SHORT $L62438
$L62439:

; 5551 : 
; 5552 :       if ( lpOpenFile->hReadBuffer == 0 )  // if buffer acquisition failed

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [ecx+542], 0
	jne	SHORT $L62441

; 5554 :          zVIEW vTask = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vTask$62442[ebp], eax

; 5555 : 
; 5556 :          IssueError( vTask, 0, 0, "SysReadLine ... buffer acquisition failure" );

	push	OFFSET FLAT:??_C@_0CL@CHJM@SysReadLine?5?4?4?4?5buffer?5acquisiti@ ; `string'
	push	0
	push	0
	mov	ecx, DWORD PTR _vTask$62442[ebp]
	push	ecx
	call	_IssueError@16

; 5557 :          lpOpenFile->uReadBufferSize = 0;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+530], 0

; 5558 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L62413
$L62441:

; 5560 : 
; 5561 :       // Bump size down by 2 so we can safely null terminate lines.
; 5562 :       lpOpenFile->uReadBufferSize -= 2;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+530]
	sub	ecx, 2
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+530], ecx

; 5563 : 
; 5564 :       lpBuffer = zGETPTR( lpOpenFile->hReadBuffer );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+542]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpBuffer$[ebp], eax

; 5565 : 
; 5566 :       // Read the first block of information into the buffer.
; 5567 :       lpOpenFile->uReadBufferUsed = fnSysReadFile( lpTask,
; 5568 :                                                    lpOpenFile->lFileHandle,
; 5569 :                                                    lpBuffer,
; 5570 :                                                    lpOpenFile->uReadBufferSize );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+530]
	push	eax
	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadFile@16
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+534], eax

; 5572 :    else

	jmp	$L62452
$L62436:

; 5573 :    // See if it is time to read more of the file in before continuing.
; 5574 :    if ( lpOpenFile->uReadBufferUsed == lpOpenFile->uReadBufferSize &&
; 5575 :         lpOpenFile->uReadBufferPos > (lpOpenFile->uReadBufferSize -
; 5576 :                                       (lpOpenFile->uReadBufferSize / 10)) )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [eax+534]
	cmp	edx, DWORD PTR [ecx+530]
	jne	$L62447
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [eax+530]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+530]
	sub	ecx, eax
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [edx+538], ecx
	jbe	$L62447

; 5578 :       lpBuffer = zGETPTR( lpOpenFile->hReadBuffer );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+542]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpBuffer$[ebp], eax

; 5579 : 
; 5580 :       // Copy remaining unprocessed buffer to beginning of buffer.
; 5581 :       if ( lpOpenFile->uReadBufferPos < lpOpenFile->uReadBufferSize )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+538]
	cmp	ecx, DWORD PTR [eax+530]
	jae	SHORT $L62449

; 5583 :          zmemcpy( lpBuffer,
; 5584 :                   &lpBuffer[ lpOpenFile->uReadBufferPos ],
; 5585 :                   lpOpenFile->uReadBufferSize - lpOpenFile->uReadBufferPos );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+530]
	sub	ecx, DWORD PTR [eax+538]
	push	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpBuffer$[ebp]
	add	eax, DWORD PTR [edx+538]
	push	eax
	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$L62449:

; 5587 : 
; 5588 :       // Adjust the position and used values.
; 5589 :       lpOpenFile->uReadBufferUsed -= lpOpenFile->uReadBufferPos;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+534]
	sub	ecx, DWORD PTR [eax+538]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+534], ecx

; 5590 :       lpOpenFile->uReadBufferPos  = 0;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+538], 0

; 5591 : 
; 5592 :       // Read another chunk of the file data.
; 5593 :       lpOpenFile->uReadBufferUsed +=
; 5594 :        fnSysReadFile( lpTask,
; 5595 :                       lpOpenFile->lFileHandle,
; 5596 :                       (zPCHAR) (lpBuffer + lpOpenFile->uReadBufferUsed),
; 5597 :                       (zULONG) (lpOpenFile->uReadBufferSize -
; 5598 :                                             lpOpenFile->uReadBufferUsed) );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [ecx+530]
	sub	eax, DWORD PTR [edx+534]
	push	eax
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpBuffer$[ebp]
	add	edx, DWORD PTR [ecx+534]
	push	edx
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysReadFile@16
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+534]
	add	edx, eax
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+534], edx

; 5600 :    else

	jmp	SHORT $L62452
$L62447:

; 5602 :       lpBuffer = zGETPTR( lpOpenFile->hReadBuffer );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+542]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpBuffer$[ebp], eax
$L62452:

; 5604 : 
; 5605 :    // If we get here, we're ready to proceed ahead in getting
; 5606 :    // a line to return.
; 5607 :    uPos = lpOpenFile->uReadBufferPos;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+538]
	mov	DWORD PTR _uPos$[ebp], ecx

; 5608 :    uEnd = lpOpenFile->uReadBufferUsed;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+534]
	mov	DWORD PTR _uEnd$[ebp], eax

; 5609 : 
; 5610 :    // If current pos is end of file, and we're at the end of file,
; 5611 :    // skip the rest of the data.
; 5612 :    if ( lpBuffer[ uPos ] == '\x1a' )

	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	add	ecx, DWORD PTR _uPos$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 26					; 0000001aH
	jne	SHORT $L62455

; 5614 :       // If followed by a crlf or new-line, also skip that.
; 5615 :       if ( (uPos + 1) >= uEnd ||
; 5616 :            (lpBuffer[ uPos + 1 ] == '\n' &&
; 5617 :             uPos + 2 >= uEnd) ||
; 5618 :            (lpBuffer[ uPos + 1 ] == '\r' &&
; 5619 :             lpBuffer[ uPos + 2 ] == '\n' &&
; 5620 :             uPos + 3 >= uEnd) )

	mov	eax, DWORD PTR _uPos$[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR _uEnd$[ebp]
	jae	SHORT $L62456
	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	add	ecx, DWORD PTR _uPos$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $L62457
	mov	eax, DWORD PTR _uPos$[ebp]
	add	eax, 2
	cmp	eax, DWORD PTR _uEnd$[ebp]
	jae	SHORT $L62456
$L62457:
	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	add	ecx, DWORD PTR _uPos$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $L62455
	mov	eax, DWORD PTR _lpBuffer$[ebp]
	add	eax, DWORD PTR _uPos$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $L62455
	mov	edx, DWORD PTR _uPos$[ebp]
	add	edx, 3
	cmp	edx, DWORD PTR _uEnd$[ebp]
	jb	SHORT $L62455
$L62456:

; 5622 :          uPos = uEnd;

	mov	eax, DWORD PTR _uEnd$[ebp]
	mov	DWORD PTR _uPos$[ebp], eax
$L62455:

; 5625 : 
; 5626 :    // If nothing to return to the user, set position to end.
; 5627 :    if ( uPos >= uEnd )

	mov	ecx, DWORD PTR _uPos$[ebp]
	cmp	ecx, DWORD PTR _uEnd$[ebp]
	jb	SHORT $L62458

; 5629 :       lpOpenFile->uReadBufferPos = lpOpenFile->uReadBufferUsed;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+534]
	mov	DWORD PTR [edx+538], ecx

; 5630 :       return( 0 );

	xor	eax, eax
	jmp	$L62413
$L62458:

; 5632 : 
; 5633 :    // Now that beginning of line is found, search for end and
; 5634 :    // put a null character there.
; 5635 :    *lpReturnLine = &lpBuffer[ uPos ];

	mov	edx, DWORD PTR _lpBuffer$[ebp]
	add	edx, DWORD PTR _uPos$[ebp]
	mov	eax, DWORD PTR _lpReturnLine$[ebp]
	mov	DWORD PTR [eax], edx
$L62460:

; 5636 :    while( uPos < uEnd &&
; 5637 :           lpBuffer[ uPos ] != '\r' &&
; 5638 :           lpBuffer[ uPos ] != '\n' &&
; 5639 :           lpBuffer[ uPos ] != '\x1a' )

	mov	ecx, DWORD PTR _uPos$[ebp]
	cmp	ecx, DWORD PTR _uEnd$[ebp]
	jae	SHORT $L62461
	mov	edx, DWORD PTR _lpBuffer$[ebp]
	add	edx, DWORD PTR _uPos$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $L62461
	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	add	ecx, DWORD PTR _uPos$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $L62461
	mov	eax, DWORD PTR _lpBuffer$[ebp]
	add	eax, DWORD PTR _uPos$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 26					; 0000001aH
	je	SHORT $L62461

; 5641 :       uPos++;

	mov	edx, DWORD PTR _uPos$[ebp]
	add	edx, 1
	mov	DWORD PTR _uPos$[ebp], edx

; 5642 :    }

	jmp	SHORT $L62460
$L62461:

; 5643 : 
; 5644 :    if ( (lpBuffer[ uPos ] == '\r' && lpBuffer[ uPos + 1 ] == '\n') ||
; 5645 :         (lpBuffer[ uPos ] == '\n' && lpBuffer[ uPos + 1 ] == '\r') )

	mov	eax, DWORD PTR _lpBuffer$[ebp]
	add	eax, DWORD PTR _uPos$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $L62464
	mov	edx, DWORD PTR _lpBuffer$[ebp]
	add	edx, DWORD PTR _uPos$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 10					; 0000000aH
	je	SHORT $L62463
$L62464:
	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	add	ecx, DWORD PTR _uPos$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $L62462
	mov	eax, DWORD PTR _lpBuffer$[ebp]
	add	eax, DWORD PTR _uPos$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $L62462
$L62463:

; 5647 :       lpBuffer[ uPos++ ] = 0;  // null end of line and skip \r or \n

	mov	edx, DWORD PTR _lpBuffer$[ebp]
	add	edx, DWORD PTR _uPos$[ebp]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _uPos$[ebp]
	add	eax, 1
	mov	DWORD PTR _uPos$[ebp], eax
$L62462:

; 5649 : 
; 5650 :    lpBuffer[ uPos++ ] = 0;            // null end of line

	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	add	ecx, DWORD PTR _uPos$[ebp]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _uPos$[ebp]
	add	edx, 1
	mov	DWORD PTR _uPos$[ebp], edx

; 5651 :    lpOpenFile->uReadBufferPos = uPos; // set new uPos

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _uPos$[ebp]
	mov	DWORD PTR [eax+538], ecx

; 5652 :    return( 1 );                       // everything is AOK

	mov	eax, 1
$L62413:

; 5653 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysReadLine@16 ENDP
_TEXT	ENDS
PUBLIC	_SysReadLine@12
_TEXT	SEGMENT
_lpTaskView$ = 8
_lpReturnLine$ = 12
_lFileHandle$ = 16
_lpTask$ = -4
_SysReadLine@12 PROC NEAR

; 5659 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5660 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64867
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64868
$L64867:
	mov	DWORD PTR -8+[ebp], 0
$L64868:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 5661 : 
; 5662 :    return( fnSysReadLine( lpTask, lpReturnLine, lFileHandle, 0 ) );

	push	0
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpReturnLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysReadLine@16

; 5663 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysReadLine@12 ENDP
_TEXT	ENDS
PUBLIC	_fnSysReadLineLth@20
_TEXT	SEGMENT
_lpTask$ = 8
_lpReturnLine$ = 12
_lFileHandle$ = 16
_ppvFile$ = 20
_ulLth$ = 24
_lpOpenFile$ = -12
_lpNewBuffer$ = -4
_lpReadBuffer$ = -8
_hNewBuffer$62509 = -16
_fnSysReadLineLth@20 PROC NEAR

; 5692 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 5693 :    LPOPENFILE    lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0

; 5694 :    zPCHAR        lpNewBuffer;
; 5695 :    zPCHAR        lpReadBuffer;
; 5696 : 
; 5697 :    *lpReturnLine = 0;

	mov	eax, DWORD PTR _lpReturnLine$[ebp]
	mov	DWORD PTR [eax], 0

; 5698 : 
; 5699 :    if ( ppvFile && *ppvFile )

	cmp	DWORD PTR _ppvFile$[ebp], 0
	je	SHORT $L62490
	mov	ecx, DWORD PTR _ppvFile$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L62490

; 5701 :       lpOpenFile = (LPOPENFILE) *ppvFile;

	mov	edx, DWORD PTR _ppvFile$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 5702 :       if ( lpOpenFile->lFileHandle != lFileHandle )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _lFileHandle$[ebp]
	je	SHORT $L62490

; 5703 :          lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0
$L62490:

; 5705 : 
; 5706 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $L62495

; 5708 :       lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+118]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
$L62494:

; 5709 :       while ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	je	SHORT $L62495

; 5711 :          if ( lpOpenFile->lFileHandle == lFileHandle )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _lFileHandle$[ebp]
	jne	SHORT $L62496

; 5712 :             break;

	jmp	SHORT $L62495
$L62496:

; 5713 : 
; 5714 :          lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 5715 :       }

	jmp	SHORT $L62494
$L62495:

; 5717 : 
; 5718 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $L62498

; 5719 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L62484
$L62498:

; 5720 : 
; 5721 :    // File found, get a file read buffer if necessary.
; 5722 :    if ( lpOpenFile->uReadBufferSize == 0 )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+530], 0
	jne	$L62499

; 5724 :       lpOpenFile->uReadBufferSize = 8192;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+530], 8192		; 00002000H
$L62501:

; 5725 :       while ( lpOpenFile->uReadBufferSize > 2040 )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [edx+530], 2040		; 000007f8H
	jbe	SHORT $L62502

; 5727 :          lpOpenFile->hReadBuffer =
; 5728 :             fnAllocDataspace( lpTask->hFirstDataHeader,
; 5729 :                               lpOpenFile->uReadBufferSize, 0, 0, 0 );

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+530]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+542], eax

; 5730 : 
; 5731 :          if ( lpOpenFile->hReadBuffer )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [edx+542], 0
	je	SHORT $L62503

; 5732 :             break;

	jmp	SHORT $L62502
$L62503:

; 5733 : 
; 5734 :          lpOpenFile->uReadBufferSize /= 2;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+530]
	shr	ecx, 1
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+530], ecx

; 5735 :       }

	jmp	SHORT $L62501
$L62502:

; 5736 : 
; 5737 :       if ( lpOpenFile->hReadBuffer == 0 )  // if buffer acquisition failed

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+542], 0
	jne	SHORT $L62504

; 5739 :          lpOpenFile->uReadBufferSize = 0;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+530], 0

; 5740 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L62484
$L62504:

; 5742 : 
; 5743 :       lpReadBuffer = zGETPTR( lpOpenFile->hReadBuffer );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+542]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpReadBuffer$[ebp], eax

; 5744 : 
; 5745 :       // Bump size down by 2 so we can safely null terminate lines
; 5746 :       lpOpenFile->uReadBufferSize -= 2;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+530]
	sub	edx, 2
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+530], edx

; 5747 : 
; 5748 :       // Read the first block of information into the buffer
; 5749 :       lpOpenFile->uReadBufferUsed = fnSysReadFile( lpTask,
; 5750 :                                                    lpOpenFile->lFileHandle,
; 5751 :                                                    lpReadBuffer,
; 5752 :                                                    lpOpenFile->uReadBufferSize );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+530]
	push	edx
	mov	eax, DWORD PTR _lpReadBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadFile@16
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+534], eax

; 5754 :    else

	jmp	SHORT $L62506
$L62499:

; 5756 :       lpReadBuffer = zGETPTR( lpOpenFile->hReadBuffer );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+542]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpReadBuffer$[ebp], eax
$L62506:

; 5758 : 
; 5759 :    // See if buffer we are using is big enough to hold the blob we want to
; 5760 :    // read, if not, we're in big trouble.
; 5761 :    if ( lpOpenFile->uReadBufferSize < ulLth )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+530]
	cmp	edx, DWORD PTR _ulLth$[ebp]
	jae	$L62508

; 5763 :       zPVOID hNewBuffer;
; 5764 : 
; 5765 :       hNewBuffer = fnAllocDataspace( lpTask->hFirstDataHeader, ulLth, 0, 0, 0 );

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hNewBuffer$62509[ebp], eax

; 5766 :       if ( hNewBuffer == 0 )

	cmp	DWORD PTR _hNewBuffer$62509[ebp], 0
	jne	SHORT $L62510

; 5767 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L62484
$L62510:

; 5768 : 
; 5769 :       lpNewBuffer = zGETPTR( hNewBuffer );

	mov	eax, DWORD PTR _hNewBuffer$62509[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewBuffer$[ebp], eax

; 5770 : 
; 5771 :       zmemcpy( lpNewBuffer, lpReadBuffer, lpOpenFile->uReadBufferSize );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+530]
	push	edx
	mov	eax, DWORD PTR _lpReadBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewBuffer$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5772 :       fnFreeDataspace( zGETPTR( lpOpenFile->hReadBuffer ) );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+542]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 5773 :       lpReadBuffer = lpNewBuffer;

	mov	ecx, DWORD PTR _lpNewBuffer$[ebp]
	mov	DWORD PTR _lpReadBuffer$[ebp], ecx

; 5774 :       lpOpenFile->hReadBuffer = hNewBuffer;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _hNewBuffer$62509[ebp]
	mov	DWORD PTR [edx+542], eax

; 5775 :       lpOpenFile->uReadBufferSize = ulLth;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR [ecx+530], edx

; 5776 :       lpOpenFile->uReadBufferUsed +=
; 5777 :             fnSysReadFile( lpTask, lpOpenFile->lFileHandle,
; 5778 :                            (zPCHAR) (lpReadBuffer + lpOpenFile->uReadBufferUsed),
; 5779 :                            (zULONG) (lpOpenFile->uReadBufferSize - lpOpenFile->uReadBufferUsed) );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [eax+530]
	sub	edx, DWORD PTR [ecx+534]
	push	edx
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpReadBuffer$[ebp]
	add	ecx, DWORD PTR [eax+534]
	push	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadFile@16
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+534]
	add	ecx, eax
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+534], ecx
$L62508:

; 5781 : 
; 5782 :    // See if it is time to read more of the file in before continuing.
; 5783 :    if ( lpOpenFile->uReadBufferUsed == lpOpenFile->uReadBufferSize &&
; 5784 :         (lpOpenFile->uReadBufferSize - lpOpenFile->uReadBufferPos) < ulLth )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [eax+534]
	cmp	edx, DWORD PTR [ecx+530]
	jne	$L62515
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [eax+530]
	sub	edx, DWORD PTR [ecx+538]
	cmp	edx, DWORD PTR _ulLth$[ebp]
	jae	$L62515

; 5786 :       // Copy remaining unprocessed buffer to beginning of buffer.
; 5787 :       if ( lpOpenFile->uReadBufferPos < lpOpenFile->uReadBufferSize )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [eax+538]
	cmp	edx, DWORD PTR [ecx+530]
	jae	SHORT $L62516

; 5789 :          zmemcpy( lpReadBuffer,
; 5790 :                   &lpReadBuffer[ lpOpenFile->uReadBufferPos ],
; 5791 :                   lpOpenFile->uReadBufferSize - lpOpenFile->uReadBufferPos );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [eax+530]
	sub	edx, DWORD PTR [ecx+538]
	push	edx
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpReadBuffer$[ebp]
	add	ecx, DWORD PTR [eax+538]
	push	ecx
	mov	edx, DWORD PTR _lpReadBuffer$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$L62516:

; 5793 : 
; 5794 :       // Adjust the position and used values.
; 5795 :       lpOpenFile->uReadBufferUsed -= lpOpenFile->uReadBufferPos;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [eax+534]
	sub	edx, DWORD PTR [ecx+538]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+534], edx

; 5796 :       lpOpenFile->uReadBufferPos = 0;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+538], 0

; 5797 : 
; 5798 :       // Read another chunk of the file data.
; 5799 :       lpOpenFile->uReadBufferUsed +=
; 5800 :          fnSysReadFile( lpTask, lpOpenFile->lFileHandle,
; 5801 :                         (zPCHAR) ((zPCHAR) zGETPTR( lpOpenFile->hReadBuffer ) +
; 5802 :                                   lpOpenFile->uReadBufferUsed),
; 5803 :                         (zULONG) (lpOpenFile->uReadBufferSize -
; 5804 :                                   lpOpenFile->uReadBufferUsed) );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+530]
	sub	ecx, DWORD PTR [eax+534]
	push	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+542]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	add	eax, DWORD PTR [ecx+534]
	push	eax
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadFile@16
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+534]
	add	ecx, eax
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+534], ecx
$L62515:

; 5806 : 
; 5807 :    // Now that beginning of line is found, search for end and
; 5808 :    // put a null character there.
; 5809 :    *lpReturnLine = &lpReadBuffer[ lpOpenFile->uReadBufferPos ];

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpReadBuffer$[ebp]
	add	ecx, DWORD PTR [eax+538]
	mov	edx, DWORD PTR _lpReturnLine$[ebp]
	mov	DWORD PTR [edx], ecx

; 5810 :    lpOpenFile->uReadBufferPos += ulLth; // set new uPos

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+538]
	add	ecx, DWORD PTR _ulLth$[ebp]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+538], ecx

; 5811 :    return( 1 );                         // everything is AOK

	mov	ax, 1
$L62484:

; 5812 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnSysReadLineLth@20 ENDP
_TEXT	ENDS
PUBLIC	_SysReadLineLth@16
_TEXT	SEGMENT
_lpTaskView$ = 8
_lpReturnLine$ = 12
_lFileHandle$ = 16
_ulLth$ = 20
_lpTask$ = -4
_SysReadLineLth@16 PROC NEAR

; 5819 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5820 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64871
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64872
$L64871:
	mov	DWORD PTR -8+[ebp], 0
$L64872:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 5821 : 
; 5822 :    return( fnSysReadLineLth( lpTask, lpReturnLine, lFileHandle, 0, ulLth ) );

	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lFileHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpReturnLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLineLth@20

; 5823 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysReadLineLth@16 ENDP
_TEXT	ENDS
EXTRN	__imp__WriteFile@20:NEAR
EXTRN	_fnIssueCoreError:NEAR
_TEXT	SEGMENT
_lpTask$ = 8
_lFileHandle$ = 12
_cpcBuffer$ = 16
_ulLth$ = 20
_ulWritten$ = -4
_lpOpenFile$62544 = -8
_fnSysWriteFile@16 PROC NEAR

; 5848 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5849 :    zULONG ulWritten;
; 5850 : 
; 5851 :    WriteFile( (HANDLE) lFileHandle, cpcBuffer, ulLth, &ulWritten, 0 );

	push	0
	lea	eax, DWORD PTR _ulWritten$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	call	DWORD PTR __imp__WriteFile@20

; 5852 : 
; 5853 :    if ( ulWritten != ulLth )

	mov	ecx, DWORD PTR _ulWritten$[ebp]
	cmp	ecx, DWORD PTR _ulLth$[ebp]
	je	SHORT $L62551

; 5855 :       LPOPENFILE  lpOpenFile;
; 5856 : 
; 5857 :       lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+118]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$62544[ebp], eax
$L62547:

; 5858 :       while ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$62544[ebp], 0
	je	SHORT $L62548

; 5860 :          if ( lpOpenFile->lFileHandle == lFileHandle )

	mov	ecx, DWORD PTR _lpOpenFile$62544[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _lFileHandle$[ebp]
	jne	SHORT $L62549

; 5861 :             break;

	jmp	SHORT $L62548
$L62549:

; 5862 : 
; 5863 :          lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile );

	mov	eax, DWORD PTR _lpOpenFile$62544[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$62544[ebp], eax

; 5864 :       }

	jmp	SHORT $L62547
$L62548:

; 5865 : 
; 5866 :       if ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$62544[ebp], 0
	je	SHORT $L62551

; 5868 :          // "KZOEE022 - Error writing file"
; 5869 :          fnIssueCoreError( lpTask, 0, 8, 22, 0,
; 5870 :                            lpOpenFile->szFileName, 0 );

	push	0
	mov	edx, DWORD PTR _lpOpenFile$62544[ebp]
	add	edx, 16					; 00000010H
	push	edx
	push	0
	push	22					; 00000016H
	push	8
	push	0
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$L62551:

; 5873 : 
; 5874 :    return( ulWritten );

	mov	eax, DWORD PTR _ulWritten$[ebp]

; 5875 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysWriteFile@16 ENDP
_TEXT	ENDS
PUBLIC	_SysWriteFile@16
_TEXT	SEGMENT
_lpTaskView$ = 8
_lFileHandle$ = 12
_cpcBuffer$ = 16
_ulLth$ = 20
_lpTask$ = -4
_SysWriteFile@16 PROC NEAR

; 5882 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5883 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64875
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64876
$L64875:
	mov	DWORD PTR -8+[ebp], 0
$L64876:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 5884 : 
; 5885 :    return( fnSysWriteFile( lpTask, lFileHandle, cpcBuffer, ulLth ) );

	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lFileHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteFile@16

; 5886 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysWriteFile@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_02PIMC@?$AN?6?$AA@			; `string'
;	COMDAT ??_C@_02PIMC@?$AN?6?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_02PIMC@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_lFileHandle$ = 12
_ppvFile$ = 16
_cpcLine$ = 20
_lLth$ = -4
_lpWriteBuffer$ = -12
_lpOpenFile$ = -8
_fnSysWriteLine@16 PROC NEAR

; 5911 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 5912 :    zLONG      lLth;
; 5913 :    zPCHAR     lpWriteBuffer;
; 5914 :    LPOPENFILE lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0

; 5915 : 
; 5916 :    // Get the task an match up the file handle passed with an
; 5917 :    // OpenFile record. If the record is not found, return a zCALL_ERROR;
; 5918 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L62575

; 5919 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L62571
$L62575:

; 5920 : 
; 5921 :    if ( ppvFile && *ppvFile )

	cmp	DWORD PTR _ppvFile$[ebp], 0
	je	SHORT $L62578
	mov	eax, DWORD PTR _ppvFile$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L62578

; 5923 :       lpOpenFile = (LPOPENFILE) *ppvFile;

	mov	ecx, DWORD PTR _ppvFile$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpOpenFile$[ebp], edx

; 5924 :       if ( lpOpenFile->lFileHandle != lFileHandle )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _lFileHandle$[ebp]
	je	SHORT $L62578

; 5925 :          lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0
$L62578:

; 5927 : 
; 5928 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $L62583

; 5930 :       lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+118]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
$L62582:

; 5931 :       while ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	je	SHORT $L62583

; 5933 :          if ( lpOpenFile->lFileHandle == lFileHandle )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _lFileHandle$[ebp]
	jne	SHORT $L62584

; 5934 :             break;

	jmp	SHORT $L62583
$L62584:

; 5935 : 
; 5936 :          lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 5937 :       }

	jmp	SHORT $L62582
$L62583:

; 5939 : 
; 5940 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $L62586

; 5941 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L62571
$L62586:

; 5942 : 
; 5943 :    // Check to see if buffered WriteLines desired, if not, write it.
; 5944 :    if ( (lpOpenFile->nFlags & COREFILE_WRITELINE_BUFFERED) == 0 )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	movsx	eax, WORD PTR [edx+10]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L62587

; 5946 :       fnSysWriteFile( lpTask, lFileHandle, cpcLine, zstrlen( cpcLine ) );

	mov	ecx, DWORD PTR _cpcLine$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _cpcLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteFile@16

; 5947 :       fnSysWriteFile( lpTask, lFileHandle, "\r\n", 2 );

	push	2
	push	OFFSET FLAT:??_C@_02PIMC@?$AN?6?$AA@	; `string'
	mov	edx, DWORD PTR _lFileHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteFile@16

; 5948 :       return( 0 );

	xor	eax, eax
	jmp	$L62571
$L62587:

; 5950 : 
; 5951 :    // File found, get a file read buffer is necessary.
; 5952 :    if ( lpOpenFile->uWriteBufferSize == 0 )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [ecx+546], 0
	jne	$L62589

; 5954 :       lpOpenFile->uWriteBufferSize = 8192;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+546], 8192		; 00002000H
$L62591:

; 5955 :       while ( lpOpenFile->uWriteBufferSize > 2040 )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+546], 2040		; 000007f8H
	jbe	SHORT $L62592

; 5957 :          lpOpenFile->hWriteBuffer =
; 5958 :             fnAllocDataspace( lpTask->hFirstDataHeader,
; 5959 :                               lpOpenFile->uWriteBufferSize, 0, 0, 0 );

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+546]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+554], eax

; 5960 :          if ( lpOpenFile->hWriteBuffer )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+554], 0
	je	SHORT $L62593

; 5961 :             break;

	jmp	SHORT $L62592
$L62593:

; 5962 : 
; 5963 :          lpOpenFile->uWriteBufferSize /= 2;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+546]
	shr	edx, 1
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+546], edx

; 5964 :       }

	jmp	SHORT $L62591
$L62592:

; 5965 : 
; 5966 :       if ( lpOpenFile->hWriteBuffer == 0 )  // if buffer acquisition failed

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [ecx+554], 0
	jne	SHORT $L62594

; 5968 :          lpOpenFile->uWriteBufferSize = 0;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+546], 0

; 5969 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L62571
$L62594:

; 5971 : 
; 5972 :       // Bump size down by 2 for safety.
; 5973 :       lpOpenFile->uWriteBufferSize -= 2;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+546]
	sub	ecx, 2
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+546], ecx
$L62589:

; 5975 : 
; 5976 :    lpWriteBuffer = zGETPTR( lpOpenFile->hWriteBuffer );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+554]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWriteBuffer$[ebp], eax

; 5977 : 
; 5978 :    // Get the length of the line to be written.
; 5979 :    lLth = zstrlen( cpcLine );

	mov	edx, DWORD PTR _cpcLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lLth$[ebp], eax

; 5980 : 
; 5981 :    // If there is not buffer room to write this line, write out the buffer
; 5982 :    // and reset position.
; 5983 :    if ( (zULONG) (lpOpenFile->uWriteBufferSize -
; 5984 :                   lpOpenFile->uWriteBufferPos) < (zULONG) (lLth + 2) )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [eax+546]
	sub	edx, DWORD PTR [ecx+550]
	mov	eax, DWORD PTR _lLth$[ebp]
	add	eax, 2
	cmp	edx, eax
	jae	SHORT $L62598

; 5986 :       fnSysWriteFile( lpTask, lFileHandle, lpWriteBuffer, lpOpenFile->uWriteBufferPos );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+550]
	push	edx
	mov	eax, DWORD PTR _lpWriteBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lFileHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteFile@16

; 5987 :       lpOpenFile->uWriteBufferPos = 0;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+550], 0
$L62598:

; 5989 : 
; 5990 :    // Copy the new line into the Buffer.
; 5991 :    zstrcpy( &lpWriteBuffer[ lpOpenFile->uWriteBufferPos ], cpcLine );

	mov	ecx, DWORD PTR _cpcLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpWriteBuffer$[ebp]
	add	eax, DWORD PTR [edx+550]
	push	eax
	call	_strcpy
	add	esp, 8

; 5992 :    lpOpenFile->uWriteBufferPos += lLth;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+550]
	add	edx, DWORD PTR _lLth$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+550], edx

; 5993 :    zstrcpy( &lpWriteBuffer[ lpOpenFile->uWriteBufferPos ], "\r\n" );

	push	OFFSET FLAT:??_C@_02PIMC@?$AN?6?$AA@	; `string'
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpWriteBuffer$[ebp]
	add	edx, DWORD PTR [ecx+550]
	push	edx
	call	_strcpy
	add	esp, 8

; 5994 :    lpOpenFile->uWriteBufferPos += 2;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+550]
	add	ecx, 2
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+550], ecx

; 5995 : 
; 5996 :    return( 0 );

	xor	eax, eax
$L62571:

; 5997 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysWriteLine@16 ENDP
_TEXT	ENDS
PUBLIC	_SysWriteLine@12
_TEXT	SEGMENT
_lpTaskView$ = 8
_lFileHandle$ = 12
_cpcLine$ = 16
_lpTask$ = -4
_SysWriteLine@12 PROC NEAR

; 6003 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6004 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64879
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64880
$L64879:
	mov	DWORD PTR -8+[ebp], 0
$L64880:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 6005 : 
; 6006 :    return( fnSysWriteLine( lpTask, lFileHandle, 0, cpcLine ) );

	mov	eax, DWORD PTR _cpcLine$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lFileHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 6007 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysWriteLine@12 ENDP
_TEXT	ENDS
PUBLIC	_fnSysWriteLineLth@24
_TEXT	SEGMENT
_lpTask$ = 8
_lFileHandle$ = 12
_ppvFile$ = 16
_cpcLine$ = 20
_ulLth$ = 24
_bAppend$ = 28
_lpWriteBuffer$ = -8
_lpOpenFile$ = -4
_fnSysWriteLineLth@24 PROC NEAR

; 6036 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6037 :    zPCHAR        lpWriteBuffer;
; 6038 :    LPOPENFILE    lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0

; 6039 : 
; 6040 :    if ( ppvFile && *ppvFile )

	cmp	DWORD PTR _ppvFile$[ebp], 0
	je	SHORT $L62625
	mov	eax, DWORD PTR _ppvFile$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L62625

; 6042 :       lpOpenFile = (LPOPENFILE) *ppvFile;

	mov	ecx, DWORD PTR _ppvFile$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpOpenFile$[ebp], edx

; 6043 :       if ( lpOpenFile->lFileHandle != lFileHandle )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _lFileHandle$[ebp]
	je	SHORT $L62625

; 6044 :          lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0
$L62625:

; 6046 : 
; 6047 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $L62630

; 6049 :       lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+118]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
$L62629:

; 6050 :       while ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	je	SHORT $L62630

; 6052 :          if ( lpOpenFile->lFileHandle == lFileHandle )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _lFileHandle$[ebp]
	jne	SHORT $L62631

; 6053 :             break;

	jmp	SHORT $L62630
$L62631:

; 6054 : 
; 6055 :          lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 6056 :       }

	jmp	SHORT $L62629
$L62630:

; 6058 : 
; 6059 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $L62633

; 6060 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L62620
$L62633:

; 6061 : 
; 6062 :    // Check to see if buffered WriteLines desired, if not, write it.
; 6063 :    if ( (lpOpenFile->nFlags & COREFILE_WRITELINE_BUFFERED) == 0 )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	movsx	eax, WORD PTR [edx+10]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L62634

; 6065 :       fnSysWriteFile( lpTask, lFileHandle, cpcLine, ulLth );

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteFile@16

; 6066 :       if ( bAppend )

	mov	edx, DWORD PTR _bAppend$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L62635

; 6067 :          fnSysWriteFile( lpTask, lFileHandle, "\r\n", 2 );

	push	2
	push	OFFSET FLAT:??_C@_02PIMC@?$AN?6?$AA@	; `string'
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteFile@16
$L62635:

; 6068 : 
; 6069 :       return( 0 );

	xor	eax, eax
	jmp	$L62620
$L62634:

; 6071 : 
; 6072 :    // File found, get a file read buffer is necessary.
; 6073 :    if ( lpOpenFile->uWriteBufferSize == 0 )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [edx+546], 0
	jne	$L62636

; 6075 :       lpOpenFile->uWriteBufferSize = 8192;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+546], 8192		; 00002000H
$L62638:

; 6076 :       while ( lpOpenFile->uWriteBufferSize > 2040 )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [ecx+546], 2040		; 000007f8H
	jbe	SHORT $L62639

; 6078 :          lpOpenFile->hWriteBuffer =
; 6079 :             fnAllocDataspace( lpTask->hFirstDataHeader,
; 6080 :                               lpOpenFile->uWriteBufferSize, 0, 0, 0 );

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+546]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+554], eax

; 6081 :          if ( lpOpenFile->hWriteBuffer )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [edx+554], 0
	je	SHORT $L62640

; 6082 :             break;

	jmp	SHORT $L62639
$L62640:

; 6083 : 
; 6084 :          lpOpenFile->uWriteBufferSize /= 2;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+546]
	shr	ecx, 1
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+546], ecx

; 6085 :       }

	jmp	SHORT $L62638
$L62639:

; 6086 : 
; 6087 :       if ( lpOpenFile->hWriteBuffer == 0 )  // if buffer acquisition failed

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+554], 0
	jne	SHORT $L62641

; 6089 :          lpOpenFile->uWriteBufferSize = 0;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+546], 0

; 6090 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L62620
$L62641:

; 6092 : 
; 6093 :       // Bump size down by 2 for safety.
; 6094 :       lpOpenFile->uWriteBufferSize -= 2;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+546]
	sub	eax, 2
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+546], eax
$L62636:

; 6096 : 
; 6097 :    lpWriteBuffer = zGETPTR( lpOpenFile->hWriteBuffer );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+554]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWriteBuffer$[ebp], eax

; 6098 : 
; 6099 :    // If there is not buffer room to write this line, write out buffer and
; 6100 :    // reset position.
; 6101 :    if ( (lpOpenFile->uWriteBufferSize -
; 6102 :                                    lpOpenFile->uWriteBufferPos) < ulLth + 2 )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [ecx+546]
	sub	eax, DWORD PTR [edx+550]
	mov	ecx, DWORD PTR _ulLth$[ebp]
	add	ecx, 2
	cmp	eax, ecx
	jae	SHORT $L62643

; 6104 :       fnSysWriteFile( lpTask, lFileHandle, lpWriteBuffer, lpOpenFile->uWriteBufferPos );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+550]
	push	eax
	mov	ecx, DWORD PTR _lpWriteBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lFileHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteFile@16

; 6105 :       lpOpenFile->uWriteBufferPos = 0;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+550], 0
$L62643:

; 6107 : 
; 6108 :    // If the write to be done is bigger than the buffer, simply write
; 6109 :    // the line passed and put a crlf in the buffer.
; 6110 :    if ( lpOpenFile->uWriteBufferSize < ulLth + 2 )

	mov	edx, DWORD PTR _ulLth$[ebp]
	add	edx, 2
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+546], edx
	jae	SHORT $L62644

; 6112 :       fnSysWriteFile( lpTask, lFileHandle, cpcLine, ulLth );

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteFile@16

; 6114 :    else

	jmp	SHORT $L62645
$L62644:

; 6116 :       // Copy the new line into the Buffer.
; 6117 :       zmemcpy( &lpWriteBuffer[ lpOpenFile->uWriteBufferPos ], cpcLine, ulLth );

	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpWriteBuffer$[ebp]
	add	edx, DWORD PTR [ecx+550]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6118 :       lpOpenFile->uWriteBufferPos += ulLth;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+550]
	add	ecx, DWORD PTR _ulLth$[ebp]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+550], ecx
$L62645:

; 6120 : 
; 6121 :    if ( bAppend )

	mov	eax, DWORD PTR _bAppend$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L62646

; 6123 :       zstrcpy( &lpWriteBuffer[ lpOpenFile->uWriteBufferPos ], "\r\n" );

	push	OFFSET FLAT:??_C@_02PIMC@?$AN?6?$AA@	; `string'
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpWriteBuffer$[ebp]
	add	edx, DWORD PTR [ecx+550]
	push	edx
	call	_strcpy
	add	esp, 8

; 6124 :       lpOpenFile->uWriteBufferPos += 2;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+550]
	add	ecx, 2
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+550], ecx
$L62646:

; 6126 : 
; 6127 :    return( 0 );

	xor	eax, eax
$L62620:

; 6128 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnSysWriteLineLth@24 ENDP
_TEXT	ENDS
PUBLIC	_SysWriteLineLth@20
_TEXT	SEGMENT
_lpTaskView$ = 8
_lFileHandle$ = 12
_cpcLine$ = 16
_ulLth$ = 20
_bAppend$ = 24
_lpTask$ = -4
_SysWriteLineLth@20 PROC NEAR

; 6136 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6137 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64883
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64884
$L64883:
	mov	DWORD PTR -8+[ebp], 0
$L64884:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 6138 : 
; 6139 :    return( fnSysWriteLineLth( lpTask, lFileHandle, 0,
; 6140 :                               cpcLine, ulLth, bAppend ) );

	mov	al, BYTE PTR _bAppend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcLine$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLineLth@24

; 6141 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SysWriteLineLth@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FG@EBEM@fnSysCloseFileWithControl?5?$CFs?5?5?5H@ ; `string'
PUBLIC	_fnSysCloseFileWithControl@16
;	COMDAT ??_C@_0FG@EBEM@fnSysCloseFileWithControl?5?$CFs?5?5?5H@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0FG@EBEM@fnSysCloseFileWithControl?5?$CFs?5?5?5H@ DB 'fnSysCloseFil'
	DB	'eWithControl %s   Handle: 0x%08x   Task: 0x%08x   Process: 0x'
	DB	'%08x:0x%08x', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_lFileHandle$ = 12
_lpOwningTask$ = 16
_lControl$ = 20
_lpOpenFile$ = -12
_lpPrevOpenFile$ = -8
_nRC$ = -4
_lProcessID$62687 = -16
_fnSysCloseFileWithControl@16 PROC NEAR

; 6169 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 6170 :    LPOPENFILE  lpOpenFile;
; 6171 :    LPOPENFILE  lpPrevOpenFile;
; 6172 :    zSHORT      nRC;
; 6173 : 
; 6174 :    nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 6175 : 
; 6176 : // TraceLine( "fnSysCloseFileWithControl ??   Handle: 0x%08x   Task: 0x%08x   Process: 0x%08x",
; 6177 : //            lFileHandle, lpTask, lProcessID );
; 6178 : 
; 6179 :    // Get the task and match up the file handle passed with an
; 6180 :    // OpenFile record. If the record is not found, return a zCALL_ERROR;
; 6181 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L62672

; 6182 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L62668
$L62672:

; 6183 : 
; 6184 :    if ( lpOwningTask == 0 )

	cmp	DWORD PTR _lpOwningTask$[ebp], 0
	jne	SHORT $L62673

; 6185 :       lpOwningTask = lpTask;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], eax
$L62673:

; 6186 : 
; 6187 :    zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 6188 : 
; 6189 :    // Find open file and prev open file.
; 6190 :    for ( lpPrevOpenFile = 0, lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );
; 6191 :          lpOpenFile;
; 6192 :          lpPrevOpenFile = lpOpenFile, lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile ) )

	mov	DWORD PTR _lpPrevOpenFile$[ebp], 0
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+118]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
	jmp	SHORT $L62676
$L62677:
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR _lpPrevOpenFile$[ebp], eax
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
$L62676:
	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	je	SHORT $L62678

; 6194 :       if ( lpOpenFile->lFileHandle == lFileHandle )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _lFileHandle$[ebp]
	jne	SHORT $L62679

; 6195 :          break;

	jmp	SHORT $L62678
$L62679:

; 6196 :    }

	jmp	SHORT $L62677
$L62678:

; 6197 : 
; 6198 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $L62680

; 6200 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 6201 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L62668
$L62680:

; 6203 : 
; 6204 :    if ( lpPrevOpenFile )

	cmp	DWORD PTR _lpPrevOpenFile$[ebp], 0
	je	SHORT $L62681

; 6205 :       lpPrevOpenFile->hNextOpenFile = lpOpenFile->hNextOpenFile;

	mov	edx, DWORD PTR _lpPrevOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR [edx+6], ecx

; 6206 :    else

	jmp	SHORT $L62682
$L62681:

; 6207 :       lpTask->hFirstOpenFile = lpOpenFile->hNextOpenFile;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR [edx+118], ecx
$L62682:

; 6208 : 
; 6209 :    zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 6210 : 
; 6211 :    // If the file has been used for buffered writes, write it out now.
; 6212 :    if ( lpOpenFile->nFlags & COREFILE_WRITELINE_BUFFERED )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	movsx	eax, WORD PTR [edx+10]
	and	eax, 1
	test	eax, eax
	je	SHORT $L62684

; 6214 :       if ( lpOwningTask == lpTask &&
; 6215 :            lpOpenFile->hWriteBuffer && lpOpenFile->uWriteBufferPos )

	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	cmp	ecx, DWORD PTR _lpTask$[ebp]
	jne	SHORT $L62684
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [edx+554], 0
	je	SHORT $L62684
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+550], 0
	je	SHORT $L62684

; 6217 :          fnSysWriteFile( lpTask, lpOpenFile->lFileHandle,
; 6218 :                          zGETPTR( lpOpenFile->hWriteBuffer ),
; 6219 :                          lpOpenFile->uWriteBufferPos );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+550]
	push	edx
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+554]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteFile@16
$L62684:

; 6222 : 
; 6223 :    // Open file record cleaned up, close the file
; 6224 :    // Note: Although the close may fail, keeping the open
; 6225 :    // file record around is probably of little value.
; 6226 :    // Note: We only close when called by application, not
; 6227 :    // when called by a task cleanup from object services because
; 6228 :    // the handle may have been reused by another task
; 6229 :    // after the owning task bombed.
; 6230 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 6231 :    if ( lpOwningTask == lpTask )

	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	cmp	edx, DWORD PTR _lpTask$[ebp]
	jne	SHORT $L62691

; 6233 :       zLONG lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$62687[ebp], eax

; 6234 : 
; 6235 :       if ( lpTask != zGETPTR( AnchorBlock->hMainTask ) ) // this trace causes problems when starting OE

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpTask$[ebp], eax
	je	SHORT $L62689

; 6237 :          TraceLine( "fnSysCloseFileWithControl %s   Handle: 0x%08x   Task: 0x%08x   Process: 0x%08x:0x%08x",
; 6238 :                     lpOpenFile->szFileName, lFileHandle, lpTask, lProcessID, lpOpenFile->lProcessID );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _lProcessID$62687[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	push	OFFSET FLAT:??_C@_0FG@EBEM@fnSysCloseFileWithControl?5?$CFs?5?5?5H@ ; `string'
	call	_TraceLine
	add	esp, 24					; 00000018H
$L62689:

; 6240 : 
; 6241 :       if ( lpOpenFile->lProcessID == lProcessID )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+2]
	cmp	eax, DWORD PTR _lProcessID$62687[ebp]
	jne	SHORT $L62691

; 6242 :          nRC = CloseHandle( (HANDLE) lFileHandle ) ? 0 : zCALL_ERROR;

	mov	ecx, DWORD PTR _lFileHandle$[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4
	neg	eax
	sbb	eax, eax
	and	eax, 16					; 00000010H
	add	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$L62691:

; 6244 : 
; 6245 :    // If the file was opened with the backup option then we need to rename
; 6246 :    // the backup file to the original file.
; 6247 :    if ( lpOpenFile->nFlags & COREFILE_BACKUP )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	movsx	eax, WORD PTR [edx+10]
	and	eax, 4096				; 00001000H
	test	eax, eax
	je	SHORT $L62695

; 6249 :       // Don't rename the file if the abort option was set.
; 6250 :       if ( (lControl & CLOSEFILE_ABORT_BACKUP) == 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L62695

; 6252 : // DGC 2000.11.06 Following code creates backups.  Taken out for more
; 6253 : // consideration.
; 6254 : #if 0
; 6255 :          zCHAR szBackup[ zMAX_FILENAME_LTH + 1 ];
; 6256 : 
; 6257 :          // Rename the original file to a .BAK file.
; 6258 :          zstrcpy( szBackup, lpOpenFile->szFileName );
; 6259 :          zstrcat( szBackup, ".BAK" );
; 6260 :          if ( SysRenameFile( lpOpenFile->szFileName,
; 6261 :                              szBackup, TRUE ) == zCALL_ERROR )
; 6262 :          {
; 6263 :             nRC = zCALL_ERROR;
; 6264 :          }
; 6265 : #endif
; 6266 : 
; 6267 :          if ( fnSysRenameFile( lpOwningTask, lpOpenFile->szTempFileName,
; 6268 :                                lpOpenFile->szFileName, TRUE ) == zCALL_ERROR )

	push	1
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	add	eax, 273				; 00000111H
	push	eax
	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	push	ecx
	call	_fnSysRenameFile@16
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $L62695

; 6270 :             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H
$L62695:

; 6274 : 
; 6275 :    fnFreeDataspace( zGETPTR( lpOpenFile->hReadBuffer ) );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+542]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 6276 :    fnFreeDataspace( zGETPTR( lpOpenFile->hWriteBuffer ) );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+554]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 6277 :    fnFreeDataspace( lpOpenFile );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 6278 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L62668:

; 6279 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysCloseFileWithControl@16 ENDP
_TEXT	ENDS
PUBLIC	_SysCloseFileWithControl@16
_TEXT	SEGMENT
_lpTaskView$ = 8
_lFileHandle$ = 12
_lpOwningTask$ = 16
_lControl$ = 20
_lpTask$ = -4
_SysCloseFileWithControl@16 PROC NEAR

; 6286 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6287 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64887
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64888
$L64887:
	mov	DWORD PTR -8+[ebp], 0
$L64888:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 6288 : 
; 6289 :    return( fnSysCloseFileWithControl( lpTask, lFileHandle,
; 6290 :                                       lpOwningTask, lControl ) );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lFileHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFileWithControl@16

; 6291 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysCloseFileWithControl@16 ENDP
_lpTask$ = 8
_lFileHandle$ = 12
_lpOwningTask$ = 16
_fnSysCloseFile@12 PROC NEAR

; 6297 : {

	push	ebp
	mov	ebp, esp

; 6298 :    return( fnSysCloseFileWithControl( lpTask, lFileHandle,
; 6299 :                                       lpOwningTask, 0 ) );

	push	0
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lFileHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFileWithControl@16
	movsx	eax, ax

; 6300 : }

	pop	ebp
	ret	12					; 0000000cH
_fnSysCloseFile@12 ENDP
_TEXT	ENDS
PUBLIC	_SysCloseFile@12
_TEXT	SEGMENT
_lpTaskView$ = 8
_lFileHandle$ = 12
_lpOwningTask$ = 16
_lpTask$ = -4
_SysCloseFile@12 PROC NEAR

; 6306 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6307 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64891
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64892
$L64891:
	mov	DWORD PTR -8+[ebp], 0
$L64892:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 6308 : 
; 6309 :    return( fnSysCloseFileWithControl( lpTask, lFileHandle, lpOwningTask, 0 ) );

	push	0
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lFileHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFileWithControl@16
	movsx	eax, ax

; 6310 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysCloseFile@12 ENDP
_TEXT	ENDS
PUBLIC	_SysSetFileTime@12
PUBLIC	??_C@_0CE@FPAN@SysSetFileTime?3?5Couldn?8t?5open?5fi@ ; `string'
EXTRN	__imp__SetFileTime@16:NEAR
EXTRN	__imp__SystemTimeToFileTime@8:NEAR
EXTRN	__imp__strncpy:NEAR
;	COMDAT ??_C@_0CE@FPAN@SysSetFileTime?3?5Couldn?8t?5open?5fi@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CE@FPAN@SysSetFileTime?3?5Couldn?8t?5open?5fi@ DB 'SysSetFileTime:'
	DB	' Couldn''t open file ', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_cpcFileName$ = 8
_cpcDateTime$ = 12
_ftTime$ = -536
_SysTime$ = -552
_hFile$ = -556
_szTemp$ = -528
_szFileName$ = -516
_SysSetFileTime@12 PROC NEAR

; 6338 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 556				; 0000022cH

; 6339 :    FILETIME   ftTime;
; 6340 :    SYSTEMTIME SysTime;
; 6341 :    HANDLE     hFile;
; 6342 :    zCHAR      szTemp[ 10 ];
; 6343 :    zCHAR      szFileName[ zMAX_FILESPEC_LTH + 1 ];
; 6344 : 
; 6345 :    zstrncpy( szTemp, cpcDateTime, 4 );

	push	4
	mov	eax, DWORD PTR _cpcDateTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 6346 :    szTemp[ 4 ] = 0;

	mov	BYTE PTR _szTemp$[ebp+4], 0

; 6347 :    SysTime.wYear         = (WORD) atoi( szTemp );

	lea	edx, DWORD PTR _szTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__atoi
	add	esp, 4
	mov	WORD PTR _SysTime$[ebp], ax

; 6348 :    SysTime.wMonth        = CONVERT_2_DIGITS( cpcDateTime + 4 );

	mov	eax, DWORD PTR _cpcDateTime$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	sub	ecx, 48					; 00000030H
	imul	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	WORD PTR _SysTime$[ebp+2], cx

; 6349 :    SysTime.wDay          = CONVERT_2_DIGITS( cpcDateTime + 6 );

	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	sub	eax, 48					; 00000030H
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _cpcDateTime$[ebp]
	movsx	edx, BYTE PTR [ecx+7]
	lea	eax, DWORD PTR [eax+edx-48]
	mov	WORD PTR _SysTime$[ebp+6], ax

; 6350 :    SysTime.wHour         = CONVERT_2_DIGITS( cpcDateTime + 8 );

	mov	ecx, DWORD PTR _cpcDateTime$[ebp]
	movsx	edx, BYTE PTR [ecx+8]
	sub	edx, 48					; 00000030H
	imul	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _cpcDateTime$[ebp]
	movsx	ecx, BYTE PTR [eax+9]
	lea	edx, DWORD PTR [edx+ecx-48]
	mov	WORD PTR _SysTime$[ebp+8], dx

; 6351 :    SysTime.wMinute       = CONVERT_2_DIGITS( cpcDateTime + 10 );

	mov	eax, DWORD PTR _cpcDateTime$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	sub	ecx, 48					; 00000030H
	imul	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+11]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	WORD PTR _SysTime$[ebp+10], cx

; 6352 :    SysTime.wSecond       = CONVERT_2_DIGITS( cpcDateTime + 12 );

	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+12]
	sub	eax, 48					; 00000030H
	imul	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _cpcDateTime$[ebp]
	movsx	edx, BYTE PTR [ecx+13]
	lea	eax, DWORD PTR [eax+edx-48]
	mov	WORD PTR _SysTime$[ebp+12], ax

; 6353 :    SysTime.wMilliseconds = (WORD) atoi( cpcDateTime + 14 );

	mov	ecx, DWORD PTR _cpcDateTime$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	call	DWORD PTR __imp__atoi
	add	esp, 4
	mov	WORD PTR _SysTime$[ebp+14], ax

; 6354 :    SystemTimeToFileTime( &SysTime, &ftTime );

	lea	edx, DWORD PTR _ftTime$[ebp]
	push	edx
	lea	eax, DWORD PTR _SysTime$[ebp]
	push	eax
	call	DWORD PTR __imp__SystemTimeToFileTime@8

; 6355 : 
; 6356 :    SysConvertEnvironmentString( szFileName, cpcFileName );

	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysConvertEnvironmentString@8

; 6357 :    hFile = CreateFile( szFileName, GENERIC_WRITE, FILE_SHARE_READ, 0,
; 6358 :                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0 );

	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	1
	push	1073741824				; 40000000H
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$[ebp], eax

; 6359 :    if ( hFile == INVALID_HANDLE_VALUE )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $L62740

; 6361 :       TraceLineS( "SysSetFileTime: Couldn't open file ", szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CE@FPAN@SysSetFileTime?3?5Couldn?8t?5open?5fi@ ; `string'
	call	_TraceLineS@8

; 6362 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L62731
$L62740:

; 6364 : 
; 6365 :    SetFileTime( hFile, 0, 0, &ftTime );

	lea	edx, DWORD PTR _ftTime$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	DWORD PTR __imp__SetFileTime@16

; 6366 :    CloseHandle( hFile );

	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 6367 :    return( 0 );

	xor	ax, ax
$L62731:

; 6368 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysSetFileTime@12 ENDP
_pchReturnString$ = 8
_lID$ = 12
_nMaxLth$ = 16
_k$ = -8
_nLth$ = -4
_SysGetBaseMessage@12 PROC NEAR

; 6387 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6388 :    zSHORT k;
; 6389 :    zSHORT nLth;
; 6390 : 
; 6391 :    for ( k = 0;
; 6392 :          BaseMsgTable[ k ].nID != lID && BaseMsgTable[ k ].nID != 9999;
; 6393 :          k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L62751
$L62752:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L62751:
	movsx	ecx, WORD PTR _k$[ebp]
	imul	ecx, 6
	movsx	edx, WORD PTR _BaseMsgTable[ecx]
	cmp	edx, DWORD PTR _lID$[ebp]
	je	SHORT $L62753
	movsx	eax, WORD PTR _k$[ebp]
	imul	eax, 6
	movsx	ecx, WORD PTR _BaseMsgTable[eax]
	cmp	ecx, 9999				; 0000270fH
	je	SHORT $L62753

; 6395 :    }

	jmp	SHORT $L62752
$L62753:

; 6396 : 
; 6397 :    nLth = zstrlen( BaseMsgTable[ k ].szMsg );

	movsx	edx, WORD PTR _k$[ebp]
	imul	edx, 6
	mov	eax, DWORD PTR _BaseMsgTable[edx+2]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$[ebp], ax

; 6398 : 
; 6399 :    if ( BaseMsgTable[ k ].nID == lID )

	movsx	ecx, WORD PTR _k$[ebp]
	imul	ecx, 6
	movsx	edx, WORD PTR _BaseMsgTable[ecx]
	cmp	edx, DWORD PTR _lID$[ebp]
	jne	SHORT $L62754

; 6401 :       if ( nLth > nMaxLth )

	movsx	eax, WORD PTR _nLth$[ebp]
	movsx	ecx, WORD PTR _nMaxLth$[ebp]
	cmp	eax, ecx
	jle	SHORT $L62755

; 6402 :          nLth = nMaxLth;

	mov	dx, WORD PTR _nMaxLth$[ebp]
	mov	WORD PTR _nLth$[ebp], dx
$L62755:

; 6403 : 
; 6404 :       zstrncpy( pchReturnString, BaseMsgTable[ k ].szMsg, nLth );

	movsx	eax, WORD PTR _nLth$[ebp]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	imul	ecx, 6
	mov	edx, DWORD PTR _BaseMsgTable[ecx+2]
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 6405 :       pchReturnString[ nLth ] = 0;

	movsx	ecx, WORD PTR _nLth$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 6406 :       return( nLth );

	mov	ax, WORD PTR _nLth$[ebp]
	jmp	SHORT $L62756
$L62754:

; 6410 :       pchReturnString[ 0 ] = 0;

	mov	eax, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [eax], 0

; 6411 :       return( 0 );

	xor	ax, ax
$L62756:

; 6413 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysGetBaseMessage@12 ENDP
_TEXT	ENDS
PUBLIC	_SysGetOperationMessage@12
_TEXT	SEGMENT
_pchReturnString$ = 8
_lID$ = 12
_nMaxLth$ = 16
_k$ = -8
_nLth$ = -4
_SysGetOperationMessage@12 PROC NEAR

; 6432 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6433 :    zSHORT k;
; 6434 :    zSHORT nLth;
; 6435 : 
; 6436 :    for ( k = 0;
; 6437 :          OperationMsgTable[ k ].nID != lID &&
; 6438 :             OperationMsgTable[ k ].nID != 9999;
; 6439 :          k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L62766
$L62767:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L62766:
	movsx	ecx, WORD PTR _k$[ebp]
	imul	ecx, 6
	movsx	edx, WORD PTR _OperationMsgTable[ecx]
	cmp	edx, DWORD PTR _lID$[ebp]
	je	SHORT $L62768
	movsx	eax, WORD PTR _k$[ebp]
	imul	eax, 6
	movsx	ecx, WORD PTR _OperationMsgTable[eax]
	cmp	ecx, 9999				; 0000270fH
	je	SHORT $L62768

; 6441 :    }

	jmp	SHORT $L62767
$L62768:

; 6442 : 
; 6443 :    nLth = zstrlen( OperationMsgTable[ k ].szMsg );

	movsx	edx, WORD PTR _k$[ebp]
	imul	edx, 6
	mov	eax, DWORD PTR _OperationMsgTable[edx+2]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$[ebp], ax

; 6444 : 
; 6445 :    if ( OperationMsgTable[ k ].nID == lID )

	movsx	ecx, WORD PTR _k$[ebp]
	imul	ecx, 6
	movsx	edx, WORD PTR _OperationMsgTable[ecx]
	cmp	edx, DWORD PTR _lID$[ebp]
	jne	SHORT $L62769

; 6447 :       if ( nLth > nMaxLth )

	movsx	eax, WORD PTR _nLth$[ebp]
	movsx	ecx, WORD PTR _nMaxLth$[ebp]
	cmp	eax, ecx
	jle	SHORT $L62770

; 6448 :          nLth = nMaxLth;

	mov	dx, WORD PTR _nMaxLth$[ebp]
	mov	WORD PTR _nLth$[ebp], dx
$L62770:

; 6449 : 
; 6450 :       zstrncpy( pchReturnString, OperationMsgTable[ k ].szMsg, nLth );

	movsx	eax, WORD PTR _nLth$[ebp]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	imul	ecx, 6
	mov	edx, DWORD PTR _OperationMsgTable[ecx+2]
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 6451 :       pchReturnString[ nLth ] = 0;

	movsx	ecx, WORD PTR _nLth$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 6452 :       return( nLth );

	mov	ax, WORD PTR _nLth$[ebp]
	jmp	SHORT $L62771
$L62769:

; 6456 :       pchReturnString[ 0 ] = 0;

	mov	eax, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [eax], 0

; 6457 :       return( 0 );

	xor	ax, ax
$L62771:

; 6459 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysGetOperationMessage@12 ENDP
_TEXT	ENDS
PUBLIC	_SysPositionFile@8
_TEXT	SEGMENT
_hFile$ = 8
_lPosition$ = 12
_SysPositionFile@8 PROC NEAR

; 6475 : {

	push	ebp
	mov	ebp, esp

; 6476 :    return( SetFilePointer( (HANDLE) hFile, lPosition, 0, FILE_BEGIN ) );

	push	0
	push	0
	mov	eax, DWORD PTR _lPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetFilePointer@16

; 6477 : }

	pop	ebp
	ret	8
_SysPositionFile@8 ENDP
_TEXT	ENDS
PUBLIC	_SysGetFilePosition@4
_TEXT	SEGMENT
_hFile$ = 8
_SysGetFilePosition@4 PROC NEAR

; 6492 : {

	push	ebp
	mov	ebp, esp

; 6493 :    return( SetFilePointer( (HANDLE) hFile, 0, 0, FILE_CURRENT ) );

	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	DWORD PTR __imp__SetFilePointer@16

; 6494 : }

	pop	ebp
	ret	4
_SysGetFilePosition@4 ENDP
_TEXT	ENDS
PUBLIC	_SysGetFileSize@4
EXTRN	__imp__GetFileSize@8:NEAR
_TEXT	SEGMENT
_hFile$ = 8
_SysGetFileSize@4 PROC NEAR

; 6509 : {

	push	ebp
	mov	ebp, esp

; 6510 :    return( GetFileSize( (HANDLE) hFile, 0 ) );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	DWORD PTR __imp__GetFileSize@8

; 6511 : }

	pop	ebp
	ret	4
_SysGetFileSize@4 ENDP
_TEXT	ENDS
PUBLIC	_fnSysTruncateFile@8
_TEXT	SEGMENT
_lpTask$ = 8
_hFile$ = 12
_fnSysTruncateFile@8 PROC NEAR

; 6529 : {

	push	ebp
	mov	ebp, esp

; 6530 :    SysPositionFile( hFile, 0 );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	_SysPositionFile@8

; 6531 :    return( fnSysWriteFile( lpTask, hFile, "", 0 ) );

	push	0
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteFile@16

; 6532 : }

	pop	ebp
	ret	8
_fnSysTruncateFile@8 ENDP
_TEXT	ENDS
PUBLIC	_SysTruncateFile@8
_TEXT	SEGMENT
_lpTaskView$ = 8
_hFile$ = 12
_lpTask$ = -4
_SysTruncateFile@8 PROC NEAR

; 6536 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6537 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64901
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -8+[ebp], eax
	jmp	SHORT $L64902
$L64901:
	mov	DWORD PTR -8+[ebp], 0
$L64902:
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 6538 : 
; 6539 :    return( fnSysTruncateFile( lpTask, hFile ) );

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysTruncateFile@8

; 6540 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SysTruncateFile@8 ENDP
_pchPortName$ = 8
_PortValue$ = 12
_pchInputString$ = 16
_k$62806 = -8
_iInputLth$62807 = -12
_iStartPos$62808 = -4
_SysParseLine@12 PROC NEAR

; 6561 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6562 :    if ( pchInputString )

	cmp	DWORD PTR _pchInputString$[ebp], 0
	je	$L62832

; 6564 :       int  k;
; 6565 :       int  iInputLth;
; 6566 :       int  iStartPos;
; 6567 : 
; 6568 :       k = -1;

	mov	DWORD PTR _k$62806[ebp], -1

; 6569 :       iInputLth = zstrlen( pchInputString );

	mov	eax, DWORD PTR _pchInputString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _iInputLth$62807[ebp], eax
$L62809:

; 6570 : 
; 6571 :       // look for begining of first parm
; 6572 :       do
; 6573 :          k++;

	mov	ecx, DWORD PTR _k$62806[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$62806[ebp], ecx

; 6574 :       while ( (pchInputString[ k ] == ' ') && (k < iInputLth) );

	mov	edx, DWORD PTR _pchInputString$[ebp]
	add	edx, DWORD PTR _k$62806[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $L62812
	mov	ecx, DWORD PTR _k$62806[ebp]
	cmp	ecx, DWORD PTR _iInputLth$62807[ebp]
	jl	SHORT $L62809
$L62812:

; 6575 :       iStartPos = k;

	mov	edx, DWORD PTR _k$62806[ebp]
	mov	DWORD PTR _iStartPos$62808[ebp], edx

; 6576 : 
; 6577 :       // if no parms
; 6578 :       if ( iStartPos >= iInputLth )

	mov	eax, DWORD PTR _iStartPos$62808[ebp]
	cmp	eax, DWORD PTR _iInputLth$62807[ebp]
	jl	SHORT $L62813

; 6580 :          pchPortName[ 0 ] = 0;

	mov	ecx, DWORD PTR _pchPortName$[ebp]
	mov	BYTE PTR [ecx], 0

; 6581 :          *PortValue = szNullS;

	mov	edx, DWORD PTR _PortValue$[ebp]
	mov	eax, DWORD PTR _szNullS
	mov	DWORD PTR [edx], eax

; 6583 :       else  // at least one parm

	jmp	$L62832
$L62813:

; 6585 :          // look for end of first parm
; 6586 :          do
; 6587 :             k++;

	mov	ecx, DWORD PTR _k$62806[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$62806[ebp], ecx

; 6588 :          while ( pchInputString[ k ] != ' ' &&
; 6589 :                  pchInputString[ k ] != '=' &&
; 6590 :                  k < iInputLth );

	mov	edx, DWORD PTR _pchInputString$[ebp]
	add	edx, DWORD PTR _k$62806[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $L62818
	mov	ecx, DWORD PTR _pchInputString$[ebp]
	add	ecx, DWORD PTR _k$62806[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 61					; 0000003dH
	je	SHORT $L62818
	mov	eax, DWORD PTR _k$62806[ebp]
	cmp	eax, DWORD PTR _iInputLth$62807[ebp]
	jl	SHORT $L62813
$L62818:

; 6591 : 
; 6592 :          zstrncpy( pchPortName, pchInputString + iStartPos, k - iStartPos );

	mov	ecx, DWORD PTR _k$62806[ebp]
	sub	ecx, DWORD PTR _iStartPos$62808[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchInputString$[ebp]
	add	edx, DWORD PTR _iStartPos$62808[ebp]
	push	edx
	mov	eax, DWORD PTR _pchPortName$[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 6593 :          pchPortName[ k - iStartPos ] = 0;

	mov	ecx, DWORD PTR _k$62806[ebp]
	sub	ecx, DWORD PTR _iStartPos$62808[ebp]
	mov	edx, DWORD PTR _pchPortName$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 6594 : 
; 6595 :          // if Only one parm created set Portvalue to null and return
; 6596 :          if ( k > iInputLth )

	mov	eax, DWORD PTR _k$62806[ebp]
	cmp	eax, DWORD PTR _iInputLth$62807[ebp]
	jle	SHORT $L62819

; 6598 :             *PortValue = szNullS;

	mov	ecx, DWORD PTR _PortValue$[ebp]
	mov	edx, DWORD PTR _szNullS
	mov	DWORD PTR [ecx], edx

; 6599 :             return;

	jmp	$L62832
$L62819:

; 6601 : 
; 6602 :          // Set StartPos to the greater of k + 1 or 11
; 6603 :          k++;

	mov	eax, DWORD PTR _k$62806[ebp]
	add	eax, 1
	mov	DWORD PTR _k$62806[ebp], eax

; 6604 :          if ( k > 10 || pchInputString[ k ] != ' ' )

	cmp	DWORD PTR _k$62806[ebp], 10		; 0000000aH
	jg	SHORT $L62821
	mov	ecx, DWORD PTR _pchInputString$[ebp]
	add	ecx, DWORD PTR _k$62806[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $L62820
$L62821:

; 6605 :             iStartPos = k;

	mov	eax, DWORD PTR _k$62806[ebp]
	mov	DWORD PTR _iStartPos$62808[ebp], eax

; 6606 :          else

	jmp	SHORT $L62822
$L62820:

; 6607 :             iStartPos = 10;

	mov	DWORD PTR _iStartPos$62808[ebp], 10	; 0000000aH
$L62822:

; 6608 : 
; 6609 :          // look for begining of second parm
; 6610 :          while ( (pchInputString[ k ] == ' ') && (k <= iInputLth) )

	mov	ecx, DWORD PTR _pchInputString$[ebp]
	add	ecx, DWORD PTR _k$62806[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $L62825
	mov	eax, DWORD PTR _k$62806[ebp]
	cmp	eax, DWORD PTR _iInputLth$62807[ebp]
	jg	SHORT $L62825

; 6611 :             k++;

	mov	ecx, DWORD PTR _k$62806[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$62806[ebp], ecx
	jmp	SHORT $L62822
$L62825:

; 6612 : 
; 6613 :          // if only one parm
; 6614 :          if ( k >= iInputLth )

	mov	edx, DWORD PTR _k$62806[ebp]
	cmp	edx, DWORD PTR _iInputLth$62807[ebp]
	jl	SHORT $L62826

; 6616 :             *PortValue = szNullS;

	mov	eax, DWORD PTR _PortValue$[ebp]
	mov	ecx, DWORD PTR _szNullS
	mov	DWORD PTR [eax], ecx

; 6618 :          else     // there is a second parm

	jmp	SHORT $L62832
$L62826:

; 6620 :             if ( k < 11 )

	cmp	DWORD PTR _k$62806[ebp], 11		; 0000000bH
	jge	SHORT $L62828

; 6621 :                iStartPos = k;

	mov	edx, DWORD PTR _k$62806[ebp]
	mov	DWORD PTR _iStartPos$62808[ebp], edx
$L62828:

; 6622 : 
; 6623 :             *PortValue = (zPCHAR) (pchInputString + iStartPos);

	mov	eax, DWORD PTR _pchInputString$[ebp]
	add	eax, DWORD PTR _iStartPos$62808[ebp]
	mov	ecx, DWORD PTR _PortValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 6624 : 
; 6625 :             // if needed, get rid of trailing blanks
; 6626 :             k = zstrlen( *PortValue ) - 1;

	mov	edx, DWORD PTR _PortValue$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR _k$62806[ebp], eax
$L62831:

; 6627 :             while ( k > 0 )

	cmp	DWORD PTR _k$62806[ebp], 0
	jle	SHORT $L62832

; 6629 :                if ( (*PortValue)[ k ] == ' ' )

	mov	ecx, DWORD PTR _PortValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _k$62806[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $L62833

; 6630 :                   (*PortValue)[ k-- ] = 0;

	mov	edx, DWORD PTR _PortValue$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _k$62806[ebp]
	mov	BYTE PTR [eax+ecx], 0
	mov	edx, DWORD PTR _k$62806[ebp]
	sub	edx, 1
	mov	DWORD PTR _k$62806[ebp], edx

; 6631 :                else

	jmp	SHORT $L62834
$L62833:

; 6632 :                   break;

	jmp	SHORT $L62832
$L62834:

; 6633 :             }

	jmp	SHORT $L62831
$L62832:

; 6637 : }  // End of SysParseLine

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysParseLine@12 ENDP
_TEXT	ENDS
PUBLIC	_SysGetLocalDirectory@4
_TEXT	SEGMENT
_pchReturnDir$ = 8
_SysGetLocalDirectory@4 PROC NEAR

; 6657 : {

	push	ebp
	mov	ebp, esp

; 6658 :    // Temporarily return the Zeidon Bin directory.
; 6659 :    if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $L62838

; 6661 :       zstrcpy( pchReturnDir, AnchorBlock->szZeidonBin );

	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 395				; 0000018bH
	push	eax
	mov	ecx, DWORD PTR _pchReturnDir$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 6662 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $L62837
$L62838:

; 6664 : 
; 6665 :    *pchReturnDir = 0;

	mov	edx, DWORD PTR _pchReturnDir$[ebp]
	mov	BYTE PTR [edx], 0

; 6666 :    return( -1 );

	or	eax, -1
$L62837:

; 6667 : }

	pop	ebp
	ret	4
_SysGetLocalDirectory@4 ENDP
_TEXT	ENDS
PUBLIC	_SysGetLocalSysDirectory@4
_TEXT	SEGMENT
_pchReturnDir$ = 8
_SysGetLocalSysDirectory@4 PROC NEAR

; 6687 : {

	push	ebp
	mov	ebp, esp

; 6688 :    // Temporarily return the Zeidon Sys directory.
; 6689 :    if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $L62842

; 6691 :       zstrcpy( pchReturnDir, AnchorBlock->szZeidonSys );

	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 652				; 0000028cH
	push	eax
	mov	ecx, DWORD PTR _pchReturnDir$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 6692 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $L62841
$L62842:

; 6694 : 
; 6695 :    *pchReturnDir = 0;

	mov	edx, DWORD PTR _pchReturnDir$[ebp]
	mov	BYTE PTR [edx], 0

; 6696 :    return( -1 );

	or	eax, -1
$L62841:

; 6697 : }

	pop	ebp
	ret	4
_SysGetLocalSysDirectory@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@PPDE@?$CF4d?$CF02d?$CF02d?$CF02d?$CF02d?$CF02d?$CF03d?$AA@ ; `string'
PUBLIC	??_C@_0BA@BLPA@?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$AA@ ; `string'
PUBLIC	_SysGetFileDateTime@8
EXTRN	__imp__GetFileTime@16:NEAR
EXTRN	__imp__FileTimeToSystemTime@8:NEAR
;	COMDAT ??_C@_0BM@PPDE@?$CF4d?$CF02d?$CF02d?$CF02d?$CF02d?$CF02d?$CF03d?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BM@PPDE@?$CF4d?$CF02d?$CF02d?$CF02d?$CF02d?$CF02d?$CF03d?$AA@ DB '%'
	DB	'4d%02d%02d%02d%02d%02d%03d', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@BLPA@?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$AA@
_DATA	SEGMENT
??_C@_0BA@BLPA@?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$AA@ DB '?'
	DB	'??????????????', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_hFile$ = 8
_pchDateTime$ = 12
_LastWriteTime$ = -24
_ST$ = -16
_SysGetFileDateTime@8 PROC NEAR

; 6722 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 6723 :    FILETIME   LastWriteTime;
; 6724 :    SYSTEMTIME ST;             // SystemTime
; 6725 : 
; 6726 :    pchDateTime[ 0 ] = 0;

	mov	eax, DWORD PTR _pchDateTime$[ebp]
	mov	BYTE PTR [eax], 0

; 6727 : 
; 6728 :    if ( GetFileTime( (HANDLE) hFile, 0, 0, &LastWriteTime ) )

	lea	ecx, DWORD PTR _LastWriteTime$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	call	DWORD PTR __imp__GetFileTime@16
	test	eax, eax
	je	SHORT $L62851

; 6730 :       FileTimeToSystemTime( &LastWriteTime, &ST );

	lea	eax, DWORD PTR _ST$[ebp]
	push	eax
	lea	ecx, DWORD PTR _LastWriteTime$[ebp]
	push	ecx
	call	DWORD PTR __imp__FileTimeToSystemTime@8

; 6731 :       zsprintf( pchDateTime, "%4d%02d%02d%02d%02d%02d%03d",
; 6732 :                 (int) ST.wYear, (int) ST.wMonth, (int) ST.wDay, (int) ST.wHour,
; 6733 :                 (int) ST.wMinute, (int) ST.wSecond, (int) ST.wMilliseconds );

	mov	edx, DWORD PTR _ST$[ebp+14]
	and	edx, 65535				; 0000ffffH
	push	edx
	mov	eax, DWORD PTR _ST$[ebp+12]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _ST$[ebp+10]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	edx, DWORD PTR _ST$[ebp+8]
	and	edx, 65535				; 0000ffffH
	push	edx
	mov	eax, DWORD PTR _ST$[ebp+6]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _ST$[ebp+2]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	edx, DWORD PTR _ST$[ebp]
	and	edx, 65535				; 0000ffffH
	push	edx
	push	OFFSET FLAT:??_C@_0BM@PPDE@?$CF4d?$CF02d?$CF02d?$CF02d?$CF02d?$CF02d?$CF03d?$AA@ ; `string'
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 36					; 00000024H

; 6735 :    else

	jmp	SHORT $L62860
$L62851:

; 6736 :       zstrcpy( pchDateTime, "???????????????" );

	push	OFFSET FLAT:??_C@_0BA@BLPA@?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$DP?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchDateTime$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$L62860:

; 6737 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SysGetFileDateTime@8 ENDP
_TEXT	ENDS
EXTRN	__imp__GetLocalTime@4:NEAR
_TEXT	SEGMENT
_pchDateTime$ = 8
_ST$ = -16
_SysGetDateTime@4 PROC NEAR

; 6763 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 6764 :    SYSTEMTIME ST;
; 6765 : 
; 6766 :    GetLocalTime( &ST );

	lea	eax, DWORD PTR _ST$[ebp]
	push	eax
	call	DWORD PTR __imp__GetLocalTime@4

; 6767 :    zsprintf( pchDateTime, "%4d%02d%02d%02d%02d%02d%03d",
; 6768 :              (int) ST.wYear, (int) ST.wMonth, (int) ST.wDay, (int) ST.wHour,
; 6769 :              (int) ST.wMinute, (int) ST.wSecond, (int) ST.wMilliseconds );

	mov	ecx, DWORD PTR _ST$[ebp+14]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	edx, DWORD PTR _ST$[ebp+12]
	and	edx, 65535				; 0000ffffH
	push	edx
	mov	eax, DWORD PTR _ST$[ebp+10]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _ST$[ebp+8]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	mov	edx, DWORD PTR _ST$[ebp+6]
	and	edx, 65535				; 0000ffffH
	push	edx
	mov	eax, DWORD PTR _ST$[ebp+2]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _ST$[ebp]
	and	ecx, 65535				; 0000ffffH
	push	ecx
	push	OFFSET FLAT:??_C@_0BM@PPDE@?$CF4d?$CF02d?$CF02d?$CF02d?$CF02d?$CF02d?$CF03d?$AA@ ; `string'
	mov	edx, DWORD PTR _pchDateTime$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 36					; 00000024H

; 6770 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetDateTime@4 ENDP
_TEXT	ENDS
PUBLIC	__zCall_GetDateTime@8
PUBLIC	??_C@_0M@BKKK@ReturnValue?$AA@			; `string'
PUBLIC	??_C@_09GMMJ@Operation?$AA@			; `string'
;	COMDAT ??_C@_0M@BKKK@ReturnValue?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0M@BKKK@ReturnValue?$AA@ DB 'ReturnValue', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GMMJ@Operation?$AA@
_DATA	SEGMENT
??_C@_09GMMJ@Operation?$AA@ DB 'Operation', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vArgs$ = 8
_szDateTime$ = -32
__zCall_GetDateTime@8 PROC NEAR

; 6775 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 6776 :    zCHAR szDateTime[ 32 ];
; 6777 : 
; 6778 :    SysGetDateTime( szDateTime );

	lea	eax, DWORD PTR _szDateTime$[ebp]
	push	eax
	call	_SysGetDateTime@4

; 6779 :    SetAttributeFromString( vArgs, "Operation", "ReturnValue", szDateTime );

	lea	ecx, DWORD PTR _szDateTime$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0M@BKKK@ReturnValue?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09GMMJ@Operation?$AA@	; `string'
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 6780 :    return( 0 );

	xor	ax, ax

; 6781 : }

	mov	esp, ebp
	pop	ebp
	ret	8
__zCall_GetDateTime@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@HBNK@Zeidon?5System?$AA@		; `string'
PUBLIC	??_C@_01KGOM@T?$AA@				; `string'
PUBLIC	??_C@_0M@BHAM@GetDateTime?$AA@			; `string'
PUBLIC	??_C@_08NCBN@kzoengaa?$AA@			; `string'
PUBLIC	??_C@_08GPBK@zWinSock?$AA@			; `string'
PUBLIC	_SysGetServerDateTime@8
EXTRN	_SfCreateSystemSubtask@12:NEAR
EXTRN	_SfDropSubtask@8:NEAR
EXTRN	_NetCallOperation:NEAR
EXTRN	_NetStatus@8:NEAR
;	COMDAT ??_C@_0O@HBNK@Zeidon?5System?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0O@HBNK@Zeidon?5System?$AA@ DB 'Zeidon System', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_01KGOM@T?$AA@
_DATA	SEGMENT
??_C@_01KGOM@T?$AA@ DB 'T', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@BHAM@GetDateTime?$AA@
_DATA	SEGMENT
??_C@_0M@BHAM@GetDateTime?$AA@ DB 'GetDateTime', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08NCBN@kzoengaa?$AA@
_DATA	SEGMENT
??_C@_08NCBN@kzoengaa?$AA@ DB 'kzoengaa', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GPBK@zWinSock?$AA@
_DATA	SEGMENT
??_C@_08GPBK@zWinSock?$AA@ DB 'zWinSock', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpView$ = 8
_pchDateTime$ = 12
_lpViewOD$ = -4
_vSystem$62890 = -12
_nRC$62891 = -8
_SysGetServerDateTime@8 PROC NEAR

; 6785 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6786 :    LPVIEWOD lpViewOD;
; 6787 : 
; 6788 :    pchDateTime[ 0 ] = 0;

	mov	eax, DWORD PTR _pchDateTime$[ebp]
	mov	BYTE PTR [eax], 0

; 6789 : 
; 6790 :    // First make sure the network is active.
; 6791 :    if ( lpView &&
; 6792 :         (lpViewOD = zGETPTR( lpView->hViewOD )) != 0 &&
; 6793 :         lpViewOD->szNetwork[ 0 ] &&
; 6794 :         NetStatus( lpView, lpViewOD->szNetwork ) != 0 )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	$L62889
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax
	cmp	DWORD PTR _lpViewOD$[ebp], 0
	je	SHORT $L62889
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+109]
	test	ecx, ecx
	je	SHORT $L62889
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 109				; 0000006dH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_NetStatus@8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L62889

; 6796 :       zVIEW  vSystem;
; 6797 :       zSHORT nRC;
; 6798 : 
; 6799 :       SfCreateSystemSubtask( &vSystem, lpView, "Zeidon System" );

	push	OFFSET FLAT:??_C@_0O@HBNK@Zeidon?5System?$AA@ ; `string'
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vSystem$62890[ebp]
	push	eax
	call	_SfCreateSystemSubtask@12

; 6800 :       nRC = NetCallOperation( "zWinSock", 0,
; 6801 :                               vSystem, FALSE, "kzoengaa", "GetDateTime",
; 6802 :                               pchDateTime, "T" );

	push	OFFSET FLAT:??_C@_01KGOM@T?$AA@		; `string'
	mov	ecx, DWORD PTR _pchDateTime$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0M@BHAM@GetDateTime?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_08NCBN@kzoengaa?$AA@	; `string'
	push	0
	mov	edx, DWORD PTR _vSystem$62890[ebp]
	push	edx
	push	0
	push	OFFSET FLAT:??_C@_08GPBK@zWinSock?$AA@	; `string'
	call	_NetCallOperation
	add	esp, 32					; 00000020H
	mov	WORD PTR _nRC$62891[ebp], ax

; 6803 :       SfDropSubtask( vSystem, 0 );

	push	0
	mov	eax, DWORD PTR _vSystem$62890[ebp]
	push	eax
	call	_SfDropSubtask@8

; 6805 :    else

	jmp	SHORT $L62897
$L62889:

; 6806 :       SysGetDateTime( pchDateTime );

	mov	ecx, DWORD PTR _pchDateTime$[ebp]
	push	ecx
	call	_SysGetDateTime@4
$L62897:

; 6807 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SysGetServerDateTime@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@GMLB@Invalid?5type?5for?5Early?5Date?$AA@ ; `string'
PUBLIC	??_C@_0BL@EONO@SysGetDateTimeDifference?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BM@GEFP@Invalid?5type?5for?5Later?5Date?$AA@ ; `string'
PUBLIC	_SysGetDateTimeDifference@16
EXTRN	_UfStringToDateTime@8:NEAR
EXTRN	_UfDateTimeDiff@16:NEAR
;	COMDAT ??_C@_0BM@GMLB@Invalid?5type?5for?5Early?5Date?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BM@GMLB@Invalid?5type?5for?5Early?5Date?$AA@ DB 'Invalid type for '
	DB	'Early Date', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BL@EONO@SysGetDateTimeDifference?3?5?$AA@
_DATA	SEGMENT
??_C@_0BL@EONO@SysGetDateTimeDifference?3?5?$AA@ DB 'SysGetDateTimeDiffer'
	DB	'ence: ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@GEFP@Invalid?5type?5for?5Later?5Date?$AA@
_DATA	SEGMENT
??_C@_0BM@GEFP@Invalid?5type?5for?5Later?5Date?$AA@ DB 'Invalid type for '
	DB	'Later Date', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_plDiff$ = 8
_pchEarlyDate$ = 12
_pchLaterDate$ = 16
_nDiffType$ = 20
_EarlyDate$ = -12
_LaterDate$ = -20
_nRC$ = -4
_SysGetDateTimeDifference@16 PROC NEAR

; 6832 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 6833 :    DateTimeRecord EarlyDate;
; 6834 :    DateTimeRecord LaterDate;
; 6835 :    zSHORT         nRC;
; 6836 : 
; 6837 :    nRC = UfStringToDateTime( pchEarlyDate, &EarlyDate );

	lea	eax, DWORD PTR _EarlyDate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchEarlyDate$[ebp]
	push	ecx
	call	_UfStringToDateTime@8
	mov	WORD PTR _nRC$[ebp], ax

; 6838 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L62910

; 6840 :       TraceLineS( "SysGetDateTimeDifference: ",  "Invalid type for Early Date" );

	push	OFFSET FLAT:??_C@_0BM@GMLB@Invalid?5type?5for?5Early?5Date?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BL@EONO@SysGetDateTimeDifference?3?5?$AA@ ; `string'
	call	_TraceLineS@8

; 6841 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L62906
$L62910:

; 6843 : 
; 6844 :    nRC = UfStringToDateTime( pchLaterDate, &LaterDate );

	lea	eax, DWORD PTR _LaterDate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchLaterDate$[ebp]
	push	ecx
	call	_UfStringToDateTime@8
	mov	WORD PTR _nRC$[ebp], ax

; 6845 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $L62913

; 6847 :       TraceLineS( "SysGetDateTimeDifference: ",  "Invalid type for Later Date" );

	push	OFFSET FLAT:??_C@_0BM@GEFP@Invalid?5type?5for?5Later?5Date?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BL@EONO@SysGetDateTimeDifference?3?5?$AA@ ; `string'
	call	_TraceLineS@8

; 6848 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L62906
$L62913:

; 6850 : 
; 6851 :    // Subtract the values.
; 6852 :    nRC = UfDateTimeDiff( plDiff, &EarlyDate, &LaterDate, nDiffType );

	mov	ax, WORD PTR _nDiffType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _LaterDate$[ebp]
	push	ecx
	lea	edx, DWORD PTR _EarlyDate$[ebp]
	push	edx
	mov	eax, DWORD PTR _plDiff$[ebp]
	push	eax
	call	_UfDateTimeDiff@16
	mov	WORD PTR _nRC$[ebp], ax

; 6853 : 
; 6854 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L62906:

; 6855 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysGetDateTimeDifference@16 ENDP
_TEXT	ENDS
PUBLIC	_SysTranslateString@8
EXTRN	__imp__CharUpperA@4:NEAR
EXTRN	__imp__CharLowerA@4:NEAR
_TEXT	SEGMENT
_pchString$ = 8
_cUpperLower$ = 12
_SysTranslateString@8 PROC NEAR

; 6876 : {

	push	ebp
	mov	ebp, esp

; 6877 :    if ( cUpperLower == 'L' )

	movsx	eax, BYTE PTR _cUpperLower$[ebp]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $L62920

; 6878 :       CharLower( pchString );

	mov	ecx, DWORD PTR _pchString$[ebp]
	push	ecx
	call	DWORD PTR __imp__CharLowerA@4

; 6879 :    else

	jmp	SHORT $L62921
$L62920:

; 6880 :       CharUpper( pchString );

	mov	edx, DWORD PTR _pchString$[ebp]
	push	edx
	call	DWORD PTR __imp__CharUpperA@4
$L62921:

; 6881 : }

	pop	ebp
	ret	8
_SysTranslateString@8 ENDP
_TEXT	ENDS
PUBLIC	_SysLoadLibraryWithErrFlag@12
PUBLIC	??_C@_0GB@KOIH@?$CIsy?$CJ?5SysLoadLibrary?5failed?5to?5lo@ ; `string'
PUBLIC	??_C@_0BJ@PAML@Load?5failed?5for?3?5?$CFs?5?$CI?$CFs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BA@POOP@System?5Services?$AA@		; `string'
PUBLIC	??_C@_07BDOP@SY00101?$AA@			; `string'
EXTRN	_fnGetApplicationForSubtask@8:NEAR
EXTRN	_fnValidView:NEAR
EXTRN	__imp__SetCurrentDirectoryA@4:NEAR
EXTRN	__imp__GetCurrentDirectoryA@8:NEAR
EXTRN	_MessageSend@24:NEAR
EXTRN	__imp__LoadLibraryA@4:NEAR
EXTRN	__imp__LoadLibraryExA@12:NEAR
EXTRN	__imp__strrchr:NEAR
;	COMDAT ??_C@_0GB@KOIH@?$CIsy?$CJ?5SysLoadLibrary?5failed?5to?5lo@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0GB@KOIH@?$CIsy?$CJ?5SysLoadLibrary?5failed?5to?5lo@ DB '(sy) SysLo'
	DB	'adLibrary failed to load file: "%s"  with error code = %d  us'
	DB	'ing Current directory: %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@PAML@Load?5failed?5for?3?5?$CFs?5?$CI?$CFs?$CJ?$AA@
_DATA	SEGMENT
??_C@_0BJ@PAML@Load?5failed?5for?3?5?$CFs?5?$CI?$CFs?$CJ?$AA@ DB 'Load fa'
	DB	'iled for: %s (%s)', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@POOP@System?5Services?$AA@
_DATA	SEGMENT
??_C@_0BA@POOP@System?5Services?$AA@ DB 'System Services', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_07BDOP@SY00101?$AA@
_DATA	SEGMENT
??_C@_07BDOP@SY00101?$AA@ DB 'SY00101', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTaskView$ = 8
_cpcLibraryName$ = 12
_lFlag$ = 16
_lpTask$ = -280
_lpApp$ = -548
_hLibrary$ = -268
_lpLibrary$ = -556
_lLibOS$ = -284
_szFileName$ = -264
_szCurrentDir$ = -544
_pchUnqualifiedName$ = -276
_bQualified$ = -552
_nUnqualLth$ = -272
_lProcessID$ = -4
_szMsg$62974 = -812
_bMutexLocked$62980 = -816
_SysLoadLibraryWithErrFlag@12 PROC NEAR

; 6926 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 820				; 00000334H

; 6927 :    LPTASK     lpTask;
; 6928 :    LPAPP      lpApp;
; 6929 :    LPLIBRARY  hLibrary;
; 6930 :    LPLIBRARY  lpLibrary;
; 6931 :    zLONG      lLibOS;
; 6932 :    char       szFileName[ zMAX_FILENAME_LTH + 1 ];
; 6933 :    char       szCurrentDir[ zMAX_FILENAME_LTH + 1 ];
; 6934 :    char       *pchUnqualifiedName;
; 6935 :    zBOOL      bQualified;
; 6936 :    zSHORT     nUnqualLth;
; 6937 :    zLONG      lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 6938 : 
; 6939 :    // If AnchorBlock or application task does not exist, return zero.
; 6940 :    if ( AnchorBlock == 0 || lpTaskView == 0 ||
; 6941 :         (lpTask = zGETPTR( lpTaskView->hTask )) == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $L62942
	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L62942
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L62941
$L62942:

; 6943 :       return( 0 );

	xor	eax, eax
	jmp	$L62928
$L62941:

; 6945 : 
; 6946 :    if ( lpTaskView )

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L62943

; 6948 :       if ( fnValidView( lpTask, lpTaskView ) == 0 )

	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnValidView
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L62944

; 6949 :          return( 0 );

	xor	eax, eax
	jmp	$L62928
$L62944:

; 6950 : 
; 6951 :       if ( fnGetApplicationForSubtask( &lpApp, lpTaskView ) != 0 )

	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	_fnGetApplicationForSubtask@8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L62945

; 6952 :          return( 0 );

	xor	eax, eax
	jmp	$L62928
$L62945:

; 6954 :    else

	jmp	SHORT $L62948
$L62943:

; 6956 :       lpApp = zGETPTR( lpTask->hApp );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 6957 :       if ( lpApp == 0 )

	cmp	DWORD PTR _lpApp$[ebp], 0
	jne	SHORT $L62948

; 6958 :          lpApp = zGETPTR( AnchorBlock->hSystemApp );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax
$L62948:

; 6960 : 
; 6961 :    zstrcpy( szFileName, cpcLibraryName );

	mov	eax, DWORD PTR _cpcLibraryName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 6962 :    SysTranslateString( szFileName, 'U' );

	push	85					; 00000055H
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysTranslateString@8

; 6963 : 
; 6964 :    // Check to see if library name is qualified.
; 6965 :    pchUnqualifiedName = zstrrchr( szFileName, cDirSep );

	movsx	eax, BYTE PTR _cDirSep
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__strrchr
	add	esp, 8
	mov	DWORD PTR _pchUnqualifiedName$[ebp], eax

; 6966 :    if ( pchUnqualifiedName )

	cmp	DWORD PTR _pchUnqualifiedName$[ebp], 0
	je	SHORT $L62951

; 6968 :       bQualified = TRUE;

	mov	BYTE PTR _bQualified$[ebp], 1

; 6969 :       pchUnqualifiedName++;         // point to file name

	mov	edx, DWORD PTR _pchUnqualifiedName$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchUnqualifiedName$[ebp], edx

; 6971 :    else

	jmp	SHORT $L62952
$L62951:

; 6973 :       bQualified = FALSE;

	mov	BYTE PTR _bQualified$[ebp], 0

; 6974 :       pchUnqualifiedName = szFileName;

	lea	eax, DWORD PTR _szFileName$[ebp]
	mov	DWORD PTR _pchUnqualifiedName$[ebp], eax
$L62952:

; 6976 : 
; 6977 :    nUnqualLth = zstrlen( pchUnqualifiedName );

	mov	ecx, DWORD PTR _pchUnqualifiedName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nUnqualLth$[ebp], ax

; 6978 : 
; 6979 :    // If module is already loaded for this application task, get out quick!
; 6980 :    lpLibrary = zGETPTR( lpTask->hFirstLibrary );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+122]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax
$L62955:

; 6981 :    while ( lpLibrary )

	cmp	DWORD PTR _lpLibrary$[ebp], 0
	je	$L62956

; 6983 :       // Name and flags must match!
; 6984 :       if ( zstrcmp( pchUnqualifiedName, lpLibrary->szName ) == 0 &&
; 6985 :            (lFlag & zLOADLIB_RESOURCES) == (lpLibrary->lFlag & zLOADLIB_RESOURCES) &&
; 6986 :            lpLibrary->lProcessID == lProcessID )

	mov	ecx, DWORD PTR _pchUnqualifiedName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _lpLibrary$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	cmp	edx, ecx
	jne	SHORT $L64913
	mov	edx, DWORD PTR _lpLibrary$[ebp]
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _pchUnqualifiedName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -820+[ebp], eax
	jmp	SHORT $L64914
$L64913:
	mov	ecx, DWORD PTR _pchUnqualifiedName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _lpLibrary$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	sub	edx, ecx
	xor	eax, eax
	test	edx, edx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -820+[ebp], eax
$L64914:
	cmp	DWORD PTR -820+[ebp], 0
	jne	SHORT $L62963
	mov	ecx, DWORD PTR _lFlag$[ebp]
	and	ecx, 2
	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR [edx+267]
	and	eax, 2
	cmp	ecx, eax
	jne	SHORT $L62963
	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	edx, DWORD PTR [ecx+271]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $L62963

; 6988 :          lpLibrary->ulUseCnt++;

	mov	eax, DWORD PTR _lpLibrary$[ebp]
	mov	ecx, DWORD PTR [eax+275]
	add	ecx, 1
	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	DWORD PTR [edx+275], ecx

; 6989 :          return( zGETHNDL( lpLibrary ) );

	mov	eax, DWORD PTR _lpLibrary$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	jmp	$L62928
$L62963:

; 6991 : 
; 6992 :       lpLibrary = zGETPTR( lpLibrary->hNextLibrary );

	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax

; 6993 :    }

	jmp	$L62955
$L62956:

; 6994 : 
; 6995 :    // Environment specific code begins here =================================
; 6996 : 
; 6997 :    // Set the current working directory.
; 6998 :    GetCurrentDirectory( zMAX_FILENAME_LTH + 1, szCurrentDir );

	lea	eax, DWORD PTR _szCurrentDir$[ebp]
	push	eax
	push	257					; 00000101H
	call	DWORD PTR __imp__GetCurrentDirectoryA@8

; 6999 :    SetCurrentDirectory( lpApp->szLibraryDir );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 90					; 0000005aH
	push	ecx
	call	DWORD PTR __imp__SetCurrentDirectoryA@4

; 7000 : 
; 7001 :    zstrcat( szFileName, ".dll" );

	push	OFFSET FLAT:??_C@_04EJNG@?4dll?$AA@	; `string'
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 7002 : 
; 7003 :    if ( lFlag & zLOADLIB_RESOURCES )

	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, 2
	test	eax, eax
	je	SHORT $L62966

; 7004 :       lLibOS = (zLONG) LoadLibraryEx( szFileName, 0,
; 7005 :                                       LOAD_LIBRARY_AS_DATAFILE );

	push	2
	push	0
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadLibraryExA@12
	mov	DWORD PTR _lLibOS$[ebp], eax

; 7006 :    else

	jmp	SHORT $L62968
$L62966:

; 7007 :       lLibOS = (zLONG) LoadLibrary( szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	DWORD PTR _lLibOS$[ebp], eax
$L62968:

; 7008 : 
; 7009 :    SetCurrentDirectory( szCurrentDir );

	lea	eax, DWORD PTR _szCurrentDir$[ebp]
	push	eax
	call	DWORD PTR __imp__SetCurrentDirectoryA@4

; 7010 : 
; 7011 :    if ( lLibOS == 0 )

	cmp	DWORD PTR _lLibOS$[ebp], 0
	jne	$L62970

; 7013 :       TraceLine( "(sy) SysLoadLibrary failed to load file: \"%s\"  "
; 7014 :                    "with error code = %d  using Current directory: %s",
; 7015 :                  szFileName, (zLONG) GetLastError( ), lpApp->szLibraryDir );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 90					; 0000005aH
	push	ecx
	call	DWORD PTR __imp__GetLastError@0
	push	eax
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0GB@KOIH@?$CIsy?$CJ?5SysLoadLibrary?5failed?5to?5lo@ ; `string'
	call	_TraceLine
	add	esp, 16					; 00000010H

; 7016 :       if ( lFlag & zLOADLIB_WITHERR )

	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L62973

; 7018 :          char  szMsg[ 256 ];
; 7019 : 
; 7020 :          zsprintf( szMsg, "Load failed for: %s (%s)", cpcLibraryName, szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcLibraryName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BJ@PAML@Load?5failed?5for?3?5?$CFs?5?$CI?$CFs?$CJ?$AA@ ; `string'
	lea	eax, DWORD PTR _szMsg$62974[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 7021 :          MessageSend( lpTaskView, "SY00101", "System Services", szMsg,
; 7022 :                       zMSGQ_SYSTEM_ERROR, 1 );

	push	1
	push	1000					; 000003e8H
	lea	ecx, DWORD PTR _szMsg$62974[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BA@POOP@System?5Services?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_07BDOP@SY00101?$AA@	; `string'
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_MessageSend@24
$L62973:

; 7024 : 
; 7025 :       // Trace the dll name always on failure!!!
; 7026 :       TraceLine( "Load failed for: %s (%s)", cpcLibraryName, szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcLibraryName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BJ@PAML@Load?5failed?5for?3?5?$CFs?5?$CI?$CFs?$CJ?$AA@ ; `string'
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 7027 : 
; 7028 :       return( 0 );

	xor	eax, eax
	jmp	$L62928
$L62970:

; 7030 : 
; 7031 : // TraceLine( "LoadLibrary Task (0x%08x) successful for: %s (%s)",
; 7032 : //            zGETHNDL( lpTask ), cpcLibraryName, szFileName );
; 7033 : 
; 7034 :    // Environment specific code ends here ===================================
; 7035 : 
; 7036 :    // Allocate a Library record for the current task.
; 7037 :    hLibrary = fnAllocDataspace( lpTask->hFirstDataHeader,
; 7038 :                                 sizeof( LibraryRecord ), 1, 0, iLibrary );

	push	10025					; 00002729H
	push	0
	push	1
	push	279					; 00000117H
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hLibrary$[ebp], eax

; 7039 :    if ( hLibrary )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	$L62985

; 7041 :       zBOOL bMutexLocked;
; 7042 : 
; 7043 :       lpLibrary = zGETPTR( hLibrary );

	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax

; 7044 :       lpLibrary->lFlag    = lFlag;

	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR _lFlag$[ebp]
	mov	DWORD PTR [edx+267], eax

; 7045 :       lpLibrary->hLibrary = lLibOS;

	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	edx, DWORD PTR _lLibOS$[ebp]
	mov	DWORD PTR [ecx+263], edx

; 7046 :       lpLibrary->ulUseCnt = 1;

	mov	eax, DWORD PTR _lpLibrary$[ebp]
	mov	DWORD PTR [eax+275], 1

; 7047 :       lpLibrary->lProcessID = lProcessID;

	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	edx, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [ecx+271], edx

; 7048 : 
; 7049 :       pchUnqualifiedName[ nUnqualLth ] = 0;

	movsx	eax, WORD PTR _nUnqualLth$[ebp]
	mov	ecx, DWORD PTR _pchUnqualifiedName$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 7050 :       zstrcpy( lpLibrary->szName, pchUnqualifiedName );

	mov	edx, DWORD PTR _pchUnqualifiedName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLibrary$[ebp]
	add	eax, 6
	push	eax
	call	_strcpy
	add	esp, 8

; 7051 : 
; 7052 :    // fnTraceLibrary( lpLibrary, 1 );
; 7053 :       if ( zGETHNDL( lpTask ) == AnchorBlock->hMainTask )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _AnchorBlock
	cmp	eax, DWORD PTR [edx+106]
	jne	SHORT $L62983

; 7055 :          bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$62980[ebp], 1

; 7056 :          zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 7058 :       else

	jmp	SHORT $L62984
$L62983:

; 7059 :          bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$62980[ebp], 0
$L62984:

; 7060 : 
; 7061 :       lpLibrary->hNextLibrary = lpTask->hFirstLibrary;

	mov	eax, DWORD PTR _lpLibrary$[ebp]
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+122]
	mov	DWORD PTR [eax+2], edx

; 7062 :       lpTask->hFirstLibrary = hLibrary;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR _hLibrary$[ebp]
	mov	DWORD PTR [eax+122], ecx

; 7063 : 
; 7064 :       if ( bMutexLocked )

	mov	edx, DWORD PTR _bMutexLocked$62980[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L62985

; 7065 :          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$L62985:

; 7067 : 
; 7068 :    return( hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
$L62928:

; 7069 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysLoadLibraryWithErrFlag@12 ENDP
_TEXT	ENDS
PUBLIC	_SysLoadLibrary@8
_TEXT	SEGMENT
_lpTaskView$ = 8
_cpcLibraryName$ = 12
_SysLoadLibrary@8 PROC NEAR

; 7104 : {

	push	ebp
	mov	ebp, esp

; 7105 :    return( SysLoadLibraryWithErrFlag( lpTaskView, cpcLibraryName, zLOADLIB_WITHERR ) );

	push	1
	mov	eax, DWORD PTR _cpcLibraryName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_SysLoadLibraryWithErrFlag@12

; 7106 : }

	pop	ebp
	ret	8
_SysLoadLibrary@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EK@FCCD@?$CIsy?$CJ?5SysGetProc?5failed?5with?5erro@ ; `string'
PUBLIC	_SysGetProc@8
EXTRN	__imp__GetProcAddress@8:NEAR
;	COMDAT ??_C@_0EK@FCCD@?$CIsy?$CJ?5SysGetProc?5failed?5with?5erro@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0EK@FCCD@?$CIsy?$CJ?5SysGetProc?5failed?5with?5erro@ DB '(sy) SysGe'
	DB	'tProc failed with error code: %d   DLL: %s   Function: %s xx:'
	DB	'%s', 00H					; `string'
_DATA	ENDS
_TEXT	SEGMENT
_hLibrary$ = 8
_cpcProcName$ = 12
_lpLibrary$ = -8
_pfReturn$ = -4
_SysGetProc@8 PROC NEAR

; 7126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 7127 :    LPLIBRARY lpLibrary = zGETPTR( hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax

; 7128 :    zPVOID    pfReturn;
; 7129 : 
; 7130 :    if ( cpcProcName == 0 || cpcProcName[ 0 ] == 0 || lpLibrary == 0 )

	cmp	DWORD PTR _cpcProcName$[ebp], 0
	je	SHORT $L63000
	mov	ecx, DWORD PTR _cpcProcName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L63000
	cmp	DWORD PTR _lpLibrary$[ebp], 0
	jne	SHORT $L62999
$L63000:

; 7131 :       pfReturn = 0;

	mov	DWORD PTR _pfReturn$[ebp], 0

; 7132 :    else

	jmp	SHORT $L63003
$L62999:

; 7134 :       pfReturn = GetProcAddress( (HMODULE) lpLibrary->hLibrary, cpcProcName );

	mov	eax, DWORD PTR _cpcProcName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	edx, DWORD PTR [ecx+263]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _pfReturn$[ebp], eax

; 7135 :       if ( pfReturn == 0 )

	cmp	DWORD PTR _pfReturn$[ebp], 0
	jne	SHORT $L63003

; 7137 : #if 0
; 7138 :          char szMessage[ 16 ];
; 7139 : 
; 7140 :          SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );
; 7141 :          if ( szMessage[ 0 ] == 'Y' )
; 7142 :          {
; 7143 :             zSHORT k = 0;
; 7144 :             k /= k;
; 7145 :          }
; 7146 : #endif
; 7147 :          TraceLine( "(sy) SysGetProc failed with error code: %d   DLL: %s   Function: %s xx:%s",
; 7148 :                     (zLONG) GetLastError( ), lpLibrary->szName, cpcProcName,lpLibrary->hLibrary  );

	mov	eax, DWORD PTR _lpLibrary$[ebp]
	mov	ecx, DWORD PTR [eax+263]
	push	ecx
	mov	edx, DWORD PTR _cpcProcName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLibrary$[ebp]
	add	eax, 6
	push	eax
	call	DWORD PTR __imp__GetLastError@0
	push	eax
	push	OFFSET FLAT:??_C@_0EK@FCCD@?$CIsy?$CJ?5SysGetProc?5failed?5with?5erro@ ; `string'
	call	_TraceLine
	add	esp, 20					; 00000014H
$L63003:

; 7151 : 
; 7152 :    return( pfReturn );

	mov	eax, DWORD PTR _pfReturn$[ebp]

; 7153 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SysGetProc@8 ENDP
_TEXT	ENDS
PUBLIC	_SysGetInstance@4
_TEXT	SEGMENT
_hLibrary$ = 8
_lpLibrary$ = -4
_SysGetInstance@4 PROC NEAR

; 7173 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7174 :    LPLIBRARY lpLibrary = zGETPTR( hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax

; 7175 : 
; 7176 :    if ( lpLibrary )

	cmp	DWORD PTR _lpLibrary$[ebp], 0
	je	SHORT $L63011

; 7177 :       return( (zLONG) lpLibrary->hLibrary );

	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR [ecx+263]
	jmp	SHORT $L63013
$L63011:

; 7178 :    else
; 7179 :       return( 0 );

	xor	eax, eax
$L63013:

; 7180 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetInstance@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EA@DNMP@FreeLibrary?5sent?5message?5?$CI0x?$CF08x@ ; `string'
PUBLIC	??_C@_0DM@HPCG@FreeLibrary?5did?5not?5free?5?$CI0x?$CF08x@ ; `string'
PUBLIC	_fnSysFreeLibrary@12
;	COMDAT ??_C@_0EA@DNMP@FreeLibrary?5sent?5message?5?$CI0x?$CF08x@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0EA@DNMP@FreeLibrary?5sent?5message?5?$CI0x?$CF08x@ DB 'FreeLibrary'
	DB	' sent message (0x%08x) for Module: %s - Task: 0x%08x', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DM@HPCG@FreeLibrary?5did?5not?5free?5?$CI0x?$CF08x@
_DATA	SEGMENT
??_C@_0DM@HPCG@FreeLibrary?5did?5not?5free?5?$CI0x?$CF08x@ DB 'FreeLibrar'
	DB	'y did not free (0x%08x) Module: %s - Task: 0x%08x', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_hLibrary$ = 12
_bAllUses$ = 16
_lpPrevSearchLibrary$ = -12
_lpSearchLibrary$ = -8
_lpLibrary$ = -20
_lProcessID$ = -4
_hModule$ = -16
_nProcessIdx$63044 = -28
_pOS_Record$63045 = -32
_lpProcessList$63046 = -24
_fnSysFreeLibrary@12 PROC NEAR

; 7198 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 7199 :    LPLIBRARY  lpPrevSearchLibrary;
; 7200 :    LPLIBRARY  lpSearchLibrary;
; 7201 :    LPLIBRARY  lpLibrary = zGETPTR( hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax

; 7202 :    zLONG      lProcessID;
; 7203 :    HMODULE    hModule;
; 7204 : 
; 7205 :    // If no AnchorBlock return error.
; 7206 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $L63027

; 7207 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L63020
$L63027:

; 7208 : 
; 7209 :    // If task is not active, return error.
; 7210 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L63028

; 7211 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$L63020
$L63028:

; 7212 : 
; 7213 :    // Lock critical section so other threads don't muck stuff.
; 7214 :    EnterCriticalSection( &g_csSysLoadLibrary );

	push	OFFSET FLAT:_g_csSysLoadLibrary
	call	DWORD PTR __imp__EnterCriticalSection@4

; 7215 : 
; 7216 :    // Find Library passed from caller.
; 7217 :    lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 7218 :    lpPrevSearchLibrary = 0;

	mov	DWORD PTR _lpPrevSearchLibrary$[ebp], 0

; 7219 :    lpSearchLibrary = zGETPTR( lpTask->hFirstLibrary );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+122]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLibrary$[ebp], eax
$L63031:

; 7220 :    while ( lpSearchLibrary )

	cmp	DWORD PTR _lpSearchLibrary$[ebp], 0
	je	SHORT $L63032

; 7222 :    // TraceLineS( "fnSysFreeLibrary checking library: ",
; 7223 :    //             lpSearchLibrary->szName );
; 7224 :       if ( lpSearchLibrary == lpLibrary || lpLibrary == 0 )

	mov	eax, DWORD PTR _lpSearchLibrary$[ebp]
	cmp	eax, DWORD PTR _lpLibrary$[ebp]
	je	SHORT $L63034
	cmp	DWORD PTR _lpLibrary$[ebp], 0
	jne	SHORT $L63033
$L63034:

; 7226 :          lpLibrary = lpSearchLibrary;  // ensure non-null library

	mov	ecx, DWORD PTR _lpSearchLibrary$[ebp]
	mov	DWORD PTR _lpLibrary$[ebp], ecx

; 7227 :          break;  // we found the Library record

	jmp	SHORT $L63032
$L63033:

; 7229 : 
; 7230 :       lpPrevSearchLibrary = lpSearchLibrary;

	mov	edx, DWORD PTR _lpSearchLibrary$[ebp]
	mov	DWORD PTR _lpPrevSearchLibrary$[ebp], edx

; 7231 :       lpSearchLibrary = zGETPTR( lpSearchLibrary->hNextLibrary );

	mov	eax, DWORD PTR _lpSearchLibrary$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLibrary$[ebp], eax

; 7232 :    }

	jmp	SHORT $L63031
$L63032:

; 7233 : 
; 7234 :    // Check to see if Library record found for task.
; 7235 :    if ( lpSearchLibrary == 0 )

	cmp	DWORD PTR _lpSearchLibrary$[ebp], 0
	jne	SHORT $L63036

; 7237 :       LeaveCriticalSection( &g_csSysLoadLibrary );

	push	OFFSET FLAT:_g_csSysLoadLibrary
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 7238 :       return( 0 );  // library already freed for this task

	xor	eax, eax
	jmp	$L63020
$L63036:

; 7240 : 
; 7241 : // TraceLine( "Free Library (0x%08x) %s - UseCount: %d   Task 0x%08x",
; 7242 : //            lpLibrary, lpLibrary->szName,
; 7243 : //            lpLibrary ? lpLibrary->ulUseCnt : 0, zGETHNDL( lpTask ) );
; 7244 : 
; 7245 :    // Decrement the use count.  If the use count is greater than zero, then
; 7246 :    // the module has been loaded multiple times, so don't free it yet.
; 7247 :    if ( lpSearchLibrary->ulUseCnt )

	mov	edx, DWORD PTR _lpSearchLibrary$[ebp]
	cmp	DWORD PTR [edx+275], 0
	je	SHORT $L63037

; 7248 :       lpSearchLibrary->ulUseCnt--;

	mov	eax, DWORD PTR _lpSearchLibrary$[ebp]
	mov	ecx, DWORD PTR [eax+275]
	sub	ecx, 1
	mov	edx, DWORD PTR _lpSearchLibrary$[ebp]
	mov	DWORD PTR [edx+275], ecx
$L63037:

; 7249 : 
; 7250 :    if ( lpSearchLibrary->ulUseCnt && bAllUses == FALSE )

	mov	eax, DWORD PTR _lpSearchLibrary$[ebp]
	cmp	DWORD PTR [eax+275], 0
	je	SHORT $L63038
	mov	ecx, DWORD PTR _bAllUses$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L63038

; 7252 :       LeaveCriticalSection( &g_csSysLoadLibrary );

	push	OFFSET FLAT:_g_csSysLoadLibrary
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 7253 :       return( 2 );  // it is freed and can be freed again for this task

	mov	eax, 2
	jmp	$L63020
$L63038:

; 7255 : 
; 7256 :    hModule = (HMODULE) lpLibrary->hLibrary;

	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR [edx+263]
	mov	DWORD PTR _hModule$[ebp], eax

; 7257 : 
; 7258 :    // We have a zero use count for this module, so we want to remove
; 7259 :    // the Library record from the ProcLib Library chain.
; 7260 :    if ( lpPrevSearchLibrary )

	cmp	DWORD PTR _lpPrevSearchLibrary$[ebp], 0
	je	SHORT $L63040

; 7261 :       lpPrevSearchLibrary->hNextLibrary = lpLibrary->hNextLibrary;

	mov	ecx, DWORD PTR _lpPrevSearchLibrary$[ebp]
	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+2], eax

; 7262 :    else

	jmp	SHORT $L63041
$L63040:

; 7263 :       lpTask->hFirstLibrary = lpLibrary->hNextLibrary;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+122], eax
$L63041:

; 7264 : 
; 7265 :    // Environment specific code begins here.
; 7266 : 
; 7267 :    if ( lpLibrary->lProcessID == lProcessID )

	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	edx, DWORD PTR [ecx+271]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $L63042

; 7269 :    // fnTraceLibrary( lpLibrary, 0 );
; 7270 :       FreeLibrary( hModule );

	mov	eax, DWORD PTR _hModule$[ebp]
	push	eax
	call	DWORD PTR __imp__FreeLibrary@4

; 7272 :    else

	jmp	$L63056
$L63042:

; 7274 :       // Send a message to the other process specified by
; 7275 :       // lpLibrary->lProcessID to free the hLibrary.
; 7276 :       zSHORT nProcessIdx;
; 7277 :       LPANCHOROS_RECORD pOS_Record = &AnchorBlock->OS_Data;

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 1503				; 000005dfH
	mov	DWORD PTR _pOS_Record$63045[ebp], ecx

; 7278 :       LPPROCESSLIST lpProcessList;
; 7279 : 
; 7280 :       // Find the process that loaded the library.
; 7281 :       for ( nProcessIdx = AnchorBlock->OS_Data.lProcessCount - 1;
; 7282 :             pOS_Record->ProcessList[ nProcessIdx ].lProcessID != lProcessID;
; 7283 :             nProcessIdx-- )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1507]
	sub	eax, 1
	mov	WORD PTR _nProcessIdx$63044[ebp], ax
	jmp	SHORT $L63047
$L63048:
	mov	cx, WORD PTR _nProcessIdx$63044[ebp]
	sub	cx, 1
	mov	WORD PTR _nProcessIdx$63044[ebp], cx
$L63047:
	movsx	edx, WORD PTR _nProcessIdx$63044[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _pOS_Record$63045[ebp]
	mov	ecx, DWORD PTR [eax+edx+24]
	cmp	ecx, DWORD PTR _lProcessID$[ebp]
	je	SHORT $L63049

; 7285 :          // Nothing needs to be done here.
; 7286 :       }

	jmp	SHORT $L63048
$L63049:

; 7287 : 
; 7288 :       if ( nProcessIdx > 0 )

	movsx	edx, WORD PTR _nProcessIdx$63044[ebp]
	test	edx, edx
	jle	SHORT $L63050

; 7290 :          lpProcessList = &pOS_Record->ProcessList[ nProcessIdx ];

	movsx	eax, WORD PTR _nProcessIdx$63044[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _pOS_Record$63045[ebp]
	lea	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _lpProcessList$63046[ebp], edx

; 7291 :          lpProcessList->nOE_Request  = TASKREQ_FREELIB;

	mov	eax, DWORD PTR _lpProcessList$63046[ebp]
	mov	WORD PTR [eax], 6

; 7292 :          lpProcessList->hMemHandle   = (zULONG) zGETHNDL( lpLibrary );

	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpProcessList$63046[ebp]
	mov	DWORD PTR [edx+12], eax

; 7293 : 
; 7294 :          // Send the message.
; 7295 :          SendMessage( (HWND) lpProcessList->hWndAppOE_Msg,
; 7296 :                       lpProcessList->uAppOE_Msg, 0, nProcessIdx );

	movsx	eax, WORD PTR _nProcessIdx$63044[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpProcessList$63046[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _lpProcessList$63046[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 7297 :          TraceLine( "FreeLibrary sent message (0x%08x) for Module: %s - Task: 0x%08x",
; 7298 :                     lpLibrary, lpLibrary->szName, zGETHNDL( lpTask ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	eax, DWORD PTR _lpLibrary$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0EA@DNMP@FreeLibrary?5sent?5message?5?$CI0x?$CF08x@ ; `string'
	call	_TraceLine
	add	esp, 16					; 00000010H

; 7300 :       else

	jmp	SHORT $L63056
$L63050:

; 7302 :          TraceLine( "FreeLibrary did not free (0x%08x) Module: %s - Task: 0x%08x",
; 7303 :                     lpLibrary, lpLibrary->szName, zGETHNDL( lpTask ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	eax, DWORD PTR _lpLibrary$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DM@HPCG@FreeLibrary?5did?5not?5free?5?$CI0x?$CF08x@ ; `string'
	call	_TraceLine
	add	esp, 16					; 00000010H
$L63056:

; 7308 : 
; 7309 :    fnFreeDataspace( lpLibrary );

	mov	edx, DWORD PTR _lpLibrary$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 7310 :    LeaveCriticalSection( &g_csSysLoadLibrary );

	push	OFFSET FLAT:_g_csSysLoadLibrary
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 7311 :    return( 1 );  // this library freed for this task

	mov	eax, 1
$L63020:

; 7312 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSysFreeLibrary@12 ENDP
_TEXT	ENDS
PUBLIC	_SysFreeLibrary@8
_TEXT	SEGMENT
_lpTaskView$ = 8
_hLibrary$ = 12
_lpTask$ = -8
_nRC$ = -4
_SysFreeLibrary@8 PROC NEAR

; 7328 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 7329 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L64920
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR -12+[ebp], eax
	jmp	SHORT $L64921
$L64920:
	mov	DWORD PTR -12+[ebp], 0
$L64921:
	mov	edx, DWORD PTR -12+[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 7330 : 
; 7331 :    int nRC = fnSysFreeLibrary( lpTask, hLibrary, FALSE );

	push	0
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysFreeLibrary@12
	mov	DWORD PTR _nRC$[ebp], eax

; 7332 :    if ( nRC > 0 )

	cmp	DWORD PTR _nRC$[ebp], 0
	jle	SHORT $L63067

; 7333 :       nRC = 0;

	mov	DWORD PTR _nRC$[ebp], 0
$L63067:

; 7334 : 
; 7335 :    return( nRC );

	mov	eax, DWORD PTR _nRC$[ebp]

; 7336 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SysFreeLibrary@8 ENDP
_TEXT	ENDS
PUBLIC	_fnReuseEntity@4
_TEXT	SEGMENT
_lpViewEntityCsr$ = 8
_lpEntityInstance$ = -4
_fnReuseEntity@4 PROC NEAR

; 7352 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7353 :    LPENTITYINSTANCE  lpEntityInstance;
; 7354 : 
; 7355 :    EnterCriticalSection( &g_csReuseEntity );

	push	OFFSET FLAT:_g_csReuseEntity
	call	DWORD PTR __imp__EnterCriticalSection@4

; 7356 : 
; 7357 :    lpEntityInstance = zGETPTR( ((LPVIEWENTITYCSR) lpViewEntityCsr)->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$L63075:

; 7358 :    while ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $L63076

; 7360 :       if ( lpEntityInstance->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	test	eax, eax
	je	SHORT $L63077

; 7362 :          lpEntityInstance->u.nInd.bHidden = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	dh, -5					; fffffffbH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 7363 :          LeaveCriticalSection( &g_csReuseEntity );

	push	OFFSET FLAT:_g_csReuseEntity
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 7364 :          return( lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	jmp	SHORT $L63070
$L63077:

; 7366 : 
; 7367 :       lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 7368 :    }

	jmp	SHORT $L63075
$L63076:

; 7369 : 
; 7370 :    LeaveCriticalSection( &g_csReuseEntity );

	push	OFFSET FLAT:_g_csReuseEntity
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 7371 :    return( 0 );

	xor	eax, eax
$L63070:

; 7372 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnReuseEntity@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_04GKDJ@?$FL?$CFs?$FN?$AA@			; `string'
;	COMDAT ??_C@_04GKDJ@?$FL?$CFs?$FN?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_04GKDJ@?$FL?$CFs?$FN?$AA@ DB '[%s]', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_hFile$ = 8
_cpcGroup$ = 12
_pchParameter$ = 16
_pchValue$ = 20
_lpTask$ = -268
_pvFile$ = -272
_szParseName$ = -128
_szGroup$ = -264
_pchLine$ = -132
_pchParseValue$ = -276
_pchLineValue$ = -136
_k$ = -280
_szFileName$63103 = -540
_nTrys$63104 = -544
_SysReadZeidonIni@16 PROC NEAR

; 7491 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 544				; 00000220H

; 7492 :    LPTASK lpTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 7493 :    zPVOID pvFile;
; 7494 :    char   szParseName[ 128 ];
; 7495 :    char   szGroup[ 128 ];
; 7496 :    zPCHAR pchLine;   // SysReadLine will allocate the buffer
; 7497 :    zPCHAR pchParseValue;
; 7498 :    zPCHAR pchLineValue;
; 7499 :    int    k;
; 7500 : 
; 7501 :    // Initialize output value to null.
; 7502 :    pchValue[ 0 ] = 0;

	mov	edx, DWORD PTR _pchValue$[ebp]
	mov	BYTE PTR [edx], 0

; 7503 : 
; 7504 :    // If Anchor block doesn't exist, abandon.
; 7505 :    if ( AnchorBlock == 0 || lpTask == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $L63098
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L63097
$L63098:

; 7506 :       return( -1 );

	or	eax, -1
	jmp	$L63087
$L63097:

; 7507 : 
; 7508 :    // Add [] if not supplied.
; 7509 :    if ( cpcGroup[ 0 ] != '[' )

	mov	eax, DWORD PTR _cpcGroup$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 91					; 0000005bH
	je	SHORT $L63099

; 7510 :       zsprintf( szGroup, "[%s]", cpcGroup );

	mov	edx, DWORD PTR _cpcGroup$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04GKDJ@?$FL?$CFs?$FN?$AA@ ; `string'
	lea	eax, DWORD PTR _szGroup$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7511 :    else

	jmp	SHORT $L63101
$L63099:

; 7512 :       zstrcpy( szGroup, cpcGroup );

	mov	ecx, DWORD PTR _cpcGroup$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szGroup$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L63101:

; 7513 : 
; 7514 :    // If this is not a repeated read, open the file.
; 7515 :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	$L63102

; 7517 :       char szFileName[ zMAX_FILENAME_LTH + 1 ];
; 7518 :       int nTrys = 0;

	mov	DWORD PTR _nTrys$63104[ebp], 0

; 7519 : 
; 7520 :       fnBuildZeidonIni( szFileName, sizeof( szFileName ) );

	push	257					; 00000101H
	lea	eax, DWORD PTR _szFileName$63103[ebp]
	push	eax
	call	_fnBuildZeidonIni
	add	esp, 8

; 7521 :       hFile = fnSysOpenFile( lpTask, szFileName, COREFILE_READ );

	push	128					; 00000080H
	lea	ecx, DWORD PTR _szFileName$63103[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 7522 :       if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $L63105

; 7523 :          return( hFile );

	mov	eax, DWORD PTR _hFile$[ebp]
	jmp	$L63087
$L63105:

; 7524 : 
; 7525 :       // Find the group to be processed.
; 7526 :       pvFile = 0;

	mov	DWORD PTR _pvFile$[ebp], 0

; 7527 :       szParseName[ 0 ] = 0;

	mov	BYTE PTR _szParseName$[ebp], 0
$L63107:

; 7528 :       while ( ((k = fnSysReadLine( lpTask, &pchLine,
; 7529 :                                    hFile, &pvFile )) == zCALL_ERROR ||
; 7530 :                pchLine == 0) && nTrys < 5 )

	lea	eax, DWORD PTR _pvFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR _k$[ebp], -16			; fffffff0H
	je	SHORT $L63109
	cmp	DWORD PTR _pchLine$[ebp], 0
	jne	SHORT $L63108
$L63109:
	cmp	DWORD PTR _nTrys$63104[ebp], 5
	jge	SHORT $L63108

; 7532 :          nTrys++;

	mov	ecx, DWORD PTR _nTrys$63104[ebp]
	add	ecx, 1
	mov	DWORD PTR _nTrys$63104[ebp], ecx

; 7533 :       }

	jmp	SHORT $L63107
$L63108:

; 7534 : 
; 7535 :       if ( k == zCALL_ERROR || pchLine == 0 )

	cmp	DWORD PTR _k$[ebp], -16			; fffffff0H
	je	SHORT $L63111
	cmp	DWORD PTR _pchLine$[ebp], 0
	jne	SHORT $L63110
$L63111:

; 7537 :          // Some kind of error ... maybe task not "alive" yet.
; 7538 :          fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFile@12

; 7539 :          return( -1 );

	or	eax, -1
	jmp	$L63087
$L63110:

; 7541 : 
; 7542 :       while ( k && zstrcmpi( szParseName, szGroup ) != 0 )

	cmp	DWORD PTR _k$[ebp], 0
	je	SHORT $L63114
	lea	ecx, DWORD PTR _szGroup$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szParseName$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L63114

; 7544 :          SysParseLine( szParseName, &pchParseValue, pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchParseValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szParseName$[ebp]
	push	edx
	call	_SysParseLine@12

; 7545 :          k = fnSysReadLine( lpTask, &pchLine, hFile, &pvFile );

	lea	eax, DWORD PTR _pvFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax

; 7546 :       }

	jmp	SHORT $L63110
$L63114:

; 7547 : 
; 7548 :       // If the Group was not found, close the file and return.
; 7549 :       if ( k == 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jne	SHORT $L63115

; 7551 :          fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 7552 :          pvFile = 0;

	mov	DWORD PTR _pvFile$[ebp], 0

; 7553 :          return( -1 );

	or	eax, -1
	jmp	$L63087
$L63115:

; 7556 :    else

	jmp	SHORT $L63116
$L63102:

; 7558 :       // Read the next line if processing an already opened file.
; 7559 :       k = fnSysReadLine( lpTask, &pchLine, hFile, &pvFile );

	lea	eax, DWORD PTR _pvFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax
$L63116:

; 7561 : 
; 7562 :    // The Group has been located and we have read the first line
; 7563 :    // following the Group identifier, look for the specified parameter.
; 7564 :    while ( k )

	cmp	DWORD PTR _k$[ebp], 0
	je	$L63119

; 7566 :       SysParseLine( szParseName, &pchParseValue, pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchParseValue$[ebp]
	push	edx
	lea	eax, DWORD PTR _szParseName$[ebp]
	push	eax
	call	_SysParseLine@12
$L63121:

; 7567 : 
; 7568 :       // Remove blanks before Parse Value.
; 7569 :       while ( pchParseValue[ 0 ] == ' ' )

	mov	ecx, DWORD PTR _pchParseValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $L63122

; 7570 :          pchParseValue++;

	mov	eax, DWORD PTR _pchParseValue$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchParseValue$[ebp], eax
	jmp	SHORT $L63121
$L63122:

; 7571 : 
; 7572 :       // If the parameter name was not delimited by an equal sign '=',
; 7573 :       // search for an equal and bump past it.
; 7574 :       if ( pchParseValue[ 0 ] == '=' )

	mov	ecx, DWORD PTR _pchParseValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 61					; 0000003dH
	jne	$L63133

; 7576 :          pchLineValue = pchLine;

	mov	eax, DWORD PTR _pchLine$[ebp]
	mov	DWORD PTR _pchLineValue$[ebp], eax
$L63125:

; 7577 : 
; 7578 :          // Find first non-blank in line.
; 7579 :          while ( pchLineValue[ 0 ] == ' ' )

	mov	ecx, DWORD PTR _pchLineValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $L63126

; 7580 :             pchLineValue++;

	mov	eax, DWORD PTR _pchLineValue$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchLineValue$[ebp], eax
	jmp	SHORT $L63125
$L63126:

; 7581 : 
; 7582 :          // Find first blank or '=' in line after first non-blank.
; 7583 :          while ( pchLineValue[ 0 ] != ' ' && pchLineValue[ 0 ] != '=' )

	mov	ecx, DWORD PTR _pchLineValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $L63129
	mov	eax, DWORD PTR _pchLineValue$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	SHORT $L63129

; 7584 :             pchLineValue++;

	mov	edx, DWORD PTR _pchLineValue$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchLineValue$[ebp], edx
	jmp	SHORT $L63126
$L63129:

; 7585 : 
; 7586 :          // If a space occurred after the parameter name and before the
; 7587 :          // '=' sign, then increment pchParseValue after the equal sign.
; 7588 :          if ( pchLineValue[ 0 ] != '=' )

	mov	eax, DWORD PTR _pchLineValue$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	SHORT $L63133

; 7590 :             pchParseValue++;

	mov	edx, DWORD PTR _pchParseValue$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchParseValue$[ebp], edx
$L63132:

; 7591 : 
; 7592 :             // Remove blanks before Parse Value.
; 7593 :             while ( pchParseValue[ 0 ] == ' ' )

	mov	eax, DWORD PTR _pchParseValue$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $L63133

; 7594 :                pchParseValue++;

	mov	edx, DWORD PTR _pchParseValue$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchParseValue$[ebp], edx
	jmp	SHORT $L63132
$L63133:

; 7597 : 
; 7598 :       // If a new group was found, close file and return invalid file.
; 7599 :       if ( szParseName[ 0 ] == '[' )

	movsx	eax, BYTE PTR _szParseName$[ebp]
	cmp	eax, 91					; 0000005bH
	jne	SHORT $L63134

; 7601 :          fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 7602 :          return( -1 );

	or	eax, -1
	jmp	$L63087
$L63134:

; 7604 : 
; 7605 :       // If no parameter was passed and a parameter was found or
; 7606 :       // a parameter was passed and it matches the name found
; 7607 :       // select this parameter to return to the caller.
; 7608 :       if ( (pchParameter[ 0 ] == 0 && szParseName[ 0 ]) ||
; 7609 :            (szParseName[ 0 ] &&
; 7610 :             zstrcmpi( szParseName, pchParameter ) == 0) )

	mov	eax, DWORD PTR _pchParameter$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L63137
	movsx	edx, BYTE PTR _szParseName$[ebp]
	test	edx, edx
	jne	SHORT $L63136
$L63137:
	movsx	eax, BYTE PTR _szParseName$[ebp]
	test	eax, eax
	je	SHORT $L63135
	mov	ecx, DWORD PTR _pchParameter$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szParseName$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L63135
$L63136:

; 7612 :          zstrcpy( pchValue, pchParseValue );

	mov	eax, DWORD PTR _pchParseValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchValue$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7613 :          if ( pchParameter[ 0 ] == 0 )

	mov	edx, DWORD PTR _pchParameter$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $L63138

; 7614 :             zstrcpy( pchParameter, szParseName );

	lea	ecx, DWORD PTR _szParseName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchParameter$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7615 :          else

	jmp	SHORT $L63139
$L63138:

; 7617 :             fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysCloseFile@12

; 7618 :             hFile = -1;

	mov	DWORD PTR _hFile$[ebp], -1
$L63139:

; 7620 : 
; 7621 :          return( hFile );

	mov	eax, DWORD PTR _hFile$[ebp]
	jmp	SHORT $L63087
$L63135:

; 7623 : 
; 7624 :       // Get the next line from the zeidon.ini file.
; 7625 :       k = fnSysReadLine( lpTask, &pchLine, hFile, &pvFile );

	lea	edx, DWORD PTR _pvFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax

; 7626 :    }

	jmp	$L63116
$L63119:

; 7627 : 
; 7628 :    // No luck finding the parameter, quit.
; 7629 :    fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysCloseFile@12

; 7630 :    return( -1 );

	or	eax, -1
$L63087:

; 7631 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysReadZeidonIni@16 ENDP
_TEXT	ENDS
PUBLIC	_SysUpdateZeidonIni@12
PUBLIC	??_C@_05DBPH@?$CFs?$DN?$CFs?$AA@		; `string'
PUBLIC	??_C@_0L@IOL@zeidon?4in?$HO?$AA@		; `string'
PUBLIC	??_C@_08KBJI@?$FLZeidon?$FN?$AA@		; `string'
PUBLIC	??_C@_0P@HMIB@?$FLEncyclopedia?$FN?$AA@		; `string'
PUBLIC	??_C@_0BC@GKOC@?$FLObject?5Services?$FN?$AA@	; `string'
;	COMDAT ??_C@_05DBPH@?$CFs?$DN?$CFs?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_05DBPH@?$CFs?$DN?$CFs?$AA@ DB '%s=%s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@IOL@zeidon?4in?$HO?$AA@
_DATA	SEGMENT
??_C@_0L@IOL@zeidon?4in?$HO?$AA@ DB 'zeidon.in~', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08KBJI@?$FLZeidon?$FN?$AA@
_DATA	SEGMENT
??_C@_08KBJI@?$FLZeidon?$FN?$AA@ DB '[Zeidon]', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@HMIB@?$FLEncyclopedia?$FN?$AA@
_DATA	SEGMENT
??_C@_0P@HMIB@?$FLEncyclopedia?$FN?$AA@ DB '[Encyclopedia]', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@GKOC@?$FLObject?5Services?$FN?$AA@
_DATA	SEGMENT
??_C@_0BC@GKOC@?$FLObject?5Services?$FN?$AA@ DB '[Object Services]', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_cpcGroup$ = 8
_cpcParameter$ = 12
_cpcValue$ = 16
_lpTask$ = -744
_pvFileIn$ = -660
_pvFileOut$ = -1276
_szParmString$ = -1272
_szFileName$ = -652
_szFileNameTmp$ = -388
_szParseName$ = -128
_szGroup$ = -740
_pchLine$ = -392
_pchParseValue$ = -748
_hFIn$ = -756
_hFOut$ = -656
_k$ = -752
_SysUpdateZeidonIni@12 PROC NEAR

; 7664 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1276				; 000004fcH

; 7665 :    LPTASK lpTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 7666 :    zPVOID pvFileIn;
; 7667 :    zPVOID pvFileOut;
; 7668 :    char   szParmString[ 2 * (zMAX_FILENAME_LTH  + 1) ];
; 7669 :    char   szFileName[ zMAX_FILENAME_LTH + 1 ];
; 7670 :    char   szFileNameTmp[ zMAX_FILENAME_LTH  + 1 ];
; 7671 :    char   szParseName[ 128 ];
; 7672 :    char   szGroup[ 80 ];
; 7673 :    zPCHAR pchLine;
; 7674 :    zPCHAR pchParseValue;
; 7675 :    zLONG  hFIn;
; 7676 :    zLONG  hFOut;
; 7677 :    int    k;
; 7678 : 
; 7679 :    // build the parameter to be written into ZEIDON.INI
; 7680 :    zsprintf( szParmString, "%s=%s", cpcParameter, cpcValue );

	mov	edx, DWORD PTR _cpcValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcParameter$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_05DBPH@?$CFs?$DN?$CFs?$AA@ ; `string'
	lea	ecx, DWORD PTR _szParmString$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 7681 : 
; 7682 :    k = fnBuildZeidonIni( szFileName, sizeof( szFileName ) );

	push	257					; 00000101H
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_fnBuildZeidonIni
	add	esp, 8
	movsx	eax, ax
	mov	DWORD PTR _k$[ebp], eax

; 7683 :    zstrcpy( szFileNameTmp, szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileNameTmp$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7684 :    zstrcpy( szFileNameTmp + k, "zeidon.in~" );

	push	OFFSET FLAT:??_C@_0L@IOL@zeidon?4in?$HO?$AA@ ; `string'
	mov	eax, DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szFileNameTmp$[ebp+eax]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7685 :    hFIn = fnSysOpenFile( lpTask, szFileName, COREFILE_READ );

	push	128					; 00000080H
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFIn$[ebp], eax

; 7686 : 
; 7687 :    // Add [] if not supplied.
; 7688 :    if ( cpcGroup[ 0 ] != '[' )

	mov	ecx, DWORD PTR _cpcGroup$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 91					; 0000005bH
	je	SHORT $L63163

; 7689 :       zsprintf( szGroup, "[%s]", cpcGroup );

	mov	eax, DWORD PTR _cpcGroup$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_04GKDJ@?$FL?$CFs?$FN?$AA@ ; `string'
	lea	ecx, DWORD PTR _szGroup$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 7690 :    else

	jmp	SHORT $L63164
$L63163:

; 7691 :       zstrcpy( szGroup, cpcGroup );

	mov	edx, DWORD PTR _cpcGroup$[ebp]
	push	edx
	lea	eax, DWORD PTR _szGroup$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L63164:

; 7692 : 
; 7693 :    // If the file does not exist, create one
; 7694 :    if ( hFIn == -1 )

	cmp	DWORD PTR _hFIn$[ebp], -1
	jne	$L63165

; 7696 :       pvFileOut = 0;

	mov	DWORD PTR _pvFileOut$[ebp], 0

; 7697 : 
; 7698 :       hFOut = fnSysOpenFile( lpTask, szFileName,
; 7699 :                              COREFILE_CREATE | COREFILE_WRITELINE_BUFFERED );

	push	33					; 00000021H
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFOut$[ebp], eax

; 7700 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "[Zeidon]" );

	push	OFFSET FLAT:??_C@_08KBJI@?$FLZeidon?$FN?$AA@ ; `string'
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 7701 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 7702 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "[Encyclopedia]" );

	push	OFFSET FLAT:??_C@_0P@HMIB@?$FLEncyclopedia?$FN?$AA@ ; `string'
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 7703 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 7704 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "[Workstation]" );

	push	OFFSET FLAT:??_C@_0O@IMEJ@?$FLWorkstation?$FN?$AA@ ; `string'
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 7705 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 7706 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "[Object Services]" );

	push	OFFSET FLAT:??_C@_0BC@GKOC@?$FLObject?5Services?$FN?$AA@ ; `string'
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 7707 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 7708 :       fnSysCloseFile( lpTask, hFOut, 0 );

	push	0
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysCloseFile@12

; 7709 : 
; 7710 :       hFIn = fnSysOpenFile( lpTask, szFileName, COREFILE_READ );

	push	128					; 00000080H
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFIn$[ebp], eax
$L63165:

; 7712 : 
; 7713 :    // Perform the Update to the temp file
; 7714 :    if ( hFIn != -1 )

	cmp	DWORD PTR _hFIn$[ebp], -1
	je	$L63169

; 7716 :       hFOut = fnSysOpenFile( lpTask, szFileNameTmp,
; 7717 :                              COREFILE_CREATE | COREFILE_WRITELINE_BUFFERED );

	push	33					; 00000021H
	lea	ecx, DWORD PTR _szFileNameTmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFOut$[ebp], eax

; 7718 : 
; 7719 :       if ( hFOut == -1 )

	cmp	DWORD PTR _hFOut$[ebp], -1
	jne	SHORT $L63170

; 7721 :          fnSysCloseFile( lpTask, hFIn, 0 );

	push	0
	mov	eax, DWORD PTR _hFIn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysCloseFile@12

; 7722 :          return;

	jmp	$L63146
$L63170:

; 7724 : 
; 7725 :       pvFileIn = 0;

	mov	DWORD PTR _pvFileIn$[ebp], 0

; 7726 :       pvFileOut = 0;

	mov	DWORD PTR _pvFileOut$[ebp], 0

; 7727 :       szParseName[ 0 ] = 0;

	mov	BYTE PTR _szParseName$[ebp], 0

; 7728 :       k = fnSysReadLine( lpTask, &pchLine, hFIn, &pvFileIn );

	lea	edx, DWORD PTR _pvFileIn$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFIn$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax
$L63172:

; 7729 : 
; 7730 :       while ( k && zstrcmpi( szParseName, szGroup ) != 0 )

	cmp	DWORD PTR _k$[ebp], 0
	je	SHORT $L63173
	lea	eax, DWORD PTR _szGroup$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szParseName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L63173

; 7732 :          SysParseLine( szParseName, &pchParseValue, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchParseValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szParseName$[ebp]
	push	ecx
	call	_SysParseLine@12

; 7733 :          fnSysWriteLine( lpTask, hFOut, &pvFileOut, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 7734 :          k = fnSysReadLine( lpTask, &pchLine, hFIn, &pvFileIn );

	lea	eax, DWORD PTR _pvFileIn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFIn$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax

; 7735 :       }

	jmp	$L63172
$L63173:

; 7736 : 
; 7737 :       // If the Group was not found, create it.
; 7738 :       if ( k == 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jne	SHORT $L63174

; 7740 :          fnSysWriteLine( lpTask, hFOut, &pvFileOut, "" ); // write blank line

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _pvFileOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteLine@16

; 7741 :          fnSysWriteLine( lpTask, hFOut, &pvFileOut, szGroup );

	lea	ecx, DWORD PTR _szGroup$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvFileOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLine@16

; 7743 :       else

	jmp	$L63178
$L63174:

; 7744 :       while ( k )

	cmp	DWORD PTR _k$[ebp], 0
	je	$L63178

; 7746 :          // Group line has been found and rewritten, search for parameter
; 7747 :          // in the group.
; 7748 :          SysParseLine( szParseName, &pchParseValue, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchParseValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szParseName$[ebp]
	push	ecx
	call	_SysParseLine@12

; 7749 :          if ( zstrcmpi( szParseName, cpcParameter ) == 0 )

	mov	edx, DWORD PTR _cpcParameter$[ebp]
	push	edx
	lea	eax, DWORD PTR _szParseName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L63179

; 7750 :             break;

	jmp	$L63178
$L63179:

; 7751 :          else
; 7752 :          if ( szParseName[ 0 ] == '[' )  // keep an eye out for another group

	movsx	ecx, BYTE PTR _szParseName$[ebp]
	cmp	ecx, 91					; 0000005bH
	jne	SHORT $L63181

; 7754 :             fnSysWriteLine( lpTask, hFOut, &pvFileOut, szParmString );  // create new parm

	lea	edx, DWORD PTR _szParmString$[ebp]
	push	edx
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 7755 :             fnSysWriteLine( lpTask, hFOut, &pvFileOut, "" );            // write blank after parm

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 7756 :             zstrcpy( szParmString, pchLine );     // set string to nxt grp

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szParmString$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7757 :             break;

	jmp	SHORT $L63178
$L63181:

; 7759 : 
; 7760 :          // Don't rewrite blank lines while searching for parameter
; 7761 :          if ( szParseName[ 0 ] )

	movsx	edx, BYTE PTR _szParseName$[ebp]
	test	edx, edx
	je	SHORT $L63182

; 7762 :             fnSysWriteLine( lpTask, hFOut, &pvFileOut, pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvFileOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteLine@16
$L63182:

; 7763 : 
; 7764 :          k = fnSysReadLine( lpTask, &pchLine, hFIn, &pvFileIn );

	lea	ecx, DWORD PTR _pvFileIn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFIn$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax

; 7765 : 
; 7766 :       } // while ( k )...

	jmp	$L63174
$L63178:

; 7767 : 
; 7768 :       // Add parameter or rewrite next group line depending on the
; 7769 :       // outcome of parameter search above
; 7770 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, szParmString );

	lea	edx, DWORD PTR _szParmString$[ebp]
	push	edx
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16
$L63184:

; 7771 :       while ( k > 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jle	SHORT $L63185

; 7773 :          k = fnSysReadLine( lpTask, &pchLine, hFIn, &pvFileIn );

	lea	eax, DWORD PTR _pvFileIn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFIn$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax

; 7774 :          if ( k )

	cmp	DWORD PTR _k$[ebp], 0
	je	SHORT $L63186

; 7775 :             fnSysWriteLine( lpTask, hFOut, &pvFileOut, pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvFileOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLine@16
$L63186:

; 7776 :       }

	jmp	SHORT $L63184
$L63185:

; 7777 : 
; 7778 :       // Close Zeidon ini file
; 7779 :       fnSysCloseFile( lpTask, hFOut, 0 );

	push	0
	mov	edx, DWORD PTR _hFOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFile@12

; 7780 :       fnSysCloseFile( lpTask, hFIn, 0 );

	push	0
	mov	ecx, DWORD PTR _hFIn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12
$L63169:

; 7782 : 
; 7783 :    // replace old ZEIDON.INI with updated temp ZEIDON.IN~
; 7784 :    fnSysOpenFile( lpTask, szFileName, COREFILE_DELETE );

	push	8
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysOpenFile@12

; 7785 :    zstrcpy( szParmString, szFileNameTmp );

	lea	edx, DWORD PTR _szFileNameTmp$[ebp]
	push	edx
	lea	eax, DWORD PTR _szParmString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 7786 :    zstrcpy( &szParmString[ zstrlen( szParmString ) + 1 ], szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szParmString$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	lea	eax, DWORD PTR _szParmString$[ebp+eax+1]
	push	eax
	call	_strcpy
	add	esp, 8

; 7787 :    fnSysOpenFile( lpTask, szParmString, COREFILE_RENAME );

	push	16					; 00000010H
	lea	ecx, DWORD PTR _szParmString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12
$L63146:

; 7788 : 
; 7789 : } // SysUpdateZeidonIni

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysUpdateZeidonIni@12 ENDP
_TEXT	ENDS
PUBLIC	_SfListTasks
_TEXT	SEGMENT
_SfListTasks PROC NEAR

; 7793 : {

	push	ebp
	mov	ebp, esp

; 7794 :    PostMessage( (HWND) AnchorBlock->lOE_hMainWnd,
; 7795 :                 WM_COMMAND, (WPARAM) IDM_LISTTASKS, (LPARAM) 10000L );

	push	10000					; 00002710H
	push	112					; 00000070H
	push	273					; 00000111H
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	DWORD PTR __imp__PostMessageA@16

; 7796 : }

	pop	ebp
	ret	0
_SfListTasks ENDP
_TEXT	ENDS
PUBLIC	_SysMessageBeep@0
EXTRN	__imp__MessageBeep@4:NEAR
_TEXT	SEGMENT
_SysMessageBeep@0 PROC NEAR

; 7809 : {

	push	ebp
	mov	ebp, esp

; 7810 :    MessageBeep( 0 );       // ring the buzzer...

	push	0
	call	DWORD PTR __imp__MessageBeep@4

; 7811 : }

	pop	ebp
	ret	0
_SysMessageBeep@0 ENDP
_pchString$ = 8
_lLth$ = -4
_SysAppendcDirSep@4 PROC NEAR

; 7824 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7825 :    zLONG  lLth;
; 7826 : 
; 7827 :    lLth = zstrlen( pchString );

	mov	eax, DWORD PTR _pchString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lLth$[ebp], eax

; 7828 :    if ( lLth > 1 && pchString[ lLth - 1 ] != cDirSep )

	cmp	DWORD PTR _lLth$[ebp], 1
	jle	SHORT $L63198
	mov	ecx, DWORD PTR _pchString$[ebp]
	add	ecx, DWORD PTR _lLth$[ebp]
	movsx	edx, BYTE PTR [ecx-1]
	movsx	eax, BYTE PTR _cDirSep
	cmp	edx, eax
	je	SHORT $L63198

; 7830 :       pchString[ lLth++ ] = cDirSep;

	mov	ecx, DWORD PTR _pchString$[ebp]
	add	ecx, DWORD PTR _lLth$[ebp]
	mov	dl, BYTE PTR _cDirSep
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _lLth$[ebp]
	add	eax, 1
	mov	DWORD PTR _lLth$[ebp], eax

; 7831 :       pchString[ lLth ] = 0;

	mov	ecx, DWORD PTR _pchString$[ebp]
	add	ecx, DWORD PTR _lLth$[ebp]
	mov	BYTE PTR [ecx], 0
$L63198:

; 7833 : 
; 7834 :    return( (zSHORT) lLth );

	mov	ax, WORD PTR _lLth$[ebp]

; 7835 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysAppendcDirSep@4 ENDP
_TEXT	ENDS
PUBLIC	_SysValidDirOrFile@16
PUBLIC	??_C@_0CB@OHMI@Error?5in?5directory?5specification@ ; `string'
PUBLIC	??_C@_0BJ@KAEF@Error?5creating?5directory?$AA@	; `string'
EXTRN	__imp__CreateDirectoryA@8:NEAR
EXTRN	__imp__GetFullPathNameA@16:NEAR
EXTRN	__imp__GetFileAttributesA@4:NEAR
;	COMDAT ??_C@_0CB@OHMI@Error?5in?5directory?5specification@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CB@OHMI@Error?5in?5directory?5specification@ DB 'Error in director'
	DB	'y specification', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@KAEF@Error?5creating?5directory?$AA@
_DATA	SEGMENT
??_C@_0BJ@KAEF@Error?5creating?5directory?$AA@ DB 'Error creating directo'
	DB	'ry', 00H					; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchPath$ = 8
_bDirectory$ = 12
_bCheckCreate$ = 16
_nMaxPathLth$ = 20
_pch$ = -4
_szFullPath$ = -520
_dwAttr$ = -524
_SysValidDirOrFile@16 PROC NEAR

; 7860 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 524				; 0000020cH

; 7861 :    zPCHAR pch;
; 7862 :    zCHAR  szFullPath[ zMAX_FILESPEC_LTH + 1 ];
; 7863 :    DWORD  dwAttr;
; 7864 : 
; 7865 : // TraceLineS( "Checking dir = ", pchPath );
; 7866 : 
; 7867 :    if ( pchPath == 0 || *pchPath == 0 )

	cmp	DWORD PTR _pchPath$[ebp], 0
	je	SHORT $L63213
	mov	eax, DWORD PTR _pchPath$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L63212
$L63213:

; 7868 :       return( FALSE );     // no directory was specified

	xor	ax, ax
	jmp	$L63208
$L63212:

; 7869 : 
; 7870 :    if ( GetFullPathName( pchPath, nMaxPathLth, szFullPath, &pch ) == 0 )

	lea	edx, DWORD PTR _pch$[ebp]
	push	edx
	lea	eax, DWORD PTR _szFullPath$[ebp]
	push	eax
	movsx	ecx, WORD PTR _nMaxPathLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchPath$[ebp]
	push	edx
	call	DWORD PTR __imp__GetFullPathNameA@16
	test	eax, eax
	jne	SHORT $L63214

; 7872 :       // "KZOEE025 - Error in directory specification"
; 7873 :       fnSysMessageBox( 0, "Zeidon Error",
; 7874 :                        "Error in directory specification", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0CB@OHMI@Error?5in?5directory?5specification@ ; `string'
	push	OFFSET FLAT:??_C@_0N@EEMD@Zeidon?5Error?$AA@ ; `string'
	push	0
	call	_fnSysMessageBox@16

; 7875 :    // fnIssueCoreError( 0, lpView, 16, 25, 0, pchPath, 0 );
; 7876 :       return( FALSE );

	xor	ax, ax
	jmp	$L63208
$L63214:

; 7878 : 
; 7879 :    zstrncpy( pchPath, szFullPath, nMaxPathLth );

	movsx	eax, WORD PTR _nMaxPathLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFullPath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchPath$[ebp]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 7880 :    pchPath[ nMaxPathLth - 1 ] = 0;              // Make sure null-term is there.

	movsx	eax, WORD PTR _nMaxPathLth$[ebp]
	mov	ecx, DWORD PTR _pchPath$[ebp]
	mov	BYTE PTR [ecx+eax-1], 0

; 7881 : 
; 7882 :    dwAttr = GetFileAttributes( szFullPath );

	lea	edx, DWORD PTR _szFullPath$[ebp]
	push	edx
	call	DWORD PTR __imp__GetFileAttributesA@4
	mov	DWORD PTR _dwAttr$[ebp], eax

; 7883 :    if ( dwAttr != -1 )

	cmp	DWORD PTR _dwAttr$[ebp], -1
	je	SHORT $L63218

; 7885 :       // Found a file or directory.  Is this what the user wants?
; 7886 :       if ( bDirectory )

	movsx	eax, WORD PTR _bDirectory$[ebp]
	test	eax, eax
	je	SHORT $L63217

; 7887 :          return( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) != 0;

	mov	eax, DWORD PTR _dwAttr$[ebp]
	and	eax, 16					; 00000010H
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $L63208
$L63217:

; 7888 :       else
; 7889 :          return( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) == 0;

	mov	eax, DWORD PTR _dwAttr$[ebp]
	and	eax, 16					; 00000010H
	neg	eax
	sbb	eax, eax
	inc	eax
	jmp	SHORT $L63208
$L63218:

; 7891 : 
; 7892 :    // If we get here then the file/dir doesn't exist.  If the user is looking
; 7893 :    // for a file then just return.
; 7894 :    if ( bDirectory == FALSE )

	movsx	ecx, WORD PTR _bDirectory$[ebp]
	test	ecx, ecx
	jne	SHORT $L63219

; 7895 :       return( FALSE );

	xor	ax, ax
	jmp	SHORT $L63208
$L63219:

; 7896 : 
; 7897 :    // We looked for a directory and it doesn't exist.  If user doesn't want us
; 7898 :    // to create it, return FALSE.
; 7899 :    if ( bCheckCreate == FALSE )

	movsx	edx, WORD PTR _bCheckCreate$[ebp]
	test	edx, edx
	jne	SHORT $L63220

; 7900 :       return( FALSE );

	xor	ax, ax
	jmp	SHORT $L63208
$L63220:

; 7901 : 
; 7902 :    if ( CreateDirectory( szFullPath, 0 ) ) // created it so let's get out

	push	0
	lea	eax, DWORD PTR _szFullPath$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateDirectoryA@8
	test	eax, eax
	je	SHORT $L63221

; 7903 :       return( TRUE );

	mov	ax, 1
	jmp	SHORT $L63208
$L63221:

; 7904 : 
; 7905 :    // If we get here then there was an error trying to create the directory.
; 7906 :    // Pop up a message.
; 7907 :    // "KZOEE026 - Error creating directory "
; 7908 :    fnSysMessageBox( 0, "Zeidon Error", "Error creating directory", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BJ@KAEF@Error?5creating?5directory?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@EEMD@Zeidon?5Error?$AA@ ; `string'
	push	0
	call	_fnSysMessageBox@16

; 7909 : // fnIssueCoreError( 0, lpView, 16, 26, 0, szFullPath, 0 );
; 7910 :    return( FALSE );

	xor	ax, ax
$L63208:

; 7911 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysValidDirOrFile@16 ENDP
_TEXT	ENDS
PUBLIC	_SysStartHelp@8
PUBLIC	??_C@_0M@LGM@SYSTEM?5HELP?$AA@			; `string'
PUBLIC	??_C@_0M@DADJ@winhelp?4hlp?$AA@			; `string'
PUBLIC	??_C@_04MCON@?4CHM?$AA@				; `string'
PUBLIC	??_C@_08NHGK@?$DOmainwin?$AA@			; `string'
PUBLIC	??_C@_0BK@OOIH@?$CIsy?$CJ?5Starting?5help?5with?3?5?$AA@ ; `string'
PUBLIC	??_C@_0CM@HOD@?$CIsy?$CJ?5Starting?5context?9sensitive?5@ ; `string'
PUBLIC	??_C@_0N@BFPA@MyWindowType?$AA@			; `string'
EXTRN	__imp__GetDesktopWindow@0:NEAR
EXTRN	__imp__atol:NEAR
EXTRN	_HtmlHelpA@16:NEAR
EXTRN	__imp__WinHelpA@16:NEAR
EXTRN	__imp___strupr:NEAR
;	COMDAT ??_C@_0M@LGM@SYSTEM?5HELP?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0M@LGM@SYSTEM?5HELP?$AA@ DB 'SYSTEM HELP', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@DADJ@winhelp?4hlp?$AA@
_DATA	SEGMENT
??_C@_0M@DADJ@winhelp?4hlp?$AA@ DB 'winhelp.hlp', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04MCON@?4CHM?$AA@
_DATA	SEGMENT
??_C@_04MCON@?4CHM?$AA@ DB '.CHM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08NHGK@?$DOmainwin?$AA@
_DATA	SEGMENT
??_C@_08NHGK@?$DOmainwin?$AA@ DB '>mainwin', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@OOIH@?$CIsy?$CJ?5Starting?5help?5with?3?5?$AA@
_DATA	SEGMENT
??_C@_0BK@OOIH@?$CIsy?$CJ?5Starting?5help?5with?3?5?$AA@ DB '(sy) Startin'
	DB	'g help with: ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@HOD@?$CIsy?$CJ?5Starting?5context?9sensitive?5@
_DATA	SEGMENT
??_C@_0CM@HOD@?$CIsy?$CJ?5Starting?5context?9sensitive?5@ DB '(sy) Starti'
	DB	'ng context-sensitive help with: ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@BFPA@MyWindowType?$AA@
_DATA	SEGMENT
??_C@_0N@BFPA@MyWindowType?$AA@ DB 'MyWindowType', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchHelpFile$ = 8
_pchContextID$ = 12
_szFileName$ = -308
_lContextID$ = -8
_hwnd$ = -4
_SysStartHelp@8 PROC NEAR

; 7934 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H

; 7935 :    char  szFileName[ 300 ];
; 7936 :    zLONG lContextID;
; 7937 :    HWND  hwnd;
; 7938 : 
; 7939 :    if ( zstrcmp( pchHelpFile, "SYSTEM HELP" ) == 0 )

	mov	eax, DWORD PTR _pchHelpFile$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR ??_C@_0M@LGM@SYSTEM?5HELP?$AA@
	cmp	ecx, edx
	jne	SHORT $L64930
	push	OFFSET FLAT:??_C@_0M@LGM@SYSTEM?5HELP?$AA@ ; `string'
	mov	eax, DWORD PTR _pchHelpFile$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -312+[ebp], eax
	jmp	SHORT $L64931
$L64930:
	mov	ecx, DWORD PTR _pchHelpFile$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR ??_C@_0M@LGM@SYSTEM?5HELP?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -312+[ebp], ecx
$L64931:
	cmp	DWORD PTR -312+[ebp], 0
	jne	SHORT $L63237

; 7941 :       // Build the file name for the help file.
; 7942 :       zstrcpy( szFileName, "winhelp.hlp" );

	push	OFFSET FLAT:??_C@_0M@DADJ@winhelp?4hlp?$AA@ ; `string'
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7943 : 
; 7944 :       // For calling HelpOnHelp use function Winhelp because there is
; 7945 :       // no compressed Helpfile for this available.
; 7946 :       if ( pchContextID == 0  )

	cmp	DWORD PTR _pchContextID$[ebp], 0
	jne	SHORT $L63240

; 7948 :          if ( WinHelp( 0, szFileName, HELP_CONTENTS, 0  ) == 0 )

	push	0
	push	3
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__WinHelpA@16
	test	eax, eax
	jne	SHORT $L63241

; 7950 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L63227
$L63241:

; 7953 :       else

	jmp	SHORT $L63243
$L63240:

; 7955 :          lContextID = zatol( pchContextID );

	mov	ecx, DWORD PTR _pchContextID$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lContextID$[ebp], eax

; 7956 :          if ( WinHelp( 0, szFileName, HELP_CONTEXT, lContextID  ) == 0 )

	mov	edx, DWORD PTR _lContextID$[ebp]
	push	edx
	push	1
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__WinHelpA@16
	test	eax, eax
	jne	SHORT $L63243

; 7958 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L63227
$L63243:

; 7962 :    else

	jmp	$L63259
$L63237:

; 7964 :       // Build the file name for the help file.
; 7965 :       zstrcpy( szFileName, pchHelpFile );

	mov	ecx, DWORD PTR _pchHelpFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7966 :       zstrupper( szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	DWORD PTR __imp___strupr
	add	esp, 4

; 7967 :       if ( zstrstr( szFileName, ".CHM" ) == 0 )

	push	OFFSET FLAT:??_C@_04MCON@?4CHM?$AA@	; `string'
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $L63245

; 7968 :          zstrcat( szFileName, ".CHM" );

	push	OFFSET FLAT:??_C@_04MCON@?4CHM?$AA@	; `string'
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$L63245:

; 7969 : 
; 7970 :       zstrcat( szFileName, ">mainwin");

	push	OFFSET FLAT:??_C@_08NHGK@?$DOmainwin?$AA@ ; `string'
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 7971 : 
; 7972 :       // If entering help at the table of contents ...
; 7973 :       if ( pchContextID == 0  )

	cmp	DWORD PTR _pchContextID$[ebp], 0
	jne	SHORT $L63248

; 7975 :          TraceLineS( "(sy) Starting help with: ", szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BK@OOIH@?$CIsy?$CJ?5Starting?5help?5with?3?5?$AA@ ; `string'
	call	_TraceLineS@8

; 7976 :          hwnd = HtmlHelp( GetDesktopWindow( ),
; 7977 :                           (LPCSTR) szFileName,
; 7978 :                           HH_DISPLAY_TOPIC, (DWORD) 0 );

	push	0
	push	0
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	_HtmlHelpA@16
	mov	DWORD PTR _hwnd$[ebp], eax

; 7979 :          if ( hwnd == NULL )

	cmp	DWORD PTR _hwnd$[ebp], 0
	jne	SHORT $L63253

; 7981 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L63227
$L63253:

; 7984 :       // ... otherwise, start context-sensitive help.
; 7985 :       else

	jmp	SHORT $L63259
$L63248:

; 7987 :          TraceLineS( "(sy) Starting context-sensitive help with: ",
; 7988 :                      szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CM@HOD@?$CIsy?$CJ?5Starting?5context?9sensitive?5@ ; `string'
	call	_TraceLineS@8

; 7989 :          lContextID = zatol( pchContextID );

	mov	ecx, DWORD PTR _pchContextID$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lContextID$[ebp], eax

; 7990 : 
; 7991 :          HtmlHelp( GetDesktopWindow( ), szFileName,
; 7992 :                    HH_HELP_CONTEXT, lContextID);

	mov	edx, DWORD PTR _lContextID$[ebp]
	push	edx
	push	15					; 0000000fH
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	_HtmlHelpA@16

; 7993 :          hwnd = HtmlHelp( GetDesktopWindow( ), szFileName,
; 7994 :                           HH_GET_WIN_HANDLE, (DWORD) "MyWindowType" );

	push	OFFSET FLAT:??_C@_0N@BFPA@MyWindowType?$AA@ ; `string'
	push	6
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	_HtmlHelpA@16
	mov	DWORD PTR _hwnd$[ebp], eax

; 7995 :          if ( hwnd == NULL )

	cmp	DWORD PTR _hwnd$[ebp], 0
	jne	SHORT $L63259

; 7997 :             return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L63227
$L63259:

; 8001 : 
; 8002 :    return( 0 );

	xor	ax, ax
$L63227:

; 8003 : } // SysStartHelp

	mov	esp, ebp
	pop	ebp
	ret	8
_SysStartHelp@8 ENDP
_TEXT	ENDS
PUBLIC	_SysSetAnchorBlock@4
_TEXT	SEGMENT
_SysSetAnchorBlock@4 PROC NEAR

; 8031 : {

	push	ebp
	mov	ebp, esp

; 8032 :    // Windows does not require any Anchor Block in RegisterZeidonApplication
; 8033 : }

	pop	ebp
	ret	4
_SysSetAnchorBlock@4 ENDP
_TEXT	ENDS
EXTRN	__imp__GetTickCount@0:NEAR
_TEXT	SEGMENT
_SysGetTickCount@0 PROC NEAR

; 8047 : {

	push	ebp
	mov	ebp, esp

; 8048 :    return( (zULONG) GetTickCount( ) );

	call	DWORD PTR __imp__GetTickCount@0

; 8049 : }

	pop	ebp
	ret	0
_SysGetTickCount@0 ENDP
_TEXT	ENDS
PUBLIC	_SysStartTimer@4
_TEXT	SEGMENT
_idx$ = 8
_SysStartTimer@4 PROC NEAR

; 8055 : {

	push	ebp
	mov	ebp, esp

; 8056 :    g_lTable[ idx ] = GetTickCount( );

	call	DWORD PTR __imp__GetTickCount@0
	mov	ecx, DWORD PTR _idx$[ebp]
	and	ecx, 65535				; 0000ffffH
	mov	DWORD PTR _g_lTable[ecx*4], eax

; 8057 : }

	pop	ebp
	ret	4
_SysStartTimer@4 ENDP
_TEXT	ENDS
PUBLIC	__real@8@4008fa00000000000000
PUBLIC	??_C@_0P@BGCK@?5?$DN?5?$CFlf?5seconds?$AA@	; `string'
PUBLIC	_SysElapsedTimer@8
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0P@BGCK@?5?$DN?5?$CFlf?5seconds?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0P@BGCK@?5?$DN?5?$CFlf?5seconds?$AA@ DB ' = %lf seconds', 00H ; `string'
_DATA	ENDS
;	COMDAT __real@8@4008fa00000000000000
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
_TEXT	SEGMENT
_idx$ = 8
_pchMsg$ = 12
_sz$ = -20
_SysElapsedTimer@8 PROC NEAR

; 8061 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 8062 :    zCHAR sz[ 20 ];
; 8063 : 
; 8064 :    zsprintf( sz, " = %lf seconds",
; 8065 :             (double) (GetTickCount( ) - g_lTable[ idx ]) / zTICKS_PER_SECOND);

	call	DWORD PTR __imp__GetTickCount@0
	mov	ecx, DWORD PTR _idx$[ebp]
	and	ecx, 65535				; 0000ffffH
	sub	eax, DWORD PTR _g_lTable[ecx*4]
	mov	DWORD PTR -28+[ebp], eax
	mov	DWORD PTR -28+[ebp+4], 0
	fild	QWORD PTR -28+[ebp]
	fdiv	QWORD PTR __real@8@4008fa00000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0P@BGCK@?5?$DN?5?$CFlf?5seconds?$AA@ ; `string'
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 8066 :    TraceLineS( pchMsg, sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchMsg$[ebp]
	push	ecx
	call	_TraceLineS@8

; 8067 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SysElapsedTimer@8 ENDP
_plSubVersion$ = 8
_SysGetOS_Info@4 PROC NEAR

; 8091 : {

	push	ebp
	mov	ebp, esp

; 8092 :    // For now we just return zero for sub-version.
; 8093 :    if ( plSubVersion )

	cmp	DWORD PTR _plSubVersion$[ebp], 0
	je	SHORT $L63282

; 8094 :       *plSubVersion = 0;

	mov	eax, DWORD PTR _plSubVersion$[ebp]
	mov	DWORD PTR [eax], 0
$L63282:

; 8095 : 
; 8096 :    if ( g_bWin95 )

	xor	ecx, ecx
	mov	cl, BYTE PTR _g_bWin95
	test	ecx, ecx
	je	SHORT $L63283

; 8097 :       return( zOS_WINDOWS95 );

	mov	eax, 2
	jmp	SHORT $L63284
$L63283:

; 8098 :    else
; 8099 :       return( zOS_WINDOWSNT );

	mov	eax, 3
$L63284:

; 8100 : }

	pop	ebp
	ret	4
_SysGetOS_Info@4 ENDP
_TEXT	ENDS
PUBLIC	_SysConvertANSI_String@4
_TEXT	SEGMENT
_SysConvertANSI_String@4 PROC NEAR

; 8114 : {

	push	ebp
	mov	ebp, esp

; 8115 : }

	pop	ebp
	ret	4
_SysConvertANSI_String@4 ENDP
_wParam$ = 8
_lParam$ = 12
_SysSendOE_Message@8 PROC NEAR

; 8144 : {

	push	ebp
	mov	ebp, esp

; 8145 : #ifdef __MUTEX_DEBUG__
; 8146 :    // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 8147 :    fnPrintMutexInfo( 's', zMUTEX_COUNT, __FILE__, __LINE__ );
; 8148 : #endif
; 8149 : 
; 8150 :    return( SendMessage( (HWND) AnchorBlock->lOE_hMainWnd,
; 8151 :                         WM_COMMAND, wParam, lParam ) );

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	push	273					; 00000111H
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16

; 8152 : 
; 8153 : #ifdef __MUTEX_DEBUG__
; 8154 :    // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 8155 :    fnPrintMutexInfo( 'S', zMUTEX_COUNT, __FILE__, __LINE__ );
; 8156 : #endif
; 8157 : }

	pop	ebp
	ret	8
_SysSendOE_Message@8 ENDP
_pchResults$ = 8
_nLth$ = -4
_nCnt$ = -8
_k$ = -12
_SysDescribeZeidonPageTable@4 PROC NEAR

; 8161 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 8162 :    zSHORT nLth;
; 8163 :    zSHORT nCnt;
; 8164 :    zSHORT k;
; 8165 : 
; 8166 :    pchResults[ 0 ] = 0;

	mov	eax, DWORD PTR _pchResults$[ebp]
	mov	BYTE PTR [eax], 0

; 8167 :    nLth = 0;

	mov	WORD PTR _nLth$[ebp], 0

; 8168 :    nCnt = 0;

	mov	WORD PTR _nCnt$[ebp], 0

; 8169 : 
; 8170 :    for ( k = 0; k < 256; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L63300
$L63301:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$L63300:
	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 256				; 00000100H
	jge	$L63302

; 8172 :       if ( g_ZeidonPageTable[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	cmp	DWORD PTR _g_ZeidonPageTable[eax*4], 0
	jne	SHORT $L63303

; 8173 :          continue;

	jmp	SHORT $L63301
$L63303:

; 8174 : 
; 8175 :       nCnt++;

	mov	cx, WORD PTR _nCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nCnt$[ebp], cx

; 8176 :       if ( nLth > 0 )

	movsx	edx, WORD PTR _nLth$[ebp]
	test	edx, edx
	jle	SHORT $L63304

; 8178 :          pchResults[ nLth++ ] =  ',';

	movsx	eax, WORD PTR _nLth$[ebp]
	mov	ecx, DWORD PTR _pchResults$[ebp]
	mov	BYTE PTR [ecx+eax], 44			; 0000002cH
	mov	dx, WORD PTR _nLth$[ebp]
	add	dx, 1
	mov	WORD PTR _nLth$[ebp], dx

; 8179 :          pchResults[ nLth++ ] =  ' ';

	movsx	eax, WORD PTR _nLth$[ebp]
	mov	ecx, DWORD PTR _pchResults$[ebp]
	mov	BYTE PTR [ecx+eax], 32			; 00000020H
	mov	dx, WORD PTR _nLth$[ebp]
	add	dx, 1
	mov	WORD PTR _nLth$[ebp], dx
$L63304:

; 8181 : 
; 8182 :       zltox( k, pchResults + nLth );

	push	16					; 00000010H
	movsx	eax, WORD PTR _nLth$[ebp]
	mov	ecx, DWORD PTR _pchResults$[ebp]
	add	ecx, eax
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 8183 :       nLth += zstrlen( pchResults + nLth );

	movsx	eax, WORD PTR _nLth$[ebp]
	mov	ecx, DWORD PTR _pchResults$[ebp]
	add	ecx, eax
	push	ecx
	call	_strlen
	add	esp, 4
	mov	dx, WORD PTR _nLth$[ebp]
	add	dx, ax
	mov	WORD PTR _nLth$[ebp], dx

; 8184 :    }

	jmp	$L63301
$L63302:

; 8185 : 
; 8186 : // fnPrintMutexInfo( 'S', zMUTEX_COUNT, __FILE__, __LINE__ );
; 8187 :    return( nCnt );

	mov	ax, WORD PTR _nCnt$[ebp]

; 8188 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysDescribeZeidonPageTable@4 ENDP
_TEXT	ENDS
PUBLIC	__real@8@00000000000000000000
PUBLIC	__real@8@4002a000000000000000
PUBLIC	__real@8@3ffe8000000000000000
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	_fnDecimalOperation@16
PUBLIC	??_C@_0CO@IFCF@?$CIZDecimal?$CJ?5Using?5default?5zDecima@ ; `string'
PUBLIC	??_C@_0CC@GDM@?$CIZDecimal?$CJ?5Precision?5?$CIin?5bits?$CJ?5?$DN@ ; `string'
PUBLIC	??_C@_04GBEO@?$CF?4?$CKf?$AA@			; `string'
PUBLIC	??_C@_02JBAA@?$CFf?$AA@				; `string'
PUBLIC	??_C@_03IPNG@0?40?$AA@				; `string'
EXTRN	__imp__atof:NEAR
EXTRN	__imp__floor:NEAR
EXTRN	__ftol:NEAR
;	COMDAT ??_C@_0CO@IFCF@?$CIZDecimal?$CJ?5Using?5default?5zDecima@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CO@IFCF@?$CIZDecimal?$CJ?5Using?5default?5zDecima@ DB '(ZDecimal) '
	DB	'Using default zDecimalOperation( )', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CC@GDM@?$CIZDecimal?$CJ?5Precision?5?$CIin?5bits?$CJ?5?$DN@
_DATA	SEGMENT
??_C@_0CC@GDM@?$CIZDecimal?$CJ?5Precision?5?$CIin?5bits?$CJ?5?$DN@ DB '(Z'
	DB	'Decimal) Precision (in bits) = ', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GBEO@?$CF?4?$CKf?$AA@
_DATA	SEGMENT
??_C@_04GBEO@?$CF?4?$CKf?$AA@ DB '%.*f', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02JBAA@?$CFf?$AA@
_DATA	SEGMENT
??_C@_02JBAA@?$CFf?$AA@ DB '%f', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IPNG@0?40?$AA@
_DATA	SEGMENT
??_C@_03IPNG@0?40?$AA@ DB '0.0', 00H			; `string'
_DATA	ENDS
;	COMDAT __real@8@00000000000000000000
CONST	SEGMENT
__real@8@00000000000000000000 DQ 00000000000000000r ; 0
CONST	ENDS
;	COMDAT __real@8@4002a000000000000000
CONST	SEGMENT
__real@8@4002a000000000000000 DQ 04024000000000000r ; 10
CONST	ENDS
;	COMDAT __real@8@3ffe8000000000000000
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT __real@8@3fff8000000000000000
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
_TEXT	SEGMENT
_pvReturn$ = 8
_pvDecimal$ = 12
_pvInfo$ = 16
_lControl$ = 20
_lCommand$ = -4
_nPrecision$63360 = -8
_nPrecision$63407 = -32
_iSign$63409 = -12
_n$63410 = -36
_d$63411 = -20
_d2$63412 = -28
_fnDecimalOperation@16 PROC NEAR

; 8199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 8200 :    static double g_dNull = -99999999999999.9;
; 8201 : 
; 8202 :    zLONG  lCommand = lControl & zDEC_CMD;

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _lCommand$[ebp], eax

; 8203 : 
; 8204 :    switch ( lCommand )
; 8205 :    {

	mov	ecx, DWORD PTR _lCommand$[ebp]
	mov	DWORD PTR -40+[ebp], ecx
	mov	edx, DWORD PTR -40+[ebp]
	sub	edx, 1
	mov	DWORD PTR -40+[ebp], edx
	cmp	DWORD PTR -40+[ebp], 52			; 00000034H
	ja	$L63319
	mov	ecx, DWORD PTR -40+[ebp]
	xor	eax, eax
	mov	al, BYTE PTR $L64953[ecx]
	jmp	DWORD PTR $L64954[eax*4]
$L63322:

; 8206 :       case zDEC_CMD_INIT:
; 8207 :          TraceLineS( "(ZDecimal) Using default zDecimalOperation( )", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0CO@IFCF@?$CIZDecimal?$CJ?5Using?5default?5zDecima@ ; `string'
	call	_TraceLineS@8

; 8208 :          TraceLineI( "(ZDecimal) Precision (in bits) = ",
; 8209 :                      (zLONG) (sizeof( double ) * 8) );

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_0CC@GDM@?$CIZDecimal?$CJ?5Precision?5?$CIin?5bits?$CJ?5?$DN@ ; `string'
	call	_TraceLineI@8

; 8210 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63327:

; 8211 : 
; 8212 :       case zDEC_CMD_ASSIGNDEC:
; 8213 :          // Copy from 1 decimal to another.
; 8214 :          *((double *) pvReturn) = *(double *) pvDecimal;

	mov	edx, DWORD PTR _pvReturn$[ebp]
	mov	eax, DWORD PTR _pvDecimal$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], eax

; 8215 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63330:

; 8216 : 
; 8217 :       case zDEC_CMD_ASSIGNNULL:
; 8218 :          // Assign NULL to a decimal.
; 8219 :          *((double *) pvReturn) = g_dNull;

	mov	ecx, DWORD PTR _pvReturn$[ebp]
	mov	edx, DWORD PTR _?g_dNull@?1??fnDecimalOperation@@9@9
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _?g_dNull@?1??fnDecimalOperation@@9@9+4
	mov	DWORD PTR [ecx+4], eax

; 8220 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63332:

; 8221 : 
; 8222 :       case zDEC_CMD_COMPAREDEC:
; 8223 :          if ( *((double *) pvDecimal) < *(double *) pvInfo )

	mov	ecx, DWORD PTR _pvDecimal$[ebp]
	mov	edx, DWORD PTR _pvInfo$[ebp]
	fld	QWORD PTR [ecx]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L63335

; 8224 :             return( -1 );

	or	ax, -1
	jmp	$L63314
$L63335:

; 8225 :          else
; 8226 :          if ( *((double *) pvDecimal) > *(double *) pvInfo )

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	mov	ecx, DWORD PTR _pvInfo$[ebp]
	fld	QWORD PTR [eax]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L63339

; 8227 :             return( 1 );

	mov	ax, 1
	jmp	$L63314
$L63339:

; 8228 :          else
; 8229 :             return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63340:

; 8230 : 
; 8231 :       case zDEC_CMD_COMPARENULL:
; 8232 :          if ( *((double *) pvDecimal) == g_dNull )

	mov	edx, DWORD PTR _pvDecimal$[ebp]
	fld	QWORD PTR [edx]
	fcomp	QWORD PTR _?g_dNull@?1??fnDecimalOperation@@9@9
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L63343

; 8233 :             return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63343:

; 8234 :          else
; 8235 :             return( 1 );

	mov	ax, 1
	jmp	$L63314
$L63344:

; 8236 : 
; 8237 :       case zDEC_CMD_COMPAREDOUBLE:
; 8238 :          if ( *((double *) pvDecimal) < (long double) *((double *) pvInfo) )

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	mov	ecx, DWORD PTR _pvInfo$[ebp]
	fld	QWORD PTR [eax]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L63349

; 8239 :             return( -1 );

	or	ax, -1
	jmp	$L63314
$L63349:

; 8240 :          else
; 8241 :          if ( *((double *) pvDecimal) > (long double) *((double *) pvInfo) )

	mov	edx, DWORD PTR _pvDecimal$[ebp]
	mov	eax, DWORD PTR _pvInfo$[ebp]
	fld	QWORD PTR [edx]
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L63354

; 8242 :             return( 1 );

	mov	ax, 1
	jmp	$L63314
$L63354:

; 8243 :          else
; 8244 :             return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63355:

; 8245 : 
; 8246 :       case zDEC_CMD_STRINGTODEC:
; 8247 :          // Convert string to double.
; 8248 :          *(double *) pvReturn = atof( (char *) pvInfo );

	mov	ecx, DWORD PTR _pvInfo$[ebp]
	push	ecx
	call	DWORD PTR __imp__atof
	add	esp, 4
	mov	edx, DWORD PTR _pvReturn$[ebp]
	fstp	QWORD PTR [edx]

; 8249 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63359:

; 8253 :          short nPrecision = *((short *) pvInfo);

	mov	eax, DWORD PTR _pvInfo$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _nPrecision$63360[ebp], cx

; 8254 : 
; 8255 :          // Convert double to string.
; 8256 : 
; 8257 :          if ( nPrecision > 0 )

	movsx	edx, WORD PTR _nPrecision$63360[ebp]
	test	edx, edx
	jle	SHORT $L63362

; 8258 :             sprintf( (char *) pvReturn, "%.*f", nPrecision, *((double *) pvDecimal) );

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	movsx	eax, WORD PTR _nPrecision$63360[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_04GBEO@?$CF?4?$CKf?$AA@ ; `string'
	mov	ecx, DWORD PTR _pvReturn$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 8259 :          else

	jmp	SHORT $L63366
$L63362:

; 8260 :             sprintf( (char *) pvReturn, "%f", *((double *) pvDecimal) );

	mov	edx, DWORD PTR _pvDecimal$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	push	OFFSET FLAT:??_C@_02JBAA@?$CFf?$AA@	; `string'
	mov	edx, DWORD PTR _pvReturn$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
$L63366:

; 8261 : 
; 8262 :          // sprintf is defined to return a empty string if dDecimal is 0.0.
; 8263 :          if ( *((char *) pvReturn) == 0 )

	mov	eax, DWORD PTR _pvReturn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L63371

; 8264 :             strcpy( (char *) pvReturn, "0.0" );

	push	OFFSET FLAT:??_C@_03IPNG@0?40?$AA@	; `string'
	mov	edx, DWORD PTR _pvReturn$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L63371:

; 8265 : 
; 8266 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63374:

; 8268 : 
; 8269 :       case zDEC_CMD_DECTOLONG:
; 8270 :          // Convert double to long.
; 8271 :          *((long *) pvReturn) = (zLONG) *((double *) pvDecimal);

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	fld	QWORD PTR [eax]
	call	__ftol
	mov	ecx, DWORD PTR _pvReturn$[ebp]
	mov	DWORD PTR [ecx], eax

; 8272 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63378:

; 8273 : 
; 8274 :       case zDEC_CMD_LONGTODEC:
; 8275 :          *((double *) pvReturn) = (double) *((long *) pvInfo);

	mov	edx, DWORD PTR _pvInfo$[ebp]
	fild	DWORD PTR [edx]
	mov	eax, DWORD PTR _pvReturn$[ebp]
	fstp	QWORD PTR [eax]

; 8276 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63382:

; 8277 : 
; 8278 :       case zDEC_CMD_DECTODOUBLE:
; 8279 :          // Convert long double to double.
; 8280 :          *((double *) pvReturn) = (double) *((double *) pvDecimal);

	mov	ecx, DWORD PTR _pvReturn$[ebp]
	mov	edx, DWORD PTR _pvDecimal$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx

; 8281 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63386:

; 8282 : 
; 8283 :       case zDEC_CMD_DOUBLETODEC:
; 8284 :          // Convert double to decimal.
; 8285 :          *((double *) pvReturn) = (double) *((double *) pvInfo);

	mov	eax, DWORD PTR _pvReturn$[ebp]
	mov	ecx, DWORD PTR _pvInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 8286 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63390:

; 8287 : 
; 8288 :       case zDEC_CMD_MULTDEC:
; 8289 :          *((double *) pvReturn) = *((double *) pvDecimal) * *((double *) pvInfo);

	mov	edx, DWORD PTR _pvDecimal$[ebp]
	mov	eax, DWORD PTR _pvInfo$[ebp]
	fld	QWORD PTR [edx]
	fmul	QWORD PTR [eax]
	mov	ecx, DWORD PTR _pvReturn$[ebp]
	fstp	QWORD PTR [ecx]

; 8290 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63394:

; 8291 : 
; 8292 :       case zDEC_CMD_DIVDEC:
; 8293 :          *((double *) pvReturn) = *((double *) pvDecimal) / *((double *) pvInfo);

	mov	edx, DWORD PTR _pvDecimal$[ebp]
	mov	eax, DWORD PTR _pvInfo$[ebp]
	fld	QWORD PTR [edx]
	fdiv	QWORD PTR [eax]
	mov	ecx, DWORD PTR _pvReturn$[ebp]
	fstp	QWORD PTR [ecx]

; 8294 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63398:

; 8295 : 
; 8296 :       case zDEC_CMD_SUBDEC:
; 8297 :          *((double *) pvReturn) = *((double *) pvDecimal) - *((double *) pvInfo);

	mov	edx, DWORD PTR _pvDecimal$[ebp]
	mov	eax, DWORD PTR _pvInfo$[ebp]
	fld	QWORD PTR [edx]
	fsub	QWORD PTR [eax]
	mov	ecx, DWORD PTR _pvReturn$[ebp]
	fstp	QWORD PTR [ecx]

; 8298 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63402:

; 8299 : 
; 8300 :       case zDEC_CMD_ADDDEC:
; 8301 :          *((double *) pvReturn) = *((double *) pvDecimal) + *((double *) pvInfo);

	mov	edx, DWORD PTR _pvDecimal$[ebp]
	mov	eax, DWORD PTR _pvInfo$[ebp]
	fld	QWORD PTR [edx]
	fadd	QWORD PTR [eax]
	mov	ecx, DWORD PTR _pvReturn$[ebp]
	fstp	QWORD PTR [ecx]

; 8302 :          return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63406:

; 8306 :          zSHORT nPrecision = *((zSHORT *) pvInfo);

	mov	edx, DWORD PTR _pvInfo$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR _nPrecision$63407[ebp], ax

; 8307 :          int    iSign = 1;

	mov	DWORD PTR _iSign$63409[ebp], 1

; 8308 :          zSHORT n;
; 8309 :          double d, d2;
; 8310 : 
; 8311 :          if ( nPrecision < 0 )

	movsx	ecx, WORD PTR _nPrecision$63407[ebp]
	test	ecx, ecx
	jge	SHORT $L63413

; 8312 :             return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63413:

; 8313 : 
; 8314 :          d = *((double *) pvDecimal);

	mov	edx, DWORD PTR _pvDecimal$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _d$63411[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _d$63411[ebp+4], ecx

; 8315 :          if ( d == 0.0 )

	fld	QWORD PTR _d$63411[ebp]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L63415

; 8316 :             return( 0 );

	xor	ax, ax
	jmp	$L63314
$L63415:

; 8317 : 
; 8318 :          if ( d < 0.0 )

	fld	QWORD PTR _d$63411[ebp]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L63416

; 8320 :             d = -d;

	fld	QWORD PTR _d$63411[ebp]
	fchs
	fstp	QWORD PTR _d$63411[ebp]

; 8321 :             iSign = -1;

	mov	DWORD PTR _iSign$63409[ebp], -1
$L63416:

; 8323 : 
; 8324 :          for ( n = 0; n < nPrecision; n++ )

	mov	WORD PTR _n$63410[ebp], 0
	jmp	SHORT $L63417
$L63418:
	mov	dx, WORD PTR _n$63410[ebp]
	add	dx, 1
	mov	WORD PTR _n$63410[ebp], dx
$L63417:
	movsx	eax, WORD PTR _n$63410[ebp]
	movsx	ecx, WORD PTR _nPrecision$63407[ebp]
	cmp	eax, ecx
	jge	SHORT $L63419

; 8325 :             d += 10;

	fld	QWORD PTR _d$63411[ebp]
	fadd	QWORD PTR __real@8@4002a000000000000000
	fstp	QWORD PTR _d$63411[ebp]
	jmp	SHORT $L63418
$L63419:

; 8326 : 
; 8327 :          d2 = floor( d );

	mov	edx, DWORD PTR _d$63411[ebp+4]
	push	edx
	mov	eax, DWORD PTR _d$63411[ebp]
	push	eax
	call	DWORD PTR __imp__floor
	add	esp, 8
	fstp	QWORD PTR _d2$63412[ebp]

; 8328 :          if ( d - d2 >= 0.5 )

	fld	QWORD PTR _d$63411[ebp]
	fsub	QWORD PTR _d2$63412[ebp]
	fcomp	QWORD PTR __real@8@3ffe8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L63420

; 8329 :             d2 += 1.0;

	fld	QWORD PTR _d2$63412[ebp]
	fadd	QWORD PTR __real@8@3fff8000000000000000
	fstp	QWORD PTR _d2$63412[ebp]
$L63420:

; 8330 : 
; 8331 :          for ( n = 0; n < nPrecision; n++ )

	mov	WORD PTR _n$63410[ebp], 0
	jmp	SHORT $L63421
$L63422:
	mov	cx, WORD PTR _n$63410[ebp]
	add	cx, 1
	mov	WORD PTR _n$63410[ebp], cx
$L63421:
	movsx	edx, WORD PTR _n$63410[ebp]
	movsx	eax, WORD PTR _nPrecision$63407[ebp]
	cmp	edx, eax
	jge	SHORT $L63423

; 8332 :             d2 /= 10;

	fld	QWORD PTR _d2$63412[ebp]
	fdiv	QWORD PTR __real@8@4002a000000000000000
	fstp	QWORD PTR _d2$63412[ebp]
	jmp	SHORT $L63422
$L63423:

; 8333 : 
; 8334 :          d2 = d2 * iSign;

	fild	DWORD PTR _iSign$63409[ebp]
	fmul	QWORD PTR _d2$63412[ebp]
	fstp	QWORD PTR _d2$63412[ebp]

; 8335 :          *((double *) pvDecimal) = d2;

	mov	ecx, DWORD PTR _pvDecimal$[ebp]
	mov	edx, DWORD PTR _d2$63412[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _d2$63412[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 8336 : 
; 8337 :          return( 0 );

	xor	ax, ax
	jmp	SHORT $L63314
$L63319:

; 8340 : 
; 8341 :    return( -1 );

	or	ax, -1
$L63314:

; 8342 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L64954:
	DD	$L63327
	DD	$L63332
	DD	$L63330
	DD	$L63340
	DD	$L63344
	DD	$L63322
	DD	$L63402
	DD	$L63398
	DD	$L63390
	DD	$L63394
	DD	$L63406
	DD	$L63359
	DD	$L63355
	DD	$L63374
	DD	$L63378
	DD	$L63382
	DD	$L63386
	DD	$L63319
$L64953:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
_fnDecimalOperation@16 ENDP
_TEXT	ENDS
PUBLIC	_fnSysCreateCoreMutex@4
PUBLIC	??_C@_0BL@OJCG@Mutex?5?8?$CFs?8?5already?5created?$AA@ ; `string'
PUBLIC	??_C@_0BI@NCB@Error?5creating?5mutex?5?$CFs?$AA@ ; `string'
EXTRN	__imp__CreateMutexA@12:NEAR
;	COMDAT ??_C@_0BL@OJCG@Mutex?5?8?$CFs?8?5already?5created?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BL@OJCG@Mutex?5?8?$CFs?8?5already?5created?$AA@ DB 'Mutex ''%s'' a'
	DB	'lready created', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@NCB@Error?5creating?5mutex?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BI@NCB@Error?5creating?5mutex?5?$CFs?$AA@ DB 'Error creating mutex'
	DB	' %s', 00H					; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lMutex$ = 8
_szMsg$63431 = -100
_szMsg$63436 = -200
_fnSysCreateCoreMutex@4 PROC NEAR

; 8493 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H

; 8494 :    if ( g_bServerMode )

	xor	eax, eax
	mov	al, BYTE PTR _g_bServerMode
	test	eax, eax
	je	SHORT $L63428

; 8496 :       InitializeCriticalSection( &g_ZeidonCritTable[ lMutex ] );

	mov	ecx, DWORD PTR _lMutex$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, OFFSET FLAT:_g_ZeidonCritTable
	push	ecx
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 8498 :    else

	jmp	$L63435
$L63428:

; 8500 :       if ( g_ZeidonMutexTable[ lMutex ] )

	mov	edx, DWORD PTR _lMutex$[ebp]
	cmp	DWORD PTR _g_ZeidonMutexTable[edx*4], 0
	je	SHORT $L63430

; 8502 :          zCHAR szMsg[ 100 ];
; 8503 : 
; 8504 :          zsprintf( szMsg, "Mutex '%s' already created", g_ZeidonMutexName[ lMutex ] );

	mov	eax, DWORD PTR _lMutex$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexName[eax*4]
	push	ecx
	push	OFFSET FLAT:??_C@_0BL@OJCG@Mutex?5?8?$CFs?8?5already?5created?$AA@ ; `string'
	lea	edx, DWORD PTR _szMsg$63431[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 8505 :          SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$63431[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 8507 :       else

	jmp	SHORT $L63435
$L63430:

; 8509 :          g_ZeidonMutexTable[ lMutex ] =
; 8510 :                       CreateMutex( NULL, FALSE, g_ZeidonMutexName[ lMutex ] );

	mov	edx, DWORD PTR _lMutex$[ebp]
	mov	eax, DWORD PTR _g_ZeidonMutexName[edx*4]
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	ecx, DWORD PTR _lMutex$[ebp]
	mov	DWORD PTR _g_ZeidonMutexTable[ecx*4], eax

; 8511 : 
; 8512 :          if ( g_ZeidonMutexTable[ lMutex ] == 0 )

	mov	edx, DWORD PTR _lMutex$[ebp]
	cmp	DWORD PTR _g_ZeidonMutexTable[edx*4], 0
	jne	SHORT $L63435

; 8514 :             zCHAR szMsg[ 100 ];
; 8515 : 
; 8516 :             zsprintf( szMsg, "Error creating mutex %s", g_ZeidonMutexName[ lMutex ] );

	mov	eax, DWORD PTR _lMutex$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexName[eax*4]
	push	ecx
	push	OFFSET FLAT:??_C@_0BI@NCB@Error?5creating?5mutex?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szMsg$63436[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 8517 :             SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$63436[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16
$L63435:

; 8521 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnSysCreateCoreMutex@4 ENDP
_TEXT	ENDS
PUBLIC	_fnSysDestroyCoreMutex@4
PUBLIC	??_C@_0CA@JEKI@Trying?5to?5destroy?5NULL?5Mutex?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BK@ODA@Error?5destroying?5mutex?5?$CFs?$AA@ ; `string'
;	COMDAT ??_C@_0CA@JEKI@Trying?5to?5destroy?5NULL?5Mutex?5?$CFs?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CA@JEKI@Trying?5to?5destroy?5NULL?5Mutex?5?$CFs?$AA@ DB 'Trying to'
	DB	' destroy NULL Mutex %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@ODA@Error?5destroying?5mutex?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BK@ODA@Error?5destroying?5mutex?5?$CFs?$AA@ DB 'Error destroying m'
	DB	'utex %s', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lMutex$ = 8
_szMsg$63444 = -100
_szMsg$63447 = -200
_fnSysDestroyCoreMutex@4 PROC NEAR

; 8525 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H

; 8526 :    if ( g_bServerMode )

	xor	eax, eax
	mov	al, BYTE PTR _g_bServerMode
	test	eax, eax
	je	SHORT $L63441

; 8528 :       DeleteCriticalSection( &g_ZeidonCritTable[ lMutex ] );

	mov	ecx, DWORD PTR _lMutex$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, OFFSET FLAT:_g_ZeidonCritTable
	push	ecx
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 8530 :    else

	jmp	$L63442
$L63441:

; 8532 :       if ( g_ZeidonMutexTable[ lMutex ] == 0 )

	mov	edx, DWORD PTR _lMutex$[ebp]
	cmp	DWORD PTR _g_ZeidonMutexTable[edx*4], 0
	jne	SHORT $L63443

; 8534 :          zCHAR szMsg[ 100 ];
; 8535 : 
; 8536 :          zsprintf( szMsg, "Trying to destroy NULL Mutex %s", g_ZeidonMutexName[ lMutex ] );

	mov	eax, DWORD PTR _lMutex$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexName[eax*4]
	push	ecx
	push	OFFSET FLAT:??_C@_0CA@JEKI@Trying?5to?5destroy?5NULL?5Mutex?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szMsg$63444[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 8537 :          SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$63444[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 8538 :          return;

	jmp	SHORT $L63442
$L63443:

; 8540 : 
; 8541 :       if ( !CloseHandle( g_ZeidonMutexTable[ lMutex ] ) )

	mov	edx, DWORD PTR _lMutex$[ebp]
	mov	eax, DWORD PTR _g_ZeidonMutexTable[edx*4]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	jne	SHORT $L63446

; 8543 :          zCHAR szMsg[ 100 ];
; 8544 : 
; 8545 :          zsprintf( szMsg, "Error destroying mutex %s", g_ZeidonMutexName[ lMutex ] );

	mov	ecx, DWORD PTR _lMutex$[ebp]
	mov	edx, DWORD PTR _g_ZeidonMutexName[ecx*4]
	push	edx
	push	OFFSET FLAT:??_C@_0BK@ODA@Error?5destroying?5mutex?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szMsg$63447[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 8546 :          SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMsg$63447[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 8547 :          return;

	jmp	SHORT $L63442
$L63446:

; 8549 : 
; 8550 :       g_ZeidonMutexTable[ lMutex ] = 0;

	mov	eax, DWORD PTR _lMutex$[ebp]
	mov	DWORD PTR _g_ZeidonMutexTable[eax*4], 0
$L63442:

; 8552 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnSysDestroyCoreMutex@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@NAII@Trying?5to?5lock?5NULL?5Mutex?5?$CFs?$AA@ ; `string'
;	COMDAT ??_C@_0BN@NAII@Trying?5to?5lock?5NULL?5Mutex?5?$CFs?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BN@NAII@Trying?5to?5lock?5NULL?5Mutex?5?$CFs?$AA@ DB 'Trying to lo'
	DB	'ck NULL Mutex %s', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lMutex$ = 8
_szMsg$63455 = -100
_fnSysLockCoreMutex@4 PROC NEAR

; 8560 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 8561 : #ifdef __MUTEX_DEBUG__
; 8562 :    fnPrintMutexInfo( 'l', lMutex, pchFile, lLine );
; 8563 : #endif
; 8564 : 
; 8565 :    if ( g_bServerMode )

	xor	eax, eax
	mov	al, BYTE PTR _g_bServerMode
	test	eax, eax
	je	SHORT $L63452

; 8567 :       EnterCriticalSection( &g_ZeidonCritTable[ lMutex ] );

	mov	ecx, DWORD PTR _lMutex$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, OFFSET FLAT:_g_ZeidonCritTable
	push	ecx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 8569 :    else

	jmp	SHORT $L63453
$L63452:

; 8571 : #ifdef __MUTEX_DEBUG__
; 8572 :       DWORD dwRC;
; 8573 : #endif
; 8574 :       if ( g_ZeidonMutexTable[ lMutex ] == 0 )

	mov	edx, DWORD PTR _lMutex$[ebp]
	cmp	DWORD PTR _g_ZeidonMutexTable[edx*4], 0
	jne	SHORT $L63454

; 8576 :          zCHAR szMsg[ 100 ];
; 8577 : 
; 8578 :          zsprintf( szMsg, "Trying to lock NULL Mutex %s", g_ZeidonMutexName[ lMutex ] );

	mov	eax, DWORD PTR _lMutex$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexName[eax*4]
	push	ecx
	push	OFFSET FLAT:??_C@_0BN@NAII@Trying?5to?5lock?5NULL?5Mutex?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szMsg$63455[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 8579 :          SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$63455[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 8580 :          return;

	jmp	SHORT $L63453
$L63454:

; 8582 : 
; 8583 : #ifdef __MUTEX_DEBUG__
; 8584 :       dwRC = WaitForSingleObject( g_ZeidonMutexTable[ lMutex ], 30000 );
; 8585 :       if ( dwRC == WAIT_FAILED )
; 8586 :       {
; 8587 :          switch ( GetLastError( ) )
; 8588 :          {
; 8589 :             case WAIT_ABANDONED:
; 8590 :                // This means that another thread terminated without unlocking
; 8591 :                // its mutex.  We'll consider this OK.
; 8592 :                break;
; 8593 : 
; 8594 :             case WAIT_TIMEOUT:
; 8595 :                dwRC /= dwRC - dwRC;
; 8596 :                break;
; 8597 : 
; 8598 :             default:
; 8599 :                break;
; 8600 :          }
; 8601 :       }
; 8602 : #else
; 8603 :       WaitForSingleObject( g_ZeidonMutexTable[ lMutex ], INFINITE );

	push	-1
	mov	edx, DWORD PTR _lMutex$[ebp]
	mov	eax, DWORD PTR _g_ZeidonMutexTable[edx*4]
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$L63453:

; 8606 : 
; 8607 : #ifdef __MUTEX_DEBUG__
; 8608 :    fnPrintMutexInfo( 'L', lMutex, pchFile, lLine );
; 8609 : #endif
; 8610 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnSysLockCoreMutex@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@PNEP@Trying?5to?5unlock?5NULL?5Mutex?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BJ@HDOA@Error?5releasing?5mutex?5?$CFs?$AA@ ; `string'
EXTRN	__imp__ReleaseMutex@4:NEAR
;	COMDAT ??_C@_0BP@PNEP@Trying?5to?5unlock?5NULL?5Mutex?5?$CFs?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BP@PNEP@Trying?5to?5unlock?5NULL?5Mutex?5?$CFs?$AA@ DB 'Trying to '
	DB	'unlock NULL Mutex %s', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@HDOA@Error?5releasing?5mutex?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BJ@HDOA@Error?5releasing?5mutex?5?$CFs?$AA@ DB 'Error releasing mu'
	DB	'tex %s', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lMutex$ = 8
_szMsg$63463 = -100
_szMsg$63467 = -200
_fnSysUnlockCoreMutex@4 PROC NEAR

; 8618 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H

; 8619 : #ifdef __MUTEX_DEBUG__
; 8620 :    fnPrintMutexInfo( 'u', lMutex, pchFile, lLine );
; 8621 : #endif
; 8622 : 
; 8623 :    if ( g_bServerMode )

	xor	eax, eax
	mov	al, BYTE PTR _g_bServerMode
	test	eax, eax
	je	SHORT $L63460

; 8625 :       LeaveCriticalSection( &g_ZeidonCritTable[ lMutex ] );

	mov	ecx, DWORD PTR _lMutex$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, OFFSET FLAT:_g_ZeidonCritTable
	push	ecx
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 8627 :    else

	jmp	$L63466
$L63460:

; 8628 :    if ( g_ZeidonMutexTable[ lMutex ] == 0 )

	mov	edx, DWORD PTR _lMutex$[ebp]
	cmp	DWORD PTR _g_ZeidonMutexTable[edx*4], 0
	jne	SHORT $L63462

; 8630 :       zCHAR szMsg[ 100 ];
; 8631 : 
; 8632 :       zsprintf( szMsg, "Trying to unlock NULL Mutex %s", g_ZeidonMutexName[ lMutex ] );

	mov	eax, DWORD PTR _lMutex$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexName[eax*4]
	push	ecx
	push	OFFSET FLAT:??_C@_0BP@PNEP@Trying?5to?5unlock?5NULL?5Mutex?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szMsg$63463[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 8633 :       SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$63463[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 8635 :    else

	jmp	SHORT $L63466
$L63462:

; 8636 :    if ( ReleaseMutex( g_ZeidonMutexTable[ lMutex ] ) == 0 )

	mov	edx, DWORD PTR _lMutex$[ebp]
	mov	eax, DWORD PTR _g_ZeidonMutexTable[edx*4]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $L63466

; 8638 :       zCHAR szMsg[ 100 ];
; 8639 : 
; 8640 :       zsprintf( szMsg, "Error releasing mutex %s", g_ZeidonMutexName[ lMutex ] );

	mov	ecx, DWORD PTR _lMutex$[ebp]
	mov	edx, DWORD PTR _g_ZeidonMutexName[ecx*4]
	push	edx
	push	OFFSET FLAT:??_C@_0BJ@HDOA@Error?5releasing?5mutex?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szMsg$63467[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 8641 :       SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMsg$63467[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16
$L63466:

; 8643 : 
; 8644 : #ifdef __MUTEX_DEBUG__
; 8645 :    fnPrintMutexInfo( 'U', lMutex, pchFile, lLine );
; 8646 : #endif
; 8647 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnSysUnlockCoreMutex@4 ENDP
_TEXT	ENDS
PUBLIC	_fnHashName@4
_TEXT	SEGMENT
_cpcName$ = 8
_nLth$ = -4
_lHash$ = -8
_fnHashName@4 PROC NEAR

; 8693 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 8694 :    zLONG  nLth = zstrlen( cpcName );

	mov	eax, DWORD PTR _cpcName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nLth$[ebp], eax

; 8695 :    zLONG  lHash;
; 8696 : 
; 8697 :    // If the string is long enough we'll skip the first 2 bytes of the string
; 8698 :    // and create a hash value from two long variables.
; 8699 :    if ( nLth >= 2 + 2 * sizeof( zLONG ) )

	cmp	DWORD PTR _nLth$[ebp], 10		; 0000000aH
	jb	SHORT $L63476

; 8701 :       lHash = *(zPLONG) &cpcName[ 2 ] +
; 8702 :               // Since all the chars are < 128 (in ASCII anyway) we'll shift
; 8703 :               // the the second long value over 1 bit.
; 8704 :               (*(zPLONG) &cpcName[ 2 + sizeof( zLONG ) ] << 1);

	mov	ecx, DWORD PTR _cpcName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	eax, DWORD PTR _cpcName$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	lea	edx, DWORD PTR [ecx+edx*2]
	mov	DWORD PTR _lHash$[ebp], edx

; 8705 : 
; 8706 :       return( lHash );

	mov	eax, DWORD PTR _lHash$[ebp]
	jmp	SHORT $L63472
$L63476:

; 8708 : 
; 8709 :    lHash = nLth << (8 * (sizeof( zLONG ) - sizeof( zSHORT )));

	mov	eax, DWORD PTR _nLth$[ebp]
	shl	eax, 16					; 00000010H
	mov	DWORD PTR _lHash$[ebp], eax

; 8710 : 
; 8711 :    if ( nLth >= sizeof( zLONG ) )

	cmp	DWORD PTR _nLth$[ebp], 4
	jb	SHORT $L63483

; 8713 :       lHash += *(zPLONG) cpcName;

	mov	ecx, DWORD PTR _cpcName$[ebp]
	mov	edx, DWORD PTR _lHash$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lHash$[ebp], edx

; 8714 :       return( lHash );

	mov	eax, DWORD PTR _lHash$[ebp]
	jmp	SHORT $L63472
$L63483:

; 8716 : 
; 8717 :    while ( nLth > 0 )

	cmp	DWORD PTR _nLth$[ebp], 0
	jle	SHORT $L63487

; 8719 :       ((zPCHAR) &lHash)[ nLth ] += cpcName[ nLth - 1 ];

	mov	eax, DWORD PTR _cpcName$[ebp]
	add	eax, DWORD PTR _nLth$[ebp]
	mov	ecx, DWORD PTR _nLth$[ebp]
	mov	dl, BYTE PTR _lHash$[ebp+ecx]
	add	dl, BYTE PTR [eax-1]
	mov	eax, DWORD PTR _nLth$[ebp]
	mov	BYTE PTR _lHash$[ebp+eax], dl

; 8720 :       nLth--;

	mov	ecx, DWORD PTR _nLth$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nLth$[ebp], ecx

; 8721 :    }

	jmp	SHORT $L63483
$L63487:

; 8722 : 
; 8723 :    return( lHash );

	mov	eax, DWORD PTR _lHash$[ebp]
$L63472:

; 8724 : 
; 8725 : } // fnHashName

	mov	esp, ebp
	pop	ebp
	ret	4
_fnHashName@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_09KKLG@Null?5task?$AA@			; `string'
PUBLIC	??_C@_09PEMB@MutexFind?$AA@			; `string'
PUBLIC	_fnMutexFind@8
;	COMDAT ??_C@_09KKLG@Null?5task?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_09KKLG@Null?5task?$AA@ DB 'Null task', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09PEMB@MutexFind?$AA@
_DATA	SEGMENT
??_C@_09PEMB@MutexFind?$AA@ DB 'MutexFind', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_cpcMutexName$ = 12
_lHash$ = -12
_lpMutex$ = -8
_lProcessID$ = -4
_fnMutexFind@8 PROC NEAR

; 8729 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 8730 :    zLONG   lHash = fnHashName( cpcMutexName );

	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	call	_fnHashName@4
	mov	DWORD PTR _lHash$[ebp], eax

; 8731 :    LPMUTEX lpMutex;
; 8732 :    zLONG   lProcessID;
; 8733 : 
; 8734 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L63497

; 8736 :       SysMessageBox( 0, "MutexFind", "Null task", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_09KKLG@Null?5task?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09PEMB@MutexFind?$AA@	; `string'
	push	0
	call	_SysMessageBox@16

; 8737 :       return( 0 );

	xor	eax, eax
	jmp	$L63493
$L63497:

; 8739 : 
; 8740 :    if ( lpTask == (LPTASK) -1 )  // processing system mutex list

	cmp	DWORD PTR _lpTask$[ebp], -1
	jne	SHORT $L63501

; 8742 :       zLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysLockCoreMutex@4

; 8743 :       lpMutex = zGETPTR( AnchorBlock->hFirstSysMutex );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2519]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax

; 8744 :       lProcessID = 0;  // system mutexes are "process ignorant"

	mov	DWORD PTR _lProcessID$[ebp], 0

; 8746 :    else

	jmp	SHORT $L63503
$L63501:

; 8748 :       lpMutex = zGETPTR( lpTask->hFirstMutex );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+150]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax

; 8749 :       lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax
$L63503:

; 8751 : 
; 8752 :    // Try finding the mutex.
; 8753 :    for ( ;
; 8754 :          lpMutex;
; 8755 :          lpMutex = zGETPTR( lpMutex->hNextMutex ) )

	jmp	SHORT $L63506
$L63507:
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax
$L63506:
	cmp	DWORD PTR _lpMutex$[ebp], 0
	je	SHORT $L63508

; 8757 :       if ( lpMutex->lNameHash != lHash )

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	edx, DWORD PTR [ecx+71]
	cmp	edx, DWORD PTR _lHash$[ebp]
	je	SHORT $L63509

; 8758 :          continue;

	jmp	SHORT $L63507
$L63509:

; 8759 : 
; 8760 :       // Don't qualify on ProcessID if it is a system mutex.
; 8761 : #if 0
; 8762 :       if ( lProcessID == 0 )  // processing system mutex list
; 8763 :       {
; 8764 :          // We don't care about process ID match.
; 8765 :       }
; 8766 :       else
; 8767 :       {
; 8768 :          // We do care about process ID match.
; 8769 :          if ( lpMutex->lProcessID != lProcessID )
; 8770 :             continue;
; 8771 :       }
; 8772 : #else
; 8773 :       if ( lProcessID && lpMutex->lProcessID != lProcessID )

	cmp	DWORD PTR _lProcessID$[ebp], 0
	je	SHORT $L63510
	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+89]
	cmp	ecx, DWORD PTR _lProcessID$[ebp]
	je	SHORT $L63510

; 8774 :          continue;

	jmp	SHORT $L63507
$L63510:

; 8775 : #endif
; 8776 : 
; 8777 :       if ( zstrcmp( lpMutex->szName, cpcMutexName ) != 0 )

	mov	edx, DWORD PTR _lpMutex$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	ecx, DWORD PTR _cpcMutexName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $L64961
	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpMutex$[ebp]
	add	ecx, 6
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -16+[ebp], eax
	jmp	SHORT $L64962
$L64961:
	mov	edx, DWORD PTR _lpMutex$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	ecx, DWORD PTR _cpcMutexName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	xor	ecx, ecx
	test	eax, eax
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -16+[ebp], ecx
$L64962:
	cmp	DWORD PTR -16+[ebp], 0
	je	SHORT $L63517

; 8778 :          continue;

	jmp	$L63507
$L63517:
$L63508:

; 8783 : 
; 8784 :    if ( lpTask == (LPTASK) -1 )

	cmp	DWORD PTR _lpTask$[ebp], -1
	jne	SHORT $L63519

; 8785 :       zUNLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysUnlockCoreMutex@4
$L63519:

; 8786 : 
; 8787 :    return( lpMutex );

	mov	eax, DWORD PTR _lpMutex$[ebp]
$L63493:

; 8788 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnMutexFind@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@KDEH@fnMutexCreate?5Invalid?5mutex?5name@ ; `string'
PUBLIC	_fnMutexCreate@16
PUBLIC	_fnMutexCreateOS@12
;	COMDAT ??_C@_0CD@KDEH@fnMutexCreate?5Invalid?5mutex?5name@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CD@KDEH@fnMutexCreate?5Invalid?5mutex?5name@ DB 'fnMutexCreate Inv'
	DB	'alid mutex name: ', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTask$ = 8
_cpcMutexName$ = 12
_lControl$ = 16
_bSkipSettingMutex$ = 20
_lpMutex$ = -8
_hMutex$ = -12
_lpSysMutex$ = -20
_hSysMutex$ = -16
_lProcessID$ = -4
_fnMutexCreate@16 PROC NEAR

; 8804 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 8805 :    LPMUTEX lpMutex;
; 8806 :    LPMUTEX hMutex;
; 8807 :    LPMUTEX lpSysMutex;
; 8808 :    LPMUTEX hSysMutex;
; 8809 :    zLONG   lProcessID;
; 8810 : 
; 8811 :    if ( zstrlen( cpcMutexName ) > zZEIDON_NAME_LTH * 2 )

	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 64					; 00000040H
	jbe	SHORT $L63534

; 8813 :       // "KZOEE032 - Invalid mutex name"
; 8814 :    // fnIssueCoreError( lpTask, lpView, 16, 32, 0, 0, 0 );
; 8815 :       TraceLineS( "fnMutexCreate Invalid mutex name: ", cpcMutexName );

	mov	ecx, DWORD PTR _cpcMutexName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CD@KDEH@fnMutexCreate?5Invalid?5mutex?5name@ ; `string'
	call	_TraceLineS@8

; 8816 :       return( 0 );

	xor	eax, eax
	jmp	$L63528
$L63534:

; 8818 : 
; 8819 :    // Look for the mutex. If it is found just return it.
; 8820 :    lpMutex = fnMutexFind( lpTask, cpcMutexName );

	mov	edx, DWORD PTR _cpcMutexName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnMutexFind@8
	mov	DWORD PTR _lpMutex$[ebp], eax

; 8821 :    if ( lpMutex )

	cmp	DWORD PTR _lpMutex$[ebp], 0
	je	SHORT $L63536

; 8822 :       return( lpMutex );

	mov	eax, DWORD PTR _lpMutex$[ebp]
	jmp	$L63528
$L63536:

; 8823 : 
; 8824 :    lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 8825 : 
; 8826 :    // If the mutex wasn't found in the task list then try looking for it
; 8827 :    // in the system list.  We put a mutex around it so we only create the
; 8828 :    // system mutex once.
; 8829 :    if ( bSkipSettingMutex == FALSE )

	mov	ecx, DWORD PTR _bSkipSettingMutex$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L63537

; 8830 :       zLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysLockCoreMutex@4
$L63537:

; 8831 : 
; 8832 :    lpSysMutex = fnMutexFind( (LPTASK) -1, cpcMutexName );

	mov	edx, DWORD PTR _cpcMutexName$[ebp]
	push	edx
	push	-1
	call	_fnMutexFind@8
	mov	DWORD PTR _lpSysMutex$[ebp], eax

; 8833 :    if ( lpSysMutex == 0 )

	cmp	DWORD PTR _lpSysMutex$[ebp], 0
	jne	SHORT $L63539

; 8835 :       // We need to create the system mutex.
; 8836 :       hSysMutex = fnAllocDataspace( (LPDATAHEADER) g_hAnchorBlock,
; 8837 :                                     sizeof( MutexRecord ), 1, 0, iMutex );

	push	10045					; 0000273dH
	push	0
	push	1
	push	602					; 0000025aH
	mov	eax, DWORD PTR _g_hAnchorBlock
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hSysMutex$[ebp], eax

; 8838 :       lpSysMutex = zGETPTR( hSysMutex );

	mov	ecx, DWORD PTR _hSysMutex$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSysMutex$[ebp], eax

; 8839 :       zstrcpy( lpSysMutex->szName, cpcMutexName );

	mov	edx, DWORD PTR _cpcMutexName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSysMutex$[ebp]
	add	eax, 6
	push	eax
	call	_strcpy
	add	esp, 8

; 8840 :       lpSysMutex->lNameHash = fnHashName( cpcMutexName );

	mov	ecx, DWORD PTR _cpcMutexName$[ebp]
	push	ecx
	call	_fnHashName@4
	mov	edx, DWORD PTR _lpSysMutex$[ebp]
	mov	DWORD PTR [edx+71], eax

; 8841 :    // lpSysMutex->lProcessID = lProcessID; we don't care what process created the system mutex
; 8842 :       lpSysMutex->lProcessID = 0;

	mov	eax, DWORD PTR _lpSysMutex$[ebp]
	mov	DWORD PTR [eax+89], 0

; 8843 : 
; 8844 :       // Right now, I don't know why we want to create the OS mutex for
; 8845 :       // a "system" mutex ... so let's disable it.  // dks  2006.02.24
; 8846 :    // if ( fnMutexCreateOS( 0, lpSysMutex, lControl ) != 0 )
; 8847 :    // {
; 8848 :    //    if ( bSkipSettingMutex == FALSE )
; 8849 :    //       zUNLOCK_MUTEX( zMUTEX_MUTEX );
; 8850 :    //
; 8851 :    //    fnFreeDataspace( hSysMutex );
; 8852 :    //    return( 0 );
; 8853 :    // }
; 8854 : 
; 8855 :       lpSysMutex->hNextMutex = AnchorBlock->hFirstSysMutex;

	mov	ecx, DWORD PTR _lpSysMutex$[ebp]
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2519]
	mov	DWORD PTR [ecx+2], eax

; 8856 :       AnchorBlock->hFirstSysMutex = hSysMutex;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _hSysMutex$[ebp]
	mov	DWORD PTR [ecx+2519], edx

; 8858 :    else

	jmp	SHORT $L63543
$L63539:

; 8859 :       hSysMutex = zGETHNDL( lpSysMutex );

	mov	eax, DWORD PTR _lpSysMutex$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hSysMutex$[ebp], eax
$L63543:

; 8860 : 
; 8861 :    // lpMutex must be null, or else we'd be out of here.
; 8862 :    // Create the task mutex.
; 8863 :    hMutex = fnAllocDataspace( lpTask->hFirstDataHeader,
; 8864 :                               sizeof( MutexRecord ), 1, 0, iMutex );

	push	10045					; 0000273dH
	push	0
	push	1
	push	602					; 0000025aH
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hMutex$[ebp], eax

; 8865 :    lpMutex = zGETPTR( hMutex );

	mov	eax, DWORD PTR _hMutex$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax

; 8866 :    zstrcpy( lpMutex->szName, cpcMutexName );

	mov	ecx, DWORD PTR _cpcMutexName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMutex$[ebp]
	add	edx, 6
	push	edx
	call	_strcpy
	add	esp, 8

; 8867 :    lpMutex->hSysMutex = hSysMutex;

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR _hSysMutex$[ebp]
	mov	DWORD PTR [eax+77], ecx

; 8868 :    lpMutex->lNameHash = lpSysMutex->lNameHash;

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR _lpSysMutex$[ebp]
	mov	ecx, DWORD PTR [eax+71]
	mov	DWORD PTR [edx+71], ecx

; 8869 :    lpMutex->lProcessID = lProcessID;

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [edx+89], eax

; 8870 : 
; 8871 :    if ( fnMutexCreateOS( lpTask, lpMutex, lControl ) != 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMutex$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnMutexCreateOS@12
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L63547

; 8873 :       if ( bSkipSettingMutex == FALSE )

	mov	edx, DWORD PTR _bSkipSettingMutex$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	jne	SHORT $L63548

; 8874 :          zUNLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysUnlockCoreMutex@4
$L63548:

; 8875 : 
; 8876 :       fnFreeDataspace( hMutex );

	mov	eax, DWORD PTR _hMutex$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 8877 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $L63528
$L63547:

; 8879 : 
; 8880 :    lpMutex->hNextMutex = lpTask->hFirstMutex;

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+150]
	mov	DWORD PTR [ecx+2], eax

; 8881 :    lpTask->hFirstMutex = hMutex;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _hMutex$[ebp]
	mov	DWORD PTR [ecx+150], edx

; 8882 : 
; 8883 :    if ( bSkipSettingMutex == FALSE )

	mov	eax, DWORD PTR _bSkipSettingMutex$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L63549

; 8884 :       zUNLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysUnlockCoreMutex@4
$L63549:

; 8885 : 
; 8886 : #ifdef TRACE_MUTEX
; 8887 : // if ( zstrcmp( lpMutex->szName, "ZDrSS" ) != 0 )
; 8888 :    TraceLine( "fnMutexCreate  (Created:) Task: 0x%08x   Mutex: 0x%08x  Handle: %d  %s  Process: 0x%08x  SysMutex: 0x%08x",
; 8889 :               zGETHNDL( lpTask ), lpMutex, lpMutex->Info.hMutexOS,
; 8890 :               lpMutex->szName, SysGetProcessID( 0 ), lpMutex->hSysMutex );
; 8891 : #endif
; 8892 : 
; 8893 :    return( lpMutex );

	mov	eax, DWORD PTR _lpMutex$[ebp]
$L63528:

; 8894 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnMutexCreate@16 ENDP
_lpMutex$ = 12
_szMsg$63560 = -100
_dw$63561 = -104
_fnMutexCreateOS@12 PROC NEAR

; 8898 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H

; 8899 :    lpMutex->Info.bCriticalSection = FALSE;

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	BYTE PTR [eax+93], 0

; 8900 : 
; 8901 :    lpMutex->Info.hMutexOS = (zLONG) CreateMutex( NULL, FALSE, lpMutex->szName );

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	add	ecx, 6
	push	ecx
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	DWORD PTR [edx+94], eax

; 8902 :    if ( lpMutex->Info.hMutexOS == 0 )

	mov	eax, DWORD PTR _lpMutex$[ebp]
	cmp	DWORD PTR [eax+94], 0
	jne	SHORT $L63559

; 8904 :       zCHAR szMsg[ 100 ];
; 8905 :       DWORD dw = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dw$63561[ebp], eax

; 8906 :       zsprintf( szMsg, "Error creating mutex %s", lpMutex->szName );

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	add	ecx, 6
	push	ecx
	push	OFFSET FLAT:??_C@_0BI@NCB@Error?5creating?5mutex?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szMsg$63560[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 8907 :       SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$63560[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 8908 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L63556
$L63559:

; 8910 : 
; 8911 :    return( 0 );

	xor	ax, ax
$L63556:

; 8912 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnMutexCreateOS@12 ENDP
_TEXT	ENDS
PUBLIC	_SysMutexCreate@12
_TEXT	SEGMENT
_lpTaskView$ = 8
_cpcMutexName$ = 12
_lControl$ = 16
_lpTask$ = -4
_SysMutexCreate@12 PROC NEAR

; 8916 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8917 :    LPTASK  lpTask;
; 8918 : 
; 8919 :    if ( lpTaskView == 0 || (lpTask = zGETPTR( lpTaskView->hTask )) == 0 )

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L63572
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L63571
$L63572:

; 8920 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $L63568
$L63571:

; 8921 : 
; 8922 :    if ( fnMutexCreate( lpTask, cpcMutexName, lControl, FALSE ) == 0 )

	push	0
	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnMutexCreate@16
	test	eax, eax
	jne	SHORT $L63573

; 8923 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $L63568
$L63573:

; 8924 : 
; 8925 :    return( 0 );

	xor	eax, eax
$L63568:

; 8926 : 
; 8927 : } // SysMutexCreate

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysMutexCreate@12 ENDP
_TEXT	ENDS
PUBLIC	_fnSysMutexLock@16
_TEXT	SEGMENT
_lpMutex$ = 12
_ulTimeout$ = 16
_nRC$ = -4
_fnSysMutexLock@16 PROC NEAR

; 8950 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 8951 :    zSHORT nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0

; 8952 : 
; 8953 : #ifdef TRACE_MUTEX
; 8954 : // if ( zstrcmp( lpMutex->szName, "ZDrSS" ) != 0 )
; 8955 :    TraceLine( "fnSysMutexLock (WaitLock) Task: 0x%08x   Mutex: 0x%08x  Handle: %d  %s  Process: 0x%08x",
; 8956 :               zGETHNDL( lpTask ), lpMutex, lpMutex->Info.hMutexOS,
; 8957 :               lpMutex->szName, SysGetProcessID( 0 ) );
; 8958 : #endif
; 8959 :    if ( ulTimeout == 0 )

	cmp	DWORD PTR _ulTimeout$[ebp], 0
	jne	SHORT $L63584

; 8960 :       ulTimeout = INFINITE;

	mov	DWORD PTR _ulTimeout$[ebp], -1
$L63584:

; 8961 : 
; 8962 :    if ( WaitForSingleObject( (HANDLE) lpMutex->Info.hMutexOS,
; 8963 :                              ulTimeout ) == WAIT_FAILED )

	mov	eax, DWORD PTR _ulTimeout$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8
	cmp	eax, -1
	jne	SHORT $L63589

; 8965 :       switch ( GetLastError( ) )
; 8966 :       {

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 128			; 00000080H
	je	SHORT $L63593
	cmp	DWORD PTR -8+[ebp], 258			; 00000102H
	je	SHORT $L63595
	jmp	SHORT $L63596
$L63593:

; 8967 :          case WAIT_ABANDONED:
; 8968 :             // This means that another thread terminated without unlocking
; 8969 :             // its mutex.  We'll consider this OK.
; 8970 :             nRC = 1;

	mov	WORD PTR _nRC$[ebp], 1

; 8971 :             break;

	jmp	SHORT $L63589
$L63595:

; 8972 : 
; 8973 :          case WAIT_TIMEOUT:
; 8974 :             nRC = -1;

	mov	WORD PTR _nRC$[ebp], -1

; 8975 :             break;

	jmp	SHORT $L63589
$L63596:

; 8976 : 
; 8977 :          default:
; 8978 :             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H
$L63589:

; 8982 : 
; 8983 : #ifdef TRACE_MUTEX
; 8984 : // if ( zstrcmp( lpMutex->szName, "ZDrSS" ) != 0 )
; 8985 :    TraceLine( "fnSysMutexLock (Acquired) Task: 0x%08x   Mutex: 0x%08x  Handle: %d  %s  Process: 0x%08x   RC: %d",
; 8986 :               zGETHNDL( lpTask ), lpMutex, lpMutex->Info.hMutexOS,
; 8987 :               lpMutex->szName, SysGetProcessID( 0 ), nRC );
; 8988 : #endif
; 8989 : 
; 8990 :    if ( nRC == 1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	jne	SHORT $L63597

; 8991 :       nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$L63597:

; 8992 : 
; 8993 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 8994 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysMutexLock@16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@MGPE@?$CItm?$CJ?5Error?5trying?5to?5lock?5mutex?5@ ; `string'
PUBLIC	??_C@_0BE@IMPM@Error?5locking?5mutex?$AA@	; `string'
PUBLIC	??_C@_05CKBG@Error?$AA@				; `string'
PUBLIC	_SysMutexLock@16
;	COMDAT ??_C@_0CB@MGPE@?$CItm?$CJ?5Error?5trying?5to?5lock?5mutex?5@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CB@MGPE@?$CItm?$CJ?5Error?5trying?5to?5lock?5mutex?5@ DB '(tm) Err'
	DB	'or trying to lock mutex ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IMPM@Error?5locking?5mutex?$AA@
_DATA	SEGMENT
??_C@_0BE@IMPM@Error?5locking?5mutex?$AA@ DB 'Error locking mutex', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_05CKBG@Error?$AA@
_DATA	SEGMENT
??_C@_05CKBG@Error?$AA@ DB 'Error', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTaskView$ = 8
_cpcMutexName$ = 12
_ulTimeout$ = 16
_lControl$ = 20
_lpTask$ = -12
_lpMutex$ = -8
_nRC$ = -4
_lpSysMutex$63616 = -16
_SysMutexLock@16 PROC NEAR

; 9001 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 9002 :    LPTASK  lpTask;
; 9003 :    LPMUTEX lpMutex;
; 9004 :    zSHORT  nRC;
; 9005 : 
; 9006 :    if ( lpTaskView == 0 || (lpTask = zGETPTR( lpTaskView->hTask )) == 0 )

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L63612
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L63611
$L63612:

; 9007 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L63618
$L63611:

; 9008 : 
; 9009 :    // If the mutex hasn't been created yet, try to create it.
; 9010 :    lpMutex = fnMutexCreate( lpTask, cpcMutexName, lControl, 0 );

	push	0
	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnMutexCreate@16
	mov	DWORD PTR _lpMutex$[ebp], eax

; 9011 :    if ( lpMutex == 0 )

	cmp	DWORD PTR _lpMutex$[ebp], 0
	jne	SHORT $L63613

; 9012 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L63618
$L63613:

; 9013 : 
; 9014 :    // Check to see if the mutex is already locked for this task.
; 9015 :    if ( lpMutex->nLockCount )

	mov	edx, DWORD PTR _lpMutex$[ebp]
	movsx	eax, WORD PTR [edx+75]
	test	eax, eax
	je	SHORT $L63614

; 9016 :       return( lpMutex->nLockCount++ );

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	ax, WORD PTR [ecx+75]
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	cx, WORD PTR [edx+75]
	add	cx, 1
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	WORD PTR [edx+75], cx
	jmp	$L63618
$L63614:

; 9017 : 
; 9018 :    lpMutex->bWaiting = TRUE;

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+85]
	or	ecx, 1
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	DWORD PTR [edx+85], ecx

; 9019 : 
; 9020 :    nRC = fnSysMutexLock( lpTask, lpMutex, ulTimeout, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulTimeout$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMutex$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysMutexLock@16
	mov	WORD PTR _nRC$[ebp], ax

; 9021 : 
; 9022 :    lpMutex->bWaiting = FALSE;

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	edx, DWORD PTR [ecx+85]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	DWORD PTR [eax+85], edx

; 9023 : 
; 9024 :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L63615

; 9026 :       LPMUTEX lpSysMutex = zGETPTR( lpMutex->hSysMutex );

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+77]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSysMutex$63616[ebp], eax

; 9027 : 
; 9028 :       lpSysMutex->lLockedTaskID = GetCurrentProcessId( );

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	ecx, DWORD PTR _lpSysMutex$63616[ebp]
	mov	DWORD PTR [ecx+81], eax

; 9029 :       return( ++lpMutex->nLockCount );  // pre-increment intended

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	ax, WORD PTR [edx+75]
	add	ax, 1
	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	WORD PTR [ecx+75], ax
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	ax, WORD PTR [edx+75]
	jmp	SHORT $L63618
$L63615:

; 9033 :       TraceLineS( "(tm) Error trying to lock mutex ", cpcMutexName );

	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CB@MGPE@?$CItm?$CJ?5Error?5trying?5to?5lock?5mutex?5@ ; `string'
	call	_TraceLineS@8

; 9034 :       SysMessageBox( lpTaskView, "Error", "Error locking mutex", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BE@IMPM@Error?5locking?5mutex?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_05CKBG@Error?$AA@	; `string'
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 9035 :       nRC /= nRC - nRC;

	movsx	eax, WORD PTR _nRC$[ebp]
	movsx	ecx, WORD PTR _nRC$[ebp]
	movsx	edx, WORD PTR _nRC$[ebp]
	sub	ecx, edx
	cdq
	idiv	ecx
	mov	WORD PTR _nRC$[ebp], ax

; 9036 : 
; 9037 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
$L63618:

; 9039 : 
; 9040 : } // SysMutexLock

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysMutexLock@16 ENDP
_TEXT	ENDS
PUBLIC	_fnSysMutexUnlock@8
_TEXT	SEGMENT
_lpMutex$ = 12
_szMsg$63629 = -100
_fnSysMutexUnlock@8 PROC NEAR

; 9061 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 9076 :       if ( ReleaseMutex( (HANDLE) lpMutex->Info.hMutexOS ) == 0 )

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $L63628

; 9078 :          zCHAR szMsg[ 100 ];
; 9079 : 
; 9080 :          zsprintf( szMsg, "Error releasing mutex %s", lpMutex->szName );

	mov	edx, DWORD PTR _lpMutex$[ebp]
	add	edx, 6
	push	edx
	push	OFFSET FLAT:??_C@_0BJ@HDOA@Error?5releasing?5mutex?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szMsg$63629[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 9081 :          TraceLineS( szMsg, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szMsg$63629[ebp]
	push	ecx
	call	_TraceLineS@8

; 9082 :          SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	edx, DWORD PTR _szMsg$63629[ebp]
	push	edx
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 9083 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L63626
$L63628:

; 9086 : 
; 9087 : #ifdef TRACE_MUTEX
; 9088 : // if ( zstrcmp( lpMutex->szName, "ZDrSS" ) != 0 )
; 9089 :    TraceLine( "fnSysMutexUnlock (Unlock) Task: 0x%08x   Mutex: 0x%08x  Handle: %d  %s  Process: 0x%08x",
; 9090 :               zGETHNDL( lpTask ), lpMutex, lpMutex->Info.hMutexOS,
; 9091 :               lpMutex->szName, SysGetProcessID( 0 ) );
; 9092 : #endif
; 9093 : 
; 9094 :    return( 0 );

	xor	ax, ax
$L63626:

; 9095 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnSysMutexUnlock@8 ENDP
_TEXT	ENDS
PUBLIC	_SysMutexUnlock@12
_TEXT	SEGMENT
_lpTaskView$ = 8
_cpcMutexName$ = 12
_lpTask$ = -8
_lpMutex$ = -4
_lpSysMutex$ = -12
_SysMutexUnlock@12 PROC NEAR

; 9099 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 9100 :    LPTASK  lpTask;
; 9101 :    LPMUTEX lpMutex;
; 9102 :    LPMUTEX lpSysMutex;
; 9103 : 
; 9104 :    if ( lpTaskView == 0 || (lpTask = zGETPTR( lpTaskView->hTask )) == 0 )

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $L63642
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L63641
$L63642:

; 9105 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L63636
$L63641:

; 9106 : 
; 9107 :    if ( (lpMutex = fnMutexFind( lpTask, cpcMutexName )) == 0 )

	mov	edx, DWORD PTR _cpcMutexName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnMutexFind@8
	mov	DWORD PTR _lpMutex$[ebp], eax
	cmp	DWORD PTR _lpMutex$[ebp], 0
	jne	SHORT $L63643

; 9108 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L63636
$L63643:

; 9109 : 
; 9110 :    if ( lpMutex->nLockCount == 0 )

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	movsx	edx, WORD PTR [ecx+75]
	test	edx, edx
	jne	SHORT $L63644

; 9111 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L63636
$L63644:

; 9112 : 
; 9113 :    if ( lpMutex->nLockCount > 1 )

	mov	eax, DWORD PTR _lpMutex$[ebp]
	movsx	ecx, WORD PTR [eax+75]
	cmp	ecx, 1
	jle	SHORT $L63645

; 9114 :       return( --lpMutex->nLockCount );  // pre-decrement intended

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	ax, WORD PTR [edx+75]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	WORD PTR [ecx+75], ax
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	ax, WORD PTR [edx+75]
	jmp	SHORT $L63636
$L63645:

; 9115 : 
; 9116 :    // We'll reset the lLockedTaskID even though we haven't actually locked
; 9117 :    // it yet.  This protects us from having two tasks change the ID at the
; 9118 :    // same time.
; 9119 :    lpSysMutex = zGETPTR( lpMutex->hSysMutex );

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+77]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSysMutex$[ebp], eax

; 9120 :    lpSysMutex->lLockedTaskID = 0;

	mov	edx, DWORD PTR _lpSysMutex$[ebp]
	mov	DWORD PTR [edx+81], 0

; 9121 : 
; 9122 :    if ( fnSysMutexUnlock( lpTask, lpMutex ) != 0 )

	mov	eax, DWORD PTR _lpMutex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysMutexUnlock@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L63647

; 9123 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L63636
$L63647:

; 9124 : 
; 9125 :    lpMutex->nLockCount = 0;

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	WORD PTR [eax+75], 0

; 9126 :    return( 0 );

	xor	ax, ax
$L63636:

; 9127 : 
; 9128 : } // SysMutexUnlock

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysMutexUnlock@12 ENDP
_TEXT	ENDS
PUBLIC	_SysMutexClose@4
_TEXT	SEGMENT
_hMutexOS$ = 8
_SysMutexClose@4 PROC NEAR

; 9132 : {

	push	ebp
	mov	ebp, esp

; 9133 :    return( CloseHandle( (HANDLE) hMutexOS ) );

	mov	eax, DWORD PTR _hMutexOS$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 9134 : }

	pop	ebp
	ret	4
_SysMutexClose@4 ENDP
_TEXT	ENDS
PUBLIC	_fnSysMutexDestroy@8
_TEXT	SEGMENT
_lpTask$ = 8
_lpMutex$ = 12
_lProcessID$ = -4
_nProcessIdx$63659 = -12
_pOS_Record$63660 = -16
_lpProcessList$63661 = -8
_szMsg$63672 = -116
_fnSysMutexDestroy@8 PROC NEAR

; 9141 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H

; 9142 :    zLONG lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 9143 : #ifdef TRACE_MUTEX
; 9144 :    TraceLine( "fnSysMutexDestroy Task: 0x%08x  Handle: %d  %s  Mutex ProcessID %d   ProcessID %d",
; 9145 :               zGETHNDL( lpTask ), lpMutex ? lpMutex->Info.hMutexOS : 0, lpMutex ? lpMutex->szName : "",
; 9146 :               lpMutex->lProcessID, lProcessID );
; 9147 : #endif
; 9148 : 
; 9149 : // if ( lpTask == 0 || lpMutex == 0 || lpMutex->Info.hMutexOS == 0 )
; 9150 : //    return( 0 );
; 9151 : 
; 9152 : 
; 9153 :    // If lpTask is zero, we are destroying a system mutex ... which does
; 9154 :    // not have a valid mutex handle, so skip this part of the destroy.
; 9155 :    if ( lpTask && lpMutex->lProcessID != lProcessID )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$L63658
	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+89]
	cmp	ecx, DWORD PTR _lProcessID$[ebp]
	je	$L63658

; 9157 :       // Send a message to the other process specified by
; 9158 :       // lpMutex->lProcessID to free the mutex.
; 9159 :       zSHORT nProcessIdx;
; 9160 :       LPANCHOROS_RECORD pOS_Record = &AnchorBlock->OS_Data;

	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 1503				; 000005dfH
	mov	DWORD PTR _pOS_Record$63660[ebp], edx

; 9161 :       LPPROCESSLIST lpProcessList;
; 9162 : 
; 9163 :       // Find the process that created the mutex.
; 9164 :       for ( nProcessIdx = AnchorBlock->OS_Data.lProcessCount - 1;
; 9165 :             pOS_Record->ProcessList[ nProcessIdx ].lProcessID != lProcessID;
; 9166 :             nProcessIdx-- )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1507]
	sub	ecx, 1
	mov	WORD PTR _nProcessIdx$63659[ebp], cx
	jmp	SHORT $L63662
$L63663:
	mov	dx, WORD PTR _nProcessIdx$63659[ebp]
	sub	dx, 1
	mov	WORD PTR _nProcessIdx$63659[ebp], dx
$L63662:
	movsx	eax, WORD PTR _nProcessIdx$63659[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _pOS_Record$63660[ebp]
	mov	edx, DWORD PTR [ecx+eax+24]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	je	SHORT $L63664

; 9168 :          // Nothing needs to be done here.
; 9169 :       }

	jmp	SHORT $L63663
$L63664:

; 9170 : 
; 9171 :       if ( nProcessIdx > 0 )

	movsx	eax, WORD PTR _nProcessIdx$63659[ebp]
	test	eax, eax
	jle	SHORT $L63665

; 9173 :          lpProcessList = &pOS_Record->ProcessList[ nProcessIdx ];

	movsx	ecx, WORD PTR _nProcessIdx$63659[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _pOS_Record$63660[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _lpProcessList$63661[ebp], eax

; 9174 :          lpProcessList->nOE_Request  = TASKREQ_FREEMUTEX;

	mov	ecx, DWORD PTR _lpProcessList$63661[ebp]
	mov	WORD PTR [ecx], 7

; 9175 :          lpProcessList->hMemHandle   = (zULONG) zGETHNDL( lpMutex );

	mov	edx, DWORD PTR _lpMutex$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpProcessList$63661[ebp]
	mov	DWORD PTR [ecx+12], eax

; 9176 : 
; 9177 :          // Send the message.
; 9178 :          SendMessage( (HWND) lpProcessList->hWndAppOE_Msg,
; 9179 :                       lpProcessList->uAppOE_Msg, 0, nProcessIdx );

	movsx	edx, WORD PTR _nProcessIdx$63659[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpProcessList$63661[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _lpProcessList$63661[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
$L63665:

; 9181 : 
; 9182 :       return( 0 );

	xor	ax, ax
	jmp	SHORT $L63656
$L63658:

; 9184 : 
; 9185 :    if ( lpMutex->Info.hMutexOS )

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	cmp	DWORD PTR [ecx+94], 0
	je	SHORT $L63669

; 9187 :       // We don't need to do the following code since the "System Mutex" is
; 9188 :       // only used to track the lLockedTaskID.  The Info.hMutexOS should not
; 9189 :       // be set for the system mutexes.
; 9190 :    // if ( lpTask )
; 9191 :    // {
; 9192 :    //    LPMUTEX lpSysMutex = fnMutexFind( (LPTASK) -1, lpMutex->szName );
; 9193 :    //    if ( lpSysMutex && lpSysMutex->Info.hMutexOS == lpMutex->Info.hMutexOS )
; 9194 :    //       lpSysMutex->Info.hMutexOS = 0;
; 9195 :    // }
; 9196 : 
; 9197 :       if ( CloseHandle( (HANDLE) lpMutex->Info.hMutexOS ) == 0 )

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	jne	SHORT $L63671

; 9199 :          char szMsg[ 100 ];
; 9200 : 
; 9201 :          zsprintf( szMsg, "Error destroying mutex: %s", lpMutex->szName );

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	add	ecx, 6
	push	ecx
	push	OFFSET FLAT:??_C@_0BL@LBEN@Error?5destroying?5mutex?3?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szMsg$63672[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 9202 :          TraceLineS( szMsg, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	eax, DWORD PTR _szMsg$63672[ebp]
	push	eax
	call	_TraceLineS@8

; 9203 :          fnSysMessageBox( lpTask, szlOE_SystemError, szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$63672[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysMessageBox@16

; 9204 :          return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	SHORT $L63656
$L63671:

; 9206 : 
; 9207 :       lpMutex->Info.hMutexOS = 0;

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	DWORD PTR [ecx+94], 0
$L63669:

; 9209 : 
; 9210 :    return( 0 );

	xor	ax, ax
$L63656:

; 9211 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnSysMutexDestroy@8 ENDP
_TEXT	ENDS
PUBLIC	_SysMutexQueryLock@4
_TEXT	SEGMENT
_cpcMutexName$ = 8
_lpMutex$ = -4
_lpTask$ = -8
_nLockCount$ = -12
_SysMutexQueryLock@4 PROC NEAR

; 9231 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 9232 :    LPMUTEX lpMutex;
; 9233 :    LPTASK  lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 9234 :    zSHORT  nLockCount = 0;

	mov	WORD PTR _nLockCount$[ebp], 0
$L63681:

; 9235 : 
; 9236 :    while ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $L63682

; 9238 :       lpMutex = fnMutexFind( lpTask, cpcMutexName );

	mov	edx, DWORD PTR _cpcMutexName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnMutexFind@8
	mov	DWORD PTR _lpMutex$[ebp], eax

; 9239 :       if ( lpMutex )

	cmp	DWORD PTR _lpMutex$[ebp], 0
	je	SHORT $L63683

; 9240 :          nLockCount += lpMutex->nLockCount;

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	dx, WORD PTR _nLockCount$[ebp]
	add	dx, WORD PTR [ecx+75]
	mov	WORD PTR _nLockCount$[ebp], dx
$L63683:

; 9241 : 
; 9242 :       lpTask = zGETPTR( lpTask->hNextTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 9243 :    }

	jmp	SHORT $L63681
$L63682:

; 9244 : 
; 9245 :    return( nLockCount );

	mov	ax, WORD PTR _nLockCount$[ebp]

; 9246 : 
; 9247 : } // SysMutexQueryLock

	mov	esp, ebp
	pop	ebp
	ret	4
_SysMutexQueryLock@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@FCNG@?5?9?9?9?9?5MUTEX?5LIST?5?9?9?9?9?5?$AA@ ; `string'
PUBLIC	??_C@_0CE@DCCM@MutexQueryStatus?5?$CFs?5?9?9?5Checking?5@ ; `string'
PUBLIC	??_C@_0CD@LOL@MutexQueryStatus?5?$CFs?5?9?9?5FAILED?5?$CI?$CF@ ; `string'
PUBLIC	??_C@_0BK@INMI@MutexQueryStatus?5?$CFs?5?9?9?5OK?$AA@ ; `string'
PUBLIC	??_C@_0CN@GMLN@Mutex?5?8?$CFs?8?5locked?5by?5Task?3?5?$CFd?5?5P@ ; `string'
PUBLIC	??_C@_0CH@OFLB@Mutex?5?8?$CFs?8?5is?5unlocked?5?5?5Process@ ; `string'
PUBLIC	??_C@_0EG@GHCJ@Task?50x?$CF08x?5?$CIprocess?5id?3?$CFd?$CJ?5is?5w@ ; `string'
PUBLIC	_SysMutexQueryStatus@0
;	COMDAT ??_C@_0BH@FCNG@?5?9?9?9?9?5MUTEX?5LIST?5?9?9?9?9?5?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0BH@FCNG@?5?9?9?9?9?5MUTEX?5LIST?5?9?9?9?9?5?$AA@ DB ' ---- MUTEX L'
	DB	'IST ---- ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CE@DCCM@MutexQueryStatus?5?$CFs?5?9?9?5Checking?5@
_DATA	SEGMENT
??_C@_0CE@DCCM@MutexQueryStatus?5?$CFs?5?9?9?5Checking?5@ DB 'MutexQueryS'
	DB	'tatus %s -- Checking ...', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@LOL@MutexQueryStatus?5?$CFs?5?9?9?5FAILED?5?$CI?$CF@
_DATA	SEGMENT
??_C@_0CD@LOL@MutexQueryStatus?5?$CFs?5?9?9?5FAILED?5?$CI?$CF@ DB 'MutexQ'
	DB	'ueryStatus %s -- FAILED (%d)', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@INMI@MutexQueryStatus?5?$CFs?5?9?9?5OK?$AA@
_DATA	SEGMENT
??_C@_0BK@INMI@MutexQueryStatus?5?$CFs?5?9?9?5OK?$AA@ DB 'MutexQueryStatu'
	DB	's %s -- OK', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CN@GMLN@Mutex?5?8?$CFs?8?5locked?5by?5Task?3?5?$CFd?5?5P@
_DATA	SEGMENT
??_C@_0CN@GMLN@Mutex?5?8?$CFs?8?5locked?5by?5Task?3?5?$CFd?5?5P@ DB 'Mute'
	DB	'x ''%s'' locked by Task: %d  ProcessID: %d', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CH@OFLB@Mutex?5?8?$CFs?8?5is?5unlocked?5?5?5Process@
_DATA	SEGMENT
??_C@_0CH@OFLB@Mutex?5?8?$CFs?8?5is?5unlocked?5?5?5Process@ DB 'Mutex ''%'
	DB	's'' is unlocked   ProcessID: %d', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EG@GHCJ@Task?50x?$CF08x?5?$CIprocess?5id?3?$CFd?$CJ?5is?5w@
_DATA	SEGMENT
??_C@_0EG@GHCJ@Task?50x?$CF08x?5?$CIprocess?5id?3?$CFd?$CJ?5is?5w@ DB 'Ta'
	DB	'sk 0x%08x (process id:%d) is waiting on mutex ''%s''   Lock C'
	DB	'ount: %d', 00H				; `string'
_DATA	ENDS
_TEXT	SEGMENT
_szMsg$ = -1008
_lpMutex$ = -8
_lpTask$ = -1012
_dwRC$ = -4
_k$ = -1016
_SysMutexQueryStatus@0 PROC NEAR

; 9267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1020				; 000003fcH

; 9268 :    zCHAR   szMsg[ 1000 ];
; 9269 :    LPMUTEX lpMutex;
; 9270 :    LPTASK  lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 9271 :    DWORD   dwRC;
; 9272 :    zSHORT  k;
; 9273 : 
; 9274 :    TraceLineS( " ---- MUTEX LIST ---- ", "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BH@FCNG@?5?9?9?9?9?5MUTEX?5LIST?5?9?9?9?9?5?$AA@ ; `string'
	call	_TraceLineS@8

; 9275 : 
; 9276 :    for ( k = 0; k < zMUTEX_COUNT; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L63693
$L63694:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$L63693:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 16					; 00000010H
	jge	$L63695

; 9278 :       TraceLine( "MutexQueryStatus %s -- Checking ...", g_ZeidonMutexName[ k ] );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _g_ZeidonMutexName[ecx*4]
	push	edx
	push	OFFSET FLAT:??_C@_0CE@DCCM@MutexQueryStatus?5?$CFs?5?9?9?5Checking?5@ ; `string'
	call	_TraceLine
	add	esp, 8

; 9279 :       dwRC = WaitForSingleObject( g_ZeidonMutexTable[ k ], 2000 );

	push	2000					; 000007d0H
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexTable[eax*4]
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	DWORD PTR _dwRC$[ebp], eax

; 9280 :       if ( dwRC == WAIT_FAILED )

	cmp	DWORD PTR _dwRC$[ebp], -1
	jne	SHORT $L63698

; 9282 :          switch ( GetLastError( ) )
; 9283 :          {

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR -1020+[ebp], eax
	cmp	DWORD PTR -1020+[ebp], 128		; 00000080H
	je	SHORT $L63704
	cmp	DWORD PTR -1020+[ebp], 258		; 00000102H
	je	SHORT $L63706
	jmp	SHORT $L63707
$L63704:

; 9284 :             case WAIT_ABANDONED:
; 9285 :                // This means that another thread terminated without unlocking
; 9286 :                // its mutex.  We'll consider this OK.
; 9287 :                dwRC = 0;

	mov	DWORD PTR _dwRC$[ebp], 0

; 9288 :                break;

	jmp	SHORT $L63700
$L63706:

; 9289 : 
; 9290 :             case WAIT_TIMEOUT:
; 9291 :                dwRC = 1;

	mov	DWORD PTR _dwRC$[ebp], 1

; 9292 :                break;

	jmp	SHORT $L63700
$L63707:

; 9293 : 
; 9294 :             default:
; 9295 :                dwRC = 2;

	mov	DWORD PTR _dwRC$[ebp], 2
$L63700:

; 9299 :       else

	jmp	SHORT $L63708
$L63698:

; 9300 :          dwRC = 0;

	mov	DWORD PTR _dwRC$[ebp], 0
$L63708:

; 9301 : 
; 9302 :       if ( dwRC )

	cmp	DWORD PTR _dwRC$[ebp], 0
	je	SHORT $L63709

; 9304 :          TraceLine( "MutexQueryStatus %s -- FAILED (%d)", g_ZeidonMutexName[ k ], dwRC );

	mov	edx, DWORD PTR _dwRC$[ebp]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexName[eax*4]
	push	ecx
	push	OFFSET FLAT:??_C@_0CD@LOL@MutexQueryStatus?5?$CFs?5?9?9?5FAILED?5?$CI?$CF@ ; `string'
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 9306 :       else

	jmp	SHORT $L63711
$L63709:

; 9308 :          ReleaseMutex( g_ZeidonMutexTable[ k ] );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _g_ZeidonMutexTable[edx*4]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 9309 :          TraceLine( "MutexQueryStatus %s -- OK", g_ZeidonMutexName[ k ] );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _g_ZeidonMutexName[ecx*4]
	push	edx
	push	OFFSET FLAT:??_C@_0BK@INMI@MutexQueryStatus?5?$CFs?5?9?9?5OK?$AA@ ; `string'
	call	_TraceLine
	add	esp, 8
$L63711:

; 9311 :    }

	jmp	$L63694
$L63695:

; 9312 : 
; 9313 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $L63713

; 9314 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L63685
$L63713:

; 9315 : 
; 9316 :    // Set lock to make sure nobody's changing the mutex chains.
; 9317 :    zLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysLockCoreMutex@4

; 9318 : 
; 9319 :    for ( lpMutex = zGETPTR( AnchorBlock->hFirstSysMutex );
; 9320 :          lpMutex;
; 9321 :          lpMutex = zGETPTR( lpMutex->hNextMutex ) )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2519]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax
	jmp	SHORT $L63716
$L63717:
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax
$L63716:
	cmp	DWORD PTR _lpMutex$[ebp], 0
	je	SHORT $L63718

; 9323 :       if ( lpMutex->lLockedTaskID )

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	cmp	DWORD PTR [ecx+81], 0
	je	SHORT $L63719

; 9325 :          zsprintf( szMsg, "Mutex '%s' locked by Task: %d  ProcessID: %d",
; 9326 :                    lpMutex->szName, lpMutex->lLockedTaskID, lpMutex->lProcessID );

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+89]
	push	eax
	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	edx, DWORD PTR [ecx+81]
	push	edx
	mov	eax, DWORD PTR _lpMutex$[ebp]
	add	eax, 6
	push	eax
	push	OFFSET FLAT:??_C@_0CN@GMLN@Mutex?5?8?$CFs?8?5locked?5by?5Task?3?5?$CFd?5?5P@ ; `string'
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 9328 :       else

	jmp	SHORT $L63721
$L63719:

; 9330 :          zsprintf( szMsg, "Mutex '%s' is unlocked   ProcessID: %d",
; 9331 :                    lpMutex->szName, lpMutex->lProcessID );

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+89]
	push	eax
	mov	ecx, DWORD PTR _lpMutex$[ebp]
	add	ecx, 6
	push	ecx
	push	OFFSET FLAT:??_C@_0CH@OFLB@Mutex?5?8?$CFs?8?5is?5unlocked?5?5?5Process@ ; `string'
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H
$L63721:

; 9333 : 
; 9334 :       TraceLineS( szMsg, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_TraceLineS@8

; 9335 :    }

	jmp	$L63717
$L63718:

; 9336 : 
; 9337 :    fnStartBrowseOfTaskList( zGETHNDL( lpTask ), FALSE );

	push	0
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	_fnStartBrowseOfTaskList@8

; 9338 : 
; 9339 :    for ( lpTask = zGETPTR( AnchorBlock->hFirstTask );
; 9340 :          lpTask;
; 9341 :          lpTask = zGETPTR( lpTask->hNextTask ) )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+130]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	jmp	SHORT $L63726
$L63727:
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$L63726:
	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $L63728

; 9343 :       for ( lpMutex = zGETPTR( lpTask->hFirstMutex );
; 9344 :             lpMutex;
; 9345 :             lpMutex = zGETPTR( lpMutex->hNextMutex ) )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+150]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax
	jmp	SHORT $L63731
$L63732:
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax
$L63731:
	cmp	DWORD PTR _lpMutex$[ebp], 0
	je	SHORT $L63733

; 9347 :          // We only care about tasks waiting for a mutex.
; 9348 :          if ( lpMutex->bWaiting == FALSE )

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	edx, DWORD PTR [ecx+85]
	and	edx, 1
	test	edx, edx
	jne	SHORT $L63734

; 9349 :             continue;

	jmp	SHORT $L63732
$L63734:

; 9350 : 
; 9351 :          zsprintf( szMsg, "Task 0x%08x (process id:%d) is waiting on mutex '%s'   Lock Count: %d",
; 9352 :                    lpTask, lpMutex->lProcessID, lpMutex->szName, SysMutexQueryLock( lpMutex->szName ) );

	mov	eax, DWORD PTR _lpMutex$[ebp]
	add	eax, 6
	push	eax
	call	_SysMutexQueryLock@4
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _lpMutex$[ebp]
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+89]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0EG@GHCJ@Task?50x?$CF08x?5?$CIprocess?5id?3?$CFd?$CJ?5is?5w@ ; `string'
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 9353 :       }

	jmp	SHORT $L63732
$L63733:

; 9354 :    }

	jmp	$L63727
$L63728:

; 9355 : 
; 9356 :    fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 9357 : 
; 9358 :    zUNLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysUnlockCoreMutex@4

; 9359 : 
; 9360 :    return( 0 );

	xor	ax, ax
$L63685:

; 9361 : 
; 9362 : } // SysMutexQueryStatus

	mov	esp, ebp
	pop	ebp
	ret	0
_SysMutexQueryStatus@0 ENDP
_TEXT	ENDS
PUBLIC	_SysStartBrowseOfTaskList@4
_TEXT	SEGMENT
_lpTaskView$ = 8
_SysStartBrowseOfTaskList@4 PROC NEAR

; 9366 : {

	push	ebp
	mov	ebp, esp

; 9367 :    return( fnStartBrowseOfTaskList( lpTaskView->hTask, FALSE ) );

	push	0
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	_fnStartBrowseOfTaskList@8

; 9368 : }

	pop	ebp
	ret	4
_SysStartBrowseOfTaskList@4 ENDP
_TEXT	ENDS
PUBLIC	_SysEndBrowseOfTaskList@0
_TEXT	SEGMENT
_SysEndBrowseOfTaskList@0 PROC NEAR

; 9372 : {

	push	ebp
	mov	ebp, esp

; 9373 :    fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 9374 : }

	pop	ebp
	ret	0
_SysEndBrowseOfTaskList@0 ENDP
_TEXT	ENDS
PUBLIC	??_C@_08EIPD@KZOESYAA?$AA@			; `string'
PUBLIC	_SysGetClientMessage@0
EXTRN	__imp__RegisterWindowMessageA@4:NEAR
;	COMDAT ??_C@_08EIPD@KZOESYAA?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_08EIPD@KZOESYAA?$AA@ DB 'KZOESYAA', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_SysGetClientMessage@0 PROC NEAR

; 9378 : {

	push	ebp
	mov	ebp, esp

; 9379 :    if ( g_wClientMessage == 0 )

	cmp	DWORD PTR _g_wClientMessage, 0
	jne	SHORT $L63741

; 9380 :       g_wClientMessage = RegisterWindowMessage( "KZOESYAA" );

	push	OFFSET FLAT:??_C@_08EIPD@KZOESYAA?$AA@	; `string'
	call	DWORD PTR __imp__RegisterWindowMessageA@4
	mov	DWORD PTR _g_wClientMessage, eax
$L63741:

; 9381 : 
; 9382 :    return( g_wClientMessage );

	mov	ax, WORD PTR _g_wClientMessage

; 9383 : }

	pop	ebp
	ret	0
_SysGetClientMessage@0 ENDP
_TEXT	ENDS
PUBLIC	_SysMainWndProc@16
PUBLIC	??_C@_0CI@DLDL@SysMainWndProc?5for?5Tomcat?5sessio@ ; `string'
EXTRN	__imp__DefWindowProcA@16:NEAR
EXTRN	__imp__PostQuitMessage@4:NEAR
;	COMDAT ??_C@_0CI@DLDL@SysMainWndProc?5for?5Tomcat?5sessio@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0CI@DLDL@SysMainWndProc?5for?5Tomcat?5sessio@ DB 'SysMainWndProc fo'
	DB	'r Tomcat session Wnd: ', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_hWnd$ = 8
_uMsg$ = 12
_wParam$ = 16
_lParam$ = 20
_SysMainWndProc@16 PROC NEAR

; 10174: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10175:    TraceLineI( "SysMainWndProc for Tomcat session Wnd: ", (zLONG) hWnd );

	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLDL@SysMainWndProc?5for?5Tomcat?5sessio@ ; `string'
	call	_TraceLineI@8

; 10176:    switch ( uMsg )
; 10177:    {

	mov	ecx, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR -4+[ebp], ecx
	cmp	DWORD PTR -4+[ebp], 2
	je	SHORT $L63759
	jmp	SHORT $L63760
$L63759:

; 10178:       case WM_DESTROY:        // message: window being destroyed
; 10179:          PostQuitMessage( 0 );

	push	0
	call	DWORD PTR __imp__PostQuitMessage@4

; 10180:          break;

	jmp	SHORT $L63756
$L63760:

; 10181: 
; 10182:       default:
; 10183:          if ( uMsg == g_wClientMessage )

	mov	edx, DWORD PTR _uMsg$[ebp]
	cmp	edx, DWORD PTR _g_wClientMessage
	jne	SHORT $L63761

; 10185:             TraceLineI( "SysMainWndProc for Tomcat session Wnd: ", (zLONG) hWnd );

	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CI@DLDL@SysMainWndProc?5for?5Tomcat?5sessio@ ; `string'
	call	_TraceLineI@8

; 10186:             ProcessZeidonMessage( wParam, lParam );

	mov	ecx, DWORD PTR _lParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wParam$[ebp]
	push	edx
	call	_ProcessZeidonMessage@8
$L63761:
$L63756:

; 10191: 
; 10192:    return( DefWindowProc( hWnd, uMsg, wParam, lParam ));

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DefWindowProcA@16

; 10193: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysMainWndProc@16 ENDP
_TEXT	ENDS
PUBLIC	_SysInitApplicationWindow@12
PUBLIC	??_C@_0DP@DCII@SysInitApplicationWindow?5Class?3?5@ ; `string'
EXTRN	__imp__CreateWindowExA@48:NEAR
EXTRN	__imp__ShowWindow@8:NEAR
EXTRN	__imp__LoadCursorA@8:NEAR
EXTRN	__imp__LoadIconA@8:NEAR
EXTRN	__imp__GetStockObject@4:NEAR
EXTRN	__imp__GetSystemMetrics@4:NEAR
EXTRN	__imp__RegisterClassA@4:NEAR
;	COMDAT ??_C@_0DP@DCII@SysInitApplicationWindow?5Class?3?5@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_0DP@DCII@SysInitApplicationWindow?5Class?3?5@ DB 'SysInitApplicatio'
	DB	'nWindow Class: %s  Title: %s  hWnd: 0x%08x=%d', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_hInstance$ = 8
_cpcClassName$ = 12
_cpcWindowTitle$ = 16
_wc$ = -40
_hMainWnd$63779 = -44
_nHeight$63780 = -60
_nPosY$63781 = -52
_nWidth$63782 = -56
_nPosX$63783 = -48
_szMsg$63785 = -316
_SysInitApplicationWindow@12 PROC NEAR

; 10212: {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH

; 10213:    WNDCLASS  wc;
; 10214: 
; 10215:    // Fill in window class structure with parameters that describe the main window.
; 10216:    wc.style = 0;                       // class style(s)

	mov	DWORD PTR _wc$[ebp], 0

; 10217:    wc.lpfnWndProc = SysMainWndProc;    // function to retrieve messages for

	mov	DWORD PTR _wc$[ebp+4], OFFSET FLAT:_SysMainWndProc@16

; 10218:                                        //   windows of this class
; 10219:    wc.cbClsExtra = 0;                  // no per-class extra data

	mov	DWORD PTR _wc$[ebp+8], 0

; 10220:    wc.cbWndExtra = 0;                  // no per-window extra data

	mov	DWORD PTR _wc$[ebp+12], 0

; 10221:    wc.hInstance = (HANDLE) hInstance;  // application that owns the class

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _wc$[ebp+16], eax

; 10222:    wc.hIcon = LoadIcon( 0, IDI_APPLICATION );

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadIconA@8
	mov	DWORD PTR _wc$[ebp+20], eax

; 10223:    wc.hCursor = LoadCursor( 0, IDC_ARROW );

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	mov	DWORD PTR _wc$[ebp+24], eax

; 10224:    wc.hbrBackground = GetStockObject( WHITE_BRUSH );

	push	0
	call	DWORD PTR __imp__GetStockObject@4
	mov	DWORD PTR _wc$[ebp+28], eax

; 10225:    wc.lpszMenuName = 0;                // name of menu resource in .RC file

	mov	DWORD PTR _wc$[ebp+32], 0

; 10226:    wc.lpszClassName = cpcClassName;    // name used in call to CreateWindow

	mov	ecx, DWORD PTR _cpcClassName$[ebp]
	mov	DWORD PTR _wc$[ebp+36], ecx

; 10227: 
; 10228:    // Register the window class and return success/failure code.
; 10229:    if ( RegisterClass( &wc ) )

	lea	edx, DWORD PTR _wc$[ebp]
	push	edx
	call	DWORD PTR __imp__RegisterClassA@4
	and	eax, 65535				; 0000ffffH
	test	eax, eax
	je	$L63787

; 10231:       HWND   hMainWnd;
; 10232:       int    nHeight, nPosY;
; 10233:       int    nWidth, nPosX;
; 10234: 
; 10235:       // Get the dimensions of the screen ... we don't really care since this
; 10236:       // window is hidden anyway.
; 10237:       nWidth = GetSystemMetrics( SM_CXSCREEN );

	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _nWidth$63782[ebp], eax

; 10238:       nHeight = GetSystemMetrics( SM_CYSCREEN );

	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _nHeight$63780[ebp], eax

; 10239:       nWidth /= 2;

	mov	eax, DWORD PTR _nWidth$63782[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nWidth$63782[ebp], eax

; 10240:       nHeight /= 2;

	mov	eax, DWORD PTR _nHeight$63780[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nHeight$63780[ebp], eax

; 10241:       nWidth -= 40;

	mov	eax, DWORD PTR _nWidth$63782[ebp]
	sub	eax, 40					; 00000028H
	mov	DWORD PTR _nWidth$63782[ebp], eax

; 10242:       nHeight -= 20;

	mov	ecx, DWORD PTR _nHeight$63780[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR _nHeight$63780[ebp], ecx

; 10243:       nPosX = nWidth / 2;

	mov	eax, DWORD PTR _nWidth$63782[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nPosX$63783[ebp], eax

; 10244:       nPosY = nHeight / 2;

	mov	eax, DWORD PTR _nHeight$63780[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nPosY$63781[ebp], eax

; 10245:       nPosX -= 8; // so it doesn't occupy same space as object services

	mov	edx, DWORD PTR _nPosX$63783[ebp]
	sub	edx, 8
	mov	DWORD PTR _nPosX$63783[ebp], edx

; 10246:       nPosY -= 8;

	mov	eax, DWORD PTR _nPosY$63781[ebp]
	sub	eax, 8
	mov	DWORD PTR _nPosY$63781[ebp], eax

; 10247: 
; 10248:       // Create a main window for this application instance.
; 10249:       hMainWnd = CreateWindow( cpcClassName,        // see RegisterClass( ) call
; 10250:                                cpcWindowTitle,      // text for window title bar
; 10251:                                WS_OVERLAPPEDWINDOW, // window style
; 10252:                                nPosX,               // default horizontal position
; 10253:                                nPosY,               // default vertical position
; 10254:                                nWidth,              // default width
; 10255:                                nHeight,             // default height
; 10256:                                0,                   // overlapped windows have no parent
; 10257:                                0,                   // menu for trace window
; 10258:                             // 0,                   // use default menu
; 10259:                                (HANDLE) hInstance,  // this instance owns this window
; 10260:                                0 );                 // pointer not needed

	push	0
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _nHeight$63780[ebp]
	push	edx
	mov	eax, DWORD PTR _nWidth$63782[ebp]
	push	eax
	mov	ecx, DWORD PTR _nPosY$63781[ebp]
	push	ecx
	mov	edx, DWORD PTR _nPosX$63783[ebp]
	push	edx
	push	13565952				; 00cf0000H
	mov	eax, DWORD PTR _cpcWindowTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcClassName$[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _hMainWnd$63779[ebp], eax

; 10262:          char szMsg[ 256 ];
; 10263: 
; 10264:          zsprintf( szMsg, "SysInitApplicationWindow Class: %s  Title: %s  hWnd: 0x%08x=%d",
; 10265:                    cpcClassName, cpcWindowTitle, hMainWnd, hMainWnd );

	mov	edx, DWORD PTR _hMainWnd$63779[ebp]
	push	edx
	mov	eax, DWORD PTR _hMainWnd$63779[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcWindowTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcClassName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0DP@DCII@SysInitApplicationWindow?5Class?3?5@ ; `string'
	lea	eax, DWORD PTR _szMsg$63785[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 10266:          TraceLineS( szMsg, "" );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szMsg$63785[ebp]
	push	ecx
	call	_TraceLineS@8

; 10269: 
; 10270:       // If window is created, return "success".
; 10271:       if ( hMainWnd )

	cmp	DWORD PTR _hMainWnd$63779[ebp], 0
	je	SHORT $L63787

; 10273:          ShowWindow( hMainWnd, SW_HIDE ); // hide the window

	push	0
	mov	edx, DWORD PTR _hMainWnd$63779[ebp]
	push	edx
	call	DWORD PTR __imp__ShowWindow@8

; 10274:          return( (zLONG) hMainWnd );      // return "success"

	mov	eax, DWORD PTR _hMainWnd$63779[ebp]
	jmp	SHORT $L63769
$L63787:

; 10277: 
; 10278:    return( 0 ); // return "failure"

	xor	eax, eax
$L63769:

; 10279: }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysInitApplicationWindow@12 ENDP
_TEXT	ENDS
PUBLIC	_DllMain@12
PUBLIC	??_C@_08HAKP@KZOESRVC?$AA@			; `string'
PUBLIC	??_C@_01OAK@N?$AA@				; `string'
PUBLIC	??_C@_0L@EMHA@ServerMode?$AA@			; `string'
PUBLIC	??_C@_0N@JELK@ObjectEngine?$AA@			; `string'
EXTRN	_fnDropTaskDomains@4:NEAR
EXTRN	__imp__GetPrivateProfileStringA@24:NEAR
EXTRN	_fnDropTaskOperation@8:NEAR
EXTRN	__imp__toupper:NEAR
EXTRN	_NetClose@8:NEAR
EXTRN	__imp__GetVersionExA@4:NEAR
;	COMDAT ??_C@_08HAKP@KZOESRVC?$AA@
; File c:\10c\w\oe\KZOESYAA.c
_DATA	SEGMENT
??_C@_08HAKP@KZOESRVC?$AA@ DB 'KZOESRVC', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01OAK@N?$AA@
_DATA	SEGMENT
??_C@_01OAK@N?$AA@ DB 'N', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@EMHA@ServerMode?$AA@
_DATA	SEGMENT
??_C@_0L@EMHA@ServerMode?$AA@ DB 'ServerMode', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@JELK@ObjectEngine?$AA@
_DATA	SEGMENT
??_C@_0N@JELK@ObjectEngine?$AA@ DB 'ObjectEngine', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_hDLL$ = 8
_dwReason$ = 12
_k$63802 = -424
_os$63803 = -408
_szFileName$63804 = -260
_szServerMode$63805 = -420
_szMessage$63808 = -680
_k$63819 = -684
_lpProcessList$63821 = -708
_lpSystemTask$63822 = -704
_vSystemView$63824 = -716
_lpTask$63826 = -724
_lpNetwork$63827 = -732
_lpNextNetwork$63828 = -692
_lpTaskOperation$63829 = -736
_lpNextTaskOperation$63830 = -728
_hLibrary$63831 = -700
_lpLibrary$63832 = -744
_hNextLibrary$63833 = -720
_hMutex$63834 = -740
_lpMutex$63835 = -712
_lpPrevMutex$63836 = -748
_hNextMutex$63837 = -696
_lProcessID$63838 = -688
_DllMain@12 PROC NEAR

; 10307: {

	push	ebp
	mov	ebp, esp
	sub	esp, 752				; 000002f0H

; 10308:   switch ( dwReason )
; 10309:   {

	mov	eax, DWORD PTR _dwReason$[ebp]
	mov	DWORD PTR -752+[ebp], eax
	cmp	DWORD PTR -752+[ebp], 0
	je	$L63818
	cmp	DWORD PTR -752+[ebp], 1
	je	SHORT $L63801
	jmp	$L63798
$L63801:

; 10312:          zSHORT        k;
; 10313:          OSVERSIONINFO os;
; 10314:          zCHAR         szFileName[ zMAX_FILENAME_LTH + 1 ];
; 10315:          zCHAR         szServerMode[ 10 ];
; 10316: 
; 10317:          g_lCurrentProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _g_lCurrentProcessID, eax

; 10318:          g_hInstance = hDLL;

	mov	ecx, DWORD PTR _hDLL$[ebp]
	mov	DWORD PTR _g_hInstance, ecx

; 10319: 
; 10320: #ifdef DEBUG_MALLOC
; 10321:          SysMalloc( -2 );
; 10322: #endif
; 10323:          // Register message of Object Services.
; 10324:          g_wOENG_Message = RegisterWindowMessage( "KZOESRVC" );

	push	OFFSET FLAT:??_C@_08HAKP@KZOESRVC?$AA@	; `string'
	call	DWORD PTR __imp__RegisterWindowMessageA@4
	mov	DWORD PTR _g_wOENG_Message, eax

; 10325: 
; 10326:          // Figure out the OS version.
; 10327:          zmemset( &os, 0, sizeof( os ) );

	push	148					; 00000094H
	push	0
	lea	edx, DWORD PTR _os$63803[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 10328:          os.dwOSVersionInfoSize = sizeof( os );

	mov	DWORD PTR _os$63803[ebp], 148		; 00000094H

; 10329:          GetVersionEx( &os );

	lea	eax, DWORD PTR _os$63803[ebp]
	push	eax
	call	DWORD PTR __imp__GetVersionExA@4

; 10330: 
; 10331:          // Check the ServerMode flag in Zeidon.ini.  Since the OE is not running
; 10332:          // yet, we have to use GetPrivateProfileString( ).
; 10333:          k = fnBuildZeidonIni( szFileName, sizeof( szFileName ) );

	push	257					; 00000101H
	lea	ecx, DWORD PTR _szFileName$63804[ebp]
	push	ecx
	call	_fnBuildZeidonIni
	add	esp, 8
	mov	WORD PTR _k$63802[ebp], ax

; 10334:          if ( k == 0 )

	movsx	edx, WORD PTR _k$63802[ebp]
	test	edx, edx
	jne	SHORT $L63807

; 10336:             char szMessage[ 256 ];
; 10337: 
; 10338:             // {2,"KZOEE002 - ZEIDON environment variable not set"},
; 10339:             SysGetBaseMessage( szMessage, KZOEE002, sizeof( szMessage ) );

	push	256					; 00000100H
	push	2
	lea	eax, DWORD PTR _szMessage$63808[ebp]
	push	eax
	call	_SysGetBaseMessage@12

; 10340:             SysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMessage$63808[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 10341: 
; 10342:             return( 1 );

	mov	eax, 1
	jmp	$L63796
$L63807:

; 10344: 
; 10345:          GetPrivateProfileString( "ObjectEngine", "ServerMode", "N", szServerMode,
; 10346:                                   sizeof( szServerMode ), szFileName );

	lea	eax, DWORD PTR _szFileName$63804[ebp]
	push	eax
	push	10					; 0000000aH
	lea	ecx, DWORD PTR _szServerMode$63805[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@EMHA@ServerMode?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@JELK@ObjectEngine?$AA@ ; `string'
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 10347:          if ( toupper( szServerMode[ 0 ] ) == 'Y' )

	movsx	edx, BYTE PTR _szServerMode$63805[ebp]
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	eax, 89					; 00000059H
	jne	SHORT $L63812

; 10348:             g_bServerMode = TRUE;

	mov	BYTE PTR _g_bServerMode, 1
$L63812:

; 10349: 
; 10350:          // We need to set up the handle/pointer conversion function.  In
; 10351:          // Win95, handle and pointers are the same thing.  Note that in
; 10352:          // server mode, handles and pointers are the same as well, so we'll
; 10353:          // use the same conversion functions.
; 10354:          if ( os.dwPlatformId == VER_PLATFORM_WIN32_NT && g_bServerMode == FALSE )

	cmp	DWORD PTR _os$63803[ebp+16], 2
	jne	SHORT $L63813
	xor	eax, eax
	mov	al, BYTE PTR _g_bServerMode
	test	eax, eax
	jne	SHORT $L63813

; 10356:             g_bWin95 = FALSE;

	mov	BYTE PTR _g_bWin95, 0

; 10357:             g_pfnGetPtr = fnSysGetPointerFromHandleShared;

	mov	DWORD PTR _g_pfnGetPtr, OFFSET FLAT:_fnSysGetPointerFromHandleShared@4

; 10358:             g_pfnGetHndl = fnSysGetHandleFromPointerShared;

	mov	DWORD PTR _g_pfnGetHndl, OFFSET FLAT:_fnSysGetHandleFromPointerShared@4

; 10360:          else

	jmp	SHORT $L63814
$L63813:

; 10362:             g_pfnGetPtr = fnSysGetPointerFromHandleServerMode;

	mov	DWORD PTR _g_pfnGetPtr, OFFSET FLAT:_fnSysGetPointerFromHandleServerMode@4

; 10363:             g_pfnGetHndl = fnSysGetHandleFromPointerServerMode;

	mov	DWORD PTR _g_pfnGetHndl, OFFSET FLAT:_fnSysGetHandleFromPointerServerMode@4
$L63814:

; 10365: 
; 10366: #ifdef __MUTEX_DEBUG__
; 10367:          g_hMutexDbg = CreateMutex( NULL, FALSE, MUTEXDBG_NAME );
; 10368: #endif
; 10369: 
; 10370:          for ( k = 0; k < zMUTEX_COUNT; k++ )

	mov	WORD PTR _k$63802[ebp], 0
	jmp	SHORT $L63815
$L63816:
	mov	cx, WORD PTR _k$63802[ebp]
	add	cx, 1
	mov	WORD PTR _k$63802[ebp], cx
$L63815:
	movsx	edx, WORD PTR _k$63802[ebp]
	cmp	edx, 16					; 00000010H
	jge	SHORT $L63817

; 10371:             zCREATE_MUTEX( k );

	movsx	eax, WORD PTR _k$63802[ebp]
	push	eax
	call	_fnSysCreateCoreMutex@4
	jmp	SHORT $L63816
$L63817:

; 10372: 
; 10373:          // Initialize critical sections used in this file.
; 10374:          InitializeCriticalSection( &g_csSysLoadLibrary );

	push	OFFSET FLAT:_g_csSysLoadLibrary
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 10375:          InitializeCriticalSection( &g_csReuseEntity );

	push	OFFSET FLAT:_g_csReuseEntity
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 10376: 
; 10377:          break;

	jmp	$L63798
$L63818:

; 10382:          zLONG     k;
; 10383: 
; 10384:          if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	$L63874

; 10386:             LPPROCESSLIST lpProcessList;
; 10387:             LPTASK     lpSystemTask = zGETPTR( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSystemTask$63822[ebp], eax

; 10388:             zVIEW      vSystemView = zGETPTR( lpSystemTask->hFirstView );

	mov	eax, DWORD PTR _lpSystemTask$63822[ebp]
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vSystemView$63824[ebp], eax

; 10389:             LPTASK     lpTask;
; 10390:             LPNETWORK  lpNetwork;
; 10391:             LPNETWORK  lpNextNetwork;
; 10392:             LPTASKOPER lpTaskOperation;
; 10393:             LPTASKOPER lpNextTaskOperation;
; 10394:             LPLIBRARY  hLibrary;
; 10395:             LPLIBRARY  lpLibrary;
; 10396:             LPLIBRARY  hNextLibrary;
; 10397:             LPMUTEX    hMutex;
; 10398:             LPMUTEX    lpMutex;
; 10399:             LPMUTEX    lpPrevMutex;
; 10400:             LPMUTEX    hNextMutex;
; 10401:             zLONG      lProcessID = GetCurrentProcessId( );

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	DWORD PTR _lProcessID$63838[ebp], eax

; 10402: 
; 10403:             if ( vSystemView )

	cmp	DWORD PTR _vSystemView$63824[ebp], 0
	je	$L63839

; 10405:                zLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysLockCoreMutex@4

; 10406: 
; 10407:                lpNextNetwork = 0;

	mov	DWORD PTR _lpNextNetwork$63828[ebp], 0

; 10408:                for ( lpNetwork = zGETPTR( AnchorBlock->hFirstNetwork );
; 10409:                      lpNetwork;
; 10410:                      lpNetwork = lpNextNetwork )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+122]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNetwork$63827[ebp], eax
	jmp	SHORT $L63841
$L63842:
	mov	ecx, DWORD PTR _lpNextNetwork$63828[ebp]
	mov	DWORD PTR _lpNetwork$63827[ebp], ecx
$L63841:
	cmp	DWORD PTR _lpNetwork$63827[ebp], 0
	je	SHORT $L63843

; 10412:                   lpNextNetwork = zGETPTR( lpNetwork->hNextNetwork );

	mov	edx, DWORD PTR _lpNetwork$63827[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextNetwork$63828[ebp], eax

; 10413: 
; 10414:                   if ( lpNetwork->lProcessID != lProcessID )

	mov	ecx, DWORD PTR _lpNetwork$63827[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _lProcessID$63838[ebp]
	je	SHORT $L63845

; 10415:                      continue;

	jmp	SHORT $L63842
$L63845:

; 10416: 
; 10417:                   NetClose( vSystemView, lpNetwork->szNetworkName );

	mov	eax, DWORD PTR _lpNetwork$63827[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _vSystemView$63824[ebp]
	push	ecx
	call	_NetClose@8

; 10418:                }

	jmp	SHORT $L63842
$L63843:

; 10419: 
; 10420:                zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4
$L63839:

; 10422: 
; 10423:             zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 10424: 
; 10425:             // Get a 'write' lock on the task list.  We pass in -1 for the
; 10426:             // task to indicate that we have no task.  It is used by Browse
; 10427:             // for information only.
; 10428:             fnStartBrowseOfTaskList( (LPTASK) -1, FALSE );

	push	0
	push	-1
	call	_fnStartBrowseOfTaskList@8

; 10429: 
; 10430:             for ( lpTask = zGETPTR( AnchorBlock->hFirstTask );
; 10431:                   lpTask;
; 10432:                   lpTask = zGETPTR( lpTask->hNextTask ) )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+130]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$63826[ebp], eax
	jmp	SHORT $L63849
$L63850:
	mov	ecx, DWORD PTR _lpTask$63826[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$63826[ebp], eax
$L63849:
	cmp	DWORD PTR _lpTask$63826[ebp], 0
	je	$L63851

; 10434:                for ( lpTaskOperation = zGETPTR( lpTask->hFirstTaskOperation );
; 10435:                      lpTaskOperation;
; 10436:                      lpTaskOperation = lpNextTaskOperation )

	mov	eax, DWORD PTR _lpTask$63826[ebp]
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$63829[ebp], eax
	jmp	SHORT $L63853
$L63854:
	mov	edx, DWORD PTR _lpNextTaskOperation$63830[ebp]
	mov	DWORD PTR _lpTaskOperation$63829[ebp], edx
$L63853:
	cmp	DWORD PTR _lpTaskOperation$63829[ebp], 0
	je	SHORT $L63855

; 10438:                   lpNextTaskOperation =
; 10439:                         zGETPTR( lpTaskOperation->hNextTaskOperationForTask );

	mov	eax, DWORD PTR _lpTaskOperation$63829[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTaskOperation$63830[ebp], eax

; 10440: 
; 10441:                   if ( lpTaskOperation->lProcessID == g_lCurrentProcessID )

	mov	edx, DWORD PTR _lpTaskOperation$63829[ebp]
	mov	eax, DWORD PTR [edx+34]
	cmp	eax, DWORD PTR _g_lCurrentProcessID
	jne	SHORT $L63857

; 10443:                      fnDropTaskOperation( lpTask, lpTaskOperation );

	mov	ecx, DWORD PTR _lpTaskOperation$63829[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$63826[ebp]
	push	edx
	call	_fnDropTaskOperation@8
$L63857:

; 10445:                }

	jmp	SHORT $L63854
$L63855:

; 10446: 
; 10447:                hLibrary = lpTask->hFirstLibrary;

	mov	eax, DWORD PTR _lpTask$63826[ebp]
	mov	ecx, DWORD PTR [eax+122]
	mov	DWORD PTR _hLibrary$63831[ebp], ecx
$L63859:

; 10448:                while ( hLibrary )

	cmp	DWORD PTR _hLibrary$63831[ebp], 0
	je	SHORT $L63860

; 10450:                   lpLibrary = zGETPTR( hLibrary );

	mov	edx, DWORD PTR _hLibrary$63831[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$63832[ebp], eax

; 10451:                   hNextLibrary = lpLibrary->hNextLibrary;

	mov	eax, DWORD PTR _lpLibrary$63832[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR _hNextLibrary$63833[ebp], ecx

; 10452:                   if ( lProcessID == lpLibrary->lProcessID )

	mov	edx, DWORD PTR _lpLibrary$63832[ebp]
	mov	eax, DWORD PTR _lProcessID$63838[ebp]
	cmp	eax, DWORD PTR [edx+271]
	jne	SHORT $L63862

; 10453:                      fnSysFreeLibrary( lpTask, hLibrary, TRUE );

	push	1
	mov	ecx, DWORD PTR _hLibrary$63831[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$63826[ebp]
	push	edx
	call	_fnSysFreeLibrary@12
$L63862:

; 10454: 
; 10455:                   hLibrary = hNextLibrary;

	mov	eax, DWORD PTR _hNextLibrary$63833[ebp]
	mov	DWORD PTR _hLibrary$63831[ebp], eax

; 10456:                }

	jmp	SHORT $L63859
$L63860:

; 10457: 
; 10458:                fnDropTaskDomains( lpTask );

	mov	ecx, DWORD PTR _lpTask$63826[ebp]
	push	ecx
	call	_fnDropTaskDomains@4

; 10459: 
; 10460:             // zLOCK_MUTEX( zMUTEX_MUTEX );    // protected by zMUTEX_ANCHORBLOCK
; 10461:                lpPrevMutex = 0;

	mov	DWORD PTR _lpPrevMutex$63836[ebp], 0

; 10462:                hMutex = lpTask->hFirstMutex;

	mov	edx, DWORD PTR _lpTask$63826[ebp]
	mov	eax, DWORD PTR [edx+150]
	mov	DWORD PTR _hMutex$63834[ebp], eax
$L63864:

; 10463:                while ( hMutex )

	cmp	DWORD PTR _hMutex$63834[ebp], 0
	je	$L63865

; 10465:                   lpMutex = zGETPTR( hMutex );

	mov	ecx, DWORD PTR _hMutex$63834[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$63835[ebp], eax

; 10466:                   hNextMutex = lpMutex->hNextMutex;

	mov	edx, DWORD PTR _lpMutex$63835[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR _hNextMutex$63837[ebp], eax

; 10467:                   if ( lProcessID == lpMutex->lProcessID )

	mov	ecx, DWORD PTR _lpMutex$63835[ebp]
	mov	edx, DWORD PTR _lProcessID$63838[ebp]
	cmp	edx, DWORD PTR [ecx+89]
	jne	SHORT $L63867

; 10469:                      if ( lpMutex->nLockCount )

	mov	eax, DWORD PTR _lpMutex$63835[ebp]
	movsx	ecx, WORD PTR [eax+75]
	test	ecx, ecx
	je	SHORT $L63868

; 10471:                         // First set nLockCount to 1 so that the next call to
; 10472:                         // fnSysMutexUnlock actually unlocks the mutex.
; 10473:                         lpMutex->nLockCount = 1;

	mov	edx, DWORD PTR _lpMutex$63835[ebp]
	mov	WORD PTR [edx+75], 1

; 10474:                         fnSysMutexUnlock( lpTask, lpMutex );

	mov	eax, DWORD PTR _lpMutex$63835[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$63826[ebp]
	push	ecx
	call	_fnSysMutexUnlock@8
$L63868:

; 10476: 
; 10477:                      fnSysMutexDestroy( lpTask, lpMutex );

	mov	edx, DWORD PTR _lpMutex$63835[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$63826[ebp]
	push	eax
	call	_fnSysMutexDestroy@8

; 10478:                      if ( lpPrevMutex )

	cmp	DWORD PTR _lpPrevMutex$63836[ebp], 0
	je	SHORT $L63869

; 10479:                         lpPrevMutex->hNextMutex = hNextMutex;

	mov	ecx, DWORD PTR _lpPrevMutex$63836[ebp]
	mov	edx, DWORD PTR _hNextMutex$63837[ebp]
	mov	DWORD PTR [ecx+2], edx

; 10480:                      else

	jmp	SHORT $L63870
$L63869:

; 10481:                         lpTask->hFirstMutex = hNextMutex;

	mov	eax, DWORD PTR _lpTask$63826[ebp]
	mov	ecx, DWORD PTR _hNextMutex$63837[ebp]
	mov	DWORD PTR [eax+150], ecx
$L63870:

; 10482: 
; 10483:                      fnFreeDataspace( lpMutex );

	mov	edx, DWORD PTR _lpMutex$63835[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 10485:                   else

	jmp	SHORT $L63871
$L63867:

; 10486:                      lpPrevMutex = lpMutex;

	mov	eax, DWORD PTR _lpMutex$63835[ebp]
	mov	DWORD PTR _lpPrevMutex$63836[ebp], eax
$L63871:

; 10487: 
; 10488:                   hMutex = hNextMutex;

	mov	ecx, DWORD PTR _hNextMutex$63837[ebp]
	mov	DWORD PTR _hMutex$63834[ebp], ecx

; 10489:                }

	jmp	$L63864
$L63865:

; 10490: 
; 10491:             // zUNLOCK_MUTEX( zMUTEX_MUTEX );
; 10492:             }

	jmp	$L63850
$L63851:

; 10493: 
; 10494:             fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 10495:             zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 10496: 
; 10497:             for ( k = 0; k < AnchorBlock->OS_Data.lProcessCount; k++ )

	mov	DWORD PTR _k$63819[ebp], 0
	jmp	SHORT $L63872
$L63873:
	mov	edx, DWORD PTR _k$63819[ebp]
	add	edx, 1
	mov	DWORD PTR _k$63819[ebp], edx
$L63872:
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _k$63819[ebp]
	cmp	ecx, DWORD PTR [eax+1507]
	jge	SHORT $L63874

; 10499:                lpProcessList = &AnchorBlock->OS_Data.ProcessList[ k ];

	mov	edx, DWORD PTR _k$63819[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _AnchorBlock
	lea	ecx, DWORD PTR [eax+edx+1511]
	mov	DWORD PTR _lpProcessList$63821[ebp], ecx

; 10500:                if ( lpProcessList->lProcessID == lProcessID )

	mov	edx, DWORD PTR _lpProcessList$63821[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _lProcessID$63838[ebp]
	jne	SHORT $L63875

; 10502:                   lpProcessList->lProcessID = 0;

	mov	ecx, DWORD PTR _lpProcessList$63821[ebp]
	mov	DWORD PTR [ecx+16], 0

; 10503:                   break;

	jmp	SHORT $L63874
$L63875:

; 10505:             }

	jmp	SHORT $L63873
$L63874:

; 10507: 
; 10508:          for ( k = 0; k < zMUTEX_COUNT; k++ )

	mov	DWORD PTR _k$63819[ebp], 0
	jmp	SHORT $L63876
$L63877:
	mov	edx, DWORD PTR _k$63819[ebp]
	add	edx, 1
	mov	DWORD PTR _k$63819[ebp], edx
$L63876:
	cmp	DWORD PTR _k$63819[ebp], 16		; 00000010H
	jge	SHORT $L63878

; 10509:             zDESTROY_MUTEX( k );

	mov	eax, DWORD PTR _k$63819[ebp]
	push	eax
	call	_fnSysDestroyCoreMutex@4
	jmp	SHORT $L63877
$L63878:

; 10510: 
; 10511: #ifdef __MUTEX_DEBUG__
; 10512:          if ( g_hMutexDbg )
; 10513:             CloseHandle( g_hMutexDbg );
; 10514: 
; 10515:          if ( g_hMutexMemFile )
; 10516:             CloseHandle( g_hMutexMemFile );
; 10517: #endif
; 10518: 
; 10519:          // Delete critical sections used in this file.
; 10520:          DeleteCriticalSection( &g_csSysLoadLibrary );

	push	OFFSET FLAT:_g_csSysLoadLibrary
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 10521:          DeleteCriticalSection( &g_csReuseEntity );

	push	OFFSET FLAT:_g_csReuseEntity
	call	DWORD PTR __imp__DeleteCriticalSection@4
$L63798:

; 10526: 
; 10527:    return( TRUE );

	mov	eax, 1
$L63796:

; 10528: }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_DllMain@12 ENDP
_TEXT	ENDS
END
